// Background service worker for Blaze Double Analyzer

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§¹ LIMPEZA AUTOMÃTICA DO CONSOLE - REMOVIDA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Removido a pedido do usuÃ¡rio - logs nÃ£o serÃ£o mais limpos automaticamente

const originalBackgroundConsoleLog = console.log.bind(console);

const LOG_STYLE = Object.freeze({
    banner: 'color:#0D47A1;font-weight:bold;font-size:14px;',
    section: 'color:#1565C0;font-weight:bold;',
    info: 'color:#37474F;',
    value: 'color:#1B5E20;font-weight:bold;',
    warn: 'color:#E65100;font-weight:bold;',
    error: 'color:#B71C1C;font-weight:bold;',
    divider: 'color:#B0BEC5;'
});

function logBanner(message) {
    originalBackgroundConsoleLog(`%c${message}`, LOG_STYLE.banner);
}

function logSection(message) {
    originalBackgroundConsoleLog(`%c${message}`, LOG_STYLE.section);
}

function logInfo(label, value) {
    originalBackgroundConsoleLog(`%câ€¢ ${label}: %c${value}`, LOG_STYLE.info, LOG_STYLE.value);
}

function logDivider() {
    originalBackgroundConsoleLog('%c------------------------------------------------------------', LOG_STYLE.divider);
}

function getGaleSummary() {
    const martingaleSettings = getMartingaleSettings();
    if (martingaleState.active) {
        return `Ativo â€¢ fase ${martingaleState.stage} (${martingaleState.entryColor || '-'})`;
    }
    if (martingaleSettings.maxGales > 0) {
        return `Configurado â€¢ atÃ© ${martingaleSettings.maxGales} gale(s)`;
    }
    return 'Desativado';
}

function getDiamondConfigSnapshot() {
    const userDiamondWindows = analyzerConfig.diamondLevelWindows || {};
    const getValue = (key, fallback) => {
        const raw = Number(userDiamondWindows[key]);
        return Number.isFinite(raw) && raw > 0 ? raw : fallback;
    };
    return [
        ['N0', `Hist ${getValue('n0History', N0_DEFAULTS.historySize)} | W ${getDiamondWindow('n0Window', N0_DEFAULTS.windowSize)} | BlockAll ${analyzerConfig.n0AllowBlockAll !== false ? 'sim' : 'nÃ£o'}`],
        ['N1', `W ${getDiamondWindow('n1WindowSize', SAFE_ZONE_DEFAULTS.windowSize)} | minA ${getDiamondWindow('n1PrimaryRequirement', SAFE_ZONE_DEFAULTS.primaryRequirement)} | minB ${getDiamondWindow('n1SecondaryRequirement', SAFE_ZONE_DEFAULTS.secondaryRequirement)}`],
        ['N2', `Janela base ${getDiamondWindow('n2Recent', 10)} (auto)`],
        ['N3', `Hist ${getDiamondWindow('n3Alternance', 12)} | Rigor ${getDiamondWindow('n3ThresholdPct', 75)}% | minOcc ${getDiamondWindow('n3MinOccurrences', 1)}`],
        ['N4', `${getDiamondWindow('n4Persistence', 20)} giros`],
        ['N5', `${getDiamondWindow('n5MinuteBias', 60)} amostras`],
        ['N6', `${getDiamondWindow('n6RetracementWindow', 80)} giros`],
        ['N7', `Dec ${getDiamondWindow('n7DecisionWindow', 20)} | Hist ${getDiamondWindow('n7HistoryWindow', 100)}`],
        ['N8', `Hist ${getDiamondWindow('n10History', 500)} | W ${getDiamondWindow('n10Window', 20)}`],
        ['N9', `${getDiamondWindow('n8Barrier', 50)} giros`],
        ['N10', `Hist ${getDiamondWindow('n9History', 100)} | Î”${getDiamondWindow('n9NullThreshold', 8)}%`]
    ];
}

function logModeSnapshot(contextLabel = 'Contexto atual', historyLength = cachedHistory.length) {
    const modeLabel = analyzerConfig.aiMode ? 'Modo Diamante' : 'Modo PadrÃ£o';
    logDivider();
    logSection(`[${contextLabel}] ${modeLabel}`);
    logInfo('Giros disponÃ­veis', historyLength || 'N/A');
    logInfo('Controle de gale', getGaleSummary());
    logInfo('ProteÃ§Ã£o no Branco', analyzerConfig.whiteProtectionAsWin ? 'Conta como WIN' : 'Conta como LOSS');
    if (analyzerConfig.aiMode) {
        if (memoriaAtiva.inicializada) {
            const tempoDecorrido = Math.round((Date.now() - memoriaAtiva.ultimaAtualizacao) / 1000);
            logInfo('MemÃ³ria IA', `Ativa â€¢ ${memoriaAtiva.totalAtualizacoes} atualizaÃ§Ãµes â€¢ ${memoriaAtiva.tempoUltimaAtualizacao.toFixed(1)}ms â€¢ hÃ¡ ${tempoDecorrido}s`);
        } else {
            logInfo('MemÃ³ria IA', 'Inicializando...');
        }
    } else {
        logInfo('Min. ocorrÃªncias', analyzerConfig.minOccurrences || 1);
        const signalInterval = (analyzerConfig.minSignalIntervalSpins ?? analyzerConfig.minIntervalSpins) || 0;
        logInfo('Intervalo entre sinais', signalInterval);
    }
    if (analyzerConfig.aiMode) {
        getDiamondConfigSnapshot().forEach(([label, detail]) => logInfo(label, detail));
    }
    logDivider();
    emitModeSnapshotToContent(contextLabel, historyLength);
}

const DEFAULT_AUTOBET_CONFIG = Object.freeze({
    enabled: false,
    simulationOnly: true,
    baseStake: 2,
    galeMultiplier: 2,
    delayMs: 1500,
    stopWin: 0,
    stopLoss: 0,
    simulationBankRoll: 5000,
    whitePayoutMultiplier: 14
});

function buildDiamondLevelSummaries() {
    const list = getDiamondConfigSnapshot();
    return list.map(([label, detail]) => {
        const id = label;
        return {
            id,
            enabled: isDiamondLevelEnabled(label),
            detail
        };
    });
}

function buildModeSnapshot(contextLabel = 'Contexto atual', historyLength = cachedHistory.length) {
    const aiModeActive = !!(analyzerConfig && analyzerConfig.aiMode);
    const snapshot = {
        context: contextLabel,
        timestamp: Date.now(),
        aiMode: aiModeActive,
        modeLabel: aiModeActive ? 'AnÃ¡lise Diamante' : 'Modo PadrÃ£o',
        historyAvailable: historyLength || 0,
    signalIntensity: analyzerConfig.signalIntensity || 'aggressive',
        galeSummary: getGaleSummary(),
        galeSettings: getMartingaleSettings(),
        galeState: {
            active: martingaleState.active,
            stage: martingaleState.stage,
            entryColor: martingaleState.entryColor
        },
        whiteProtectionAsWin: !!analyzerConfig.whiteProtectionAsWin
    };

    if (aiModeActive) {
        snapshot.memoriaAtiva = getMemoriaAtivaStatus();
        snapshot.enabledDiamondLevels = countEnabledDiamondLevels();
        snapshot.diamondLevels = buildDiamondLevelSummaries();
    } else {
        snapshot.standardConfig = {
            historyDepth: analyzerConfig.historyDepth,
            minOccurrences: analyzerConfig.minOccurrences,
            maxOccurrences: analyzerConfig.maxOccurrences,
            minIntervalSpins: analyzerConfig.minIntervalSpins,
            minPatternSize: analyzerConfig.minPatternSize,
            maxPatternSize: analyzerConfig.maxPatternSize,
            winPercentOthers: analyzerConfig.winPercentOthers
        };
    }

    return snapshot;
}

function emitModeSnapshotToContent(contextLabel = 'Contexto atual', historyLength = cachedHistory.length) {
    try {
        const snapshot = buildModeSnapshot(contextLabel, historyLength);
        sendMessageToContent('MODE_SNAPSHOT', snapshot);
    } catch (error) {
        console.warn('NÃ£o foi possÃ­vel emitir MODE_SNAPSHOT para content:', error);
    }
}

const BOX_CHAR_PREFIXES = ['%câ•‘', '%câ•”', '%câ•š', '%câ•', '%câ–ˆâ–ˆâ–ˆâ–ˆ'];
const ENABLE_LEGACY_LOGS = false;
console.log = (...args) => {
    const first = args[0];
    if (typeof first === 'string') {
        if (BOX_CHAR_PREFIXES.some(prefix => first.startsWith(prefix)) && !ENABLE_LEGACY_LOGS) {
            return;
        }
    }
    if (ENABLE_LEGACY_LOGS) {
        originalBackgroundConsoleLog(...args);
    }
};

let isRunning = false;
let analysisEnabled = true;
let intervalId = null;
let forceLogoutTabOpened = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’¾ CACHE EM MEMÃ“RIA (nÃ£o persiste apÃ³s recarregar)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let cachedHistory = [];  // HistÃ³rico de giros em memÃ³ria (atÃ© 2000)
let historyInitialized = false;  // Flag de inicializaÃ§Ã£o

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  MEMÃ“RIA ATIVA - SISTEMA INCREMENTAL DE ANÃLISE
// Sistema inteligente que mantÃ©m anÃ¡lises prÃ©-calculadas em memÃ³ria
// Atualiza apenas o delta (novo giro) ao invÃ©s de recalcular tudo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let memoriaAtiva = {
    // ğŸ“Š STATUS
    inicializada: false,
    ultimaAtualizacao: null,
    versao: 1,
    
    // ğŸ“œ HISTÃ“RICO (2000 giros)
    giros: [],
    ultimos20: [],
    
    // ğŸ¯ PADRÃ•ES PRÃ‰-DETECTADOS (cache)
    padroesDetectados: {
        alternanciaSimples: [],
        alternanciasDupla: [],
        alternanciasTripla: [],
        sequenciasRed: [],
        sequenciasBlack: []
    },
    
    // ğŸ“Š ESTATÃSTICAS PRÃ‰-CALCULADAS
    estatisticas: {
        totalGiros: 0,
        distribuicao: {
            red: { count: 0, percent: 0 },
            black: { count: 0, percent: 0 },
            white: { count: 0, percent: 0 }
        },
        // EstatÃ­sticas por tipo de padrÃ£o
        porPadrao: {}
    },
    
    // ğŸ¯ PADRÃƒO ATIVO ATUAL
    padraoAtual: null,
    
    // ğŸ“ˆ PERFORMANCE
    tempoInicializacao: 0,
    tempoUltimaAtualizacao: 0,
    totalAtualizacoes: 0
};

const PATTERN_DISCOVERY_CUTOFF_KEY = 'patternDiscoveryCutoff';
let patternDiscoveryCutoff = null;

async function loadPatternDiscoveryCutoffFlag() {
    try {
        const stored = await chrome.storage.local.get([PATTERN_DISCOVERY_CUTOFF_KEY]);
        patternDiscoveryCutoff = stored[PATTERN_DISCOVERY_CUTOFF_KEY] || null;
    } catch (error) {
        console.warn('âš ï¸ Erro ao carregar patternDiscoveryCutoff:', error);
        patternDiscoveryCutoff = null;
    }
}

async function setPatternDiscoveryCutoffFlag(timestamp = Date.now()) {
    patternDiscoveryCutoff = timestamp;
    try {
        await chrome.storage.local.set({ [PATTERN_DISCOVERY_CUTOFF_KEY]: timestamp });
    } catch (error) {
        console.warn('âš ï¸ NÃ£o foi possÃ­vel salvar patternDiscoveryCutoff:', error);
    }
}

async function clearPatternDiscoveryCutoffFlag() {
    patternDiscoveryCutoff = null;
    try {
        await chrome.storage.local.remove(PATTERN_DISCOVERY_CUTOFF_KEY);
    } catch (error) {
        console.warn('âš ï¸ NÃ£o foi possÃ­vel limpar patternDiscoveryCutoff:', error);
    }
}

function getSpinTimestampMs(spin) {
    if (!spin) return null;
    const candidates = [spin.timestamp, spin.created_at, spin.createdAt];
    for (const value of candidates) {
        if (value) {
            const parsed = Date.parse(value);
            if (!Number.isNaN(parsed)) {
                return parsed;
            }
        }
    }
    if (typeof spin.time === 'number') return spin.time;
    return null;
}

function filterHistoryByResetCutoff(history) {
    if (!patternDiscoveryCutoff || !Array.isArray(history)) {
        return history;
    }
    return history.filter(spin => {
        const ts = getSpinTimestampMs(spin);
        return ts ? ts >= patternDiscoveryCutoff : false;
    });
}

loadPatternDiscoveryCutoffFlag();

let memoriaAtivaInicializando = false;  // Flag para evitar inicializaÃ§Ãµes simultÃ¢neas

// Runtime analyzer configuration (overridable via chrome.storage.local)
// âœ… CONFIGURAÃ‡Ã•ES PADRÃƒO OTIMIZADAS (Modo de AnÃ¡lise PadrÃ£o do Sistema)
const DEFAULT_ANALYZER_CONFIG = {
    historyDepth: 500,            // âœ… profundidade de anÃ¡lise em giros (100-2000) - MODO PADRÃƒO
    minOccurrences: 2,            // âœ… quantidade mÃ­nima de WINS exigida (padrÃ£o: 2) - MODO PADRÃƒO
    maxOccurrences: 0,            // âœ… quantidade MÃXIMA de ocorrÃªncias (0 = sem limite)
    minIntervalSpins: 2,          // âœ… intervalo mÃ­nimo em GIROS entre OCORRÃŠNCIAS do MESMO padrÃ£o (modo padrÃ£o)
    minSignalIntervalSpins: 2,    // âœ… intervalo mÃ­nimo em GIROS entre ENTRADAS/SINAIS (modo Diamante)
    minPatternSize: 3,            // âœ… tamanho MÃNIMO do padrÃ£o (giros)
    maxPatternSize: 0,            // âœ… tamanho MÃXIMO do padrÃ£o (0 = sem limite)
    winPercentOthers: 100,        // âœ… WIN% mÃ­nima para as ocorrÃªncias restantes (100% = apenas padrÃµes perfeitos)
    requireTrigger: true,         // âœ… exigir cor de disparo (ATIVADO)
    consecutiveMartingale: false, // âœ… Legado: valor do modo ativo (mantido para compatibilidade)
    maxGales: 0,                  // âœ… Legado: valor do modo ativo (mantido para compatibilidade)
    n0AllowBlockAll: true,        // âœ… Permite bloqueio total pelo detector de branco (modo informativo se false)
    martingaleProfiles: {         // âœ… Perfis independentes por modo
        // consecutiveGales = quantos gales sÃ£o IMEDIATOS (consecutivos) antes de passar a esperar novo sinal
        // Ex.: maxGales=2 e consecutiveGales=1 => G1 imediato, G2 sÃ³ no prÃ³ximo sinal
        standard: { maxGales: 0, consecutiveMartingale: false, consecutiveGales: 0 },
        diamond: { maxGales: 0, consecutiveMartingale: false, consecutiveGales: 0 }
    },
    telegramChatId: '',           // Chat ID do Telegram para enviar sinais
    aiMode: false,                // Modo Diamante (true) ou Modo PadrÃ£o (false)
    signalIntensity: 'aggressive',  // Intensidade de sinais: 'aggressive' ou 'conservative'
    whiteProtectionAsWin: false,  // ProteÃ§Ã£o no Branco: conta branco como WIN (default: conta como LOSS)
    autoBetConfig: DEFAULT_AUTOBET_CONFIG,
    diamondLevelWindows: {        // ConfiguraÃ§Ã£o dos nÃ­veis do modo Diamante
        n1WindowSize: 20,         // N1 - Zona Segura (tamanho da janela)
        n1PrimaryRequirement: 15, // N1 - Zona Segura (requisito mÃ­nimo A)
        n1SecondaryRequirement: 3,// N1 - Zona Segura (requisito mÃ­nimo B)
        n1MaxEntries: 1,          // N1 - Zona Segura (entradas consecutivas permitidas)
        n2Recent: 10,             // N2 - Ritmo AutÃ´nomo (janela base W)
        n2Previous: 10,           // N2 - (legado) espelha W por compatibilidade
        n3Alternance: 12,         // N3 - AlternÃ¢ncia (histÃ³rico analisado em giros)
        n3PatternLength: 4,       // N3 - AlternÃ¢ncia (tamanho da janela n-gram L)
        n3MinOccurrences: 1,      // N3 - AlternÃ¢ncia (ocorrÃªncias mÃ­nimas para considerar a janela)
        n3ThresholdPct: 75,       // N3 - AlternÃ¢ncia (probabilidade mÃ­nima, em %)
        n3AllowBackoff: false,    // N3 - AlternÃ¢ncia (tentar janelas menores se nÃ£o houver dados)
        n3IgnoreWhite: false,     // N3 - AlternÃ¢ncia (ignorar previsÃµes de branco)
        n4Persistence: 20,        // N4 - PersistÃªncia / Ciclos
        n5MinuteBias: 60,         // N5 - Ritmo por Giro / Minuto
        n6RetracementWindow: 80,  // N6 - RetraÃ§Ã£o HistÃ³rica (janela de anÃ¡lise)
        n7DecisionWindow: 20,     // N7 - Continuidade Global (decisÃµes analisadas)
        n7HistoryWindow: 100,     // N7 - Continuidade Global (histÃ³rico base)
        n0History: 2000,          // N0 - Detector de Branco (histÃ³rico analisado)
        n0Window: 100,            // N0 - Detector de Branco (tamanho da janela nÃ£o-sobreposta)
        n8Barrier: 50,            // N9 - Barreira Final (mantido como n8Barrier por compatibilidade)
        n9History: 100,           // N9 - CalibraÃ§Ã£o Bayesiana (histÃ³rico base)
        n9NullThreshold: 8,       // N9 - CalibraÃ§Ã£o Bayesiana (diferenÃ§a mÃ­nima em % para votar)
        n9PriorStrength: 1,       // N9 - CalibraÃ§Ã£o Bayesiana (forÃ§a do prior Dirichlet)
        // N10 - Walk-forward NÃ£o-Sobreposto (janela em giros e histÃ³rico base)
        n10Window: 20,            // Tamanho da janela NÃƒO-SOBREPOSTA (W)
        n10History: 500,          // Quantidade de giros usados no walk-forward
        n10Analyses: 1000,        // Quantidade alvo de estratÃ©gias/variaÃ§Ãµes testadas
        n10MinWindows: 8,         // NÃºmero mÃ­nimo de janelas com prediÃ§Ã£o para ser elegÃ­vel
        n10ConfMin: 60            // ConfianÃ§a mÃ­nima global (%) para N10 votar
    },
    diamondLevelEnabled: {        // Controle individual dos 11 nÃ­veis (todos ativos por padrÃ£o)
        n0: true,
        n1: true,
        n2: true,
        n3: true,
        n4: true,
        n5: true,
        n6: true,
        n7: true,
        n8: true,  // N8 - Walk-forward nÃ£o-sobreposto
        n9: true,  // N9 - Barreira Final
        n10: true  // N10 - CalibraÃ§Ã£o Bayesiana
    }
};

const DIAMOND_LEVEL_IDS = Object.freeze(['N0', 'N1', 'N2', 'N3', 'N4', 'N5', 'N6', 'N7', 'N8', 'N9', 'N10']);

const SAFE_ZONE_DEFAULTS = Object.freeze({
    windowSize: DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n1WindowSize,
    primaryRequirement: DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n1PrimaryRequirement,
    secondaryRequirement: DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n1SecondaryRequirement,
    maxEntries: DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n1MaxEntries
});

function analyzeSafeZone(history, options = {}) {
    const colorPriority = ['black', 'red', 'white'];
    const windowSize = Math.max(5, Math.min(options.windowSize || SAFE_ZONE_DEFAULTS.windowSize, history.length));
    const minPrimary = Math.max(1, options.minPrimary || SAFE_ZONE_DEFAULTS.primaryRequirement);
    const minSecondary = Math.max(1, options.minSecondary || SAFE_ZONE_DEFAULTS.secondaryRequirement);
    const windowSpins = history.slice(0, windowSize);
    const counts = { red: 0, black: 0, white: 0 };
    windowSpins.forEach(spin => {
        if (spin && counts.hasOwnProperty(spin.color)) {
            counts[spin.color]++;
        }
    });

    const result = {
        windowSize,
        minPrimary,
        minSecondary,
        counts,
        dominant: null,
        secondary: null,
        lastColor: windowSpins[0]?.color || history[0]?.color || null,
        zoneActive: false,
        signal: false,
        strength: 0,
        reason: 'req_not_met'
    };

    if (windowSpins.length < windowSize) {
        result.reason = 'insufficient_history';
        return result;
    }

    const eligibleDominants = colorPriority
        .filter(color => counts[color] >= minPrimary)
        .sort((a, b) => {
            if (counts[b] === counts[a]) {
                return colorPriority.indexOf(a) - colorPriority.indexOf(b);
            }
            return counts[b] - counts[a];
        });

    if (!eligibleDominants.length) {
        return result;
    }

    result.dominant = eligibleDominants[0];

    const secondaryCandidates = colorPriority
        .filter(color => color !== result.dominant && counts[color] >= minSecondary)
        .sort((a, b) => counts[b] - counts[a]);

    if (!secondaryCandidates.length) {
        return result;
    }

    result.secondary = secondaryCandidates[0];
    result.zoneActive = true;
    result.strength = Math.min(1, counts[result.dominant] / windowSize);

    if (result.lastColor === result.dominant) {
        result.signal = true;
        result.reason = 'zone_active_last_is_dominant';

        // âœ… NOVO FILTRO FLEXÃVEL (N1):
        // - Permitir entradas mesmo se as Ãºltimas 2 ou 3 forem a dominante (ex.: RR ou RRR),
        //   mas SEMPRE evitando entrar no "topo" da sequÃªncia.
        // - A zona segura decide atÃ© onde "vai" olhando o histÃ³rico *dentro da prÃ³pria janela*:
        //   se a zona sÃ³ tem sequÃªncias de atÃ© 2/3, nÃ£o tentar 3â†’4; se tem atÃ© 4, permitir 3â†’4 etc.
        // - O N9 (Barreira Final) continua sendo o veto final de viabilidade histÃ³rica global.
        const recentColor = result.dominant;
        let recentStreak = 0;
        for (let i = 0; i < history.length; i++) {
            const c = history[i]?.color;
            if (!c) break;
            if (c === recentColor) recentStreak++;
            else break;
        }
        result.recentStreak = recentStreak;

        // Calcular o maior tamanho de sequÃªncia da dominante dentro da janela da zona (exclui brancos como continuidade).
        let dominantRunMax = 0;
        let curLen = 0;
        for (let i = 0; i < windowSpins.length; i++) {
            const c = windowSpins[i]?.color;
            if (c === recentColor) {
                curLen++;
                if (curLen > dominantRunMax) dominantRunMax = curLen;
            } else {
                curLen = 0;
            }
        }
        result.dominantRunMax = dominantRunMax;

        // Regra principal: sÃ³ sinaliza se a prÃ³xima sequÃªncia (recentStreak+1) estiver "dentro do que a zona jÃ¡ mostrou".
        // Ex.: se max na zona Ã© 3, permitir 1â†’2 e 2â†’3, mas bloquear 3â†’4.
        const nextTargetStreak = recentStreak + 1;
        result.nextTargetStreak = nextTargetStreak;
        if (dominantRunMax < 2) {
            result.signal = false;
            result.reason = 'zone_no_pairs';
        } else if (nextTargetStreak > dominantRunMax) {
            result.signal = false;
            result.reason = 'zone_run_limit';
        }
    } else {
        result.signal = false;
        result.reason = 'last_not_dominant';
    }

    return result;
}

function getSafeZoneSettingsFromAnalyzerConfig() {
    const windows = analyzerConfig?.diamondLevelWindows || {};
    let windowSize = Number(windows.n1WindowSize) || SAFE_ZONE_DEFAULTS.windowSize;
    let minPrimary = Number(windows.n1PrimaryRequirement) || SAFE_ZONE_DEFAULTS.primaryRequirement;
    let minSecondary = Number(windows.n1SecondaryRequirement) || SAFE_ZONE_DEFAULTS.secondaryRequirement;
    let maxEntries = Number(windows.n1MaxEntries) || SAFE_ZONE_DEFAULTS.maxEntries;

    windowSize = Math.max(5, Math.min(200, windowSize));
    minPrimary = Math.max(1, Math.min(windowSize - 1, minPrimary));
    minSecondary = Math.max(1, Math.min(minPrimary - 1, minSecondary));
    maxEntries = Math.max(1, Math.min(20, Math.floor(maxEntries)));

    return {
        windowSize,
        minPrimary,
        minSecondary,
        maxEntries
    };
}

let safeZoneEntryState = {
    signature: null,
    entriesUsed: 0
};

function buildSafeZoneSignature(meta) {
    if (!meta || !meta.dominant) return null;
    return `${meta.dominant}-${meta.secondary || 'none'}-${meta.windowSize}`;
}

function describeSafeZoneReason(reason) {
    switch (reason) {
        case 'insufficient_history':
            return 'HistÃ³rico insuficiente';
        case 'last_not_dominant':
            return 'Ãšltima cor nÃ£o confirma a dominante';
        case 'entry_limit_reached':
            return 'Limite de entradas atingido';
        case 'zone_active_last_is_dominant':
            return 'Zona confirmada';
        case 'zone_no_pairs':
            return 'Zona sem duplas (max=1)';
        case 'zone_run_limit':
            return 'Bloqueado: topo da sequÃªncia na zona';
        case 'req_not_met':
        default:
            return 'Requisitos mÃ­nimos nÃ£o atendidos';
    }
}

function getDiamondLevelKeyFromId(levelId = '') {
    return String(levelId).toLowerCase();
}

function isDiamondLevelEnabled(levelId, config = analyzerConfig) {
    const key = getDiamondLevelKeyFromId(levelId);
    const enabledMap = config && config.diamondLevelEnabled ? config.diamondLevelEnabled : DEFAULT_ANALYZER_CONFIG.diamondLevelEnabled;
    if (enabledMap && Object.prototype.hasOwnProperty.call(enabledMap, key)) {
        return !!enabledMap[key];
    }
    return true;
}

function countEnabledDiamondLevels(config = analyzerConfig) {
    return DIAMOND_LEVEL_IDS.reduce((sum, id) => sum + (isDiamondLevelEnabled(id, config) ? 1 : 0), 0);
}

function sanitizeMaxGales(value, fallback = 0) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric)) {
        const fallbackNumeric = Number(fallback);
        return Math.max(0, Math.min(200, Number.isFinite(fallbackNumeric) ? Math.floor(fallbackNumeric) : 0));
    }
    return Math.max(0, Math.min(200, Math.floor(numeric)));
}

function getMartingaleStageNumber(stage) {
    const s = String(stage || '').toUpperCase().trim();
    if (!s || s === 'ENTRADA' || s === 'G0') return 0;
    const m = s.match(/^G(\d+)$/);
    if (!m) return 0;
    const n = Number(m[1]);
    return Number.isFinite(n) && n >= 0 ? n : 0;
}

function roundMoney(value) {
    const n = Number(value);
    return Number.isFinite(n) ? Number(n.toFixed(2)) : 0;
}

function snapshotAutoBetConfig(config = analyzerConfig) {
    try {
        return sanitizeAutoBetConfig(config && config.autoBetConfig ? config.autoBetConfig : null);
    } catch (_) {
        return sanitizeAutoBetConfig(null);
    }
}

function getPayoutMultiplierForBetColor(betColor, autoBetCfg) {
    const c = String(betColor || '').toLowerCase();
    if (c === 'white' || c === 'branco') {
        const wm = Number(autoBetCfg && autoBetCfg.whitePayoutMultiplier);
        return Math.max(2, Number.isFinite(wm) ? wm : 14);
    }
    return 2;
}

function calcStakeForStage(stageLabel, autoBetCfg) {
    const cfg = autoBetCfg && typeof autoBetCfg === 'object' ? autoBetCfg : snapshotAutoBetConfig();
    const base = Math.max(0.01, Number(cfg.baseStake) || 0.01);
    const mult = Math.max(1, Number(cfg.galeMultiplier) || 1);
    const k = getMartingaleStageNumber(stageLabel);
    return roundMoney(base * Math.pow(mult, k));
}

function calcTotalInvestedThroughStage(stageLabel, autoBetCfg) {
    const cfg = autoBetCfg && typeof autoBetCfg === 'object' ? autoBetCfg : snapshotAutoBetConfig();
    const base = Math.max(0.01, Number(cfg.baseStake) || 0.01);
    const mult = Math.max(1, Number(cfg.galeMultiplier) || 1);
    const k = getMartingaleStageNumber(stageLabel);
    let sum = 0;
    for (let i = 0; i <= k; i++) {
        sum += base * Math.pow(mult, i);
    }
    return roundMoney(sum);
}

function ensureMartingaleCycleConfig(autoBetCfg) {
    try {
        const cfg = autoBetCfg && typeof autoBetCfg === 'object' ? autoBetCfg : snapshotAutoBetConfig();
        if (!martingaleState || typeof martingaleState !== 'object') return cfg;
        if (!martingaleState.cycleAutoBetConfig || typeof martingaleState.cycleAutoBetConfig !== 'object') {
            martingaleState.cycleAutoBetConfig = {
                baseStake: Number(cfg.baseStake) || 0,
                galeMultiplier: Number(cfg.galeMultiplier) || 0,
                whitePayoutMultiplier: Number(cfg.whitePayoutMultiplier) || 14
            };
        }
        return martingaleState.cycleAutoBetConfig;
    } catch (_) {
        return snapshotAutoBetConfig();
    }
}

function isMartingaleStageConsecutive(stage, consecutiveGales) {
    const k = getMartingaleStageNumber(stage);
    const limit = Math.max(0, Number(consecutiveGales) || 0);
    return k > 0 && k <= limit;
}

function ensureMartingaleProfiles(config) {
    if (!config) return;
    const defaults = DEFAULT_ANALYZER_CONFIG.martingaleProfiles || {};
    if (!config.martingaleProfiles || typeof config.martingaleProfiles !== 'object') {
        config.martingaleProfiles = {};
    }
    ['standard', 'diamond'].forEach(mode => {
        const profile = config.martingaleProfiles[mode] || {};
        const defaultProfile = defaults[mode] || { maxGales: 0, consecutiveMartingale: false, consecutiveGales: 0 };
        const inheritedMax = profile.maxGales != null ? profile.maxGales : config.maxGales;
        const inheritedConsecutive = profile.consecutiveMartingale != null ? profile.consecutiveMartingale : config.consecutiveMartingale;

        const maxGales = sanitizeMaxGales(inheritedMax, defaultProfile.maxGales);

        // âœ… consecutiveGales: 0..maxGales
        // - se vier no profile, respeitar (com clamp)
        // - senÃ£o, compat com boolean antigo: consecutiveMartingale=true => todos os gales consecutivos
        const rawConsecutiveGales =
            profile.consecutiveGales != null
                ? Number(profile.consecutiveGales)
                : (typeof inheritedConsecutive === 'boolean' && inheritedConsecutive ? maxGales : 0);
        const consecutiveGales = Math.max(0, Math.min(maxGales, Math.floor(Number.isFinite(rawConsecutiveGales) ? rawConsecutiveGales : 0)));

        // âœ… Mantido por compatibilidade: agora significa "tem parte consecutiva"
        const consecutiveMartingale = consecutiveGales > 0;
        config.martingaleProfiles[mode] = {
            maxGales,
            consecutiveGales,
            consecutiveMartingale
        };
    });
}

function sanitizeAutoBetConfig(rawConfig) {
    const source = rawConfig && typeof rawConfig === 'object' ? rawConfig : {};
    const parseNumber = (value, fallback) => {
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : fallback;
    };
    const sanitized = {
        ...DEFAULT_AUTOBET_CONFIG
    };
    sanitized.enabled = !!source.enabled;
    sanitized.simulationOnly = source.simulationOnly === undefined
        ? DEFAULT_AUTOBET_CONFIG.simulationOnly
        : !!source.simulationOnly;
    sanitized.baseStake = Math.max(0.01, parseNumber(source.baseStake, DEFAULT_AUTOBET_CONFIG.baseStake));
    sanitized.galeMultiplier = Math.max(1, parseNumber(source.galeMultiplier, DEFAULT_AUTOBET_CONFIG.galeMultiplier));
    sanitized.delayMs = Math.max(0, Math.round(parseNumber(source.delayMs, DEFAULT_AUTOBET_CONFIG.delayMs)));
    sanitized.stopWin = Math.max(0, parseNumber(source.stopWin, DEFAULT_AUTOBET_CONFIG.stopWin || 0));
    sanitized.stopLoss = Math.max(0, parseNumber(source.stopLoss, DEFAULT_AUTOBET_CONFIG.stopLoss || 0));
    sanitized.simulationBankRoll = Math.max(0, parseNumber(source.simulationBankRoll, DEFAULT_AUTOBET_CONFIG.simulationBankRoll || 0));
    sanitized.whitePayoutMultiplier = Math.max(2, parseNumber(source.whitePayoutMultiplier, DEFAULT_AUTOBET_CONFIG.whitePayoutMultiplier || 14));
    return sanitized;
}

function getModeKey(config = analyzerConfig) {
    return config && config.aiMode ? 'diamond' : 'standard';
}

function getMartingaleSettings(modeKey = getModeKey(), config = analyzerConfig) {
    if (!config) {
        return { maxGales: 0, consecutiveMartingale: false, consecutiveGales: 0 };
    }
    ensureMartingaleProfiles(config);
    const profiles = config.martingaleProfiles || {};
    const profile = profiles[modeKey] || { maxGales: 0, consecutiveMartingale: false, consecutiveGales: 0 };
    const maxGales = sanitizeMaxGales(profile.maxGales);
    const consecutiveGales = Math.max(0, Math.min(maxGales, Math.floor(Number(profile.consecutiveGales) || 0)));
    return {
        maxGales,
        consecutiveGales,
        consecutiveMartingale: consecutiveGales > 0
    };
}

function syncActiveMartingaleSettings(config = analyzerConfig) {
    if (!config) return;
    const activeProfile = getMartingaleSettings(getModeKey(config), config);
    config.maxGales = activeProfile.maxGales;
    config.consecutiveMartingale = activeProfile.consecutiveMartingale;
}

function mergeAnalyzerConfig(overrides = {}) {
    const defaults = DEFAULT_ANALYZER_CONFIG.martingaleProfiles || {};
    const overrideProfiles = (overrides && overrides.martingaleProfiles) || {};
    analyzerConfig = {
        ...DEFAULT_ANALYZER_CONFIG,
        ...(overrides || {})
    };
    const hasAllowBlockOverride = overrides && Object.prototype.hasOwnProperty.call(overrides, 'n0AllowBlockAll');
    analyzerConfig.n0AllowBlockAll = hasAllowBlockOverride
        ? !!overrides.n0AllowBlockAll
        : DEFAULT_ANALYZER_CONFIG.n0AllowBlockAll;
    analyzerConfig.martingaleProfiles = {
        standard: { ...(defaults.standard || {}), ...(overrideProfiles.standard || {}) },
        diamond: { ...(defaults.diamond || {}), ...(overrideProfiles.diamond || {}) }
    };
    const defaultEnabled = DEFAULT_ANALYZER_CONFIG.diamondLevelEnabled || {};
    const overrideEnabled = (overrides && overrides.diamondLevelEnabled) || {};
    analyzerConfig.diamondLevelEnabled = {};
    Object.keys(defaultEnabled).forEach(key => {
        analyzerConfig.diamondLevelEnabled[key] = Object.prototype.hasOwnProperty.call(overrideEnabled, key)
            ? !!overrideEnabled[key]
            : !!defaultEnabled[key];
    });
    Object.keys(overrideEnabled).forEach(key => {
        if (!Object.prototype.hasOwnProperty.call(analyzerConfig.diamondLevelEnabled, key)) {
            analyzerConfig.diamondLevelEnabled[key] = !!overrideEnabled[key];
        }
    });
    ensureMartingaleProfiles(analyzerConfig);
    syncActiveMartingaleSettings(analyzerConfig);
    analyzerConfig.autoBetConfig = sanitizeAutoBetConfig(
        (overrides && overrides.autoBetConfig) || analyzerConfig.autoBetConfig
    );
    return analyzerConfig;
}

function getProfileCompletionSnapshot(user) {
    const missing = [];
    if (!user || typeof user !== 'object') {
        return { complete: false, missing: ['Telefone', 'CPF', 'CEP', 'Rua', 'NÃºmero', 'Bairro', 'Cidade', 'Estado'] };
    }
    const digits = (value) => String(value || '').replace(/\D/g, '');
    const phoneDigits = digits(user.phone);
    const cpfDigits = digits(user.cpf);
    const addr = typeof user.address === 'string'
        ? (() => { try { return JSON.parse(user.address); } catch (_) { return null; } })()
        : (user.address || null);
    const zipDigits = digits(addr?.zipCode);
    const street = String(addr?.street || '').trim();
    const number = String(addr?.number || '').trim();
    const neighborhood = String(addr?.neighborhood || '').trim();
    const city = String(addr?.city || '').trim();
    const state = String(addr?.state || '').trim();

    if (phoneDigits.length < 10) missing.push('Telefone');
    if (cpfDigits.length !== 11) missing.push('CPF');
    if (zipDigits.length !== 8) missing.push('CEP');
    if (!street) missing.push('Rua');
    if (!number) missing.push('NÃºmero');
    if (!neighborhood) missing.push('Bairro');
    if (!city) missing.push('Cidade');
    if (state.length !== 2) missing.push('Estado');

    return { complete: missing.length === 0, missing };
}

async function enforceProfileGateOnAIMode(context = 'unknown') {
    try {
        if (!analyzerConfig || !analyzerConfig.aiMode) return { allowed: true };
        const storage = await chrome.storage.local.get(['user', 'analyzerConfig']);
        const user = storage.user || null;
        const status = getProfileCompletionSnapshot(user);
        if (status.complete) return { allowed: true };

        console.warn(`ğŸ”’ [${context}] Bloqueando Modo IA: cadastro incompleto.`, status.missing);
        // ForÃ§ar off em memÃ³ria e persistir
        analyzerConfig.aiMode = false;
        if (storage.analyzerConfig && typeof storage.analyzerConfig === 'object') {
            const updated = { ...storage.analyzerConfig, aiMode: false };
            await chrome.storage.local.set({ analyzerConfig: updated });
        } else {
            await chrome.storage.local.set({ analyzerConfig: { ...(analyzerConfig || {}), aiMode: false } });
        }

        // Avisar UI para atualizar e mostrar motivo
        try {
            sendMessageToContent('AI_MODE_BLOCKED_PROFILE', {
                missing: status.missing
            });
        } catch (err) {
            console.warn('âš ï¸ NÃ£o foi possÃ­vel notificar content.js sobre bloqueio de IA:', err);
        }

        return { allowed: false, missing: status.missing };
    } catch (error) {
        console.warn('âš ï¸ Erro ao aplicar gate de cadastro no Modo IA:', error);
        return { allowed: true };
    }
}

let analyzerConfig;
mergeAnalyzerConfig();

function getDiamondWindow(key, fallback) {
    const windows = analyzerConfig && analyzerConfig.diamondLevelWindows ? analyzerConfig.diamondLevelWindows : {};
    const rawValue = windows ? Number(windows[key]) : NaN;
    if (Number.isFinite(rawValue) && rawValue > 0) {
        return rawValue;
    }
    const legacyKeyMap = {
        n6RetracementWindow: 'n8RetracementWindow',
        n7DecisionWindow: 'n10DecisionWindow',
        n7HistoryWindow: 'n10HistoryWindow',
        n8Barrier: 'n6Barrier',
        n0History: 'n0TotalHistory',
        n0Window: 'n0WindowSize'
    };
    const legacyKey = legacyKeyMap[key];
    if (legacyKey && Number.isFinite(Number(windows[legacyKey])) && Number(windows[legacyKey]) > 0) {
        return Number(windows[legacyKey]);
    }
    // Compatibilidade com versÃµes antigas (ex.: minuteSpinWindow individual)
    if (key === 'n5MinuteBias' && Number.isFinite(Number(analyzerConfig.minuteSpinWindow))) {
        const legacy = Number(analyzerConfig.minuteSpinWindow);
        if (legacy > 0) return legacy;
    }
    return fallback;
}

function getDiamondConfigRawValue(key) {
    if (!analyzerConfig || !analyzerConfig.diamondLevelWindows) {
        return undefined;
    }
    return analyzerConfig.diamondLevelWindows[key];
}

function getDiamondBoolean(key, fallback = false) {
    const raw = getDiamondConfigRawValue(key);
    if (raw === undefined) {
        return fallback;
    }
    if (typeof raw === 'boolean') {
        return raw;
    }
    if (typeof raw === 'string') {
        const lowered = raw.trim().toLowerCase();
        if (lowered === 'true') return true;
        if (lowered === 'false') return false;
        const numeric = Number(raw);
        if (!Number.isNaN(numeric)) {
            return numeric > 0;
        }
        return fallback;
    }
    if (typeof raw === 'number') {
        if (!Number.isNaN(raw)) {
            return raw > 0;
        }
    }
    return fallback;
}

// âš ï¸ FLAG DE CONTROLE: Evitar envio de sinal na primeira anÃ¡lise apÃ³s ativar modo IA
let aiModeJustActivated = false;

// Armazena timeouts usados para animar a exibiÃ§Ã£o sequencial dos nÃ­veis Diamante
let lastDiamondLevelTimeouts = [];

// ğŸ“Š CONTADOR DE CORES RECOMENDADAS PELA IA (para detectar viÃ©s)
let aiColorCounter = {
    red: 0,
    black: 0,
    white: 0,
    total: 0
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ CONSTANTES GLOBAIS PARA CÃLCULO DE ASSERTIVIDADE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const RECENT_WINDOW = 25;
const PENALTY_OPPOSITE_DOMINANCE = 15; // -15% se dominÃ¢ncia da cor oposta >70%
const PENALTY_LONG_STREAK = 10; // -10% se repetiÃ§Ã£o >5
const BONUS_FAVORABLE_TREND = 10; // +10% se tendÃªncia a favor >60%
const BONUS_STABILITY = 5; // +5% estÃ¡vel
const PENALTY_INSTABILITY = 5; // -5% instÃ¡vel

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š CALIBRADOR DE PORCENTAGENS - CONFIGURAÃ‡ÃƒO E DADOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const OBSERVER_CONFIG = {
    maxHistorySize: 200,        // MÃ¡ximo de entradas observadas
    minEntriesForCalibration: 20 // MÃ­nimo para comeÃ§ar a calibrar
};

// Estrutura do observador em memÃ³ria (DEVE estar no topo para evitar TDZ errors)
let observerData = {
    entries: [],              // HistÃ³rico de entradas observadas
    calibrationFactor: 1.0,   // Fator de correÃ§Ã£o global (1.0 = sem ajuste)
    lastCalibration: null,    // Timestamp da Ãºltima calibraÃ§Ã£o
    lastCalibratedCount: 0,   // NÃºmero de entradas na Ãºltima calibraÃ§Ã£o
    stats: {                  // EstatÃ­sticas por faixa de confianÃ§a
        high: { predicted: 0, actual: 0, wins: 0, total: 0 },    // 80-100%
        medium: { predicted: 0, actual: 0, wins: 0, total: 0 },  // 60-79%
        low: { predicted: 0, actual: 0, wins: 0, total: 0 }      // 0-59%
    }
};

// Telegram Bot Configuration
const TELEGRAM_BOT_TOKEN = '8330409447:AAHTWT8BzRZOnNukKYdiI9_QMyTUORvE1gg';
const TELEGRAM_API_URL = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– PROMPT PADRÃƒO DA IA (usado se customPrompt estiver vazio)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DEFAULT_AI_PROMPT = (historyLength, historyText, patternsText = '', last20Text = '') => `VocÃª Ã© um especialista em anÃ¡lise de padrÃµes do jogo Double da Blaze.

${patternsText}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸš¨ ÃšLTIMOS 20 GIROS (OS MAIS IMPORTANTES - ANALISE ESTES!) ğŸš¨
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${last20Text || historyText.split(',').slice(0, 20).join(',')}

âš ï¸ ATENÃ‡ÃƒO CRÃTICA:
- O giro "1." Ã© o MAIS RECENTE (acabou de sair)
- O giro "2." Ã© o anterior ao 1.
- O giro "3." Ã© o anterior ao 2.
- E assim por diante...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
HISTÃ“RICO COMPLETO (${historyLength} GIROS - para contexto):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${historyText}

REGRAS DO JOGO:
- Existem 3 cores: red (vermelho), black (preto), white (branco)
- NÃºmeros 1-7 = red
- NÃºmeros 8-14 = black
- NÃºmero 0 = white

âš ï¸ REGRA FUNDAMENTAL - SEM VIÃ‰S:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VOCÃŠ NÃƒO PODE TER PREFERÃŠNCIA POR NENHUMA COR!
- Se o padrÃ£o indicar VERMELHO com 90% â†’ aposte em VERMELHO
- Se o padrÃ£o indicar PRETO com 90% â†’ aposte em PRETO
- Se o padrÃ£o indicar BRANCO com 90% â†’ aposte em BRANCO
- NUNCA favoreÃ§a uma cor sobre outra sem justificativa nos dados!
- Suas apostas devem ser baseadas APENAS nos padrÃµes do histÃ³rico!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
METODOLOGIA DE ANÃLISE (SIGA EXATAMENTE ESTA ORDEM):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PASSO 1: CITAR OS ÃšLTIMOS 20 GIROS (OBRIGATÃ“RIO)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸš¨ VOCÃŠ **DEVE** COMEÃ‡AR SUA RESPOSTA CITANDO OS 20 GIROS! ğŸš¨

FORMATO OBRIGATÃ“RIO:
"Ãšltimos 20 giros recebidos:
1. (mais recente) [cor] ([nÃºmero])
2. [cor] ([nÃºmero])
3. [cor] ([nÃºmero])
...atÃ© 20"

âš ï¸ NÃƒO INVENTE! COPIE EXATAMENTE O QUE ESTÃ EM "ÃšLTIMOS 20 GIROS"!
âš ï¸ SE VOCÃŠ CITAR GIROS DIFERENTES, SUA ANÃLISE SERÃ REJEITADA!
âš ï¸ Ã‰ **OBRIGATÃ“RIO** CITAR OS 20 GIROS ANTES DE FAZER QUALQUER ANÃLISE!

PASSO 2: ANALISAR OS ÃšLTIMOS 20 GIROS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ¯ SISTEMA: COMPARAÃ‡ÃƒO COM PADRÃ•ES DETECTADOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

O sistema JavaScript JÃ ANALISOU todo o histÃ³rico e DETECTOU padrÃµes reais!
VocÃª recebeu um RELATÃ“RIO COM ESTATÃSTICAS REAIS de cada padrÃ£o.

SUA TAREFA:
1ï¸âƒ£ **LEIA O RELATÃ“RIO DE PADRÃ•ES** (no inÃ­cio)
   - Veja quais padrÃµes foram encontrados
   - Veja as ESTATÃSTICAS REAIS de cada padrÃ£o
   - Essas porcentagens sÃ£o FATOS (nÃ£o invente outras!)

2ï¸âƒ£ **IDENTIFIQUE O PADRÃƒO QUE ESTÃ ATIVO AGORA (comeÃ§ando do giro 1)**
   - âš ï¸ **CRÃTICO:** O padrÃ£o DEVE comeÃ§ar no giro 1 (mais recente) e ir para trÃ¡s!
   - âœ… O padrÃ£o pode ter qualquer tamanho (6, 8, 10, 15 giros... nÃ£o tem limite)!
   - âœ… Use os 20 giros para ter CONTEXTO MACRO e identificar padrÃµes grandes
   - âœ… Exemplo CORRETO: Se giros **1-6** = P-V-P-V-P-V â†’ "AlternÃ¢ncia Simples ATIVA"
   - âœ… Exemplo CORRETO: Se giros **1-15** = P-P-V-V-P-P-V-V-P-P-V-V-P-P-V â†’ "AlternÃ¢ncia Dupla ATIVA" (padrÃ£o grande!)
   - âŒ Exemplo ERRADO: Giros 1-5 = P-V-P-V-P, mas vocÃª usa padrÃ£o dos giros **8-14** = R-R-R-R-R-R-R
   - âŒ **NÃƒO USE** padrÃµes que estÃ£o "no meio" ou "no final" dos 20 giros se eles NÃƒO incluem o giro 1!

3ï¸âƒ£ **USE AS ESTATÃSTICAS REAIS DO RELATÃ“RIO**
   - Se encontrou um padrÃ£o que bate, use a estatÃ­stica REAL do relatÃ³rio
   - Exemplo: RelatÃ³rio diz "AlternÃ¢ncia Simples â†’ VERMELHO 80% (12/15)"
   - Sua recomendaÃ§Ã£o deve ser: VERMELHO com 80% de confianÃ§a

4ï¸âƒ£ **SE NÃƒO BATER COM NENHUM PADRÃƒO DO RELATÃ“RIO**
   - Analise o padrÃ£o visual dos Ãºltimos 20 giros de forma livre
   - Identifique tendÃªncias (alternÃ¢ncia, sequÃªncia, etc)
   - Use confianÃ§a MENOR (50-70%) pois nÃ£o tem estatÃ­stica histÃ³rica comprovada

âš ï¸ REGRAS CRÃTICAS:
- **NUNCA** invente sequÃªncias que NÃƒO existem nos 20 giros que vocÃª citou!
- **SEMPRE** compare com os padrÃµes do relatÃ³rio PRIMEIRO!
- **USE** apenas as porcentagens do relatÃ³rio (nÃ£o invente outras!)
- Se nÃ£o hÃ¡ padrÃ£o claro nos Ãºltimos 20 giros â†’ confidence: 0 (nÃ£o apostar)

TIPOS DE PADRÃƒO:

A) ALTERNÃ‚NCIA SIMPLES?
   Exemplo: P-V-P-V-P-V-P-V-P-V ou V-P-V-P-V-P-V-P-V-P
   
B) ALTERNÃ‚NCIA DUPLA?
   Exemplo: P-P-V-V-P-P-V-V-P-P-V-V ou V-V-P-P-V-V-P-P-V-V
   
C) ALTERNÃ‚NCIA TRIPLA?
   Exemplo: P-P-P-V-V-V-P-P-P-V-V-V ou V-V-V-P-P-P-V-V-V-P-P-P
   
D) SEQUÃŠNCIA LONGA (mesma cor)?
   Exemplo: P-P-P-P-P-P-P-P-P-P ou V-V-V-V-V-V-V-V-V-V
   
E) TRANSIÃ‡ÃƒO DE PADRÃƒO?
   Exemplo: Giros 11-20 eram alternÃ¢ncia dupla, mas Ãºltimos 10 viraram sequÃªncia
   âš ï¸ Neste caso, considere que estÃ¡ em TRANSIÃ‡ÃƒO â†’ use padrÃ£o dos Ãºltimos 10
   
F) ALEATÃ“RIO (sem padrÃ£o)?
   Exemplo: P-V-P-P-V-V-P-V-P-V-P-V (nÃ£o segue lÃ³gica clara)

PASSO 3: FAZER RECOMENDAÃ‡ÃƒO BASEADA NO PADRÃƒO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸš¨ VOCÃŠ **NÃƒO PODE** INVENTAR ESTATÃSTICAS! ğŸš¨

âœ… SE ENCONTROU PADRÃƒO QUE BATE COM O RELATÃ“RIO:
"PadrÃ£o identificado: [nome do padrÃ£o do relatÃ³rio]"
"Baseado em [X] ocorrÃªncias no histÃ³rico, esse padrÃ£o foi seguido por [cor] em [Y]% das vezes"
"RecomendaÃ§Ã£o: [cor]"

âŒ NÃƒO INVENTE NÃšMEROS OU SEQUÃŠNCIAS!
- Use APENAS as estatÃ­sticas do RELATÃ“RIO!
- O padrÃ£o identificado DEVE comeÃ§ar no giro 1 (mais recente)!
- NÃƒO use padrÃµes que estÃ£o "no meio" dos 20 giros (ex: giros 8-14)!
- Se o padrÃ£o nÃ£o INCLUI o giro 1, ele NÃƒO estÃ¡ ativo!
- Exemplo: Se giros 1-5 = V-P-V-V-P, NÃƒO diga "SequÃªncia de 7 vermelhos" baseado nos giros 8-14!

âœ… SE NÃƒO BATEU COM NENHUM PADRÃƒO DO RELATÃ“RIO:
"Nenhum padrÃ£o conhecido detectado nos Ãºltimos 20 giros"
"PadrÃ£o visual: [descreva o que REALMENTE VÃŠ]"
"RecomendaÃ§Ã£o: [cor] (confianÃ§a baixa)" ou "confidence: 0 (nÃ£o apostar)"

PASSO 4: REGRA DE DECISÃƒO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Se o padrÃ£o Ã© CLARO â†’ confianÃ§a 70-95%
- Se o padrÃ£o Ã© FRACO/INCERTO â†’ confianÃ§a 0-50%
- Se ALEATÃ“RIO â†’ confidence: 0 (nÃ£o apostar)

PASSO 5: CASOS ESPECIAIS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BRANCO (0):
- NUNCA use lÃ³gica de "branco atrasado"
- SÃ³ considere branco se ele fizer parte de um padrÃ£o claro nos Ãºltimos 10-20 giros
- Se nÃ£o hÃ¡ branco no padrÃ£o recente, ignore-o completamente

ALEATÃ“RIO:
- Se os Ãºltimos 20 giros nÃ£o tÃªm padrÃ£o claro, retorne confidence: 0
- NÃƒO force um padrÃ£o onde nÃ£o existe!
- Ã‰ melhor NÃƒO apostar do que apostar em padrÃ£o aleatÃ³rio

ANÃLISE EM CAMADAS (IMPORTANTE):
1ï¸âƒ£ Primeiro: Analise os Ãºltimos **15-20 giros** para identificar o padrÃ£o DOMINANTE
2ï¸âƒ£ Segundo: Verifique se os Ãºltimos **10 giros** CONFIRMAM esse padrÃ£o
3ï¸âƒ£ Terceiro: 
   - Se CONFIRMAM â†’ alta confianÃ§a! Busque esse padrÃ£o no histÃ³rico completo
   - Se CONTRADIZEM â†’ pode estar em transiÃ§Ã£o. Retorne confidence baixo ou 0
   - NUNCA use apenas os Ãºltimos 10 giros como padrÃ£o Ãºnico!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
INSTRUÃ‡Ã•ES FINAIS (PASSO A PASSO):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1ï¸âƒ£ **CITE os 10 primeiros giros** literalmente (nÃ£o invente!)

2ï¸âƒ£ **ANALISE 15-20 giros** para identificar o padrÃ£o dominante
   - NÃƒO olhe apenas 10 giros!
   - Identifique o padrÃ£o na janela maior

3ï¸âƒ£ **CONFIRME com os Ãºltimos 10 giros**
   - Os Ãºltimos 10 devem estar alinhados com o padrÃ£o identificado
   - Se nÃ£o estiverem, pode estar em transiÃ§Ã£o (cuidado!)

4ï¸âƒ£ **FAÃ‡A A RECOMENDAÃ‡ÃƒO**
   - Baseie-se apenas no padrÃ£o VISUAL identificado
   - NÃƒO INVENTE estatÃ­sticas ou contagens!
   - Seja honesto se nÃ£o houver padrÃ£o claro

5ï¸âƒ£ **SEJA IMPARCIAL**
   - NÃƒO favoreÃ§a nenhuma cor especÃ­fica!
   - Baseie-se APENAS nos padrÃµes visuais que vocÃª vÃª!

FORMATO DE RESPOSTA (JSON):

âš ï¸ ATENÃ‡ÃƒO: NÃƒO inclua o campo "last10Spins" na resposta!
O sistema automaticamente pega os dados REAIS do histÃ³rico.
Se vocÃª incluir esse campo, estarÃ¡ INVENTANDO dados falsos!

{
  "color": "red ou black ou white",
  "confidence": nÃºmero de 0 a 100 (0 = sem padrÃ£o confiÃ¡vel),
  "probability": nÃºmero de 0 a 100,
  "reasoning": "PadrÃ£o identificado: [descreva o padrÃ£o]. Encontrado [X] vezes no histÃ³rico. ApÃ³s esse padrÃ£o: [cor] saiu [Y]% das vezes. DecisÃ£o: [apostar/nÃ£o apostar]"
}

âš ï¸ IMPORTANTE: APENAS 4 campos no JSON (color, confidence, probability, reasoning)
NÃƒO inclua last10Spins, last5Spins ou qualquer outro campo!

EXEMPLOS DE RESPOSTAS CORRETAS (USANDO RELATÃ“RIO DE PADRÃ•ES):

EXEMPLO 1 - PADRÃƒO ATIVO comeÃ§ando no giro 1 (8 giros):
{
  "color": "red",
  "confidence": 85,
  "probability": 85,
  "reasoning": "Ãšltimos 20 giros recebidos: 1. black (9), 2. black (11), 3. red (4), 4. red (7), 5. black (14), 6. black (8), 7. red (2), 8. red (5), 9. black (12)... atÃ© 20. PadrÃ£o ATIVO identificado nos giros 1-8: 1.P, 2.P, 3.V, 4.V, 5.P, 6.P, 7.V, 8.V = AlternÃ¢ncia Dupla (P-P-V-V-P-P-V-V). Segundo o relatÃ³rio, este padrÃ£o apareceu 15 vezes no histÃ³rico e foi seguido por VERMELHO em 85% das vezes (13/15). RecomendaÃ§Ã£o: VERMELHO."
}

EXEMPLO 2 - PADRÃƒO ATIVO comeÃ§ando no giro 1 (15 giros - PADRÃƒO GRANDE!):
{
  "color": "black",
  "confidence": 90,
  "probability": 90,
  "reasoning": "Ãšltimos 20 giros: 1. black (10), 2. black (9), 3. red (4), 4. red (7), 5. black (14), 6. black (8), 7. red (2), 8. red (5), 9. black (12), 10. black (11), 11. red (3), 12. red (1), 13. black (13), 14. black (9), 15. red (6)... atÃ© 20. PadrÃ£o ATIVO identificado nos giros 1-15: AlternÃ¢ncia Dupla (P-P-V-V-P-P-V-V-P-P-V-V-P-P-V). PadrÃ£o grande e consistente! Segundo o relatÃ³rio, foi seguido por VERMELHO em 85% das vezes. RecomendaÃ§Ã£o: VERMELHO com alta confianÃ§a."
}

EXEMPLO 3 - NENHUM PADRÃƒO DO RELATÃ“RIO (analise livre):
{
  "color": "red",
  "confidence": 60,
  "probability": 60,
  "reasoning": "Ãšltimos 20 giros: 1. black (12), 2. red (3), 3. black (9), 4. red (7), 5. black (11)... atÃ© 20. Analisando os giros comeÃ§ando do 1: AlternÃ¢ncia irregular (P-V-P-V-P...). Nenhum padrÃ£o conhecido do relatÃ³rio detectado. VisÃ£o macro dos 20 giros: leve predominÃ¢ncia de pretos. RecomendaÃ§Ã£o: VERMELHO (reversÃ£o esperada) com confianÃ§a moderada."
}

EXEMPLO 4 - NÃƒO APOSTAR (sem padrÃ£o):
{
  "color": "red",
  "confidence": 0,
  "probability": 0,
  "reasoning": "Giro 1 (mais recente): black (12), Giro 2: red (3), Giro 3: white (0), Giro 4: black (8), Giro 5: red (7). PadrÃ£o identificado: ALEATÃ“RIO. NÃ£o hÃ¡ padrÃ£o claro ou consistente nos Ãºltimos 20 giros. Giros completamente irregulares (P-V-B-P-V-P-B-V...). Sem padrÃ£o detectÃ¡vel. RecomendaÃ§Ã£o: NÃƒO APOSTAR."
}

âš ï¸ REGRAS CRÃTICAS: 
- CITE os primeiros 5-10 giros no campo "reasoning"
- NÃƒO inclua o campo "last10Spins" - o sistema pega automaticamente!
- NÃƒO INVENTE contagens, porcentagens ou estatÃ­sticas!
- Descreva APENAS o padrÃ£o VISUAL que vocÃª vÃª
- NÃƒO TENHA VIÃ‰S para nenhuma cor! Analise imparcialmente!
- Se nÃ£o hÃ¡ padrÃ£o claro â†’ retorne confidence: 0

RESPONDA APENAS COM O JSON, SEM TEXTO ADICIONAL.`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SISTEMA DE MARTINGALE (G1, G2)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Estado do ciclo de Martingale atual
let martingaleState = {
    active: false,                    // Se hÃ¡ um ciclo ativo
    stage: 'ENTRADA',                 // 'ENTRADA' | 'G1' | 'G2'
    patternKey: null,                 // Identificador do padrÃ£o atual
    entryColor: null,                 // Cor da entrada inicial (aposta)
    entryColorResult: null,           // Cor que realmente saiu na entrada
    entryTimestamp: null,             // Timestamp da entrada inicial
    analysisData: null,               // Dados completos da anÃ¡lise
    lossCount: 0,                     // Contador de LOSS consecutivos
    lossColors: [],                   // Array de cores dos giros que deram LOSS
    patternsWithoutHistory: 0         // Contador de padrÃµes sem histÃ³rico que deram LOSS
};

function calculateGaleConfidenceValue(baseConfidence = 0, analysis = null, state = martingaleState) {
    if (!state || !state.active) {
        return Number.isFinite(baseConfidence) ? Math.round(baseConfidence * 10) / 10 : 0;
    }

    const lossCount = Number(state.lossCount || 0);
    const lossColors = Array.isArray(state.lossColors) ? state.lossColors : [];
    const targetColor = state.entryColor || analysis?.color || null;
    const numericBase = Number(baseConfidence) || 0;

    const baseWeight = 0.30;
    const consecutiveWeight = 0.25;
    const colorWeight = 0.25;
    const patternWeight = 0.20;

    let weightedConfidence = numericBase * baseWeight;

    let consecutiveBonus = 0;
    if (lossCount === 1) {
        consecutiveBonus = 10;
    } else if (lossCount === 2) {
        consecutiveBonus = 15;
    } else if (lossCount >= 3) {
        consecutiveBonus = 20;
    }
    weightedConfidence += consecutiveBonus * consecutiveWeight;

    let colorBonus = 0;
    if (targetColor) {
        const recentColors = lossColors.slice(-5);
        const targetHits = recentColors.filter(color => color === targetColor).length;
        if (targetHits === 0) {
            colorBonus = 12;
        } else if (targetHits === 1) {
            colorBonus = 5;
        } else {
            colorBonus = 2;
        }
    }
    weightedConfidence += colorBonus * colorWeight;

    let patternBonus = 0;
    if (analysis && analysis.patternDescription) {
        try {
            let patternObj = analysis.patternDescription;
            if (typeof patternObj === 'string') {
                patternObj = JSON.parse(patternObj);
            }
            if (patternObj && typeof patternObj === 'object' && patternObj.type !== 'AI_ANALYSIS') {
                const occurrences = Number(patternObj.occurrences || patternObj.ocorrencias || 0);
                if (occurrences >= 3) {
                    patternBonus += 3;
                }
            }
        } catch (_) {
            // Ignorar erros de parse
        }
    }
    weightedConfidence += patternBonus * patternWeight;

    let finalConfidence = weightedConfidence;
    if (finalConfidence < 45) finalConfidence = 45;
    if (finalConfidence > 95) finalConfidence = 95;

    if (lossCount >= 4) {
        finalConfidence *= 0.85;
    } else if (lossCount >= 3) {
        finalConfidence *= 0.90;
    }

    return Math.round(finalConfidence * 10) / 10;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTROLE DE ENTRADAS DE ALTERNÃ‚NCIA (MODO DIAMANTE - NÃVEL 3)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let alternanceEntryControl = {
    active: false,                    // Se hÃ¡ alternÃ¢ncia ativa
    patternSignature: null,           // Identificador do padrÃ£o de alternÃ¢ncia (ex: "alternancia-simples")
    entryColor: null,                 // Cor da entrada inicial
    entryCount: 0,                    // Quantas entradas foram feitas (mÃ¡x 2)
    lastResult: null,                 // 'win' | 'loss' | null
    lastEntryTimestamp: null,         // Timestamp da Ãºltima entrada
    blockedUntil: null,               // Timestamp atÃ© quando estÃ¡ bloqueado (apÃ³s loss)
    totalWins: 0,                     // Contador de wins da alternÃ¢ncia
    totalLosses: 0                    // Contador de losses da alternÃ¢ncia
};

// HistÃ³rico de "cores quentes" por padrÃ£o
// Estrutura: { "patternKey": { after1Loss: {red: 5, black: 3}, after2Loss: {red: 2, black: 8} } }
let hotColorsHistory = {};

logBanner(`background.js v17 carregado â€¢ ${new Date().toLocaleString('pt-BR')}`);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNÃ‡Ã•ES DO SISTEMA DE MARTINGALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Carregar histÃ³rico de cores quentes do storage
async function loadHotColorsHistory() {
    try {
        const result = await chrome.storage.local.get(['hotColorsHistory']);
        if (result.hotColorsHistory) {
            hotColorsHistory = result.hotColorsHistory;
            console.log('âœ… HistÃ³rico de cores quentes carregado:', Object.keys(hotColorsHistory).length, 'padrÃµes');
        }
    } catch (e) {
        console.error('âŒ Erro ao carregar histÃ³rico de cores quentes:', e);
    }
}

// Salvar histÃ³rico de cores quentes no storage
async function saveHotColorsHistory() {
    try {
        await chrome.storage.local.set({ hotColorsHistory });
        console.log('âœ… HistÃ³rico de cores quentes salvo');
    } catch (e) {
        console.error('âŒ Erro ao salvar histÃ³rico de cores quentes:', e);
    }
}

// Calcular "cor quente" baseado no histÃ³rico de LOSSes
function calculateHotColor(patternKey, afterLossCount) {
    console.log(`ğŸ”¥ Calculando cor quente para padrÃ£o: ${patternKey} apÃ³s ${afterLossCount} LOSS(es)`);
    
    // Verificar se existe histÃ³rico para este padrÃ£o
    if (!hotColorsHistory[patternKey]) {
        console.log('âš ï¸ PadrÃ£o sem histÃ³rico de LOSS anterior');
        return null;
    }
    
    const history = afterLossCount === 1 ? 
        hotColorsHistory[patternKey].after1Loss : 
        hotColorsHistory[patternKey].after2Loss;
    
    if (!history || Object.keys(history).length === 0) {
        console.log('âš ï¸ Sem dados de cores apÃ³s', afterLossCount, 'LOSS(es)');
        return null;
    }
    
    // Encontrar cor que mais aparece
    let maxCount = 0;
    let hotColor = null;
    
    for (const [color, count] of Object.entries(history)) {
        if (count > maxCount) {
            maxCount = count;
            hotColor = color;
        }
    }
    
    if (hotColor) {
        const total = Object.values(history).reduce((a, b) => a + b, 0);
        const percentage = ((maxCount / total) * 100).toFixed(1);
        console.log(`ğŸ”¥ Cor quente encontrada: ${hotColor} (${maxCount}/${total} = ${percentage}%)`);
    }
    
    return hotColor;
}

// Atualizar histÃ³rico de cores apÃ³s um ciclo completado
async function updateHotColorsHistory(patternKey, lossSequence) {
    console.log(`ğŸ“Š Atualizando histÃ³rico de cores quentes para padrÃ£o: ${patternKey}`);
    console.log('   SequÃªncia de LOSS:', lossSequence);
    
    // Inicializar estrutura se nÃ£o existir
    if (!hotColorsHistory[patternKey]) {
        hotColorsHistory[patternKey] = {
            after1Loss: { red: 0, black: 0, white: 0 },
            after2Loss: { red: 0, black: 0, white: 0 }
        };
    }
    
    // Atualizar apÃ³s 1 LOSS (se tiver pelo menos 2 entradas: LOSS + resultado)
    if (lossSequence.length >= 2) {
        const colorAfter1Loss = lossSequence[1].color;  // Cor que saiu apÃ³s 1Âº LOSS
        hotColorsHistory[patternKey].after1Loss[colorAfter1Loss]++;
        console.log(`   âœ… Cor apÃ³s 1 LOSS: ${colorAfter1Loss}`);
    }
    
    // Atualizar apÃ³s 2 LOSS (se tiver pelo menos 3 entradas: 2 LOSS + resultado)
    if (lossSequence.length >= 3) {
        const colorAfter2Loss = lossSequence[2].color;  // Cor que saiu apÃ³s 2Âº LOSS
        hotColorsHistory[patternKey].after2Loss[colorAfter2Loss]++;
        console.log(`   âœ… Cor apÃ³s 2 LOSS: ${colorAfter2Loss}`);
    }
    
    // Salvar no storage
    await saveHotColorsHistory();
}

// Resetar estado do Martingale
function resetMartingaleState() {
    console.log('ğŸ”„ Resetando estado do Martingale');
    martingaleState = {
        active: false,
        stage: 'ENTRADA',
        patternKey: null,
        entryColor: null,
        entryColorResult: null,
        entryTimestamp: null,
        analysisData: null,
        lossCount: 0,
        lossColors: [],
        patternsWithoutHistory: martingaleState.patternsWithoutHistory  // Manter contador
    };
}

// Criar identificador Ãºnico para o padrÃ£o
function createPatternKey(analysisData) {
    try {
        if (analysisData && analysisData.patternDescription) {
            // âš ï¸ CRÃTICO: Se for anÃ¡lise IA, patternDescription Ã© texto, nÃ£o JSON
            if (analysisData.patternDescription.includes('ğŸ¤– ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL')) {
                // Para IA, criar chave Ãºnica baseada em timestamp + cor
                const timestamp = Date.now();
                const color = analysisData.color || 'unknown';
                return `ai_pattern_${color}_${timestamp}`;
            } else {
                // Para anÃ¡lise padrÃ£o, patternDescription Ã© JSON
                const desc = JSON.parse(analysisData.patternDescription);
                if (desc.colorAnalysis && desc.colorAnalysis.pattern) {
                    return desc.colorAnalysis.pattern.join('-');
                }
            }
        }
    } catch (e) {
        console.error('âŒ Erro ao criar chave do padrÃ£o:', e);
    }
    return `pattern_${Date.now()}`;  // Fallback
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ SINCRONIZAÃ‡ÃƒO COM API - DUAS APIS SEPARADAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const API_CONFIG = {
    // API de Giros (coleta automÃ¡tica, histÃ³rico, WebSocket)
    baseURL: 'https://blaze-giros-api-v2-sx14.onrender.com',
    wsURL: 'wss://blaze-giros-api-v2-sx14.onrender.com',
    
    // API de AutenticaÃ§Ã£o (usuÃ¡rios, admin, padrÃµes customizados)
    authURL: 'https://blaze-analyzer-api-v2-z8s3.onrender.com',
    
    enabled: true,  // Ativar/desativar sincronizaÃ§Ã£o
    syncInterval: 5 * 60 * 1000,  // Sincronizar a cada 5 minutos
    timeout: 10000,  // Timeout de 10 segundos
    retryAttempts: 3,
    useWebSocket: true  // âœ… Usar WebSocket ao invÃ©s de polling
};

let apiStatus = {
    isOnline: false,
    lastSync: null,
    lastError: null,
    syncAttempts: 0
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”Œ WEBSOCKET - CONEXÃƒO EM TEMPO REAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let ws = null;
let wsReconnectTimeout = null;
let wsHeartbeatInterval = null;
let lastDataReceived = Date.now(); // âœ… Rastrear Ãºltimo dado recebido
let pollingInterval = null; // âœ… Intervalo de polling de fallback
let dataCheckInterval = null; // âœ… Intervalo para verificar dados desatualizados

// Conectar ao WebSocket
function connectWebSocket() {
    if (!API_CONFIG.enabled || !API_CONFIG.useWebSocket) {
        console.log('âš ï¸ WebSocket desabilitado na configuraÃ§Ã£o');
        return;
    }
    
    if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
        console.log('âš ï¸ WebSocket jÃ¡ conectado ou conectando');
        return;
    }
    
    console.log('â•‘  ğŸ”Œ CONECTANDO AO WEBSOCKET...                            â•‘');
    console.log(`â•‘  URL: ${API_CONFIG.wsURL}                               `);
    
    try {
        ws = new WebSocket(API_CONFIG.wsURL);
        
        ws.onopen = () => {
            console.log('âœ… WebSocket conectado com sucesso!');
            console.log('âš¡ Aguardando giros em TEMPO REAL...');
            apiStatus.isOnline = true;
            apiStatus.lastSync = new Date().toISOString();
            
            // Limpar timeout de reconexÃ£o se existir
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }
            
            // âœ… Parar polling de fallback (WebSocket reconectado)
            stopPollingFallback();
            
            // Iniciar heartbeat (responder a PING do servidor)
            startWebSocketHeartbeat();
        };
        
        ws.onmessage = async (event) => {
            try {
                const message = JSON.parse(event.data);
                console.log('ğŸ“¨ Mensagem WebSocket recebida:', message.type);
                
                // âœ… Atualizar timestamp de Ãºltimo dado recebido
                lastDataReceived = Date.now();
                
                switch (message.type) {
                    case 'CONNECTED':
                        console.log('âœ… ConfirmaÃ§Ã£o de conexÃ£o:', message.message);
                        console.log(`ğŸ“Š Clientes conectados: ${message.clientsConnected}`);
                        break;
                        
                    case 'INITIAL_DATA':
                        console.log('ğŸ“Š Dados iniciais recebidos');
                        if (message.data && message.data.lastSpin) {
                            await processNewSpinFromServer(message.data.lastSpin);
                        }
                        break;
                        
                    case 'NEW_SPIN':
                        // âœ… NOVO GIRO EM TEMPO REAL!
                        console.log('ğŸ¯ NOVO GIRO RECEBIDO VIA WEBSOCKET!', message.data);
                        await processNewSpinFromServer(message.data);
                        break;
                        
                    case 'PING':
                        // Servidor enviou PING, responder com PONG
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'PONG', timestamp: new Date().toISOString() }));
                        }
                        break;
                        
                    case 'PONG':
                        // Resposta do servidor ao nosso PING
                        console.log('ğŸ’š PONG recebido do servidor');
                        break;
                        
                    default:
                        console.log('âš ï¸ Tipo de mensagem desconhecido:', message.type);
                }
            } catch (error) {
                console.error('âŒ Erro ao processar mensagem WebSocket:', error);
            }
        };
        
        ws.onerror = (error) => {
            console.error('âŒ Erro WebSocket:', error);
            apiStatus.isOnline = false;
            apiStatus.lastError = new Date().toISOString();
        };
        
        ws.onclose = (event) => {
            console.log('âŒ WebSocket desconectado');
            console.log(`   CÃ³digo: ${event.code}, Motivo: ${event.reason || 'NÃ£o especificado'}`);
            apiStatus.isOnline = false;
            
            // Parar heartbeat
            stopWebSocketHeartbeat();
            
            // âœ… Iniciar polling de fallback imediatamente
            startPollingFallback();
            
            // âœ… Tentar reconectar apÃ³s 2 segundos (reduzido de 5s)
            console.log('â³ Tentando reconectar em 2 segundos...');
            wsReconnectTimeout = setTimeout(() => {
                console.log('ğŸ”„ Tentando reconectar WebSocket...');
                connectWebSocket();
            }, 2000);
        };
        
    } catch (error) {
        console.error('âŒ Erro ao criar conexÃ£o WebSocket:', error);
        apiStatus.isOnline = false;
        
        // âœ… Iniciar polling de fallback imediatamente
        startPollingFallback();
        
        // âœ… Tentar reconectar apÃ³s 2 segundos (reduzido de 5s)
        wsReconnectTimeout = setTimeout(() => {
            connectWebSocket();
        }, 2000);
    }
}

// Desconectar WebSocket
function disconnectWebSocket() {
    console.log('â¸ï¸ Desconectando WebSocket...');
    
    if (wsReconnectTimeout) {
        clearTimeout(wsReconnectTimeout);
        wsReconnectTimeout = null;
    }
    
    stopWebSocketHeartbeat();
    
    if (ws) {
        ws.close(1000, 'DesconexÃ£o normal');
        ws = null;
    }
}

// Heartbeat - enviar PING ativo do cliente a cada 20s
function startWebSocketHeartbeat() {
    stopWebSocketHeartbeat(); // Limpar qualquer heartbeat anterior
    
    // âœ… Enviar PING ativo do cliente a cada 20 segundos
    wsHeartbeatInterval = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
            try {
                ws.send(JSON.stringify({ type: 'PING', timestamp: Date.now() }));
                console.log('ğŸ’“ Heartbeat: PING enviado');
            } catch (error) {
                console.error('âŒ Erro ao enviar PING:', error);
                // Se falhou ao enviar PING, tentar reconectar
                connectWebSocket();
            }
        } else {
            console.warn('âš ï¸ WebSocket nÃ£o estÃ¡ aberto. Tentando reconectar...');
            connectWebSocket();
        }
    }, 20000); // 20 segundos
}

function stopWebSocketHeartbeat() {
    if (wsHeartbeatInterval) {
        clearInterval(wsHeartbeatInterval);
        wsHeartbeatInterval = null;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ POLLING DE FALLBACK - Quando WebSocket falha ou estÃ¡ inativo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function startPollingFallback() {
    // Se jÃ¡ estÃ¡ rodando, nÃ£o iniciar novamente
    if (pollingInterval) return;
    
    console.log('%câ•‘  ğŸ”„ POLLING DE FALLBACK ATIVADO                          â•‘', 'color: #FFA500; font-weight: bold;');
    console.log('%câ•‘  WebSocket estÃ¡ offline - buscando dados via HTTP       â•‘', 'color: #FFA500;');
    console.log('%câ•‘  FrequÃªncia: a cada 2 segundos                          â•‘', 'color: #FFA500;');
    
    // âœ… Notificar content.js que WebSocket caiu
    sendMessageToContent('WEBSOCKET_STATUS', { connected: false });
    
    // âœ… Buscar dados a cada 2 segundos quando WebSocket estÃ¡ offline
    pollingInterval = setInterval(async () => {
        try {
            // Buscar Ãºltimo giro do servidor
            const response = await fetch(`${API_CONFIG.baseURL}/api/giros/latest`, {
                signal: AbortSignal.timeout(5000)
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.data) {
                    await processNewSpinFromServer(data.data);
                }
            }
        } catch (error) {
            console.warn('âš ï¸ Polling fallback: erro ao buscar dados:', error.message);
        }
    }, 2000); // A cada 2 segundos
}

function stopPollingFallback() {
    if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
        console.log('âœ… Polling de fallback parado - WebSocket reconectado');
        
        // âœ… Notificar content.js que WebSocket reconectou
        sendMessageToContent('WEBSOCKET_STATUS', { connected: true });
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” VERIFICAÃ‡ÃƒO DE DADOS DESATUALIZADOS - Critical para mobile
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function startDataFreshnessCheck() {
    // Se jÃ¡ estÃ¡ rodando, nÃ£o iniciar novamente
    if (dataCheckInterval) return;
    
    console.log('   VerificarÃ¡ se dados estÃ£o atualizados a cada 30 segundos');
    
    // âœ… Verificar a cada 30 segundos se os dados estÃ£o desatualizados
    dataCheckInterval = setInterval(() => {
        const now = Date.now();
        const timeSinceLastData = now - lastDataReceived;
        const maxStaleTime = 90000; // 90 segundos (1.5 minutos)
        
        if (timeSinceLastData > maxStaleTime) {
            console.warn('');
            console.warn('%câš ï¸âš ï¸âš ï¸ DADOS DESATUALIZADOS DETECTADOS! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; font-size: 16px; background: #330000; padding: 5px;');
            console.warn(`   Ãšltimo dado recebido hÃ¡ ${Math.floor(timeSinceLastData / 1000)} segundos`);
            console.warn('   ForÃ§ando reconexÃ£o e atualizaÃ§Ã£o...');
            console.warn('');
            
            // âœ… ForÃ§ar reconexÃ£o WebSocket
            disconnectWebSocket();
            connectWebSocket();
            
            // âœ… ForÃ§ar busca imediata de dados via polling
            collectDoubleData();
        }
    }, 30000); // Verificar a cada 30 segundos
}

function stopDataFreshnessCheck() {
    if (dataCheckInterval) {
        clearInterval(dataCheckInterval);
        dataCheckInterval = null;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERIFICAÃ‡ÃƒO DE ABA DA BLAZE - GARANTIR QUE EXTENSÃƒO SÃ“ FUNCIONE COM PÃGINA ABERTA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Verificar se hÃ¡ uma aba da Blaze aberta
async function hasBlazeTabOpen() {
    try {
        const tabs = await chrome.tabs.query({});
        
        const blazeTabs = tabs.filter(tab => {
            if (!tab.url) return false;
            
            // âœ… Aceitar mÃºltiplos domÃ­nios da Blaze
            const blazeDomains = [
                'blaze.com',
                'blaze1.space',
                'blaze-1.com',
                'blaze-bet.com',
                'blaze.bet.br'
            ];
            
            return blazeDomains.some(domain => tab.url.includes(domain));
        });
        
        return blazeTabs.length > 0;
    } catch (e) {
        console.error('Erro ao verificar abas da Blaze:', e);
        return false;
    }
}

// Fazer requisiÃ§Ã£o com timeout e retry
async function fetchWithTimeout(url, options = {}, timeout = API_CONFIG.timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        // Melhorar mensagem de erro quando for timeout
        if (error.name === 'AbortError') {
            throw new Error(`Timeout apÃ³s ${timeout/1000}s - Servidor nÃ£o respondeu a tempo`);
        }
        throw error;
    }
}

// Verificar se API estÃ¡ online
async function checkAPIStatus() {
    if (!API_CONFIG.enabled) {
        console.log('âš ï¸ API DESATIVADA - SincronizaÃ§Ã£o offline');
        return false;
    }
    
    try {
        // Usar timeout maior para conexÃ£o inicial (20s)
        const response = await fetchWithTimeout(`${API_CONFIG.baseURL}/api/status`, {}, 20000);
        if (response.ok) {
            const data = await response.json();
            apiStatus.isOnline = true;
            apiStatus.lastError = null;
            apiStatus.lastSync = new Date().toISOString();
            console.log('%câœ… API ONLINE - SincronizaÃ§Ã£o ativada!', 'color: #00ff00; font-weight: bold; font-size: 14px;');
            console.log(`ğŸ“Š Servidor: ${data.database?.giros || 0} giros, ${data.database?.padroes || 0} padrÃµes`);
            return true;
        }
    } catch (error) {
        apiStatus.isOnline = false;
        apiStatus.lastError = error.message;
        // NÃ£o mostrar erro se for timeout inicial - servidor pode estar em cold start
        if (error.message.includes('Timeout')) {
            console.log('%câ³ Servidor demorando (cold start) - TentarÃ¡ novamente...', 'color: #FFAA00; font-weight: bold;');
        } else {
            console.log('%câŒ API OFFLINE - Modo local ativado', 'color: #ff0000; font-weight: bold; font-size: 14px;');
            console.log(`âš ï¸ Erro: ${error.message}`);
        }
    }
    return false;
}

// Buscar giros do servidor
async function fetchGirosFromAPI() {
    if (!API_CONFIG.enabled) {
        console.log('âš ï¸ API_CONFIG.enabled = false - nÃ£o buscarÃ¡ giros do servidor');
        return null;
    }
    
    try {
        console.log('ğŸ“¥ INICIANDO BUSCA DE GIROS DO SERVIDOR...');
        console.log('   URL:', `${API_CONFIG.baseURL}/api/giros?limit=2000`);
        console.log('   Timeout: 20 segundos');
        
        const startTime = Date.now();
        
        // Usar timeout maior para busca inicial de 2000 giros (20s)
        const response = await fetchWithTimeout(`${API_CONFIG.baseURL}/api/giros?limit=2000`, {}, 20000);
        
        const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(2);
        console.log(`â±ï¸ Tempo de resposta: ${elapsedTime}s`);
        
        if (response.ok) {
            const data = await response.json();
            console.log('âœ… Resposta recebida com sucesso!');
            console.log('   data.success:', data.success);
            console.log('   data.data existe?', !!data.data);
            console.log('   data.data.length:', data.data ? data.data.length : 'N/A');
            
            if (data.success && data.data) {
                console.log(`%câœ… SERVIDOR RETORNOU ${data.data.length} GIROS!`, 'color: #00ff00; font-weight: bold; font-size: 14px;');
                console.log('   Primeiro giro (mais recente):', data.data[0]);
                console.log('   Ãšltimo giro (mais antigo):', data.data[data.data.length - 1]);
                return data.data;
            } else {
                console.log('âš ï¸ Resposta do servidor sem dados vÃ¡lidos');
                console.log('   Estrutura recebida:', Object.keys(data));
            }
        } else {
            console.log('âŒ Resposta com erro do servidor');
            console.log('   Status:', response.status);
            console.log('   StatusText:', response.statusText);
        }
    } catch (error) {
        console.log('âŒ ERRO AO BUSCAR GIROS DO SERVIDOR!');
        console.log('   Tipo de erro:', error.name);
        console.log('   Mensagem:', error.message);
        console.log('   Stack:', error.stack);
        
        // NÃ£o mostrar erro assustador se for timeout - servidor pode estar ocupado
        if (error.message.includes('Timeout')) {
            console.log('â³ Servidor ocupado - ContinuarÃ¡ sincronizando em tempo real...');
        } else {
            console.warn('âš ï¸ Erro ao buscar giros do servidor:', error.message);
        }
    }
    return null;
}

// Salvar giros no servidor
async function saveGirosToAPI(giros) {
    if (!API_CONFIG.enabled || !apiStatus.isOnline) return false;
    
    const girosArray = Array.isArray(giros) ? giros : [giros];
    
    try {
        console.log(`ğŸ“¤ Enviando ${girosArray.length} giro(s) para o servidor...`);
        const response = await fetchWithTimeout(`${API_CONFIG.baseURL}/api/giros`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(giros)
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(`%câœ… ${data.message || 'Giros salvos com sucesso!'}`, 'color: #00ff00; font-weight: bold;');
            console.log(`ğŸ“Š Total no servidor: ${data.totalGiros || '?'} giros`);
            return true;
        }
    } catch (error) {
        console.warn('%câš ï¸ Erro ao salvar giros no servidor:', 'color: #ff9900; font-weight: bold;', error.message);
    }
    return false;
}

// PadrÃµes NÃƒO sÃ£o mais enviados para o servidor (sÃ£o recalculados a cada sessÃ£o)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡ÃƒO AUXILIAR: EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function displaySystemFooter() {
    if (analyzerConfig.aiMode) {
        const activeLevelsSummary = `${countEnabledDiamondLevels()}/${DIAMOND_LEVEL_IDS.length}`;
        logSection(`Sistema ativo Â· Modo Diamante (${activeLevelsSummary})`);
        if (memoriaAtiva.inicializada) {
            const tempoDecorrido = Math.round((Date.now() - memoriaAtiva.ultimaAtualizacao) / 1000);
            logInfo('Cache', `${memoriaAtiva.giros.length} giros â€¢ ${memoriaAtiva.totalAtualizacoes} updates â€¢ ${memoriaAtiva.tempoUltimaAtualizacao.toFixed(1)}ms â€¢ hÃ¡ ${tempoDecorrido}s`);
        } else {
            logInfo('Cache', 'Inicializando memÃ³ria ativa...');
        }
    } else {
        logSection('Sistema ativo Â· Modo PadrÃ£o');
        logInfo('Min. ocorrÃªncias', analyzerConfig.minOccurrences || 5);
        logInfo('Trigger', analyzerConfig.requireTrigger ? 'Ativo' : 'Desativado');
    }
}

// SincronizaÃ§Ã£o inicial ao carregar extensÃ£o
async function syncInitialData() {
    console.log('%cğŸŒ SINCRONIZAÃ‡ÃƒO COM SERVIDOR RENDER.COM', 'color: #00d4ff; font-weight: bold; font-size: 16px;');
    
    // Verificar se API estÃ¡ online
    const isOnline = await checkAPIStatus();
    
    if (!isOnline) {
        console.log('%câš ï¸ MODO OFFLINE - Usando apenas dados locais', 'color: #ffaa00; font-weight: bold; font-size: 14px;');
        return;
    }
    
    // Buscar giros do servidor e popular cache em memÃ³ria
    console.log('ğŸ“¥ Baixando histÃ³rico de giros para cache em memÃ³ria...');
    const serverGiros = await fetchGirosFromAPI();
    if (serverGiros && serverGiros.length > 0) {
        // Popular cache em memÃ³ria (SEM salvar em chrome.storage.local)
        cachedHistory = [...serverGiros].slice(0, 2000);
        historyInitialized = true;
        console.log(`%câœ… Cache em memÃ³ria populado: ${cachedHistory.length} giros`, 'color: #00ff00; font-weight: bold;');
        
        // âœ… INICIALIZAR MEMÃ“RIA ATIVA SE MODO IA ESTIVER ATIVO
        if (analyzerConfig.aiMode && !memoriaAtiva.inicializada && cachedHistory.length >= 60) {
            console.log('%cğŸ§  MODO IA ATIVO - Inicializando MemÃ³ria Ativa automaticamente...', 'color: #00CED1; font-weight: bold;');
            const sucesso = await inicializarMemoriaAtiva(cachedHistory);
            if (sucesso) {
                console.log('%câœ… MemÃ³ria Ativa inicializada com sucesso!', 'color: #00FF88; font-weight: bold;');
            } else {
                console.log('%câš ï¸ Falha ao inicializar MemÃ³ria Ativa', 'color: #FFAA00; font-weight: bold;');
            }
        }
        
        // âœ… ENVIAR ÃšLTIMO GIRO E HISTÃ“RICO PARA A UI
        const lastSpin = serverGiros[0]; // O mais recente estÃ¡ na posiÃ§Ã£o 0
        if (lastSpin) {
            console.log('ğŸ“¤ Enviando Ãºltimo giro para UI:', lastSpin);
            await chrome.storage.local.set({ lastSpin: lastSpin });
            // âœ… NÃƒO enviar history aqui: o content.js jÃ¡ busca atÃ© 10k diretamente do servidor.
            // Enviar history (2000) aqui sobrescrevia o buffer de 10k e fazia a UI ficar "travada em 2000".
            sendMessageToContent('NEW_SPIN', { lastSpin: lastSpin });
            console.log('%câœ… UI atualizada com histÃ³rico do servidor', 'color: #00ff00; font-weight: bold;');
        }
    } else {
        console.log('â„¹ï¸ Nenhum giro no servidor ainda');
        cachedHistory = [];
        historyInitialized = true;
    }
    
    // PadrÃµes NÃƒO sÃ£o mais sincronizados do servidor (apenas locais)
    console.log('â„¹ï¸ PadrÃµes sÃ£o gerados localmente - nÃ£o hÃ¡ sincronizaÃ§Ã£o do servidor');
    
    apiStatus.lastSync = new Date().toISOString();
    console.log('%cğŸ‰ SINCRONIZAÃ‡ÃƒO COMPLETA!', 'color: #00ff00; font-weight: bold; font-size: 14px;');
}

// FunÃ§Ã£o removida: padrÃµes nÃ£o sÃ£o mais enviados para servidor

// âœ… SincronizaÃ§Ã£o periÃ³dica REMOVIDA - agora usamos cache em memÃ³ria
// Cache Ã© atualizado a cada novo giro em processNewSpinFromServer()

function rigorLogString() {
    try {
        const maxOccStr = analyzerConfig.maxOccurrences > 0 ? analyzerConfig.maxOccurrences : 'sem limite';
        const maxSizeStr = analyzerConfig.maxPatternSize > 0 ? analyzerConfig.maxPatternSize : 'sem limite';
        return `minOcc=${analyzerConfig.minOccurrences} | maxOcc=${maxOccStr} | intervaloPadrao=${analyzerConfig.minIntervalSpins}giros | minTam=${analyzerConfig.minPatternSize} | maxTam=${maxSizeStr} | win%Outras=${analyzerConfig.winPercentOthers}% | exigirTrigger=${analyzerConfig.requireTrigger}`;
    } catch(_) { return '[rigor indisponÃ­vel]'; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VALIDAÃ‡Ã•ES ESPECÃFICAS POR TIPO DE PADRÃƒO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âœ… VALIDAR ANÃLISE DE TENDÃŠNCIA/FREQUÃŠNCIA
function validateFrequencyAnalysis(analysis) {
    if (!analysis) return { valid: false, reason: 'AnÃ¡lise nÃ£o disponÃ­vel' };
    
    const minOccurrences = 5;
    const requiredWinRate = 100; // 100% WIN (0 LOSS)
    
    const occurrences = analysis.occurrences || 0;
    // âœ… Se wins/losses nÃ£o existirem, assumir 100% win rate (padrÃ£o das anÃ¡lises antigas)
    const wins = analysis.wins !== undefined ? analysis.wins : occurrences;
    const losses = analysis.losses !== undefined ? analysis.losses : 0;
    const winRate = occurrences > 0 ? (wins / occurrences) * 100 : 0;
    
    // ValidaÃ§Ã£o silenciosa, apenas logs quando rejeita
    if (occurrences < minOccurrences) {
        logRejectedPattern('TendÃªncia/FrequÃªncia', `${occurrences}/${minOccurrences} ocorrÃªncias`);
        return { valid: false, reason: `${occurrences}/${minOccurrences} ocorrÃªncias` };
    }
    
    if (losses > 0) {
        logRejectedPattern('TendÃªncia/FrequÃªncia', `${losses} LOSS (exige 100% WIN)`);
        return { valid: false, reason: `${losses} LOSS (exige 100% WIN)` };
    }
    
    console.log(`âœ… [ValidaÃ§Ã£o]: TendÃªncia/FrequÃªncia APROVADA (${wins}W/${losses}L)`);
    return { valid: true };
}

// âœ… VALIDAR ANÃLISE TEMPORAL (HORÃRIO)
function validateTemporalAnalysis(analysis) {
    if (!analysis) return { valid: false, reason: 'AnÃ¡lise nÃ£o disponÃ­vel' };
    
    const minOccurrences = 6;
    const requiredWinRate = 100; // 100% WIN (0 LOSS)
    
    const occurrences = analysis.occurrences || 0;
    // âœ… Se wins/losses nÃ£o existirem, assumir 100% win rate (padrÃ£o das anÃ¡lises antigas)
    const wins = analysis.wins !== undefined ? analysis.wins : occurrences;
    const losses = analysis.losses !== undefined ? analysis.losses : 0;
    const winRate = occurrences > 0 ? (wins / occurrences) * 100 : 0;
    
    // ValidaÃ§Ã£o silenciosa, apenas logs quando rejeita
    if (occurrences < minOccurrences) {
        logRejectedPattern('Temporal/HorÃ¡rio', `${occurrences}/${minOccurrences} ocorrÃªncias`);
        return { valid: false, reason: `${occurrences}/${minOccurrences} ocorrÃªncias` };
    }
    
    if (losses > 0) {
        logRejectedPattern('Temporal/HorÃ¡rio', `${losses} LOSS (exige 100% WIN)`);
        return { valid: false, reason: `${losses} LOSS (exige 100% WIN)` };
    }
    
    console.log(`âœ… [ValidaÃ§Ã£o]: Temporal/HorÃ¡rio APROVADO (${wins}W/${losses}L)`);
    return { valid: true };
}

// âœ… VALIDAR ANÃLISE NÃšMERO + COR
function validateNumberAnalysis(analysis) {
    if (!analysis) return { valid: false, reason: 'AnÃ¡lise nÃ£o disponÃ­vel' };
    
    const minOccurrences = 3;
    const requiredWinRate = 100; // 100% WIN (0 LOSS)
    
    const occurrences = analysis.occurrences || 0;
    // âœ… Se wins/losses nÃ£o existirem, calcular baseado na confidence (assumindo que confidence reflete winRate)
    const wins = analysis.wins !== undefined ? analysis.wins : Math.round((analysis.confidence / 100) * occurrences);
    const losses = analysis.losses !== undefined ? analysis.losses : (occurrences - wins);
    const winRate = occurrences > 0 ? (wins / occurrences) * 100 : 0;
    
    // ValidaÃ§Ã£o silenciosa, apenas logs quando rejeita
    if (occurrences < minOccurrences) {
        logRejectedPattern('NÃºmero+Cor', `${occurrences}/${minOccurrences} ocorrÃªncias`);
        return { valid: false, reason: `${occurrences}/${minOccurrences} ocorrÃªncias` };
    }
    
    if (losses > 0) {
        logRejectedPattern('NÃºmero+Cor', `${losses} LOSS (exige 100% WIN)`);
        return { valid: false, reason: `${losses} LOSS (exige 100% WIN)` };
    }
    
    console.log(`âœ… [ValidaÃ§Ã£o]: NÃºmero+Cor APROVADO (${wins}W/${losses}L)`);
    return { valid: true };
}

// âœ… VALIDAR ANÃLISE DE CICLO (CORRELAÃ‡ÃƒO)
function validateCorrelationAnalysis(analysis) {
    if (!analysis) return { valid: false, reason: 'AnÃ¡lise nÃ£o disponÃ­vel' };
    
    const minOccurrences = 6;
    const requiredWinRate = 100; // 100% WIN (0 LOSS)
    
    const occurrences = analysis.occurrences || 0;
    // âœ… Se wins/losses nÃ£o existirem, assumir 100% win rate (padrÃ£o das anÃ¡lises antigas)
    const wins = analysis.wins !== undefined ? analysis.wins : occurrences;
    const losses = analysis.losses !== undefined ? analysis.losses : 0;
    const winRate = occurrences > 0 ? (wins / occurrences) * 100 : 0;
    
    // ValidaÃ§Ã£o silenciosa, apenas logs quando rejeita
    if (occurrences < minOccurrences) {
        logRejectedPattern('Ciclo/PeriÃ³dica', `${occurrences}/${minOccurrences} ocorrÃªncias`);
        return { valid: false, reason: `${occurrences}/${minOccurrences} ocorrÃªncias` };
    }
    
    if (losses > 0) {
        logRejectedPattern('Ciclo/PeriÃ³dica', `${losses} LOSS (exige 100% WIN)`);
        return { valid: false, reason: `${losses} LOSS (exige 100% WIN)` };
    }
    
    console.log(`âœ… [ValidaÃ§Ã£o]: Ciclo/PeriÃ³dica APROVADO (${wins}W/${losses}L)`);
    return { valid: true };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SISTEMA DE LOGS LIMPOS E ORGANIZADOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âœ… LOG PADRONIZADO PARA CICLO DE ANÃLISE
function logAnalysisCycle(data) {
    const {
        serverStatus = 'desconhecido',
        patternsFound = [],
        searchingNewSpin = false,
        rejectedPatterns = [],
        telegramSent = null,
        displayedPatternsCount = 0,
        spinsAvailable = { server: 0, app: 0 }
    } = data;
    
    console.log('â•‘  ğŸ“Š CICLO DE ANÃLISE - RESUMO                             â•‘');
    
    // 1. STATUS DO SERVIDOR
    const serverIcon = serverStatus === 'ativo' ? 'âœ…' : serverStatus === 'erro' ? 'âŒ' : 'â³';
    console.log(`â•‘  ğŸŒ Servidor: ${serverIcon} ${serverStatus.toUpperCase()}`.padEnd(62) + 'â•‘');
    
    // 2. GIROS DISPONÃVEIS
    console.log(`â•‘  ğŸ² Giros: Servidor=${spinsAvailable.server} | App=${spinsAvailable.app}`.padEnd(62) + 'â•‘');
    
    // 3. BUSCA POR NOVO GIRO
    if (searchingNewSpin) {
        console.log('â•‘  ğŸ” Busca: AGUARDANDO NOVO GIRO...'.padEnd(62) + 'â•‘');
    }
    
    
    // 4. PADRÃ•ES ENCONTRADOS
    if (patternsFound.length > 0) {
        console.log(`â•‘  âœ… PadrÃµes encontrados: ${patternsFound.length}`.padEnd(62) + 'â•‘');
        patternsFound.slice(0, 3).forEach((p, i) => {
            const label = `${i + 1}. ${p.type}: ${p.color}`;
            console.log(`â•‘     ${label}`.padEnd(62) + 'â•‘');
        });
        if (patternsFound.length > 3) {
            console.log(`â•‘     ... +${patternsFound.length - 3} padrÃµes`.padEnd(62) + 'â•‘');
        }
    } else {
        console.log('â•‘  âš ï¸ PadrÃµes encontrados: NENHUM'.padEnd(62) + 'â•‘');
    }
    
    // 5. PADRÃ•ES REJEITADOS
    if (rejectedPatterns.length > 0) {
        console.log(`â•‘  âŒ PadrÃµes rejeitados: ${rejectedPatterns.length}`.padEnd(62) + 'â•‘');
        rejectedPatterns.slice(0, 2).forEach((r, i) => {
            const reason = r.reason ? r.reason.substring(0, 40) : 'motivo nÃ£o especificado';
            console.log(`â•‘     ${i + 1}. ${r.type}: ${reason}`.padEnd(62) + 'â•‘');
        });
        if (rejectedPatterns.length > 2) {
            console.log(`â•‘     ... +${rejectedPatterns.length - 2} rejeitados`.padEnd(62) + 'â•‘');
        }
    }
    
    // 6. MENSAGEM TELEGRAM
    if (telegramSent !== null) {
        if (telegramSent) {
            console.log('â•‘  ğŸ“² Telegram: âœ… MENSAGEM ENVIADA COM SUCESSO'.padEnd(62) + 'â•‘');
        } else {
            console.log('â•‘  ğŸ“² Telegram: âŒ MENSAGEM NÃƒO ENVIADA'.padEnd(62) + 'â•‘');
        }
    }
    
    // 7. PADRÃ•ES EXIBIDOS
    console.log(`â•‘  ğŸ“± PadrÃµes exibidos na extensÃ£o: ${displayedPatternsCount}`.padEnd(62) + 'â•‘');
    
}

// âœ… LOG SIMPLIFICADO PARA STATUS DO SERVIDOR
function logServerStatus(status, spinsCount = 0) {
    const icon = status === 'ativo' ? 'âœ…' : status === 'erro' ? 'âŒ' : 'â³';
    console.log(`\nğŸŒ [Servidor]: ${icon} ${status.toUpperCase()} | Giros disponÃ­veis: ${spinsCount}`);
}

// âœ… LOG PARA BUSCA DE NOVO GIRO
function logSearchingNewSpin() {
    console.log('ğŸ” [Busca por novo giro]: AGUARDANDO...');
}

// âœ… LOG PARA PADRÃƒO REJEITADO
function logRejectedPattern(type, reason) {
    console.log(`âŒ [PadrÃ£o rejeitado]: ${type} - ${reason}`);
}

// âœ… LOG PARA TELEGRAM
function logTelegramStatus(sent, reason = '') {
    if (sent) {
        console.log('ğŸ“² [Telegram]: âœ… MENSAGEM ENVIADA');
    } else {
        console.log(`ğŸ“² [Telegram]: âŒ NÃƒO ENVIADA ${reason ? `- ${reason}` : ''}`);
    }
}

// âœ… LOG PARA PADRÃ•ES ENCONTRADOS
function logPatternsFound(patterns) {
    if (patterns.length === 0) {
        console.log('âš ï¸ [PadrÃµes encontrados]: NENHUM');
    } else {
        console.log(`âœ… [PadrÃµes encontrados]: ${patterns.length}`);
        patterns.forEach((p, i) => {
            console.log(`   ${i + 1}. ${p.type || 'desconhecido'} â†’ ${p.color || '?'} (${p.confidence?.toFixed(1) || '0'}%)`);
        });
    }
}

// âœ… FUNÃ‡ÃƒO PARA EXIBIR CONFIGURAÃ‡Ã•ES ATIVAS DE FORMA VISUAL
function logActiveConfiguration() {
    try {
        const config = analyzerConfig;
        
        console.log('â•‘  âš™ï¸ CONFIGURAÃ‡Ã•ES ATIVAS DO ANALISADOR                   â•‘');
        
        // OCORRÃŠNCIAS
        console.log('â•‘  ğŸ“Š CONTROLE DE OCORRÃŠNCIAS:                              â•‘');
        console.log(`â•‘     â€¢ MÃ­nimo de WINS: ${config.minOccurrences.toString().padEnd(35)}â•‘`);
        const maxOccStr = config.maxOccurrences > 0 ? config.maxOccurrences.toString() : 'SEM LIMITE âˆ';
        console.log(`â•‘     â€¢ MÃ¡ximo de ocorrÃªncias: ${maxOccStr.padEnd(26)}â•‘`);
        
        // TAMANHO DO PADRÃƒO
        console.log('â•‘  ğŸ“ TAMANHO DO PADRÃƒO:                                    â•‘');
        console.log(`â•‘     â€¢ MÃ­nimo (giros): ${config.minPatternSize.toString().padEnd(32)}â•‘`);
        const maxSizeStr = config.maxPatternSize > 0 ? config.maxPatternSize.toString() : 'SEM LIMITE âˆ';
        console.log(`â•‘     â€¢ MÃ¡ximo (giros): ${maxSizeStr.padEnd(32)}â•‘`);
        
        // INTERVALO E QUALIDADE
        console.log('â•‘  â±ï¸ INTERVALO E QUALIDADE:                                â•‘');
        console.log(`â•‘     â€¢ Intervalo entre padrÃµes: ${config.minIntervalSpins.toString().padEnd(21)} giro(s) â•‘`);
        console.log(`â•‘     â€¢ WIN% demais ocorrÃªncias: ${config.winPercentOthers.toString().padEnd(20)}%     â•‘`);
        
        console.log('â•‘  âšª PROTEÃ‡ÃƒO NO BRANCO:                                    â•‘');
        const whiteProtectionText = config.whiteProtectionAsWin ? 'Conta como WIN' : 'Conta como LOSS';
        console.log(`â•‘     â€¢ ${`Branco â†’ ${whiteProtectionText}`.padEnd(49)}â•‘`);
        
        // COR DE DISPARO
        console.log('â•‘  ğŸ¯ VALIDAÃ‡ÃƒO DE TRIGGER:                                 â•‘');
        const triggerStatus = config.requireTrigger ? 'âœ… ATIVADO (mais rigoroso)' : 'âŒ DESATIVADO (menos rigoroso)';
        console.log(`â•‘     ${triggerStatus.padEnd(54)}â•‘`);
        
        // MARTINGALE
        console.log('â•‘  ğŸ² SISTEMA DE MARTINGALE (GALE):                         â•‘');
        const padMartingaleLine = (text) => text.padEnd(54);
        const formatGaleQty = (value) => value === 0
            ? 'DESATIVADO'
            : value === 1
                ? '1 Gale (G1)'
                : value === 2
                    ? '2 Gales (G1, G2)'
                    : `${value} Gales`;
        const activeModeKey = getModeKey(config);
        const otherModeKey = activeModeKey === 'diamond' ? 'standard' : 'diamond';
        const activeProfile = getMartingaleSettings(activeModeKey, config);
        const otherProfile = getMartingaleSettings(otherModeKey, config);
        const activeLabel = activeModeKey === 'diamond' ? 'Diamante' : 'PadrÃ£o';
        const otherLabel = otherModeKey === 'diamond' ? 'Diamante' : 'PadrÃ£o';
        
        console.log(`â•‘     ${padMartingaleLine(`â€¢ ${activeLabel} (ativo): ${formatGaleQty(activeProfile.maxGales)}`)}â•‘`);
        console.log(`â•‘     ${padMartingaleLine(`  Modo: ${activeProfile.consecutiveMartingale ? 'CONSECUTIVO (imediato)' : 'PADRÃƒO (aguarda novo)'}`)}â•‘`);
        console.log(`â•‘     ${padMartingaleLine(`â€¢ ${otherLabel} (perfil): ${formatGaleQty(otherProfile.maxGales)}`)}â•‘`);
        console.log(`â•‘     ${padMartingaleLine(`  Modo: ${otherProfile.consecutiveMartingale ? 'CONSECUTIVO (imediato)' : 'PADRÃƒO (aguarda novo)'}`)}â•‘`);
        
        // TELEGRAM
        console.log('â•‘  ğŸ“² TELEGRAM:                                             â•‘');
        const telegramStatus = config.telegramChatId ? `âœ… Ativo (ID: ${config.telegramChatId.substring(0, 10)}...)` : 'âŒ NÃ£o configurado';
        console.log(`â•‘     ${telegramStatus.padEnd(54)}â•‘`);
        
        console.log('â•‘  ğŸ’ MODO DIAMANTE:                                        â•‘');
        const activeLevelsCount = countEnabledDiamondLevels(config);
        const totalLevels = DIAMOND_LEVEL_IDS.length;
        const diamondModeStatus = config.aiMode
            ? `âœ… ATIVO (${activeLevelsCount}/${totalLevels} nÃ­veis)`
            : 'âšª Desativado (Modo PadrÃ£o)';
        console.log(`â•‘     ${diamondModeStatus.padEnd(54)}â•‘`);
        if (config.aiMode) {
            const disabledLevels = DIAMOND_LEVEL_IDS.filter(id => !isDiamondLevelEnabled(id, config));
            if (disabledLevels.length > 0) {
                const disabledList = disabledLevels.join(', ');
                const line = `â€¢ NÃ­veis desativados: ${disabledList}`;
                console.log(`â•‘     ${line.padEnd(54)}â•‘`);
            }
        }
        
        
        // âš ï¸ AVISOS DE CONFIGURAÃ‡ÃƒO PERMISSIVA/RIGOROSA
        const warnings = [];
        
        if (config.minOccurrences <= 2) {
            warnings.push('âš ï¸ ConfiguraÃ§Ã£o MUITO PERMISSIVA: minOccurrences <= 2');
        }
        
        if (config.winPercentOthers === 0) {
            warnings.push('âš ï¸ Sem filtro de WIN% para outras ocorrÃªncias (aceita qualquer %)');
        }
        
        if (!config.requireTrigger) {
            warnings.push('âš ï¸ Cor de disparo DESATIVADA (menos rigoroso)');
        }
        
        if (config.maxOccurrences > 0 && config.maxOccurrences < 5) {
            warnings.push(`âš ï¸ Limite de ocorrÃªncias BAIXO: mÃ¡x ${config.maxOccurrences}`);
        }
        
        if (warnings.length > 0) {
            console.log('\nâš ï¸ AVISOS DE CONFIGURAÃ‡ÃƒO:');
            warnings.forEach(w => console.log(`   ${w}`));
        }
        
    } catch (e) {
        console.error('Erro ao exibir configuraÃ§Ãµes:', e);
    }
}

// Load analyzer config at startup
(async function loadAnalyzerConfigAtStartup() {
    try {
        const res = await chrome.storage.local.get(['analyzerConfig']);
        if (res && res.analyzerConfig) {
            mergeAnalyzerConfig(res.analyzerConfig);
        } else {
            await chrome.storage.local.set({ analyzerConfig: analyzerConfig });
        }
        await enforceProfileGateOnAIMode('startup_load');
        console.log('AnalyzerConfig carregado:', analyzerConfig);
        
        // âœ… INICIALIZAR HISTÃ“RICO DE SINAIS (para auto-aprendizado)
        await initializeSignalsHistory();
        
        // âœ… EXIBIR CONFIGURAÃ‡Ã•ES ATIVAS
        logActiveConfiguration();
        
        // âœ… VALIDAR CONFIGURAÃ‡Ã•ES (detectar conflitos)
        const minSize = analyzerConfig.minPatternSize || 2;
        const maxSize = analyzerConfig.maxPatternSize || 0;
        const minOcc = analyzerConfig.minOccurrences || 1;
        const maxOcc = analyzerConfig.maxOccurrences || 0;
        
        if (maxSize > 0 && maxSize < minSize) {
            console.error('â•‘  âš ï¸ CONFIGURAÃ‡ÃƒO INVÃLIDA DETECTADA!                     â•‘');
            console.error(`â•‘  âŒ Tamanho MÃXIMO (${maxSize}) < MÃNIMO (${minSize})!`);
            console.error('â•‘  ğŸš« NENHUM PADRÃƒO SERÃ ENCONTRADO!                        â•‘');
            console.error('â•‘  ğŸ’¡ Ajuste: maxPatternSize >= minPatternSize             â•‘');
        }
        
        if (maxOcc > 0 && maxOcc < minOcc) {
            console.error('â•‘  âš ï¸ CONFIGURAÃ‡ÃƒO INVÃLIDA DETECTADA!                     â•‘');
            console.error(`â•‘  âŒ OcorrÃªncias MÃXIMAS (${maxOcc}) < MÃNIMAS (${minOcc})!`);
            console.error('â•‘  ğŸš« NENHUM PADRÃƒO SERÃ ENCONTRADO!                        â•‘');
            console.error('â•‘  ğŸ’¡ Ajuste: maxOccurrences >= minOccurrences             â•‘');
        }
    } catch (e) {
        console.warn('Falha ao carregar analyzerConfig, usando defaults:', e);
    }
})();

// Apply config changes immediately
chrome.storage.onChanged.addListener((changes, area) => {
    if (area === 'local' && changes.analyzerConfig) {
        try {
            const newVal = changes.analyzerConfig.newValue || {};
            mergeAnalyzerConfig(newVal);
            (async () => {
                await enforceProfileGateOnAIMode('storage_changed');
            })();
            console.log('AnalyzerConfig aplicado imediatamente:', analyzerConfig);
            
            // âœ… EXIBIR NOVAS CONFIGURAÃ‡Ã•ES
            console.log('\nğŸ”„ CONFIGURAÃ‡Ã•ES ATUALIZADAS:');
            logActiveConfiguration();
            
            // âœ… VALIDAR CONFIGURAÃ‡Ã•ES (detectar conflitos)
            const minSize = analyzerConfig.minPatternSize || 2;
            const maxSize = analyzerConfig.maxPatternSize || 0;
            const minOcc = analyzerConfig.minOccurrences || 1;
            const maxOcc = analyzerConfig.maxOccurrences || 0;
            
            if (maxSize > 0 && maxSize < minSize) {
                console.error('â•‘  âš ï¸ CONFIGURAÃ‡ÃƒO INVÃLIDA DETECTADA!                     â•‘');
                console.error(`â•‘  âŒ Tamanho MÃXIMO (${maxSize}) < MÃNIMO (${minSize})!`);
                console.error('â•‘  ğŸš« NENHUM PADRÃƒO SERÃ ENCONTRADO!                        â•‘');
                console.error('â•‘  ğŸ’¡ Ajuste: maxPatternSize >= minPatternSize             â•‘');
            }
            
            if (maxOcc > 0 && maxOcc < minOcc) {
                console.error('â•‘  âš ï¸ CONFIGURAÃ‡ÃƒO INVÃLIDA DETECTADA!                     â•‘');
                console.error(`â•‘  âŒ OcorrÃªncias MÃXIMAS (${maxOcc}) < MÃNIMAS (${minOcc})!`);
                console.error('â•‘  ğŸš« NENHUM PADRÃƒO SERÃ ENCONTRADO!                        â•‘');
                console.error('â•‘  ğŸ’¡ Ajuste: maxOccurrences >= minOccurrences             â•‘');
            }

        // âœ… Notificar todas as abas do Blaze para atualizar UI imediatamente (sem refresh)
        try {
            chrome.tabs.query({ url: '*://blaze.com/*' }, function(tabs) {
                tabs.forEach(tab => {
                    chrome.tabs.sendMessage(tab.id, {
                        type: 'ANALYZER_CONFIG_UPDATED',
                        analyzerConfig
                    }).catch(() => {});
                });
            });
        } catch (err) {
            console.warn('âš ï¸ Falha ao notificar abas sobre atualizaÃ§Ã£o de config:', err);
        }
        } catch (e) {
            console.warn('Falha ao aplicar analyzerConfig:', e);
        }
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALIBRADOR DE PORCENTAGENS - INICIALIZAÃ‡ÃƒO
// (VariÃ¡veis movidas para o topo do arquivo para evitar TDZ errors)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âœ… Carregar histÃ³rico de cores quentes ao iniciar
loadHotColorsHistory();

// Carregar dados do observador ao iniciar
(async function loadObserverDataAtStartup() {
    try {
        const res = await chrome.storage.local.get(['observerData', 'entriesHistory', 'martingaleState']);
        if (res && res.observerData) {
            observerData = { ...observerData, ...res.observerData };
            console.log('â•‘  ğŸ“Š CALIBRADOR DE PORCENTAGENS CARREGADO                 â•‘');
            console.log(`â•‘  ğŸ“ˆ Entradas monitoradas: ${observerData.entries.length}`);
            console.log(`â•‘  ğŸ“Š Ãšltima calibraÃ§Ã£o: ${observerData.lastCalibratedCount} entradas`);
            console.log(`â•‘  ğŸ”§ Fator de calibraÃ§Ã£o: ${(observerData.calibrationFactor * 100).toFixed(1)}%`);
            console.log(`â•‘  ğŸ¯ Alta (â‰¥80%): ${observerData.stats.high.total} entradas`);
            console.log(`â•‘  ğŸŸ¡ MÃ©dia (60-79%): ${observerData.stats.medium.total} entradas`);
            console.log(`â•‘  ğŸŸ¢ Baixa (<60%): ${observerData.stats.low.total} entradas`);
        } else {
            console.log('â„¹ï¸ Calibrador de porcentagens: Nenhum dado anterior encontrado (primeira execuÃ§Ã£o)');
        }
        
        // âœ… SINCRONIZAR: Sempre manter observerData sincronizado com entriesHistory
        const entriesHistory = res.entriesHistory || [];
        console.log(`   entriesHistory existe?`, !!entriesHistory);
        console.log(`   entriesHistory.length:`, entriesHistory.length);
        console.log(`   observerData.entries.length:`, observerData.entries.length);
        
        // âœ… CASO 1: entriesHistory foi LIMPO (menos entradas que observerData)
        // Isso significa que o usuÃ¡rio limpou o histÃ³rico, entÃ£o resetar observerData
        if (entriesHistory.length < observerData.entries.length) {
            console.log('â•‘  ğŸ—‘ï¸ HISTÃ“RICO FOI LIMPO - RESETANDO CALIBRADOR          â•‘');
            console.log(`â•‘  Entradas antigas no calibrador: ${observerData.entries.length}`);
            console.log(`â•‘  Entradas atuais no histÃ³rico: ${entriesHistory.length}`);
            
            // Resetar observerData e reconstruir a partir do entriesHistory
            observerData = {
                entries: [],
                calibrationFactor: 1.0,
                lastCalibration: null,
                lastCalibratedCount: 0,
                stats: {
                    high: { predicted: 0, actual: 0, wins: 0, total: 0 },
                    medium: { predicted: 0, actual: 0, wins: 0, total: 0 },
                    low: { predicted: 0, actual: 0, wins: 0, total: 0 }
                }
            };
            
            // Reconstruir observerData a partir das entradas restantes
            for (const entry of entriesHistory) {
                if (entry.confidence && entry.result) {
                    observerData.entries.push({
                        timestamp: entry.timestamp,
                        predicted: Math.round(entry.confidence),
                        result: entry.result.toLowerCase() === 'win' ? 'win' : 'loss',
                        pattern: entry.patternData ? {
                            type: entry.patternData.type || 'unknown',
                            occurrences: entry.patternData.occurrences || 0
                        } : null
                    });
                }
            }
            
            console.log(`âœ… Calibrador resetado e reconstruÃ­do: ${observerData.entries.length} entradas`);
            
            // Atualizar estatÃ­sticas
            updateObserverStats();
            
            // Salvar dados sincronizados
            await saveObserverData(true);
            
            // Enviar atualizaÃ§Ã£o para UI
            sendObserverUpdate(true);
        }
        // âœ… CASO 2: entriesHistory tem MAIS entradas (adicionar novas)
        else if (entriesHistory.length > observerData.entries.length) {
            console.log('â•‘  ğŸ”„ SINCRONIZANDO ENTRADAS COM OBSERVADOR                â•‘');
            console.log(`â•‘  Entradas no histÃ³rico: ${entriesHistory.length}`);
            console.log(`â•‘  Entradas no observador: ${observerData.entries.length}`);
            
            // Adicionar entradas que estÃ£o faltando no observador
            let syncedCount = 0;
            for (const entry of entriesHistory) {
                // Verificar se jÃ¡ existe no observador (por timestamp)
                const exists = observerData.entries.some(e => e.timestamp === entry.timestamp);
                
                console.log(`   Entrada ${syncedCount + 1}/${entriesHistory.length}:`, {
                    timestamp: entry.timestamp,
                    confidence: entry.confidence,
                    result: entry.result,
                    exists: exists
                });
                
                if (!exists && entry.confidence && entry.result) {
                    observerData.entries.push({
                        timestamp: entry.timestamp,
                        predicted: Math.round(entry.confidence),
                        result: entry.result.toLowerCase() === 'win' ? 'win' : 'loss',
                        pattern: entry.patternData ? {
                            type: entry.patternData.type || 'unknown',
                            occurrences: entry.patternData.occurrences || 0
                        } : null
                    });
                    syncedCount++;
                    console.log(`      âœ… Adicionado ao observador (${syncedCount} sincronizadas)`);
                } else if (exists) {
                    console.log(`      â­ï¸ JÃ¡ existe no observador`);
                } else {
                    console.log(`      âš ï¸ Entrada invÃ¡lida (sem confidence ou result)`);
                }
            }
            
            console.log(`â•‘  Total sincronizado: ${syncedCount} novas entradas`);
            
            // Limitar ao mÃ¡ximo configurado
            if (observerData.entries.length > OBSERVER_CONFIG.maxHistorySize) {
                observerData.entries = observerData.entries.slice(-OBSERVER_CONFIG.maxHistorySize);
            }
            
            // Atualizar estatÃ­sticas
            updateObserverStats();
            
            // Salvar dados sincronizados
            await saveObserverData();
            
            console.log(`âœ… SincronizaÃ§Ã£o concluÃ­da: ${observerData.entries.length} entradas no observador`);
            
            // Enviar atualizaÃ§Ã£o para UI
            sendObserverUpdate(true); // Mostrar log ao carregar
        }
        // âœ… CASO 3: JÃ¡ estÃ£o sincronizados (mesmo nÃºmero de entradas)
        else {
            console.log('âœ… Calibrador jÃ¡ estÃ¡ sincronizado com histÃ³rico de entradas');
        }
        
        // âœ… RESTAURAR ESTADO DO MARTINGALE (se houver ciclo ativo)
        if (res.martingaleState && res.martingaleState.active) {
            martingaleState = res.martingaleState;
            console.log('â•‘  ğŸ”„ CICLO DE MARTINGALE RESTAURADO                       â•‘');
            console.log(`â•‘  EstÃ¡gio: ${martingaleState.stage}`);
            console.log(`â•‘  PadrÃ£o: ${martingaleState.patternKey}`);
            console.log(`â•‘  Cor: ${martingaleState.entryColor}`);
            console.log(`â•‘  LOSS consecutivos: ${martingaleState.lossCount}`);
        }
    } catch (e) {
        console.warn('âš ï¸ Falha ao carregar observerData:', e);
    }
})();

// Salvar dados do observador
async function saveObserverData(showLog = false) {
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO
    if (!observerData || !observerData.entries) {
        return;
    }
    
    try {
        await chrome.storage.local.set({ observerData: observerData });
        if (showLog) {
            console.log(`ğŸ’¾ Calibrador salvo: ${observerData.entries.length} entradas, fator ${(observerData.calibrationFactor * 100).toFixed(1)}%, Ãºltima calibraÃ§Ã£o em ${observerData.lastCalibratedCount}`);
        }
    } catch (e) {
        console.error('Erro ao salvar observerData:', e);
    }
}

// Enviar atualizaÃ§Ã£o do observador para content.js
function sendObserverUpdate(showLog = false) {
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO
    if (!observerData || !observerData.entries) {
        return;
    }
    
    const stats = getObserverStats();
    if (showLog) {
        console.log('ğŸ“¤ Enviando OBSERVER_UPDATE para UI:', {
            total: stats.total,
            wins: stats.wins,
            losses: stats.losses,
            winRate: stats.winRate,
            calibrationFactor: stats.calibrationFactor
        });
    }
    sendMessageToContent('OBSERVER_UPDATE', stats);
}

// Registrar uma nova entrada no observador
async function registerEntryInObserver(predictedConfidence, actualResult, entryTime, patternInfo = null) {
    const entry = {
        timestamp: entryTime || Date.now(),
        predicted: Math.round(predictedConfidence),
        result: actualResult, // 'win' ou 'loss'
        pattern: patternInfo ? {
            type: patternInfo.type || 'unknown',
            occurrences: patternInfo.occurrences || 0
        } : null
    };
    
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO (com try/catch para evitar TDZ)
    try {
        if (!observerData || !observerData.entries) {
            console.warn('âš ï¸ observerData nÃ£o inicializado ainda - pulando registro');
            return;
        }
    } catch (error) {
        console.warn('âš ï¸ Erro ao acessar observerData - pulando registro:', error.message);
        return;
    }
    
    // Adicionar ao histÃ³rico
    observerData.entries.push(entry);
    
    // Limitar tamanho do histÃ³rico (manter apenas as Ãºltimas N)
    if (observerData.entries.length > OBSERVER_CONFIG.maxHistorySize) {
        observerData.entries.shift(); // Remove mais antiga
    }
    
    // Atualizar estatÃ­sticas
    updateObserverStats();
    
    // âœ… RECALIBRAR A CADA NOVA ENTRADA (apÃ³s ter o mÃ­nimo de 20 entradas)
    // Isso garante que o peso da calibraÃ§Ã£o usado nos prÃ³ximos cÃ¡lculos esteja sempre atualizado
    if (observerData.entries.length >= OBSERVER_CONFIG.minEntriesForCalibration) {
        console.log(`ğŸ”„ Recalibrando automaticamente apÃ³s nova entrada (${observerData.entries.length} entradas)...`);
        recalibrateConfidenceModel();
    } else {
        console.log(`â³ Aguardando ${OBSERVER_CONFIG.minEntriesForCalibration - observerData.entries.length} entradas para iniciar calibraÃ§Ã£o automÃ¡tica`);
    }
    
    // Salvar dados
    await saveObserverData();
    
    // âœ… Enviar atualizaÃ§Ã£o para UI automaticamente
    sendObserverUpdate();
    
    // Log visual
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“Š ENTRADA OBSERVADA                                     
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ¯ Previsto: ${entry.predicted}%
â•‘  ${actualResult === 'win' ? 'âœ… Resultado: WIN' : 'âŒ Resultado: LOSS'}
â•‘  ğŸ“ˆ Total observado: ${observerData.entries.length}/${OBSERVER_CONFIG.maxHistorySize}
â•‘  ğŸ”§ Fator de calibraÃ§Ã£o: ${(observerData.calibrationFactor * 100).toFixed(1)}%
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `.trim());
}

// Atualizar estatÃ­sticas do observador
function updateObserverStats() {
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO
    if (!observerData || !observerData.entries) {
        return;
    }
    
    // Resetar stats
    observerData.stats = {
        high: { predicted: 0, actual: 0, wins: 0, total: 0 },
        medium: { predicted: 0, actual: 0, wins: 0, total: 0 },
        low: { predicted: 0, actual: 0, wins: 0, total: 0 }
    };
    
    // Calcular para cada faixa
    for (const entry of observerData.entries) {
        let bucket;
        if (entry.predicted >= 80) bucket = 'high';
        else if (entry.predicted >= 60) bucket = 'medium';
        else bucket = 'low';
        
        observerData.stats[bucket].predicted += entry.predicted;
        observerData.stats[bucket].total++;
        
        if (entry.result === 'win') {
            observerData.stats[bucket].wins++;
        }
    }
    
    // Calcular taxas reais
    for (const bucket of ['high', 'medium', 'low']) {
        const stat = observerData.stats[bucket];
        if (stat.total > 0) {
            stat.actual = (stat.wins / stat.total) * 100;
            stat.predicted = stat.predicted / stat.total; // MÃ©dia prevista
        }
    }
}

// Recalibrar o modelo de confianÃ§a baseado no histÃ³rico
// Esta funÃ§Ã£o Ã© chamada:
// - AUTOMATICAMENTE: A cada nova entrada registrada (apÃ³s ter 20+ entradas)
// - MANUALMENTE: Quando o usuÃ¡rio clica no botÃ£o "Atualizar"
function recalibrateConfidenceModel() {
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO
    if (!observerData || !observerData.entries) {
        return;
    }
    
    const entries = observerData.entries;
    if (entries.length < OBSERVER_CONFIG.minEntriesForCalibration) {
        console.log(`âš ï¸ CalibraÃ§Ã£o cancelada: apenas ${entries.length} entradas (mÃ­nimo: ${OBSERVER_CONFIG.minEntriesForCalibration})`);
        return;
    }
    
    // âœ… VERIFICAR SE HÃ NOVAS ENTRADAS desde a Ãºltima calibraÃ§Ã£o
    if (entries.length === observerData.lastCalibratedCount) {
        console.log(`â„¹ï¸ CalibraÃ§Ã£o nÃ£o necessÃ¡ria: nenhuma entrada nova desde a Ãºltima calibraÃ§Ã£o (${entries.length} entradas)`);
        return;
    }
    
    // Calcular taxa de acerto global
    const totalWins = entries.filter(e => e.result === 'win').length;
    const totalEntries = entries.length;
    const actualWinRate = totalWins / totalEntries;
    
    // Calcular mÃ©dia das previsÃµes
    const avgPredicted = entries.reduce((sum, e) => sum + e.predicted, 0) / totalEntries;
    const predictedWinRate = avgPredicted / 100;
    
    // Calcular fator de correÃ§Ã£o
    // Se real = 0.7 (70%) e previsto = 0.85 (85%), fator = 0.7/0.85 = 0.82
    // Isso vai reduzir as prÃ³ximas previsÃµes em ~18%
    let newFactor = predictedWinRate > 0 ? actualWinRate / predictedWinRate : 1.0;
    
    // âœ… REMOVIDA SUAVIZAÃ‡ÃƒO: CÃ¡lculo agora Ã© determinÃ­stico (sempre retorna o mesmo valor para os mesmos dados)
    // NÃ£o hÃ¡ mais mÃ©dia ponderada com valor anterior - o cÃ¡lculo Ã© puro e baseado apenas nos dados atuais
    
    // Limitar fator entre 0.5 e 1.5 (nÃ£o permitir correÃ§Ãµes muito drÃ¡sticas)
    newFactor = Math.max(0.5, Math.min(1.5, newFactor));
    
    const oldFactor = observerData.calibrationFactor;
    observerData.calibrationFactor = newFactor;
    observerData.lastCalibration = new Date().toISOString();
    observerData.lastCalibratedCount = entries.length; // âœ… Salvar quantas entradas foram calibradas
    
    // Log detalhado da calibraÃ§Ã£o
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ”§ RECALIBRAÃ‡ÃƒO DO MODELO (${entries.length} entradas)              
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“Š Entradas analisadas: ${totalEntries}
â•‘  
â•‘  ğŸ¯ GLOBAL:
â•‘     Previsto mÃ©dio: ${(predictedWinRate * 100).toFixed(1)}%
â•‘     Real: ${(actualWinRate * 100).toFixed(1)}%
â•‘     DiferenÃ§a: ${((actualWinRate - predictedWinRate) * 100).toFixed(1)}%
â•‘  
â•‘  ğŸ”´ ALTA (â‰¥80%):
â•‘     Previsto: ${observerData.stats.high.predicted.toFixed(1)}%
â•‘     Real: ${observerData.stats.high.actual.toFixed(1)}%
â•‘     Total: ${observerData.stats.high.total} entradas
â•‘  
â•‘  ğŸŸ¡ MÃ‰DIA (60-79%):
â•‘     Previsto: ${observerData.stats.medium.predicted.toFixed(1)}%
â•‘     Real: ${observerData.stats.medium.actual.toFixed(1)}%
â•‘     Total: ${observerData.stats.medium.total} entradas
â•‘  
â•‘  ğŸŸ¢ BAIXA (<60%):
â•‘     Previsto: ${observerData.stats.low.predicted.toFixed(1)}%
â•‘     Real: ${observerData.stats.low.actual.toFixed(1)}%
â•‘     Total: ${observerData.stats.low.total} entradas
â•‘  
â•‘  âš™ï¸ AJUSTE:
â•‘     Fator anterior: ${(oldFactor * 100).toFixed(1)}%
â•‘     Fator novo: ${(newFactor * 100).toFixed(1)}%
â•‘     CorreÃ§Ã£o: ${((newFactor - oldFactor) * 100).toFixed(1)}%
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `.trim());
}

// Aplicar calibraÃ§Ã£o a uma porcentagem de confianÃ§a
function applyCalibratedConfidence(rawConfidence) {
    // âœ… VERIFICAÃ‡ÃƒO DEFENSIVA: observerData pode nÃ£o estar inicializado ainda
    if (!observerData || !observerData.entries) {
        console.log(`âš ï¸ CalibraÃ§Ã£o indisponÃ­vel: observerData nÃ£o inicializado (retornando confianÃ§a original)`);
        return Math.round(rawConfidence);
    }
    
    // âœ… REGRA: SÃ³ aplicar calibraÃ§Ã£o apÃ³s 10+ entradas no observador
    const minEntriesForCalibration = 10;
    const currentEntries = observerData.entries.length;
    
    if (currentEntries < minEntriesForCalibration) {
        console.log(`â„¹ï¸ CalibraÃ§Ã£o desativada: ${currentEntries}/${minEntriesForCalibration} entradas (coletando dados)`);
        return Math.round(rawConfidence); // Retorna confianÃ§a original
    }
    
    // Aplicar fator de calibraÃ§Ã£o
    let calibrated = rawConfidence * observerData.calibrationFactor;
    
    // Garantir que fique entre 0-100
    calibrated = Math.max(0, Math.min(100, calibrated));
    
    console.log(`ğŸ”§ CalibraÃ§Ã£o aplicada: ${rawConfidence.toFixed(1)}% â†’ ${Math.round(calibrated)}% (fator: ${(observerData.calibrationFactor * 100).toFixed(1)}%, ${currentEntries} entradas)`);
    
    return Math.round(calibrated);
}

// Obter estatÃ­sticas do observador para exibiÃ§Ã£o
function getObserverStats() {
    const entries = observerData.entries;
    if (entries.length === 0) {
        return {
            total: 0,
            wins: 0,
            losses: 0,
            winRate: 0,
            calibrationFactor: observerData.calibrationFactor,
            byConfidence: observerData.stats
        };
    }
    
    const wins = entries.filter(e => e.result === 'win').length;
    const losses = entries.length - wins;
    
    return {
        total: entries.length,
        wins: wins,
        losses: losses,
        winRate: (wins / entries.length) * 100,
        calibrationFactor: observerData.calibrationFactor,
        byConfidence: observerData.stats,
        lastCalibration: observerData.lastCalibration,
        lastCalibratedCount: observerData.lastCalibratedCount // Quantas entradas foram processadas na Ãºltima calibraÃ§Ã£o
    };
}

// Start data collection
async function startDataCollection() {
    if (isRunning) return;
    
    // âœ… VERIFICAR SE HÃ ABA DA BLAZE ABERTA ANTES DE INICIAR
    const hasBlaze = await hasBlazeTabOpen();
    if (!hasBlaze) {
        console.log('â•‘  â›” IMPOSSÃVEL INICIAR: NENHUMA ABA DA BLAZE ABERTA      â•‘');
        console.log('â•‘  ğŸ’¡ Abra blaze.com para usar a extensÃ£o                  â•‘');
        return;
    }
    
    isRunning = true;
    
    // âœ… CARREGAR CONFIGURAÃ‡Ã•ES E ESTADO DO MARTINGALE DO STORAGE IMEDIATAMENTE
    try {
        const storageData = await chrome.storage.local.get(['analyzerConfig', 'martingaleState']);
        
        // Carregar configuraÃ§Ãµes
        if (storageData.analyzerConfig) {
            mergeAnalyzerConfig(storageData.analyzerConfig);
            console.log('âœ… ConfiguraÃ§Ãµes carregadas do storage com sucesso!');
            console.log('ğŸ”§ DEBUG - Config carregada:', {
                aiMode: analyzerConfig.aiMode,
                modoDiamante: analyzerConfig.aiMode ? 'ATIVO' : 'Desativado',
                minOccurrences: analyzerConfig.minOccurrences
            });
            
            // âœ… Se Modo Diamante jÃ¡ estava ativo ao iniciar, marcar flag para aguardar 1 giro
            if (analyzerConfig.aiMode) {
                aiModeJustActivated = true;
                console.log('%câ³ MODO DIAMANTE DETECTADO AO INICIAR: Aguardando 1 giro antes de enviar primeiro sinal...', 'color: #FFAA00; font-weight: bold;');
            }
        } else {
            console.log('â„¹ï¸ Usando configuraÃ§Ãµes padrÃ£o (nenhuma personalizaÃ§Ã£o salva)');
        }
        
        // âš ï¸ CRÃTICO: Carregar estado do Martingale do storage (pode haver ciclo em andamento)
        if (storageData.martingaleState && storageData.martingaleState.active) {
            martingaleState = storageData.martingaleState;
            console.log('ğŸ”„ Ciclo de Martingale em andamento detectado:', {
                stage: martingaleState.stage,
                entryColor: martingaleState.entryColor,
                lossCount: martingaleState.lossCount
            });
        }
    } catch (e) {
        console.warn('âš ï¸ Erro ao carregar configuraÃ§Ãµes/estado, usando padrÃ£o:', e);
    }
    
    console.log('â•‘  ğŸš€ BLAZE ANALYZER - INICIANDO                            â•‘');
    console.log('â•‘  ğŸ“¡ Modo: SERVIDOR (coleta do Render.com)                 â•‘');
    console.log('â•‘  âš¡ AtualizaÃ§Ã£o: TEMPO REAL via WebSocket                 â•‘');
    console.log('â•‘  ğŸ“Š Limite: 2000 giros | 5000 padrÃµes                     â•‘');
    console.log('â•‘  ğŸ’¾ Cache: Em memÃ³ria (nÃ£o persiste apÃ³s recarregar)      â•‘');
    
    // âœ… EXIBIR CONFIGURAÃ‡Ã•ES ATIVAS AO INICIAR
    logActiveConfiguration();
	logModeSnapshot('InicializaÃ§Ã£o', cachedHistory.length);
    
    // 1. Limpar padrÃµes locais (comeÃ§ar do zero)
    // âœ… Isso NÃƒO limpa: entriesHistory, anÃ¡lise pendente, calibrador
    // âœ… Limpa APENAS: banco de padrÃµes (patterns_found)
    await clearAllPatterns();
    
    // âœ… Verificar se entriesHistory foi preservado
    const checkData = await chrome.storage.local.get(['entriesHistory', 'analysis']);
    console.log(`âœ… HistÃ³rico de entradas preservado: ${(checkData.entriesHistory || []).length} entradas`);
    
    // âœ… Verificar se hÃ¡ anÃ¡lise pendente (aguardando resultado)
    if (checkData.analysis && checkData.analysis.createdOnTimestamp) {
        console.log('â•‘  ğŸ¯ ANÃLISE PENDENTE DETECTADA!                          â•‘');
        console.log(`â•‘  Cor recomendada: ${checkData.analysis.color}`);
        console.log(`â•‘  ConfianÃ§a: ${checkData.analysis.confidence}%`);
        console.log(`â•‘  Fase: ${checkData.analysis.phase || 'G0'}`);
        console.log(`â•‘  Criada em: ${checkData.analysis.createdOnTimestamp}`);
        console.log('â•‘  Status: Aguardando resultado do prÃ³ximo giro           â•‘');
    } else {
        console.log('â„¹ï¸ Nenhuma anÃ¡lise pendente no momento');
    }
    
    // 2. Resetar cache em memÃ³ria
    console.log('ğŸ—‘ï¸ Resetando cache em memÃ³ria...');
    cachedHistory = [];
    historyInitialized = false;
    console.log('âœ… Cache em memÃ³ria resetado.');
    
    // 3. Sincronizar dados com servidor primeiro (popula cache em memÃ³ria)
    await syncInitialData().catch(e => console.warn('Falha ao sincronizar com servidor:', e));
    
    // 4. Inicializar histÃ³rico completo (atÃ© 2000) uma vez ao iniciar
    await initializeHistoryIfNeeded().catch(e => console.warn('Falha ao inicializar histÃ³rico completo:', e));
    
    // 5. Busca de padrÃµes agora Ã© MANUAL (usuÃ¡rio clica no botÃ£o)
    // â±ï¸ DuraÃ§Ã£o atual: 30s (busca rÃ¡pida e intensiva)
    console.log('ğŸ’¡ Para buscar padrÃµes, clique em "ğŸ” Buscar PadrÃµes (30s)" na interface.');
    
    // 6. âœ… CONECTAR AO WEBSOCKET PARA RECEBER GIROS EM TEMPO REAL
    if (API_CONFIG.useWebSocket) {
        console.log('â•‘  âš¡ MODO WEBSOCKET ATIVO                                   â•‘');
        console.log('â•‘  Giros serÃ£o recebidos em TEMPO REAL (sem delay)         â•‘');
        connectWebSocket();
        
        // âœ… Iniciar sistema de verificaÃ§Ã£o de dados desatualizados
        startDataFreshnessCheck();
    } else {
        // Fallback: Polling com fetch (modo antigo)
        console.log('âš ï¸ Modo polling ativo (a cada 2s)');
        intervalId = setInterval(async () => {
            try {
                // âœ… VERIFICAR SE ABA DA BLAZE AINDA ESTÃ ABERTA (A CADA TICK)
                const hasBlaze = await hasBlazeTabOpen();
                if (!hasBlaze) {
                    console.log('â•‘  âš ï¸ ABA DA BLAZE FECHADA - PARANDO COLETA                â•‘');
                    stopDataCollection();
                    return;
                }
                
                await collectDoubleData();
            } catch (error) {
                console.error('Erro na coleta de dados:', error);
            }
        }, 2000);
    }
}

// Stop data collection
function stopDataCollection() {
    if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
    }
    
    // âœ… DESCONECTAR WEBSOCKET
    disconnectWebSocket();
    
    // âœ… PARAR POLLING DE FALLBACK
    stopPollingFallback();
    
    // âœ… PARAR VERIFICAÃ‡ÃƒO DE DADOS DESATUALIZADOS
    stopDataFreshnessCheck();
    
    isRunning = false;
    console.log('Blaze Double Analyzer: Parando coleta de dados');
}

// Collect data from SERVER (agora busca do servidor que estÃ¡ coletando 24/7)
async function collectDoubleData() {
    try {
        // Buscar Ãºltimo giro do SERVIDOR
        const response = await fetch(`${API_CONFIG.baseURL}/api/giros/latest`, {
            signal: AbortSignal.timeout(5000) // Timeout de 5s
        });
        
        if (!response.ok) {
            // Se servidor offline, tenta buscar direto da Blaze (fallback)
            console.warn('âš ï¸ Servidor offline, buscando direto da Blaze...');
            const blazeResponse = await fetch('https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/1');
            if (!blazeResponse.ok) throw new Error('Blaze API offline');
            const dataArr = await blazeResponse.json();
            if (!Array.isArray(dataArr) || dataArr.length === 0) return;
            
            const latestSpin = dataArr[0];
            const rollNumber = latestSpin.roll;
            const rollColor = getColorFromNumber(rollNumber);
            
            processNewSpin({
                id: `spin_${latestSpin.created_at}`,
                number: rollNumber,
                color: rollColor,
                timestamp: latestSpin.created_at,
                created_at: latestSpin.created_at,
                source: 'blaze_direct'
            });
            return;
        }
        
        const data = await response.json();
        
        if (data.success && data.data) {
            const latestSpin = data.data;
            
            // Verificar se jÃ¡ temos esse giro localmente e processar
            await processNewSpinFromServer(latestSpin);
        } else {
            console.log('â³ Aguardando giros do servidor...');
        }
    } catch (error) {
        console.error('Erro ao coletar dados do servidor:', error);
    }
}

// Helper: Converter nÃºmero em cor
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GET COLOR FROM NUMBER - REFATORADO 100%
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function getColorFromNumber(number) {
                // âœ… VALIDAÃ‡ÃƒO DE ENTRADA (silenciosa)
                if (typeof number !== 'number' || isNaN(number) || number === undefined || number === null) {
                    return 'unknown';
                }
                
                // âœ… NORMALIZAR NÃšMERO (caso seja float)
                const normalizedNumber = Math.floor(number);
                
                // âœ… VALIDAR RANGE (0-14)
                if (normalizedNumber < 0 || normalizedNumber > 14) {
                    return 'unknown';
                }
                
                // âœ… DETERMINAR COR
                if (normalizedNumber === 0) {
                    return 'white';
                } else if (normalizedNumber >= 1 && normalizedNumber <= 7) {
                    return 'red';
                } else if (normalizedNumber >= 8 && normalizedNumber <= 14) {
                    return 'black';
                }
                
                // âœ… FALLBACK (nunca deve chegar aqui)
                return 'unknown';
            }

// Processar novo giro vindo do servidor
async function processNewSpinFromServer(spinData) {
    try {
        const rollNumber = spinData.number;
        const rollColor = spinData.color;
        const latestSpin = {
            created_at: spinData.timestamp || spinData.created_at,
            roll: rollNumber
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // âš¡ PRIORIDADE MÃXIMA: ENVIAR GIRO PARA O UI IMEDIATAMENTE (SEM ESPERAR NADA!)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Adiciona novo giro ao cache ANTES de qualquer operaÃ§Ã£o assÃ­ncrona
        const newGiro = {
            id: spinData.id || `spin_${latestSpin.created_at}`,
                    number: rollNumber,
                    color: rollColor,
            timestamp: latestSpin.created_at,
            created_at: latestSpin.created_at
        };
        
        // Verificar se Ã© realmente um giro novo
        const isNewSpin = cachedHistory.length === 0 || 
                        cachedHistory[0].timestamp !== latestSpin.created_at || 
                        cachedHistory[0].number !== rollNumber;
            
            if (isNewSpin) {
            console.log('ğŸ¯ NOVO GIRO DETECTADO!', {
                    number: rollNumber,
                    color: rollColor,
                    timestamp: latestSpin.created_at
                });
            
            // âš¡ ATUALIZAR CACHE IMEDIATAMENTE (operaÃ§Ã£o sÃ­ncrona, super rÃ¡pida!)
            cachedHistory.unshift(newGiro);
            if (cachedHistory.length > 2000) {
                cachedHistory = cachedHistory.slice(0, 2000);
            }
            
            console.log(`âš¡ Cache atualizado! ${cachedHistory.length} giros`);
            
            // âš¡âš¡âš¡ ENVIAR PARA O UI IMEDIATAMENTE - SEM ESPERAR NADA! âš¡âš¡âš¡
            // Usar sendMessage sÃ­ncrono + try/catch para mÃ¡xima velocidade
            const spinMessage = {
                type: 'NEW_SPIN',
                data: {
                    lastSpin: { 
                    number: rollNumber,
                    color: rollColor,
                        timestamp: latestSpin.created_at 
                    }
                }
            };
            
            // âœ… ENVIAR PARA O UI IMEDIATAMENTE
            chrome.tabs.query({ url: '*://blaze.com/*' }, (tabs) => {
                if (tabs && tabs.length > 0) {
                    tabs.forEach(tab => {
                        chrome.tabs.sendMessage(tab.id, spinMessage).catch(() => {
                            // Ignorar tabs sem content.js
                        });
                    });
                    console.log(`âš¡ GIRO ENVIADO INSTANTANEAMENTE para ${tabs.length} tab(s)!`);
                } else {
                    // Fallback: tentar enviar para todas as tabs
                    chrome.tabs.query({}, (allTabs) => {
                        if (allTabs && allTabs.length > 0) {
                            allTabs.forEach(tab => {
                                chrome.tabs.sendMessage(tab.id, spinMessage).catch(() => {});
                            });
                        }
                    });
                }
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ“¦ OPERAÃ‡Ã•ES NECESSÃRIAS (UI jÃ¡ foi atualizado instantaneamente acima!)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Salvar lastSpin no storage (para persistÃªncia)
            await chrome.storage.local.set({
                lastSpin: {
                    number: rollNumber,
                    color: rollColor,
                    timestamp: latestSpin.created_at
                }
            });
            
            // Buscar entriesHistory
            let entriesHistory = [];
            try {
                const result = await chrome.storage.local.get(['entriesHistory']);
                entriesHistory = result['entriesHistory'] || [];
            } catch (e) {
                console.warn('âš ï¸ Erro ao buscar entriesHistory:', e);
            }
            
            // âš¡ ATUALIZAR MEMÃ“RIA ATIVA INCREMENTALMENTE (super rÃ¡pido!)
            if (memoriaAtiva.inicializada) {
                const sucesso = atualizarMemoriaIncrementalmente(newGiro);
                if (sucesso) {
                    console.log(`%câš¡ MemÃ³ria Ativa atualizada! (${memoriaAtiva.tempoUltimaAtualizacao.toFixed(2)}ms)`, 'color: #00CED1; font-weight: bold;');
                } else {
                    console.warn('%câš ï¸ Falha ao atualizar MemÃ³ria Ativa!', 'color: #FFA500;');
                }
            } else {
                // âœ… Se modo IA estÃ¡ ativo e memÃ³ria nÃ£o foi inicializada, inicializar agora
                if (analyzerConfig.aiMode && cachedHistory.length >= 60) {
                    console.log('%cğŸ§  Inicializando MemÃ³ria Ativa...', 'color: #00CED1; font-weight: bold;');
                    const sucesso = await inicializarMemoriaAtiva(cachedHistory);
                    if (sucesso) {
                        console.log('%câœ… MemÃ³ria Ativa inicializada!', 'color: #00FF88; font-weight: bold;');
                    } else {
                        console.log('%câš ï¸ Falha ao inicializar MemÃ³ria Ativa', 'color: #FFAA00;');
                    }
                }
            }
            
            // âœ… CARREGAR CONFIGURAÃ‡Ã•ES E ESTADO DO MARTINGALE DO STORAGE
            try {
                const storageData = await chrome.storage.local.get(['analyzerConfig', 'martingaleState']);
                
                // Carregar configuraÃ§Ãµes
                if (storageData.analyzerConfig) {
                    mergeAnalyzerConfig(storageData.analyzerConfig);
                    const activeModeKey = getModeKey();
                    const otherModeKey = activeModeKey === 'diamond' ? 'standard' : 'diamond';
                    console.log('âš™ï¸ ConfiguraÃ§Ãµes carregadas:', {
                        aiMode: analyzerConfig.aiMode,
                        n0AllowBlockAll: analyzerConfig.n0AllowBlockAll !== false,
                        martingale: {
                            [activeModeKey]: getMartingaleSettings(activeModeKey),
                            [otherModeKey]: getMartingaleSettings(otherModeKey)
                        }
                    });
                }
                
                // âš ï¸ CRÃTICO: Carregar estado do Martingale do storage
                if (storageData.martingaleState) {
                    martingaleState = storageData.martingaleState;
                    console.log('ğŸ”„ Estado do Martingale carregado:', {
                        active: martingaleState.active,
                        stage: martingaleState.stage,
                        entryColor: martingaleState.entryColor,
                        lossCount: martingaleState.lossCount
                    });
                }
            } catch (e) {
                console.warn('âš ï¸ Erro ao carregar configuraÃ§Ãµes/estado, usando padrÃ£o:', e);
            }
            
            console.log('ğŸ” Buscando currentAnalysis de chrome.storage.local...');
                
                // Avaliar recomendaÃ§Ã£o pendente (WIN / G1 / G2)
            const currentAnalysisResult = await chrome.storage.local.get(['analysis']);
            const currentAnalysis = currentAnalysisResult['analysis'];
            
            console.log('ğŸ“Š Resultado da busca:', currentAnalysisResult);
            console.log('ğŸ“Š currentAnalysis existe?', currentAnalysis ? 'SIM' : 'NÃƒO');
            
            if (currentAnalysis) {
                console.log('   Cor recomendada:', currentAnalysis.color);
                console.log('   ConfianÃ§a:', currentAnalysis.confidence);
                console.log('   Fase:', currentAnalysis.phase || 'G0');
                console.log('   Timestamp recomendaÃ§Ã£o:', currentAnalysis.createdOnTimestamp);
                console.log('   PredictedFor:', currentAnalysis.predictedFor);
            }
            
            console.log('ğŸ² Giro atual:');
            console.log('   Cor:', rollColor);
            console.log('   NÃºmero:', rollNumber);
            console.log('   Timestamp:', latestSpin.created_at);
            
                if (currentAnalysis && currentAnalysis.createdOnTimestamp && currentAnalysis.predictedFor === 'next') {
                console.log('âœ… RecomendaÃ§Ã£o pendente encontrada!');
                console.log('ğŸ” Comparando timestamps:');
                console.log('   RecomendaÃ§Ã£o:', currentAnalysis.createdOnTimestamp);
                console.log('   Giro atual:', latestSpin.created_at);
                console.log('   SÃ£o diferentes?', currentAnalysis.createdOnTimestamp !== latestSpin.created_at);
                
                    // Novo giro chegou para a recomendaÃ§Ã£o pendente
                    if (currentAnalysis.createdOnTimestamp !== latestSpin.created_at) {
                    console.log('ğŸ¯ AVALIAR RESULTADO!');
                    console.log('   Esperado:', currentAnalysis.color);
                    console.log('   Real:', rollColor);
                    console.log('   Tipo esperado:', typeof currentAnalysis.color);
                    console.log('   Tipo real:', typeof rollColor);
                    console.log('   ComparaÃ§Ã£o exata:', rollColor === currentAnalysis.color);
                    console.log('   ComparaÃ§Ã£o case-insensitive:', rollColor.toLowerCase() === currentAnalysis.color.toLowerCase());
                    
                        // âœ… CORREÃ‡ÃƒO CRÃTICA: ComparaÃ§Ã£o robusta de cores
                        const expectedColor = String(currentAnalysis.color || '').toLowerCase().trim();
                        const actualColor = String(rollColor || '').toLowerCase().trim();
                        const whiteProtectionWin = !!analyzerConfig.whiteProtectionAsWin
                            && actualColor === 'white'
                            && (expectedColor === 'red' || expectedColor === 'black');
                        const hit = whiteProtectionWin || (expectedColor === actualColor);
                    
                    console.log('   ğŸ” VERIFICAÃ‡ÃƒO FINAL DE WIN/LOSS:');
                    console.log('   Esperado (processado):', expectedColor);
                    console.log('   Real (processado):', actualColor);
                    if (whiteProtectionWin) {
                        console.log('   ProteÃ§Ã£o no Branco ativa? SIM â†’ branco considerado WIN');
                    }
                    console.log('   SÃ£o iguais?', hit);
                    console.log('   Resultado FINAL:', hit ? 'âœ… WIN!' : 'âŒ LOSS!');
                    
                        if (hit) {
                        console.log('â•‘  âœ… WIN DETECTADO!                                       â•‘');
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // âœ… SISTEMA DE MARTINGALE - LÃ“GICA DE WIN
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            
                            // âœ… VALIDAÃ‡ÃƒO CRÃTICA: Garantir que nÃ£o hÃ¡ processamento duplo
                            console.log('   Martingale ativo:', martingaleState.active);
                            console.log('   EstÃ¡gio atual:', martingaleState.stage);
                            console.log('   AnÃ¡lise fase:', currentAnalysis.phase);
                            
                            // Se jÃ¡ foi processado como WIN, nÃ£o processar novamente
                            if (martingaleState.active && martingaleState.stage !== 'ENTRADA' && currentAnalysis.phase === 'G0') {
                                console.log('âš ï¸ ATENÃ‡ÃƒO: PossÃ­vel processamento duplo detectado!');
                                console.log('   Martingale ativo mas anÃ¡lise Ã© G0 - pode ser WIN jÃ¡ processado');
                                return; // Sair sem processar
                            }
                            
                            // Determinar estÃ¡gio do Martingale CORRETAMENTE
                            // âœ… Verificar PRIMEIRO a fase da anÃ¡lise (G1/G2), depois o estado
                            let martingaleStage = 'ENTRADA';
                            if (currentAnalysis.phase === 'G1') {
                                martingaleStage = 'G1';
                            } else if (currentAnalysis.phase === 'G2') {
                                martingaleStage = 'G2';
                            } else if (martingaleState.active) {
                                martingaleStage = martingaleState.stage;
                            }
                            
                            const patternKey = martingaleState.active ? martingaleState.patternKey : createPatternKey(currentAnalysis);
                            
                            console.log(`ğŸ¯ WIN no estÃ¡gio: ${martingaleStage}`);
                            console.log(`ğŸ”‘ PadrÃ£o: ${patternKey}`);
                            
                            // WIN: registrar entrada com informaÃ§Ãµes de Martingale
                            // âœ… Fix: gravar valores financeiros da entrada no momento (para nÃ£o â€œmudar o passadoâ€ ao alterar config)
                            const cycleAutoBetCfg = martingaleState && martingaleState.active
                                ? ensureMartingaleCycleConfig(snapshotAutoBetConfig(analyzerConfig))
                                : snapshotAutoBetConfig(analyzerConfig);
                            const betColor = currentAnalysis.color;
                            const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                            const stakeAmount = calcStakeForStage(martingaleStage, cycleAutoBetCfg);
                            const cycleId = (martingaleState && martingaleState.active && martingaleState.entryTimestamp)
                                ? martingaleState.entryTimestamp
                                : (currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now());
                            const cycleTotalInvested = calcTotalInvestedThroughStage(martingaleStage, cycleAutoBetCfg);
                            const cycleNetProfit = roundMoney((stakeAmount * payoutMultiplier) - cycleTotalInvested);
                            const winEntry = {
                                timestamp: latestSpin.created_at,
                                number: rollNumber,
                                color: rollColor,
                                phase: currentAnalysis.phase || 'G0',
                                result: 'WIN',
                                confidence: currentAnalysis.confidence,
                                patternData: {
                                    patternDescription: currentAnalysis.patternDescription,
                                    confidence: currentAnalysis.confidence,
                                    color: currentAnalysis.color,
                                    createdOnTimestamp: currentAnalysis.createdOnTimestamp
                                },
                                // âœ… CAMPOS DO MARTINGALE
                                martingaleStage: martingaleStage,  // 'ENTRADA' | 'G1' | 'G2'
                                wonAt: martingaleStage,             // Onde ganhou
                                finalResult: 'WIN',                 // Resultado final do ciclo
                                // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard', // 'diamond' | 'standard'
                                // âœ… FINANCEIRO (fixo no tempo)
                                cycleId,
                                betColor,
                                stakeAmount,
                                baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                payoutMultiplier,
                                cycleTotalInvested,
                                cycleNetProfit
                            };
                            
                            console.log('%câ•‘  ğŸ“ DEBUG COMPLETO: SALVANDO ENTRADA WIN                                    â•‘', 'color: #00FF00; font-weight: bold; font-size: 14px;');
                            console.log('%cğŸ“Š DADOS DA ENTRADA WIN:', 'color: #00FF88; font-weight: bold;');
                            console.log('   â¤ Timestamp:', winEntry.timestamp);
                            console.log('   â¤ NÃºmero:', winEntry.number);
                            console.log('   â¤ Cor:', winEntry.color);
                            console.log('   â¤ Fase:', winEntry.phase);
                            console.log('   â¤ Resultado:', winEntry.result);
                            console.log('   â¤ ConfianÃ§a:', winEntry.confidence + '%');
                            console.log('   â¤ Martingale Stage:', winEntry.martingaleStage);
                            console.log('   â¤ Won At:', winEntry.wonAt);
                            console.log('   â¤ Final Result:', winEntry.finalResult);
                            console.log('%cğŸ“‹ ESTADO DO HISTÃ“RICO ANTES DE ADICIONAR:', 'color: #00FFFF; font-weight: bold;');
                            console.log('   â¤ entriesHistory existe?', !!entriesHistory);
                            console.log('   â¤ entriesHistory.length ANTES:', entriesHistory.length);
                            
                            entriesHistory.unshift(winEntry);
                            
                            console.log('%câœ… ENTRADA ADICIONADA AO HISTÃ“RICO!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
                            console.log('   â¤ entriesHistory.length DEPOIS:', entriesHistory.length);
                            
                            // âœ… Calcular estatÃ­sticas WIN/LOSS FILTRADAS POR MODO
                            const currentMode = analyzerConfig.aiMode ? 'diamond' : 'standard';
                            const { wins: filteredWins, losses: filteredLosses } = calculateFilteredScore(entriesHistory, currentMode);
                            
                            console.log(`ğŸ“Š Placar total: ${calculateCycleScore(entriesHistory).totalWins} wins / ${calculateCycleScore(entriesHistory).totalLosses} losses`);
                            console.log(`ğŸ“Š Placar ${currentMode}: ${filteredWins} wins / ${filteredLosses} losses`);
                            
                            // âœ… Enviar confirmaÃ§Ã£o de WIN ao Telegram (com informaÃ§Ã£o de Martingale e modo)
                            await sendTelegramMartingaleWin(
                                martingaleStage, 
                                { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                filteredWins,
                                filteredLosses,
                                currentMode
                            );
                            
                            // Registrar no observador inteligente
                            await registerEntryInObserver(
                                currentAnalysis.confidence,
                                'win',
                                currentAnalysis.createdOnTimestamp,
                                { type: currentAnalysis.patternType, occurrences: currentAnalysis.occurrences }
                            );
                            
                            // âœ… ATUALIZAR HISTÃ“RICO DE CORES QUENTES
                            if (martingaleState.active && (martingaleStage === 'G1' || martingaleStage === 'G2')) {
                                console.log('ğŸ“Š Atualizando histÃ³rico de cores quentes apÃ³s WIN...');
                                
                                // Construir sequÃªncia de cores DOS GIROS (nÃ£o das apostas!)
                                const colorSequence = [];
                                
                                // Adicionar cores dos LOSSes (giros que realmente saÃ­ram)
                                martingaleState.lossColors.forEach(color => {
                                    colorSequence.push({ color });
                                });
                                
                                // Adicionar cor que GANHOU (giro atual)
                                colorSequence.push({ color: rollColor });
                                
                                console.log('   SequÃªncia de cores dos giros:', colorSequence.map(c => c.color).join(' â†’ '));
                                
                                await updateHotColorsHistory(patternKey, colorSequence);
                            }
                            
                            // âœ… RESETAR CICLO DE MARTINGALE - CRÃTICO!
                            if (martingaleState.active) {
                                console.log('ğŸ”„ Resetando ciclo de Martingale apÃ³s WIN');
                                console.log('   Estado ANTES do reset:', {
                                    active: martingaleState.active,
                                    stage: martingaleState.stage,
                                    patternKey: martingaleState.patternKey
                                });
                                resetMartingaleState();
                                console.log('   Estado APÃ“S o reset:', {
                                    active: martingaleState.active,
                                    stage: martingaleState.stage,
                                    patternKey: martingaleState.patternKey
                                });
                            }
                            
                            console.log('%cğŸ’¾ SALVANDO NO CHROME.STORAGE.LOCAL...', 'color: #FFD700; font-weight: bold; font-size: 14px;');
                            console.log('   â¤ analysis: null (limpar)');
                            console.log('   â¤ pattern: null (limpar)');
                            console.log('   â¤ lastBet.status: win');
                            console.log('   â¤ entriesHistory.length:', entriesHistory.length);
                            console.log('   â¤ martingaleState.active:', martingaleState.active);
                            console.log('   â¤ rigorLevel: 75 (reset)');
                            
                            await chrome.storage.local.set({ 
                                analysis: null, 
                                pattern: null,
                                lastBet: { status: 'win', phase: currentAnalysis.phase || 'G0', resolvedAtTimestamp: latestSpin.created_at },
                                // âœ… Intervalo apÃ³s entrada (Diamante): contar a partir do FIM DO CICLO
                                lastCycleResolvedSpinId: latestSpin ? (latestSpin.id || null) : null,
                                lastCycleResolvedSpinTimestamp: latestSpin ? (latestSpin.created_at || null) : null,
                                lastCycleResolvedTimestamp: Date.now(),
                                entriesHistory,
                                martingaleState,  // âœ… Salvar estado do Martingale
                                rigorLevel: 75 // RESET: Volta para 75% apÃ³s WIN
                            });
                            
                            
                            sendMessageToContent('CLEAR_ANALYSIS');
                            
                            // âœ… Enviar atualizaÃ§Ã£o de entradas para UI
                            console.log('%cğŸ“¤ ENVIANDO ENTRIES_UPDATE PARA UI...', 'color: #00D4FF; font-weight: bold; font-size: 14px;');
                            console.log('   â¤ Type: ENTRIES_UPDATE');
                            console.log('   â¤ Total de entradas:', entriesHistory.length);
                            console.log('   â¤ Primeira entrada:', entriesHistory[0] ? {
                                result: entriesHistory[0].result,
                                color: entriesHistory[0].color,
                                number: entriesHistory[0].number,
                                phase: entriesHistory[0].phase
                            } : 'N/A');
                            
                            const uiUpdateResult = sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                            console.log('%cğŸ“¨ Resultado do envio para UI:', uiUpdateResult ? 'color: #00FF00;' : 'color: #FF0000;', uiUpdateResult);
                            console.log('%câ•‘  âœ… ENTRADA WIN PROCESSADA COMPLETAMENTE!                                   â•‘', 'color: #00FF00; font-weight: bold;');
                        } else {
                            console.log('â•‘  âŒ LOSS DETECTADO!                                      â•‘');
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // âœ… SISTEMA DE MARTINGALE - LÃ“GICA DE LOSS
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            
                            // Determinar estÃ¡gio atual
                            const currentStage = martingaleState.active ? martingaleState.stage : 'ENTRADA';
                            const patternKey = martingaleState.active ? martingaleState.patternKey : createPatternKey(currentAnalysis);
                            
                            console.log(`âŒ LOSS no estÃ¡gio: ${currentStage}`);
                            console.log(`ğŸ”‘ PadrÃ£o: ${patternKey}`);
                            console.log(`ğŸ² Esperado: ${currentAnalysis.color}, Real: ${rollColor}`);
                            
                            // âœ… VERIFICAR SE Ã‰ O ÃšLTIMO GALE (vai virar RET) ou se ainda tem mais Gales
                            // NÃƒO ENVIAR MENSAGEM AQUI - serÃ¡ enviada dentro da lÃ³gica abaixo
                            
                            // âœ… REGISTRAR NO CALIBRADOR DE PORCENTAGENS
                            await registerEntryInObserver(
                                currentAnalysis.confidence,
                                'loss',
                                currentAnalysis.createdOnTimestamp,
                                { type: currentAnalysis.patternType, occurrences: currentAnalysis.occurrences }
                            );
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // NOVA LÃ“GICA DE MARTINGALE - DECIDIR PRÃ“XIMA AÃ‡ÃƒO
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // âœ… LÃ“GICA DINÃ‚MICA DE MARTINGALE - FUNCIONA PARA QUALQUER QUANTIDADE
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            
                            // Determinar o nÃºmero do Gale atual (0=ENTRADA, 1=G1, 2=G2, 3=G3...)
                            let currentGaleNumber = 0;
                            if (currentStage === 'ENTRADA') {
                                currentGaleNumber = 0;
                            } else if (currentStage.startsWith('G')) {
                                currentGaleNumber = parseInt(currentStage.substring(1)) || 0;
                            }
                            
                            const nextGaleNumber = currentGaleNumber + 1;
                            const { maxGales, consecutiveGales } = getMartingaleSettings();
                            
                            console.log(`â•‘  âŒ LOSS no ${currentStage === 'ENTRADA' ? 'ENTRADA PADRÃƒO' : currentStage}                                  â•‘`);
                            console.log(`â•‘  âš™ï¸  ConfiguraÃ§Ã£o: ${maxGales} Gale${maxGales !== 1 ? 's' : ''} permitido${maxGales !== 1 ? 's' : ''}           â•‘`);
                            console.log(`â•‘  ğŸ“Š Atual: Gale ${currentGaleNumber} (${currentStage})                        â•‘`);
                            console.log(`â•‘  ğŸ¯ PrÃ³ximo: ${nextGaleNumber <= maxGales ? `Tentar G${nextGaleNumber}` : 'RET (limite atingido)'}                  â•‘`);
                            
                            // Verificar se ainda pode tentar mais Gales
                            const canTryNextGale = nextGaleNumber <= maxGales;
                            
                            if (currentStage === 'ENTRADA') {
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // âœ… LOSS NA ENTRADA: Verificar se pode tentar G1
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                
                                if (!canTryNextGale) {
                                    // âŒ SEM GALES: Registrar LOSS direto
                                    console.log('â›” CONFIGURAÃ‡ÃƒO: 0 Gales - Registrando LOSS direto');
                                    
                                    // âœ… Fix financeiro: congelar config e calcular valores do ciclo (RET)
                                    const cycleAutoBetCfg = snapshotAutoBetConfig(analyzerConfig);
                                    const betColor = currentAnalysis.color;
                                    const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                                    const stakeAmount = calcStakeForStage('ENTRADA', cycleAutoBetCfg);
                                    const cycleId = currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now();
                                    const cycleTotalInvested = calcTotalInvestedThroughStage('ENTRADA', cycleAutoBetCfg);
                                    const cycleNetProfit = roundMoney(-cycleTotalInvested);
                                    
                                    const lossEntry = {
                                        timestamp: latestSpin.created_at,
                                        number: rollNumber,
                                        color: rollColor,
                                        phase: 'G0',
                                        result: 'LOSS',
                                        confidence: currentAnalysis.confidence,
                                        patternData: {
                                            patternDescription: currentAnalysis.patternDescription,
                                            confidence: currentAnalysis.confidence,
                                            color: currentAnalysis.color,
                                            createdOnTimestamp: currentAnalysis.createdOnTimestamp
                                        },
                                        martingaleStage: 'ENTRADA',
                                        finalResult: 'RET',
                                        // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                        analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard',
                                        // âœ… FINANCEIRO (fixo no tempo)
                                        cycleId,
                                        betColor,
                                        stakeAmount,
                                        baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                        galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                        payoutMultiplier,
                                        cycleTotalInvested,
                                        cycleNetProfit
                                    };
                                    
                                    console.log('%câ•‘  ğŸ“ DEBUG COMPLETO: SALVANDO ENTRADA LOSS (SEM GALES)                      â•‘', 'color: #FF0000; font-weight: bold; font-size: 14px;');
                                    console.log('%cğŸ“Š DADOS DA ENTRADA LOSS:', 'color: #FF6666; font-weight: bold;');
                                    console.log('   â¤ Timestamp:', lossEntry.timestamp);
                                    console.log('   â¤ NÃºmero:', lossEntry.number);
                                    console.log('   â¤ Cor:', lossEntry.color);
                                    console.log('   â¤ Fase:', lossEntry.phase);
                                    console.log('   â¤ Resultado:', lossEntry.result);
                                    console.log('   â¤ ConfianÃ§a:', lossEntry.confidence + '%');
                                    console.log('   â¤ Martingale Stage:', lossEntry.martingaleStage);
                                    console.log('   â¤ Final Result:', lossEntry.finalResult);
                                    console.log('%cğŸ“‹ ESTADO DO HISTÃ“RICO ANTES DE ADICIONAR:', 'color: #00FFFF; font-weight: bold;');
                                    console.log('   â¤ entriesHistory existe?', !!entriesHistory);
                                    console.log('   â¤ entriesHistory.length ANTES:', entriesHistory.length);
                                    
                                    entriesHistory.unshift(lossEntry);
                                    
                                    console.log('%câœ… ENTRADA ADICIONADA AO HISTÃ“RICO!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
                                    console.log('   â¤ entriesHistory.length DEPOIS:', entriesHistory.length);
                                    
                                    // âœ… Calcular estatÃ­sticas WIN/LOSS FILTRADAS POR MODO
                                    const currentMode = analyzerConfig.aiMode ? 'diamond' : 'standard';
                                    const { wins: filteredWins, losses: filteredLosses } = calculateFilteredScore(entriesHistory, currentMode);
                                    
                                    console.log(`ğŸ“Š Placar total: ${calculateCycleScore(entriesHistory).totalWins} wins / ${calculateCycleScore(entriesHistory).totalLosses} losses`);
                                    console.log(`ğŸ“Š Placar ${currentMode}: ${filteredWins} wins / ${filteredLosses} losses`);
                                    
                                    // âœ… ENVIAR MENSAGEM DE RET AO TELEGRAM (sem Gales)
                                    console.log('ğŸ“¤ Enviando mensagem de RET ao Telegram (0 Gales configurados)...');
                                    await sendTelegramMartingaleRET(filteredWins, filteredLosses, currentMode);
                                    
                                    resetMartingaleState();
                                    
                                    console.log('%cğŸ’¾ SALVANDO NO CHROME.STORAGE.LOCAL...', 'color: #FFD700; font-weight: bold; font-size: 14px;');
                                    console.log('   â¤ analysis: null (limpar)');
                                    console.log('   â¤ pattern: null (limpar)');
                                    console.log('   â¤ lastBet.status: loss');
                                    console.log('   â¤ entriesHistory.length:', entriesHistory.length);
                                    
                                    await chrome.storage.local.set({ 
                                        analysis: null, 
                                        pattern: null,
                                        lastBet: { status: 'loss', phase: 'G0', resolvedAtTimestamp: latestSpin.created_at },
                                        // âœ… Intervalo apÃ³s entrada (Diamante): contar a partir do FIM DO CICLO (RET)
                                        lastCycleResolvedSpinId: latestSpin ? (latestSpin.id || null) : null,
                                        lastCycleResolvedSpinTimestamp: latestSpin ? (latestSpin.created_at || null) : null,
                                        lastCycleResolvedTimestamp: Date.now(),
                                        entriesHistory,
                                        martingaleState
                                    });
                                    
                                    
                                    sendMessageToContent('CLEAR_ANALYSIS');
                                    
                                    console.log('%cğŸ“¤ ENVIANDO ENTRIES_UPDATE PARA UI...', 'color: #00D4FF; font-weight: bold; font-size: 14px;');
                                    console.log('   â¤ Type: ENTRIES_UPDATE');
                                    console.log('   â¤ Total de entradas:', entriesHistory.length);
                                    console.log('   â¤ Primeira entrada:', entriesHistory[0] ? {
                                        result: entriesHistory[0].result,
                                        color: entriesHistory[0].color,
                                        number: entriesHistory[0].number,
                                        phase: entriesHistory[0].phase,
                                        finalResult: entriesHistory[0].finalResult
                                    } : 'N/A');
                                    
                                    const uiUpdateResult = sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                    console.log('%cğŸ“¨ Resultado do envio para UI:', uiUpdateResult ? 'color: #00FF00;' : 'color: #FF0000;', uiUpdateResult);
                                    console.log('%câ•‘  âœ… ENTRADA LOSS PROCESSADA COMPLETAMENTE!                                  â•‘', 'color: #00FF00; font-weight: bold;');
                                    return;
                                }
                                
                                // âœ… TEM GALES: Tentar G1
                                console.log(`ğŸ”„ Tentando G${nextGaleNumber}...`);
                                console.log(`âš™ï¸ Gales consecutivos (atÃ©): ${consecutiveGales}`);
                                
                                // âœ… ENVIAR MENSAGEM DE LOSS ENTRADA (vai tentar G1)
                                await sendTelegramMartingaleLoss(
                                    currentStage,
                                    { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at }
                                );
                                
                                // âœ… USAR SEMPRE A MESMA COR DA ENTRADA ORIGINAL
                                const g1Color = currentAnalysis.color;
                                
                                // âš ï¸ CRÃTICO: Registrar LOSS da ENTRADA antes de tentar G1
                                // âœ… Fix financeiro: congelar config do ciclo na primeira entrada
                                const cycleAutoBetCfg = ensureMartingaleCycleConfig(snapshotAutoBetConfig(analyzerConfig));
                                const betColor = currentAnalysis.color;
                                const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                                const stakeAmount = calcStakeForStage('ENTRADA', cycleAutoBetCfg);
                                const cycleId = currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now();
                                const entradaLossEntry = {
                            timestamp: latestSpin.created_at,
                            number: rollNumber,
                            color: rollColor,
                                    phase: 'G0',
                            result: 'LOSS',
                            confidence: currentAnalysis.confidence,
                            patternData: {
                                patternDescription: currentAnalysis.patternDescription,
                                confidence: currentAnalysis.confidence,
                                color: currentAnalysis.color,
                                createdOnTimestamp: currentAnalysis.createdOnTimestamp
                                    },
                                    martingaleStage: 'ENTRADA',
                                    finalResult: null,  // Ainda nÃ£o Ã© final, vai tentar G1
                                    continuingToG1: true,  // Flag indicando que continuarÃ¡
                                    // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                    analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard',
                                    // âœ… FINANCEIRO (fixo no tempo)
                                    cycleId,
                                    betColor,
                                    stakeAmount,
                                    baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                    galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                    payoutMultiplier
                                };
                                
                                entriesHistory.unshift(entradaLossEntry);
                                
                                // Salvar estado do Martingale
                                martingaleState.active = true;
                                martingaleState.stage = 'G1';
                                martingaleState.patternKey = patternKey;
                                martingaleState.entryColor = currentAnalysis.color;
                                martingaleState.entryColorResult = rollColor;  // âœ… Cor que realmente saiu
                                martingaleState.entryTimestamp = currentAnalysis.createdOnTimestamp;
                                martingaleState.analysisData = currentAnalysis;
                                martingaleState.lossCount = 1;
                                martingaleState.lossColors = [rollColor];  // âœ… Guardar cores dos LOSSes
                                
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // VERIFICAR MODO DE MARTINGALE
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                
                                if (nextGaleNumber <= consecutiveGales) {
                                    // âœ… MODO CONSECUTIVO: Enviar G1 IMEDIATAMENTE no prÃ³ximo giro
                                    console.log('ğŸ¯ MODO CONSECUTIVO: G1 serÃ¡ enviado no PRÃ“XIMO GIRO');
                                    
                                    await sendTelegramMartingaleG1(g1Color, null);
                                    
                                    // Criar anÃ¡lise G1 com timestamp do prÃ³ximo giro
                                    const g1Analysis = {
                                        ...currentAnalysis,
                                        color: g1Color,
                                        phase: 'G1',
                                        predictedFor: 'next',
                                        createdOnTimestamp: latestSpin.created_at  // âœ… Usar giro atual
                                    };
                                    g1Analysis.confidence = calculateGaleConfidenceValue(g1Analysis.confidence, g1Analysis);
                                    
                                    await chrome.storage.local.set({
                                        analysis: g1Analysis,
                                        pattern: { description: g1Analysis.patternDescription, confidence: g1Analysis.confidence },
                                        lastBet: { status: 'pending', phase: 'G1', createdOnTimestamp: g1Analysis.createdOnTimestamp },
                                        entriesHistory,
                                        martingaleState
                                    });
                                    
                                    emitAnalysisToContent(g1Analysis, analyzerConfig.aiMode ? 'diamond' : 'standard');
                                    sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                } else {
                                    // âŒ MODO PADRÃƒO: Aguardar novo padrÃ£o para enviar G1
                                    console.log('â³ MODO PRÃ“XIMO SINAL: Aguardando novo sinal para enviar G1...');
                                    
                                    await chrome.storage.local.set({
                                        analysis: null,
                                        pattern: null,
                                        lastBet: { status: 'loss', phase: 'G0', resolvedAtTimestamp: latestSpin.created_at },
                                        entriesHistory,
                                        martingaleState
                                    });
                                    
                                    sendMessageToContent('CLEAR_ANALYSIS');
                                    sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                }
                                
                            } else if (currentStage.startsWith('G')) {
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // âœ… LOSS EM QUALQUER GALE (G1, G2, G3... G200)
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                
                                if (!canTryNextGale) {
                                    // âŒ LIMITE ATINGIDO: Registrar RET
                                    console.log(`â›” Limite de Gales atingido (${currentGaleNumber}/${maxGales}) - Registrando RET`);
                                    
                                    // âœ… Fix financeiro: usar config do ciclo (congelada) e calcular net do RET
                                    const cycleAutoBetCfg = ensureMartingaleCycleConfig(snapshotAutoBetConfig(analyzerConfig));
                                    const betColor = (martingaleState && martingaleState.entryColor) ? martingaleState.entryColor : currentAnalysis.color;
                                    const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                                    const stakeAmount = calcStakeForStage(currentStage, cycleAutoBetCfg);
                                    const cycleId = (martingaleState && martingaleState.entryTimestamp)
                                        ? martingaleState.entryTimestamp
                                        : (currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now());
                                    const cycleTotalInvested = calcTotalInvestedThroughStage(currentStage, cycleAutoBetCfg);
                                    const cycleNetProfit = roundMoney(-cycleTotalInvested);
                                    
                                    const retEntry = {
                                        timestamp: latestSpin.created_at,
                                        number: rollNumber,
                                        color: rollColor,
                                        phase: currentStage,
                                        result: 'LOSS',
                                        confidence: currentAnalysis.confidence,
                                        patternData: {
                                            patternDescription: currentAnalysis.patternDescription,
                                            confidence: currentAnalysis.confidence,
                                            color: currentAnalysis.color,
                                            createdOnTimestamp: currentAnalysis.createdOnTimestamp
                                        },
                                        martingaleStage: currentStage,
                                        finalResult: 'RET',
                                        // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                        analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard',
                                        // âœ… FINANCEIRO (fixo no tempo)
                                        cycleId,
                                        betColor,
                                        stakeAmount,
                                        baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                        galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                        payoutMultiplier,
                                        cycleTotalInvested,
                                        cycleNetProfit
                                    };
                                    
                                    entriesHistory.unshift(retEntry);
                                    
                                    // âœ… Calcular estatÃ­sticas WIN/LOSS FILTRADAS POR MODO
                                    const currentMode = analyzerConfig.aiMode ? 'diamond' : 'standard';
                                    const { wins: filteredWins, losses: filteredLosses } = calculateFilteredScore(entriesHistory, currentMode);
                                    
                                    console.log(`ğŸ“Š Placar total: ${calculateCycleScore(entriesHistory).totalWins} wins / ${calculateCycleScore(entriesHistory).totalLosses} losses`);
                                    console.log(`ğŸ“Š Placar ${currentMode}: ${filteredWins} wins / ${filteredLosses} losses`);
                                    
                                    await sendTelegramMartingaleRET(filteredWins, filteredLosses, currentMode);
                                    
                                    // âœ… ATUALIZAR HISTÃ“RICO DE CORES QUENTES
                                    const colorSequence = [];
                                    martingaleState.lossColors.forEach(color => {
                                        colorSequence.push({ color });
                                    });
                                    colorSequence.push({ color: rollColor });
                                    await updateHotColorsHistory(patternKey, colorSequence);
                                    
                                    resetMartingaleState();
                                    
                                    await chrome.storage.local.set({ 
                                        analysis: null, 
                                        pattern: null, 
                                        lastBet: { status: 'loss', phase: currentStage, resolvedAtTimestamp: latestSpin.created_at },
                                        // âœ… Intervalo apÃ³s entrada (Diamante): contar a partir do FIM DO CICLO (RET)
                                        lastCycleResolvedSpinId: latestSpin ? (latestSpin.id || null) : null,
                                        lastCycleResolvedSpinTimestamp: latestSpin ? (latestSpin.created_at || null) : null,
                                        lastCycleResolvedTimestamp: Date.now(),
                                        entriesHistory,
                                        martingaleState
                                    });
                                    
                                    sendMessageToContent('CLEAR_ANALYSIS');
                                    sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                    return;
                                }
                                
                                // âœ… TEM GALES: Tentar prÃ³ximo
                                console.log(`ğŸ”„ Tentando G${nextGaleNumber}...`);
                                console.log(`âš™ï¸ Gales consecutivos (atÃ©): ${consecutiveGales}`);
                                
                                // âœ… ENVIAR MENSAGEM DE LOSS (vai tentar prÃ³ximo Gale)
                                await sendTelegramMartingaleLoss(
                                    currentStage,
                                    { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at }
                                );
                                
                                // âœ… USAR SEMPRE A MESMA COR DA ENTRADA ORIGINAL
                                console.log(`â•‘  martingaleState.entryColor: ${martingaleState.entryColor}                   â•‘`);
                                console.log(`â•‘  currentAnalysis.color: ${currentAnalysis.color}                        â•‘`);
                                
                                const nextGaleColor = martingaleState.entryColor;
                                
                                console.log(`ğŸ¯ COR CONFIRMADA PARA G${nextGaleNumber}: ${nextGaleColor}`);
                                
                                // âš ï¸ CRÃTICO: Registrar LOSS do Gale atual
                                const galeLossEntry = {
                                    timestamp: latestSpin.created_at,
                                    number: rollNumber,
                                    color: rollColor,
                                    phase: currentStage,
                                    result: 'LOSS',
                                    confidence: currentAnalysis.confidence,
                                    patternData: {
                                        patternDescription: currentAnalysis.patternDescription,
                                        confidence: currentAnalysis.confidence,
                                        color: currentAnalysis.color,
                                        createdOnTimestamp: currentAnalysis.createdOnTimestamp
                                    },
                                    martingaleStage: currentStage,
                                    finalResult: null,
                                    [`continuingToG${nextGaleNumber}`]: true,
                                    // âœ… IDENTIFICAR MODO DE ANÃLISE (crÃ­tico para UI filtrar corretamente no grÃ¡fico)
                                    analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard'
                                };
                                
                                entriesHistory.unshift(galeLossEntry);
                                
                                // Atualizar estado do Martingale
                                martingaleState.stage = `G${nextGaleNumber}`;
                                martingaleState.lossCount = nextGaleNumber;
                                martingaleState.lossColors.push(rollColor);
                                
                                // Verificar modo de Martingale
                                if (nextGaleNumber <= consecutiveGales) {
                                    // âœ… MODO CONSECUTIVO
                                    console.log(`ğŸ¯ MODO CONSECUTIVO: G${nextGaleNumber} serÃ¡ enviado no PRÃ“XIMO GIRO`);
                                    
                                    await sendTelegramMartingaleGale(nextGaleNumber, nextGaleColor, null);
                                    
                                    const nextGaleAnalysis = {
                                        ...currentAnalysis,
                                        color: nextGaleColor,
                                        phase: `G${nextGaleNumber}`,
                                        predictedFor: 'next',
                                        createdOnTimestamp: latestSpin.created_at
                                    };
                                    nextGaleAnalysis.confidence = calculateGaleConfidenceValue(nextGaleAnalysis.confidence, nextGaleAnalysis);
                                    
                                    await chrome.storage.local.set({
                                        analysis: nextGaleAnalysis,
                                        pattern: { description: nextGaleAnalysis.patternDescription, confidence: nextGaleAnalysis.confidence },
                                        lastBet: { status: 'pending', phase: `G${nextGaleNumber}`, createdOnTimestamp: nextGaleAnalysis.createdOnTimestamp },
                                        entriesHistory,
                                        martingaleState
                                    });
                                    
                                    emitAnalysisToContent(nextGaleAnalysis, analyzerConfig.aiMode ? 'diamond' : 'standard');
                                    sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                } else {
                                    // âŒ MODO PADRÃƒO
                                    console.log(`â³ MODO PRÃ“XIMO SINAL: Aguardando novo sinal para enviar G${nextGaleNumber}...`);
                                    
                                    await chrome.storage.local.set({
                                        analysis: null,
                                        pattern: null,
                                        lastBet: { status: 'loss', phase: currentStage, resolvedAtTimestamp: latestSpin.created_at },
                                        entriesHistory,
                                        martingaleState
                                    });
                                    
                                    sendMessageToContent('CLEAR_ANALYSIS');
                                    sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                }
                                
                            } else if (false) {
                                // BLOCO ANTIGO DESATIVADO - MANTIDO PARA REFERÃŠNCIA
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // âœ… LOSS NO G1: Verificar modo de Martingale
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                console.log(`âš™ï¸ Gales consecutivos (atÃ©): ${consecutiveGales}`);
                                
                                // âœ… USAR SEMPRE A MESMA COR DA ENTRADA ORIGINAL
                                const g2Color = martingaleState.entryColor;
                                
                                // âš ï¸ CRÃTICO: Registrar LOSS do G1 antes de tentar G2
                                const g1LossEntry = {
                                    timestamp: latestSpin.created_at,
                                    number: rollNumber,
                                    color: rollColor,
                                    phase: 'G1',
                                    result: 'LOSS',
                                    confidence: currentAnalysis.confidence,
                                    patternData: {
                                        patternDescription: currentAnalysis.patternDescription,
                                        confidence: currentAnalysis.confidence,
                                        color: currentAnalysis.color,
                                        createdOnTimestamp: currentAnalysis.createdOnTimestamp
                                    },
                                    martingaleStage: 'G1',
                                    finalResult: null,  // Ainda nÃ£o Ã© final, vai tentar G2
                                    continuingToG2: true,  // Flag indicando que continuarÃ¡
                                    // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                    analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard'
                                };
                                
                                entriesHistory.unshift(g1LossEntry);
                                
                                // Atualizar estado do Martingale
                                martingaleState.stage = 'G2';
                                martingaleState.lossCount = 2;
                                martingaleState.lossColors.push(rollColor);  // âœ… Adicionar cor do G1 que perdeu
                                
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // VERIFICAR MODO DE MARTINGALE
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                
                                if (consecutiveMartingale) {
                                    // âœ… MODO CONSECUTIVO: Enviar G2 IMEDIATAMENTE no prÃ³ximo giro
                                    console.log('ğŸ¯ MODO CONSECUTIVO: G2 serÃ¡ enviado no PRÃ“XIMO GIRO');
                                    
                                    await sendTelegramMartingaleG2(g2Color, null);
                                    
                                    // Criar anÃ¡lise G2 com timestamp do prÃ³ximo giro
                                    const g2Analysis = {
                                        ...currentAnalysis,
                                        color: g2Color,
                                        phase: 'G2',
                                        predictedFor: 'next',
                                        createdOnTimestamp: latestSpin.created_at  // âœ… Usar giro atual
                                    };
                                    g2Analysis.confidence = calculateGaleConfidenceValue(g2Analysis.confidence, g2Analysis);
                                    
                                    await chrome.storage.local.set({
                                        analysis: g2Analysis,
                                        pattern: { description: g2Analysis.patternDescription, confidence: g2Analysis.confidence },
                                        lastBet: { status: 'pending', phase: 'G2', createdOnTimestamp: g2Analysis.createdOnTimestamp },
                                        entriesHistory,
                                        martingaleState
                                    });
                                    
                                    emitAnalysisToContent(g2Analysis, analyzerConfig.aiMode ? 'diamond' : 'standard');
                                } else {
                                    // âŒ MODO PADRÃƒO: Aguardar novo padrÃ£o para enviar G2
                                    console.log('â³ MODO PADRÃƒO: Aguardando novo padrÃ£o para enviar G2...');
                                    
                                    await chrome.storage.local.set({
                                        analysis: null,
                                        pattern: null,
                                        lastBet: { status: 'loss', phase: 'G1', resolvedAtTimestamp: latestSpin.created_at },
                                        entriesHistory,
                                        martingaleState
                                    });
                                    
                                    sendMessageToContent('CLEAR_ANALYSIS');
                                    sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                }
                                
                            } else if (currentStage === 'G2') {
                                // âŒ LOSS NO G2: RET (Loss Final)
                                console.log('â›” LOSS no G2 - RET');
                                
                                // âœ… Fix financeiro: usar config do ciclo (congelada) e calcular net do RET
                                const cycleAutoBetCfg = ensureMartingaleCycleConfig(snapshotAutoBetConfig(analyzerConfig));
                                const betColor = (martingaleState && martingaleState.entryColor) ? martingaleState.entryColor : currentAnalysis.color;
                                const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                                const stakeAmount = calcStakeForStage('G2', cycleAutoBetCfg);
                                const cycleId = (martingaleState && martingaleState.entryTimestamp)
                                    ? martingaleState.entryTimestamp
                                    : (currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now());
                                const cycleTotalInvested = calcTotalInvestedThroughStage('G2', cycleAutoBetCfg);
                                const cycleNetProfit = roundMoney(-cycleTotalInvested);
                                
                                const retEntry = {
                                    timestamp: latestSpin.created_at,
                                    number: rollNumber,
                                    color: rollColor,
                                    phase: 'G2',
                                    result: 'LOSS',
                                    confidence: currentAnalysis.confidence,
                                    patternData: {
                                        patternDescription: currentAnalysis.patternDescription,
                                        confidence: currentAnalysis.confidence,
                                        color: currentAnalysis.color,
                                        createdOnTimestamp: currentAnalysis.createdOnTimestamp
                                    },
                                    martingaleStage: 'G2',
                                    finalResult: 'RET',
                                    // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                    analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard',
                                    // âœ… FINANCEIRO (fixo no tempo)
                                    cycleId,
                                    betColor,
                                    stakeAmount,
                                    baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                    galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                    payoutMultiplier,
                                    cycleTotalInvested,
                                    cycleNetProfit
                                };
                                
                                entriesHistory.unshift(retEntry);
                                
                                // âœ… Calcular estatÃ­sticas WIN/LOSS FILTRADAS POR MODO
                                const currentMode = analyzerConfig.aiMode ? 'diamond' : 'standard';
                                const { wins: filteredWins, losses: filteredLosses } = calculateFilteredScore(entriesHistory, currentMode);
                                
                                console.log(`ğŸ“Š Placar total: ${calculateCycleScore(entriesHistory).totalWins} wins / ${calculateCycleScore(entriesHistory).totalLosses} losses`);
                                console.log(`ğŸ“Š Placar ${currentMode}: ${filteredWins} wins / ${filteredLosses} losses`);
                                
                                await sendTelegramMartingaleRET(filteredWins, filteredLosses, currentMode);
                                
                                // âœ… ATUALIZAR HISTÃ“RICO DE CORES QUENTES
                                console.log('ğŸ“Š Atualizando histÃ³rico de cores quentes apÃ³s RET...');
                                
                                // Construir sequÃªncia de cores DOS GIROS (nÃ£o das apostas!)
                                const colorSequence = [];
                                
                                // Adicionar cores dos LOSSes (giros que realmente saÃ­ram)
                                martingaleState.lossColors.forEach(color => {
                                    colorSequence.push({ color });
                                });
                                
                                // Adicionar cor do G2 que perdeu (giro atual)
                                colorSequence.push({ color: rollColor });
                                
                                console.log('   SequÃªncia de cores dos giros:', colorSequence.map(c => c.color).join(' â†’ '));
                                
                                await updateHotColorsHistory(patternKey, colorSequence);
                                
                                resetMartingaleState();
                                
                                    await chrome.storage.local.set({ 
                                        analysis: null, 
                                        pattern: null, 
                                    lastBet: { status: 'loss', phase: 'G2', resolvedAtTimestamp: latestSpin.created_at },
                                        // âœ… Intervalo apÃ³s entrada (Diamante): contar a partir do FIM DO CICLO (RET)
                                        lastCycleResolvedSpinId: latestSpin ? (latestSpin.id || null) : null,
                                        lastCycleResolvedSpinTimestamp: latestSpin ? (latestSpin.created_at || null) : null,
                                        lastCycleResolvedTimestamp: Date.now(),
                                        entriesHistory,
                                    martingaleState
                                    });
                                
                                    sendMessageToContent('CLEAR_ANALYSIS');
                                    sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                            }
                        }
                    }
                } else {
                    console.log('âš ï¸ NÃƒO hÃ¡ recomendaÃ§Ã£o pendente para avaliar');
                    if (!currentAnalysis) {
                        console.log('   Motivo: currentAnalysis nÃ£o existe');
                    } else if (!currentAnalysis.createdOnTimestamp) {
                        console.log('   Motivo: createdOnTimestamp ausente');
                    } else if (currentAnalysis.predictedFor !== 'next') {
                        console.log('   Motivo: predictedFor =', currentAnalysis.predictedFor, '(esperado: "next")');
                    }
                }
                
                // Notificar content script sobre novo giro (SEMPRE usar cachedHistory - array vÃ¡lido!)
                // âœ… NÃƒO enviar history a cada giro (evita sobrescrever buffer de 10k no content.js e reduz payload)
                sendMessageToContent('NEW_SPIN', { 
                    lastSpin: { number: rollNumber, color: rollColor, timestamp: latestSpin.created_at } 
                });
                
                // âœ… EXECUTAR NOVA ANÃLISE (apÃ³s processar WIN/LOSS)
            console.log('%câ•‘                                                                               â•‘', 'color: #FFD700; font-weight: bold; font-size: 16px; background: #333300; padding: 5px;');
            console.log('%câ•‘                                                                               â•‘', 'color: #FFD700; font-weight: bold; font-size: 16px; background: #333300; padding: 5px;');
            console.log('%câ•‘       ğŸ“Š Giros no histÃ³rico:', 'color: #FFD700; font-weight: bold; background: #333300; padding: 5px;', cachedHistory ? cachedHistory.length : 0);
            console.log('%câ•‘       ğŸ¤– Modo IA ativo:', 'color: #FFD700; font-weight: bold; background: #333300; padding: 5px;', analyzerConfig.aiMode);
            console.log('%câ•‘                                                                               â•‘', 'color: #FFD700; font-weight: bold; font-size: 16px; background: #333300; padding: 5px;');
            
            const executed = await runAnalysisIfEnabled(cachedHistory, 'NEW_SPIN');
            if (!executed) {
                return;
            }
            
            console.log('%câœ… runAnalysisController() FINALIZADO!', 'color: #00FF88; font-weight: bold; font-size: 16px; background: #003300; padding: 5px;');
        }
    } catch (error) {
        console.error('Erro ao processar giro do servidor:', error);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… FUNÃ‡ÃƒO PARA CALCULAR PLACAR BASEADO EM CICLOS COMPLETOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calculateCycleScore(entriesHistory) {
    console.log('ğŸ“Š Calculando placar baseado em CICLOS...');
    
    let totalWins = 0;
    let totalLosses = 0;
    
    // Contar apenas entradas com finalResult definido (ciclos completos)
    for (const entry of entriesHistory) {
        if (entry.finalResult === 'WIN') {
            totalWins++;
            console.log(`  âœ… WIN (${entry.martingaleStage || entry.phase})`);
        } else if (entry.finalResult === 'RET') {
            totalLosses++;
            console.log(`  âŒ LOSS (${entry.martingaleStage || entry.phase} - NÃ£o pagou)`);
        }
    }
    
    console.log(`ğŸ“Š Placar final: WIN: ${totalWins} | LOSS: ${totalLosses}`);
    return { totalWins, totalLosses };
}

// FunÃ§Ã£o auxiliar para processar giro vindo direto da Blaze (fallback)
function processNewSpin(spinData) {
    return processNewSpinFromServer(spinData);
}

// Tenta carregar os Ãºltimos 2000 giros de uma vez do SERVIDOR e popular cache em memÃ³ria
async function initializeHistoryIfNeeded() {
    if (historyInitialized) return; // jÃ¡ inicializado nesta sessÃ£o

    try {
        // Buscar giros do SERVIDOR primeiro
        console.log('ğŸ“¥ Buscando histÃ³rico inicial do servidor para cache em memÃ³ria...');
        const serverGiros = await fetchGirosFromAPI();
        
        if (serverGiros && serverGiros.length > 0) {
            console.log(`âœ… ${serverGiros.length} giros recebidos do servidor!`);
            // âœ… Popular CACHE EM MEMÃ“RIA (nÃ£o salvar em chrome.storage.local)
            cachedHistory = [...serverGiros].slice(0, 2000);
            historyInitialized = true;
            console.log(`ğŸ“Š Cache em memÃ³ria inicializado: ${cachedHistory.length} giros`);
            
            // âœ… INICIALIZAR MEMÃ“RIA ATIVA SE MODO IA ESTIVER ATIVO
            if (analyzerConfig.aiMode && !memoriaAtiva.inicializada && cachedHistory.length >= 60) {
                console.log('%cğŸ§  MODO IA ATIVO - Inicializando MemÃ³ria Ativa automaticamente...', 'color: #00CED1; font-weight: bold;');
                const sucesso = await inicializarMemoriaAtiva(cachedHistory);
                if (sucesso) {
                    console.log('%câœ… MemÃ³ria Ativa inicializada com sucesso!', 'color: #00FF88; font-weight: bold;');
                } else {
                    console.log('%câš ï¸ Falha ao inicializar MemÃ³ria Ativa', 'color: #FFAA00; font-weight: bold;');
                }
            }
            
            // âœ… ENVIAR ÃšLTIMO GIRO E HISTÃ“RICO PARA A UI
            const lastSpin = serverGiros[0]; // O mais recente estÃ¡ na posiÃ§Ã£o 0
            if (lastSpin) {
                console.log('ğŸ“¤ Enviando Ãºltimo giro para UI:', lastSpin);
                await chrome.storage.local.set({ lastSpin: lastSpin });
                // âœ… NÃƒO enviar history aqui (ver comentÃ¡rio em syncInitialData)
                sendMessageToContent('NEW_SPIN', { lastSpin: lastSpin });
                console.log('%câœ… UI atualizada com histÃ³rico do servidor (initializeHistoryIfNeeded)', 'color: #00ff00; font-weight: bold;');
            }
            return;
        }
        
        // Se servidor nÃ£o tiver dados, buscar direto da Blaze (fallback)
        console.log('âš ï¸ Servidor sem dados, buscando direto da Blaze...');
        const endpoints = [
            'https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/2000',
            'https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/300',
            'https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/100'
        ];
        let combined = [];
        for (const url of endpoints) {
            try {
                const r = await fetch(url);
                if (!r.ok) continue;
                const json = await r.json();
                const arr = Array.isArray(json) ? json : (json?.data || json?.records || json?.items || []);
                if (Array.isArray(arr)) combined = combined.concat(arr);
            } catch(_) { /* tenta prÃ³ximo */ }
        }
        // Remover duplicados por created_at
        const uniqMap = new Map();
        combined.forEach(spin => {
            if (spin && spin.created_at) uniqMap.set(spin.created_at, spin);
        });
        const dataArr = Array.from(uniqMap.values());
        if (Array.isArray(dataArr) && dataArr.length > 0) {
            const sorted = [...dataArr].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            const mapped = sorted.slice(0, 800).map(spin => ({
                id: `spin_${spin.created_at}`,
                number: spin.roll,
                color: getColorFromNumber(spin.roll),
                timestamp: spin.created_at,
                created_at: spin.created_at
            }));
            const last = mapped[0];
            
            // âœ… Popular CACHE EM MEMÃ“RIA (nÃ£o salvar em chrome.storage.local)
            cachedHistory = mapped;
            historyInitialized = true;
            
            await chrome.storage.local.set({ lastSpin: last });
            sendMessageToContent('NEW_SPIN', { lastSpin: last });
            console.log(`ğŸ“Š Cache em memÃ³ria inicializado (fallback Blaze): ${mapped.length} giros`);
        } else {
            cachedHistory = [];
            historyInitialized = true;
            console.log('âš ï¸ Nenhum giro disponÃ­vel - cache em memÃ³ria vazio');
        }
    } catch (err) {
        console.warn('NÃ£o foi possÃ­vel carregar giros iniciais. Mantendo coleta incremental.', err);
        cachedHistory = [];
        historyInitialized = true;
    }
}

// Analyze patterns in the data - ONLY triggered when new spin detected
async function analyzePatterns(history) {
    console.log('ğŸ” Iniciando anÃ¡lise de padrÃµes...');
    
    // REGRA: MÃ­nimo de 50 giros para comeÃ§ar anÃ¡lises
    if (history.length < 50) {
        console.log('âš ï¸ HistÃ³rico insuficiente para anÃ¡lise:', history.length, '/ 50 giros necessÃ¡rios');
        sendAnalysisStatus(`Coletando dados... ${history.length}/50 giros`);
        return; // Precisa de pelo menos 50 giros para anÃ¡lises confiÃ¡veis
    }
    
    // REGRA: Verificar se nÃ£o estÃ¡ usando o mesmo padrÃ£o da Ãºltima entrada
    const entriesResult = await chrome.storage.local.get(['entriesHistory']);
    const entriesHistory = entriesResult.entriesHistory || [];
    
    if (entriesHistory.length > 0) {
        const lastEntry = entriesHistory[0];
        
        // Verificar se a Ãºltima entrada tem dados de padrÃ£o
        if (lastEntry.patternData && lastEntry.patternData.patternDescription) {
            try {
                // âš ï¸ CRÃTICO: Se for anÃ¡lise IA, patternDescription Ã© texto, nÃ£o JSON
                if (lastEntry.patternData.patternDescription.includes('ğŸ¤– ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL')) {
                    console.log('ğŸ” Ãšltimo padrÃ£o usado: AnÃ¡lise AvanÃ§ada (IA)');
                } else {
                    const lastPatternData = JSON.parse(lastEntry.patternData.patternDescription);
                    console.log('ğŸ” Ãšltimo padrÃ£o usado:', lastPatternData);
                }
                
                // Esta verificaÃ§Ã£o serÃ¡ feita apÃ³s a anÃ¡lise para comparar padrÃµes
                // Por enquanto, continuamos com a anÃ¡lise
            } catch (e) {
                console.log('âš ï¸ Erro ao analisar Ãºltimo padrÃ£o:', e);
            }
        }
    }
    
    try {
        console.log('ğŸš€ Executando anÃ¡lise multidimensional...', '| Rigor:', rigorLogString());
        const analysis = await performPatternAnalysis(history);
        
        if (analysis) {
            // REGRA: Verificar se nÃ£o Ã© o mesmo padrÃ£o da Ãºltima entrada
            let isDuplicatePattern = false;
            
            if (entriesHistory.length > 0) {
                const lastEntry = entriesHistory[0];
                
                if (lastEntry.patternData && lastEntry.patternData.patternDescription) {
                    try {
                        // âš ï¸ CRÃTICO: Se for anÃ¡lise IA, patternDescription Ã© texto, nÃ£o JSON
                        const isLastAI = lastEntry.patternData.patternDescription.includes('ğŸ¤– ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL');
                        const isCurrentAI = analysis.patternDescription.includes('ğŸ¤– ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL');
                        
                        // Se qualquer um for IA, sempre considerar como padrÃ£o diferente
                        if (isLastAI || isCurrentAI) {
                            console.log('âœ… AnÃ¡lise aceita (IA sempre permite novos sinais)');
                            isDuplicatePattern = false;
                        } else {
                            // Ambos sÃ£o anÃ¡lise padrÃ£o, comparar como JSON
                            const lastPatternData = JSON.parse(lastEntry.patternData.patternDescription);
                            const currentPatternData = JSON.parse(analysis.patternDescription);
                            
                            // Comparar caracterÃ­sticas dos padrÃµes
                            isDuplicatePattern = comparePatterns(lastPatternData, currentPatternData);
                            
                            if (isDuplicatePattern) {
                                console.log('âŒ AnÃ¡lise rejeitada: mesmo padrÃ£o da Ãºltima entrada');
                                sendAnalysisStatus('â³ Aguardando padrÃ£o diferente...');
                                return;
                            } else {
                                console.log('âœ… PadrÃ£o diferente detectado, anÃ¡lise aceita');
                            }
                        }
                    } catch (e) {
                        console.log('âš ï¸ Erro ao comparar padrÃµes:', e);
                    }
                }
            }
            
            console.log('âœ… AnÃ¡lise concluÃ­da com sucesso!');
            await chrome.storage.local.set({
                analysis: analysis,
                pattern: {
                    description: analysis.patternDescription,
                    confidence: analysis.confidence
                },
                lastBet: { status: 'pending', phase: analysis.phase || 'G0', createdOnTimestamp: analysis.createdOnTimestamp }
            });
            
            emitAnalysisToContent(analysis, 'standard');
            } else {
            console.log('âŒ Nenhum padrÃ£o vÃ¡lido encontrado na anÃ¡lise');
            // Limpar anÃ¡lise primeiro
            await chrome.storage.local.set({ analysis: null, pattern: null });
            sendMessageToContent('CLEAR_ANALYSIS');
            // Enviar status de aguardando novo giro APÃ“S limpar a anÃ¡lise
            sendAnalysisStatus('â³ Aguardando novo giro...');
        }
    } catch (error) {
        console.error('Erro na anÃ¡lise de padrÃµes:', error);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– SISTEMA DE ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL (IA)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * VARREDURA 1: AnÃ¡lise Macro - Contexto Geral
 * Analisa 2000, 500 e 240 giros para entender:
 * - PadrÃµes gerais da Blaze
 * - ResistÃªncias e quebras
 * - Aleatoriedade
 */
function analyzeMacroContext(history) {
    console.log('ğŸ” VARREDURA 1: AnÃ¡lise Macro (Contexto Geral)');
    
    const results = {
        full: analyzeWindow(history.slice(0, 2000), '2000 giros'),
        recent: analyzeWindow(history.slice(0, 500), '500 giros'),
        immediate: analyzeWindow(history.slice(0, 240), '240 giros')
    };
    
    console.log('âœ… Varredura 1 completa:', results);
    return results;
}

/**
 * AnÃ¡lise de uma janela de giros
 */
function analyzeWindow(window, label) {
    if (!window || window.length === 0) return null;
    
    const colors = window.map(g => g.color);
    const red = colors.filter(c => c === 'red').length;
    const black = colors.filter(c => c === 'black').length;
    const white = colors.filter(c => c === 'white').length;
    
    const total = colors.length;
    const redPct = (red / total) * 100;
    const blackPct = (black / total) * 100;
    const whitePct = (white / total) * 100;
    
    // Detectar resistÃªncias (cor que aparece muito)
    let resistance = null;
    if (redPct > 55) resistance = 'red';
    else if (blackPct > 55) resistance = 'black';
    
    // Detectar quebra de resistÃªncia (mudanÃ§a brusca)
    const last20 = colors.slice(0, 20);
    const last20Red = last20.filter(c => c === 'red').length;
    const last20Black = last20.filter(c => c === 'black').length;
    
    let breakResistance = null;
    if (resistance === 'red' && last20Black > last20Red) breakResistance = 'black';
    else if (resistance === 'black' && last20Red > last20Black) breakResistance = 'red';
    
    // Medir aleatoriedade (quanto mais prÃ³ximo de 50/50, mais aleatÃ³rio)
    const randomness = 100 - Math.abs(redPct - blackPct);
    
    return {
        label,
        total,
        distribution: { red: redPct.toFixed(1), black: blackPct.toFixed(1), white: whitePct.toFixed(1) },
        resistance,
        breakResistance,
        randomness: randomness.toFixed(1)
    };
}

/**
 * VARREDURA 2: AnÃ¡lise Micro - Janelas de 20 giros
 * Divide os Ãºltimos 240 giros em janelas de 20
 * Identifica qual cor tende a sair apÃ³s cada padrÃ£o
 */
function analyzeMicroWindows(history) {
    console.log('ğŸ” VARREDURA 2: AnÃ¡lise Micro (Janelas de 20 giros)');
    
    const last240 = history.slice(0, 240);
    if (last240.length < 240) {
        console.warn('âš ï¸ HistÃ³rico insuficiente para anÃ¡lise micro (precisa 240 giros)');
        return null;
    }
    
    const windows = [];
    const windowSize = 20;
    const numWindows = Math.floor(last240.length / windowSize);
    
    // Dividir em janelas de 20 giros
    for (let i = 0; i < numWindows; i++) {
        const start = i * windowSize;
        const end = start + windowSize;
        const windowGiros = last240.slice(start, end);
        
        // Analisar janela
        const colors = windowGiros.map(g => g.color);
        const pattern = colors.join('-');
        
        // Verificar qual cor veio DEPOIS dessa janela
        const nextGiro = last240[end];
        const nextColor = nextGiro ? nextGiro.color : null;
        
        windows.push({
            index: i + 1,
            giros: `${start + 1}-${end}`,
            pattern,
            colors: {
                red: colors.filter(c => c === 'red').length,
                black: colors.filter(c => c === 'black').length,
                white: colors.filter(c => c === 'white').length
            },
            nextColor
        });
    }
    
    console.log(`âœ… Varredura 2 completa: ${windows.length} janelas analisadas`);
    return windows;
}

/**
 * Combinar resultados das 2 varreduras + padrÃµes salvos
 * Retorna a cor recomendada e confianÃ§a
 */
async function combineAIResults(macroResults, microWindows, savedPatterns) {
    console.log('ğŸ§® Combinando resultados das anÃ¡lises...');
    
    const scores = { red: 0, black: 0, white: 0 };
    
    // 1. PESO DA VARREDURA 1 (Contexto Macro) - 30%
    if (macroResults) {
        const weight = 0.30;
        
        // Quebra de resistÃªncia tem prioridade
        if (macroResults.immediate?.breakResistance) {
            scores[macroResults.immediate.breakResistance] += 30 * weight;
            console.log(`  âœ… Quebra de resistÃªncia detectada: ${macroResults.immediate.breakResistance} (+${30 * weight})`);
        }
        
        // ResistÃªncia tambÃ©m influencia (favor da resistÃªncia)
        if (macroResults.recent?.resistance) {
            scores[macroResults.recent.resistance] += 15 * weight;
        }
    }
    
    // 2. PESO DA VARREDURA 2 (Janelas de 20) - 50% (MAIOR PESO)
    if (microWindows && microWindows.length > 0) {
        const weight = 0.50;
        
        // Analisar Ãºltimos 20 giros (janela mais recente)
        const lastWindow = microWindows[0];
        
        // Contar qual cor apareceu DEPOIS de janelas similares
        const colorAfterPatterns = {};
        microWindows.forEach(w => {
            if (w.nextColor) {
                colorAfterPatterns[w.nextColor] = (colorAfterPatterns[w.nextColor] || 0) + 1;
            }
        });
        
        // Dar pontos baseado na frequÃªncia
        const total = Object.values(colorAfterPatterns).reduce((a, b) => a + b, 0);
        Object.keys(colorAfterPatterns).forEach(color => {
            const frequency = (colorAfterPatterns[color] / total) * 100;
            scores[color] += frequency * weight;
            console.log(`  âœ… Janelas de 20: ${color} aparece ${frequency.toFixed(1)}% (+${(frequency * weight).toFixed(1)})`);
        });
    }
    
    // 3. PESO DOS PADRÃ•ES SALVOS - 20%
    if (savedPatterns && savedPatterns.length > 0) {
        const weight = 0.20;
        
        // Pegar padrÃ£o com maior confianÃ§a
        const bestPattern = savedPatterns.reduce((best, p) => 
            p.confidence > (best?.confidence || 0) ? p : best
        , null);
        
        if (bestPattern) {
            scores[bestPattern.color] += bestPattern.confidence * weight;
            console.log(`  âœ… Melhor padrÃ£o salvo: ${bestPattern.color} (${bestPattern.confidence}%) (+${(bestPattern.confidence * weight).toFixed(1)})`);
        }
    }
    
    // Encontrar cor com maior score
    const bestColor = Object.keys(scores).reduce((a, b) => scores[a] > scores[b] ? a : b);
    const confidence = Math.min(95, Math.max(45, scores[bestColor]));
    
    console.log('ğŸ“Š Scores finais:', scores);
    console.log(`ğŸ¯ RecomendaÃ§Ã£o IA: ${bestColor} (${confidence.toFixed(1)}%)`);
    
    // âœ… VALIDAR CONFIANÃ‡A MÃNIMA (configurada pelo usuÃ¡rio) - MODO IA
    const minConfidence = analyzerConfig.minPercentage || 60; // Porcentagem mÃ­nima configurada para o modo IA
    if (confidence < minConfidence) {
        console.log(`âš ï¸ ConfianÃ§a ${confidence.toFixed(1)}% estÃ¡ abaixo do mÃ­nimo configurado (${minConfidence}%)`);
        console.log('âŒ AnÃ¡lise IA rejeitada por nÃ£o atingir confianÃ§a mÃ­nima');
        return null; // NÃ£o retorna anÃ¡lise
    }
    console.log(`âœ… ConfianÃ§a ${confidence.toFixed(1)}% atende ao mÃ­nimo (${minConfidence}%)`);
    
    // âœ… CRIAR RESUMOS DETALHADOS PARA O USUÃRIO
    let macroSummary = '';
    if (macroResults) {
        const parts = [];
        if (macroResults.immediate?.breakResistance) {
            parts.push(`âœ… Quebra de resistÃªncia detectada em ${macroResults.immediate.breakResistance}`);
        }
        if (macroResults.recent?.resistance) {
            parts.push(`ğŸ“Š ResistÃªncia atual: ${macroResults.recent.resistance}`);
        }
        if (macroResults.immediate?.randomness) {
            const randomPct = parseFloat(macroResults.immediate.randomness);
            if (randomPct > 90) parts.push('âš ï¸ Alto grau de aleatoriedade detectado');
            else if (randomPct < 70) parts.push('âœ… PadrÃµes consistentes identificados');
        }
        macroSummary = parts.length > 0 ? parts.join('\n   ') : 'âœ… AnÃ¡lise de tendÃªncias concluÃ­da';
    }
    
    let microSummary = '';
    if (microWindows && microWindows.length > 0) {
        const colorCounts = {};
        microWindows.forEach(w => {
            if (w.nextColor) {
                colorCounts[w.nextColor] = (colorCounts[w.nextColor] || 0) + 1;
            }
        });
        const topColor = Object.keys(colorCounts).reduce((a, b) => colorCounts[a] > colorCounts[b] ? a : b, null);
        if (topColor) {
            const freq = ((colorCounts[topColor] / microWindows.length) * 100).toFixed(0);
            microSummary = `âœ… ${topColor} aparece em ${freq}% dos padrÃµes similares`;
        } else {
            microSummary = 'âœ… PadrÃµes recentes mapeados';
        }
    }
    
    let patternSummary = 'âœ… Base de dados consultada';
    if (savedPatterns && savedPatterns.length > 0) {
        const bestPattern = savedPatterns.reduce((best, p) => 
            p.confidence > (best?.confidence || 0) ? p : best
        , null);
        if (bestPattern) {
            patternSummary = `âœ… Melhor padrÃ£o: ${bestPattern.color} (${bestPattern.confidence}% confianÃ§a)`;
        }
    } else {
        patternSummary = 'âš ï¸ Nenhum padrÃ£o salvo encontrado';
    }
    
    // Criar raciocÃ­nio baseado na pontuaÃ§Ã£o
    let reasoning = '';
    const diff = scores[bestColor] - Math.max(...Object.keys(scores).filter(c => c !== bestColor).map(c => scores[c]));
    if (diff > 20) {
        reasoning = `âœ… IA identificou forte tendÃªncia para ${bestColor} com ${diff.toFixed(1)} pontos de vantagem sobre outras cores.`;
    } else if (diff > 10) {
        reasoning = `âœ… IA recomenda ${bestColor} com vantagem moderada de ${diff.toFixed(1)} pontos.`;
    } else {
        reasoning = `âš ï¸ IA recomenda ${bestColor} com pequena vantagem de ${diff.toFixed(1)} pontos. Entrada de risco moderado.`;
    }
    
    return {
        color: bestColor,
        confidence: parseFloat(confidence.toFixed(1)),
        scores,
        macroSummary,
        microSummary,
        patternSummary,
        reasoning
    };
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ” DETECTOR DE PADRÃ•ES NO HISTÃ“RICO (ANÃLISE ESTATÃSTICA REAL)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Esta funÃ§Ã£o analisa TODO o histÃ³rico e detecta padrÃµes especÃ­ficos:
 * - AlternÃ¢ncia simples (P-V-P-V)
 * - AlternÃ¢ncia dupla (P-P-V-V)
 * - AlternÃ¢ncia tripla (P-P-P-V-V-V)
 * - SequÃªncias longas (6+ mesma cor)
 * 
 * Para cada padrÃ£o, conta O QUE VEIO DEPOIS (estatÃ­stica REAL)
 */
function detectPatternsInHistory(history) {
    console.log('%câ•‘  ğŸ” DETECTANDO PADRÃ•ES NO HISTÃ“RICO                      â•‘', 'color: #00BFFF; font-weight: bold;');
    console.log('%c   HistÃ³rico recebido: ' + history.length + ' giros', 'color: #00BFFF;');
    
    // âœ… VALIDAÃ‡ÃƒO: Verificar se histÃ³rico Ã© vÃ¡lido
    if (!history || !Array.isArray(history) || history.length === 0) {
        console.warn('%câš ï¸ HistÃ³rico invÃ¡lido ou vazio!', 'color: #FFAA00; font-weight: bold;');
        return [];
    }
    
    const patterns = {
        // AlternÃ¢ncia simples: P-V-P-V-P-V
        alternanciaSimples: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // AlternÃ¢ncia dupla: P-P-V-V-P-P-V-V
        alternanciaDupla: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // AlternÃ¢ncia tripla: P-P-P-V-V-V-P-P-P
        alternanciaTripla: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // SequÃªncia longa de vermelhos (6+)
        sequenciaVermelho6Plus: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // SequÃªncia longa de pretos (6+)
        sequenciaPreto6Plus: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // SequÃªncia longa de mesma cor (4-5)
        sequenciaMesmaCor4a5: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 }
    };
    
    // Simplificar cores (ignorar white temporariamente para padrÃµes)
    const simplifiedHistory = history.map(spin => {
        if (spin.color === 'white') return 'W';
        return spin.color === 'red' ? 'R' : 'B';
    });
    
    // Analisar histÃ³rico (deixar espaÃ§o para o "prÃ³ximo giro")
    for (let i = 0; i < history.length - 1; i++) {
        const next = history[i]; // O giro que VEIO DEPOIS do padrÃ£o
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALTERNÃ‚NCIA SIMPLES: R-B-R-B-R-B (mÃ­nimo 6 giros)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 6 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 7).join('');
            
            // PadrÃ£o: R-B-R-B-R-B ou B-R-B-R-B-R
            if (seq === 'RBRBRB' || seq === 'BRBRBR') {
                // ğŸ”¥ VALIDAR COR DE DISPARO: Cor antes do padrÃ£o DEVE ser diferente da primeira cor
                const colorBefore = simplifiedHistory[i + 7]; // Cor imediatamente antes do padrÃ£o
                const firstPatternColor = seq[0]; // Primeira cor do padrÃ£o (R ou B)
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = normalizeColorName(firstPatternColor === 'R' ? 'red' : 'black');
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) {
                        continue; // Sem trigger vÃ¡lida
                    }
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.alternanciaSimples.count++;
                if (next.color === 'red') patterns.alternanciaSimples.afterRed++;
                else if (next.color === 'black') patterns.alternanciaSimples.afterBlack++;
                else patterns.alternanciaSimples.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALTERNÃ‚NCIA DUPLA: R-R-B-B-R-R-B-B (mÃ­nimo 8 giros)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 8 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 9).join('');
            
            // PadrÃ£o: R-R-B-B-R-R-B-B ou B-B-R-R-B-B-R-R
            if (seq === 'RRBBRRBB' || seq === 'BBRRBBRR') {
                // ğŸ”¥ VALIDAR COR DE DISPARO
                const colorBefore = simplifiedHistory[i + 9];
                const firstPatternColor = seq[0];
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = normalizeColorName(firstPatternColor === 'R' ? 'red' : 'black');
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.alternanciaDupla.count++;
                if (next.color === 'red') patterns.alternanciaDupla.afterRed++;
                else if (next.color === 'black') patterns.alternanciaDupla.afterBlack++;
                else patterns.alternanciaDupla.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALTERNÃ‚NCIA TRIPLA: R-R-R-B-B-B-R-R-R (mÃ­nimo 9 giros)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 9 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 10).join('');
            
            // PadrÃ£o: R-R-R-B-B-B-R-R-R ou B-B-B-R-R-R-B-B-B
            if (seq === 'RRRBBBRRR' || seq === 'BBBRRRBBB') {
                // ğŸ”¥ VALIDAR COR DE DISPARO
                const colorBefore = simplifiedHistory[i + 10];
                const firstPatternColor = seq[0];
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = normalizeColorName(firstPatternColor === 'R' ? 'red' : 'black');
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.alternanciaTripla.count++;
                if (next.color === 'red') patterns.alternanciaTripla.afterRed++;
                else if (next.color === 'black') patterns.alternanciaTripla.afterBlack++;
                else patterns.alternanciaTripla.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SEQUÃŠNCIA DE VERMELHO 6+ (ignorando brancos)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 6 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 7).filter(c => c !== 'W').join('');
            
            if (seq === 'RRRRRR') {
                // ğŸ”¥ VALIDAR COR DE DISPARO (ignorando brancos)
                let colorBeforeIndex = i + 7;
                let colorBefore = simplifiedHistory[colorBeforeIndex];
                // Pular brancos para encontrar a cor de disparo real
                while (colorBefore === 'W' && colorBeforeIndex < simplifiedHistory.length) {
                    colorBeforeIndex++;
                    colorBefore = simplifiedHistory[colorBeforeIndex];
                }
                const firstPatternColor = 'R'; // Sempre vermelho neste padrÃ£o
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = 'red';
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.sequenciaVermelho6Plus.count++;
                if (next.color === 'red') patterns.sequenciaVermelho6Plus.afterRed++;
                else if (next.color === 'black') patterns.sequenciaVermelho6Plus.afterBlack++;
                else patterns.sequenciaVermelho6Plus.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SEQUÃŠNCIA DE PRETO 6+ (ignorando brancos)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 6 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 7).filter(c => c !== 'W').join('');
            
            if (seq === 'BBBBBB') {
                // ğŸ”¥ VALIDAR COR DE DISPARO (ignorando brancos)
                let colorBeforeIndex = i + 7;
                let colorBefore = simplifiedHistory[colorBeforeIndex];
                // Pular brancos para encontrar a cor de disparo real
                while (colorBefore === 'W' && colorBeforeIndex < simplifiedHistory.length) {
                    colorBeforeIndex++;
                    colorBefore = simplifiedHistory[colorBeforeIndex];
                }
                const firstPatternColor = 'B'; // Sempre preto neste padrÃ£o
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = 'black';
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.sequenciaPreto6Plus.count++;
                if (next.color === 'red') patterns.sequenciaPreto6Plus.afterRed++;
                else if (next.color === 'black') patterns.sequenciaPreto6Plus.afterBlack++;
                else patterns.sequenciaPreto6Plus.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SEQUÃŠNCIA MESMA COR 4-5 (mais comum, mais dados)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 5 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 6).filter(c => c !== 'W').join('');
            
            if (seq === 'RRRRR' || seq === 'BBBBB' || seq === 'RRRR' || seq === 'BBBB') {
                // ğŸ”¥ VALIDAR COR DE DISPARO (ignorando brancos)
                let colorBeforeIndex = i + 6;
                let colorBefore = simplifiedHistory[colorBeforeIndex];
                // Pular brancos para encontrar a cor de disparo real
                while (colorBefore === 'W' && colorBeforeIndex < simplifiedHistory.length) {
                    colorBeforeIndex++;
                    colorBefore = simplifiedHistory[colorBeforeIndex];
                }
                const firstPatternColor = seq[0]; // R ou B (primeira cor do padrÃ£o)
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = normalizeColorName(firstPatternColor === 'R' ? 'red' : 'black');
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.sequenciaMesmaCor4a5.count++;
                if (next.color === 'red') patterns.sequenciaMesmaCor4a5.afterRed++;
                else if (next.color === 'black') patterns.sequenciaMesmaCor4a5.afterBlack++;
                else patterns.sequenciaMesmaCor4a5.afterWhite++;
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CALCULAR PORCENTAGENS E MONTAR RELATÃ“RIO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const report = [];
    
    for (const [patternName, data] of Object.entries(patterns)) {
        if (data.count > 0) {
            const total = data.afterRed + data.afterBlack + data.afterWhite;
            const redPercent = ((data.afterRed / total) * 100).toFixed(1);
            const blackPercent = ((data.afterBlack / total) * 100).toFixed(1);
            const whitePercent = ((data.afterWhite / total) * 100).toFixed(1);
            
            // Nome legÃ­vel do padrÃ£o
            let readableName = '';
            switch(patternName) {
                case 'alternanciaSimples':
                    readableName = 'AlternÃ¢ncia Simples (P-V-P-V-P-V)';
                    break;
                case 'alternanciaDupla':
                    readableName = 'AlternÃ¢ncia Dupla (P-P-V-V-P-P-V-V)';
                    break;
                case 'alternanciaTripla':
                    readableName = 'AlternÃ¢ncia Tripla (P-P-P-V-V-V-P-P-P)';
                    break;
                case 'sequenciaVermelho6Plus':
                    readableName = 'SequÃªncia de 6+ Vermelhos';
                    break;
                case 'sequenciaPreto6Plus':
                    readableName = 'SequÃªncia de 6+ Pretos';
                    break;
                case 'sequenciaMesmaCor4a5':
                    readableName = 'SequÃªncia de 4-5 Mesma Cor';
                    break;
            }
            
            report.push({
                name: readableName,
                pattern: patternName,
                occurrences: data.count,
                afterRed: data.afterRed,
                afterBlack: data.afterBlack,
                afterWhite: data.afterWhite,
                redPercent: parseFloat(redPercent),
                blackPercent: parseFloat(blackPercent),
                whitePercent: parseFloat(whitePercent)
            });
        }
    }
    
    // Ordenar por nÃºmero de ocorrÃªncias (mais confiÃ¡vel primeiro)
    report.sort((a, b) => b.occurrences - a.occurrences);
    
    // Exibir relatÃ³rio no console
    console.log('%cğŸ“Š RELATÃ“RIO DE PADRÃ•ES DETECTADOS:', 'color: #00BFFF; font-weight: bold; font-size: 14px;');
    
    if (report.length === 0) {
        console.log('%câš ï¸ Nenhum padrÃ£o claro detectado no histÃ³rico', 'color: #FFAA00;');
        console.log('%c   Isso Ã© NORMAL se o histÃ³rico for muito aleatÃ³rio', 'color: #FFAA00;');
        console.log('%c   A IA vai analisar de forma livre.', 'color: #FFAA00;');
    } else {
        report.forEach((p, index) => {
            console.log(`%c${index + 1}. ${p.name}`, 'color: #00FF88; font-weight: bold;');
            console.log(`   OcorrÃªncias: ${p.occurrences} vezes`);
            console.log(`   ApÃ³s esse padrÃ£o:`);
            console.log(`   %câ†’ VERMELHO: ${p.afterRed} vezes (${p.redPercent}%)`, 'color: #FF0000; font-weight: bold;');
            console.log(`   %câ†’ PRETO: ${p.afterBlack} vezes (${p.blackPercent}%)`, 'color: #FFFFFF; font-weight: bold;');
            console.log(`   %câ†’ BRANCO: ${p.afterWhite} vezes (${p.whitePercent}%)`, 'color: #00FF00; font-weight: bold;');
        });
    }
    
    console.log('%câœ… DetecÃ§Ã£o de padrÃµes concluÃ­da! Retornando ' + report.length + ' padrÃµes', 'color: #00BFFF; font-weight: bold;');
    
    return report;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ SISTEMA DE ANÃLISE AVANÃ‡ADA POR PADRÃ•ES (100% JavaScript - SEM IA)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ARMAZENAMENTO DE SINAIS ENVIADOS (para auto-aprendizado)
 * Persiste em chrome.storage.local
 */
let signalsHistory = {
    signals: [],              // Todos os sinais enviados
    patternStats: {},         // EstatÃ­sticas por tipo de padrÃ£o
    contextStats: {},         // EstatÃ­sticas por contexto
    blockedPatterns: {},      // ğŸš« PadrÃµes bloqueados temporariamente {patternKey: {until: timestamp, reason: string}}
    consecutiveLosses: 0,     // ğŸ“‰ Contador de losses consecutivos GLOBAL
    recentPerformance: [],    // ğŸ“Š Ãšltimos 20 sinais (para ajuste dinÃ¢mico de minPercentage)
    lastUpdated: null
};

/**
 * Inicializar histÃ³rico de sinais do storage
 */
async function initializeSignalsHistory() {
    try {
        const result = await chrome.storage.local.get('signalsHistory');
        if (result.signalsHistory) {
            signalsHistory = result.signalsHistory;
            
            // âœ… Garantir que TODOS os campos existam (migraÃ§Ã£o + seguranÃ§a)
            if (!signalsHistory.signals || !Array.isArray(signalsHistory.signals)) signalsHistory.signals = [];
            if (!signalsHistory.patternStats) signalsHistory.patternStats = {};
            if (!signalsHistory.contextStats) signalsHistory.contextStats = {};
            if (!signalsHistory.blockedPatterns) signalsHistory.blockedPatterns = {};
            if (signalsHistory.consecutiveLosses === undefined) signalsHistory.consecutiveLosses = 0;
            if (!signalsHistory.recentPerformance || !Array.isArray(signalsHistory.recentPerformance)) signalsHistory.recentPerformance = [];
            
            console.log(`%câœ… HistÃ³rico de sinais carregado: ${signalsHistory.signals.length} sinais`, 'color: #00FF88;');
            console.log(`%c   ğŸ“‰ Losses consecutivos: ${signalsHistory.consecutiveLosses}`, 'color: #FFA500;');
        } else {
            // Se nÃ£o tem nada no storage, garantir estrutura padrÃ£o
            console.log('%câš ï¸ Nenhum histÃ³rico encontrado - inicializando estrutura padrÃ£o', 'color: #FFA500;');
        }
    } catch (error) {
        console.error('%câŒ Erro ao carregar histÃ³rico de sinais:', 'color: #FF0000;', error);
        // Em caso de erro, garantir estrutura padrÃ£o
        signalsHistory = {
            signals: [],
            patternStats: {},
            contextStats: {},
            blockedPatterns: {},
            consecutiveLosses: 0,
            recentPerformance: [],
            lastUpdated: null
        };
    }
}

/**
 * Salvar histÃ³rico de sinais no storage
 */
async function saveSignalsHistory() {
    try {
        signalsHistory.lastUpdated = Date.now();
        await chrome.storage.local.set({ signalsHistory });
    } catch (error) {
        console.error('%câŒ Erro ao salvar histÃ³rico de sinais:', 'color: #FF0000;', error);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ SISTEMA DE PADRÃ•ES CUSTOMIZADOS (NÃVEL DIAMANTE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let customPatternsCache = []; // Cache dos padrÃµes customizados

/**
 * Carregar padrÃµes customizados do storage
 */
async function loadCustomPatterns() {
    customPatternsCache = [];
        
    
    try {
        await chrome.storage.local.remove('customPatterns');
        console.log('%c   â¤ Dados antigos removidos do storage (customPatterns)', 'color: #666; font-style: italic;');
    } catch (error) {
        console.warn('âš ï¸ NÃ£o foi possÃ­vel limpar customPatterns do storage:', error);
    }
    
    console.log('%câ•‘  ğŸ¯ PADRÃ•ES CUSTOMIZADOS DESATIVADOS (MODO DIAMANTE)     â•‘', 'color: #666; font-weight: bold;');
    console.log('%c   â¤ AnÃ¡lise focada apenas na Zona Segura automÃ¡tica', 'color: #666; font-style: italic;');
        
        return customPatternsCache;
}

/**
 * Buscar padrÃ£o customizado no histÃ³rico
 */
function findCustomPatternInHistory(customPattern, history) {
    console.log(`%cğŸ” Buscando padrÃ£o customizado: ${customPattern.name}`, 'color: #00d4ff; font-weight: bold;');
    console.log('   SequÃªncia:', customPattern.sequence.join(' â†’ '));
    console.log('   Cor anterior:', customPattern.beforeColor);
    console.log('   âšª WHITE serÃ¡ IGNORADO na busca');
    
    const colors = history.map(spin => spin.color);
    const patternLength = customPattern.sequence.length;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”¥ NOVA LÃ“GICA: Agrupar por trigger
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const matchesByTrigger = new Map(); // Chave: trigger normalizada
    
    // Buscar no histÃ³rico (pegando mais giros para compensar possÃ­veis whites)
    const extraForWhites = 5;
    for (let i = 0; i <= colors.length - patternLength - extraForWhites; i++) {
        // Pegar slice maior para compensar whites
        const sliceRaw = colors.slice(i, i + patternLength + extraForWhites);
        
        // âœ… FILTRAR WHITE antes de comparar
        const sliceFiltered = sliceRaw.filter(c => c !== 'white');
        const slice = sliceFiltered.slice(0, patternLength);
        
        // Verificar se temos giros suficientes apÃ³s filtrar white
        if (slice.length < patternLength) {
            continue; // NÃ£o hÃ¡ giros suficientes
        }
        
        // Verificar se a sequÃªncia bate (SEM WHITE)
        const isMatch = slice.every((color, index) => color === customPattern.sequence[index]);
        
        if (isMatch) {
            // Verificar cor anterior (se especificada)
            const colorBefore = (i + patternLength < colors.length) ? colors[i + patternLength] : null;
            
            // ğŸ”¥ VALIDAÃ‡ÃƒO CRÃTICA: Cor de disparo DEVE ser DIFERENTE da primeira cor do padrÃ£o
            const firstPatternColor = customPattern.sequence[0];
            const colorBeforeNormalized = normalizeColorName(colorBefore);
            const firstPatternColorNormalized = normalizeColorName(firstPatternColor);
            
            if (colorBeforeNormalized && !validateDisparoColor(firstPatternColorNormalized, colorBeforeNormalized).valid) {
                // âŒ OCORRÃŠNCIA INVÃLIDA: trigger invÃ¡lida
                continue;
            }
            
            // âœ… Validar cor anterior com as novas opÃ§Ãµes
            let isBeforeColorValid = false;
            if (customPattern.beforeColor === 'red-white') {
                isBeforeColorValid = (colorBefore === 'red' || colorBefore === 'white');
            } else if (customPattern.beforeColor === 'black-white') {
                isBeforeColorValid = (colorBefore === 'black' || colorBefore === 'white');
            } else {
                // Retrocompatibilidade com modelos antigos
                isBeforeColorValid = (customPattern.beforeColor === 'any' || colorBefore === customPattern.beforeColor);
            }
            
            if (isBeforeColorValid) {
                // âœ… PADRÃƒO ENCONTRADO!
                const whatCameNext = (i > 0) ? colors[i - 1] : null;
                
                if (whatCameNext && whatCameNext !== 'white') {
                    // âœ… Agrupar por trigger
                    const triggerKey = colorBeforeNormalized || 'unknown';
                    if (!matchesByTrigger.has(triggerKey)) {
                        matchesByTrigger.set(triggerKey, []);
                    }
                    
                    matchesByTrigger.get(triggerKey).push({
                        index: i,
                        colorBefore: colorBefore,
                        whatCameNext: whatCameNext
                    });
                }
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âœ… SELECIONAR APENAS O GRUPO COM TRIGGER MAIS FREQUENTE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let bestTrigger = null;
    let bestMatches = [];
    
    for (const [trigger, matches] of matchesByTrigger.entries()) {
        if (matches.length > bestMatches.length) {
            bestTrigger = trigger;
            bestMatches = matches;
        }
    }
    
    if (matchesByTrigger.size > 1) {
        console.log(`   âš ï¸ Encontradas ocorrÃªncias com ${matchesByTrigger.size} triggers diferentes!`);
        for (const [trigger, matches] of matchesByTrigger.entries()) {
            console.log(`      - Trigger ${trigger}: ${matches.length} ocorrÃªncia(s)`);
        }
        console.log(`   âœ… Selecionado trigger mais frequente: ${bestTrigger} (${bestMatches.length} ocorrÃªncias)`);
    }
    
    console.log(`   âœ… ${bestMatches.length} ocorrÃªncia(s) VÃLIDA(s) com trigger consistente`);
    
    return bestMatches;
}

/**
 * Analisar padrÃ£o customizado e calcular estatÃ­sticas
 */
function analyzeCustomPatternStatistics(matches) {
    if (matches.length === 0) {
        return null;
    }
    
    // Contar o que veio depois
    const nextColorCount = {
        red: 0,
        black: 0,
        white: 0
    };
    
    matches.forEach(match => {
        if (match.whatCameNext) {
            nextColorCount[match.whatCameNext]++;
        }
    });
    
    const total = matches.length;
    const stats = {
        occurrences: total,
        nextColor: {
            red: nextColorCount.red,
            black: nextColorCount.black,
            white: nextColorCount.white,
            redPercent: Math.round((nextColorCount.red / total) * 100),
            blackPercent: Math.round((nextColorCount.black / total) * 100),
            whitePercent: Math.round((nextColorCount.white / total) * 100)
        }
    };
    
    console.log(`%cğŸ“Š ESTATÃSTICAS DO PADRÃƒO CUSTOMIZADO:`, 'color: #00ff88; font-weight: bold;');
    console.log(`   Total de ocorrÃªncias: ${total}`);
    console.log(`   PrÃ³xima cor:`);
    console.log(`   ğŸ”´ Vermelho: ${stats.nextColor.redPercent}% (${nextColorCount.red}x)`);
    console.log(`   âš« Preto: ${stats.nextColor.blackPercent}% (${nextColorCount.black}x)`);
    console.log(`   âšª Branco: ${stats.nextColor.whitePercent}% (${nextColorCount.white}x)`);
    
    return stats;
}

/**
 * Verificar se o padrÃ£o atual bate com algum padrÃ£o customizado
 */
async function checkForCustomPatterns(history) {
    // âš ï¸ Funcionalidade desativada: padrÃµes customizados foram removidos do sistema.
    return null;
    // âœ… SEMPRE recarregar do storage para pegar mudanÃ§as mais recentes
    console.log('%cğŸ”„ Recarregando padrÃµes customizados do storage...', 'color: #00d4ff; font-weight: bold;');
    await loadCustomPatterns();
    
    if (customPatternsCache.length === 0) {
        console.log('%câ•‘  âš ï¸ NENHUM PADRÃƒO CUSTOMIZADO ENCONTRADO                 â•‘', 'color: #FFA500; font-weight: bold;');
        console.log('%c   â¤ Storage foi verificado e estÃ¡ vazio', 'color: #FFA500;');
        console.log('%c   â¤ Nenhum sinal de padrÃ£o customizado serÃ¡ gerado', 'color: #FFA500;');
        return null;
    }
    
    console.log('%câœ… PadrÃµes customizados carregados do storage!', 'color: #00FF88; font-weight: bold;');
    console.log(`%c   Total: ${customPatternsCache.length} padrÃ£o(Ãµes)`, 'color: #00FF88;');
    
    console.log(`ğŸ“Š Total de padrÃµes carregados no cache: ${customPatternsCache.length}`);
    
    const colors = history.map(spin => spin.color);
    
    // Mostrar em ordem cronolÃ³gica (do mais antigo para o mais recente)
    const last15Reversed = colors.slice(0, 15).reverse();
    const last15Display = last15Reversed.map(c => c === 'red' ? 'ğŸ”´' : c === 'black' ? 'âš«' : 'âšª').join(' â†’ ');
    
    console.log('%cğŸ“œ ÃšLTIMOS 15 GIROS DO HISTÃ“RICO (ordem cronolÃ³gica):', 'color: #00d4ff; font-weight: bold;');
    console.log(`%c   â†‘ PASSADO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PRESENTE â†‘`, 'color: #888; font-style: italic;');
    console.log(`%c   ${last15Display}`, 'color: #FFD700; font-weight: bold;');
    console.log(`%c   ${last15Reversed.join(' â†’ ')}`, 'color: #888;');
    
    let patternIndex = 0;
    // Verificar cada padrÃ£o customizado
    for (const customPattern of customPatternsCache) {
        patternIndex++;
        console.log(`%cğŸ” PADRÃƒO #${patternIndex}: "${customPattern.name}"`, 'color: #00d4ff; font-weight: bold;');
        console.log(`   Status: ${customPattern.active ? 'âœ… ATIVO' : 'âŒ INATIVO'}`);
        console.log(`%c   ğŸ“‹ SEQUÃŠNCIA CONFIGURADA (ordem cronolÃ³gica):`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c      [ANTERIOR] â†’ [1Âº] â†’ [2Âº] â†’ [3Âº] â†’ ... â†’ [ÃšLTIMO/ATUAL]`, 'color: #888; font-style: italic;');
        
        // Construir visualizaÃ§Ã£o com cor anterior
        const beforeColorDisplay = customPattern.beforeColor === 'red-white' ? 'ğŸ”´/âšª' :
                                    customPattern.beforeColor === 'black-white' ? 'âš«/âšª' :
                                    customPattern.beforeColor === 'red' ? 'ğŸ”´' :
                                    customPattern.beforeColor === 'black' ? 'âš«' :
                                    customPattern.beforeColor === 'white' ? 'âšª' : 'â“';
        
        const sequenceDisplay = customPattern.sequence.map((c, idx) => {
            const symbol = c === 'red' ? 'ğŸ”´' : c === 'black' ? 'âš«' : 'âšª';
            return `[${idx + 1}Âº: ${symbol}]`;
        }).join(' â†’ ');
        
        console.log(`%c      ${beforeColorDisplay} (anterior) â†’ ${sequenceDisplay}`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c      â†‘ PASSADO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PRESENTE â†‘`, 'color: #888;');
        
        if (!customPattern.active) {
            console.log(`%c   â­ï¸ PULANDO: PadrÃ£o estÃ¡ INATIVO`, 'color: #888;');
            continue;
        }
        
        const patternLength = customPattern.sequence.length;
        
        // HistÃ³rico vem do MAIS RECENTE para o MAIS ANTIGO
        // Mas padrÃ£o Ã© configurado na ordem cronolÃ³gica (do mais antigo para o mais recente)
        // EntÃ£o precisamos REVERTER a sequÃªncia atual para comparar!
        
        // âœ… PEGAR MAIS GIROS PARA COMPENSAR POSSÃVEIS WHITES
        const extraForWhites = 5; // Pegar 5 giros extras para compensar whites
        const currentSequenceRaw = colors.slice(0, patternLength + extraForWhites);
        const currentSequenceReversed = [...currentSequenceRaw].reverse(); // âœ… INVERTER para ordem cronolÃ³gica
        
        // âœ… REMOVER WHITES (branco nÃ£o conta para padrÃµes)
        console.log(`%c   ğŸ” FILTRANDO GIROS (removendo WHITE):`, 'color: #FFD700; font-weight: bold;');
        console.log(`      SequÃªncia bruta: [${currentSequenceReversed.join(' â†’ ')}]`);
        
        const currentSequenceFiltered = currentSequenceReversed.filter(c => c !== 'white');
        const currentSequence = currentSequenceFiltered.slice(0, patternLength); // Pegar apenas o tamanho do padrÃ£o
        
        console.log(`      ApÃ³s remover WHITE: [${currentSequenceFiltered.join(' â†’ ')}]`);
        console.log(`      Comparando primeiros ${patternLength} giros: [${currentSequence.join(' â†’ ')}]`);
        
        console.log(`%c   ğŸ“‹ COMPARANDO SEQUÃŠNCIAS (ordem cronolÃ³gica, SEM WHITE):`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c      ğŸ“ IMPORTANTE: WHITE Ã© IGNORADO na comparaÃ§Ã£o!`, 'color: #FFD700; font-weight: bold;');
        console.log(`      ğŸ¯ Esperado: [${customPattern.sequence.join(' â†’ ')}]`);
        console.log(`      ğŸ“Š Atual:    [${currentSequence.join(' â†’ ')}]`);
        console.log(`      ğŸ“ Tamanho:  ${patternLength} giros (sem contar WHITE)`);
        
        // Comparar posiÃ§Ã£o por posiÃ§Ã£o (agora ambos estÃ£o em ordem cronolÃ³gica)
        let matchDetails = [];
        for (let i = 0; i < patternLength; i++) {
            const match = (currentSequence[i] === customPattern.sequence[i]);
            matchDetails.push({
                position: i + 1,
                expected: customPattern.sequence[i],
                actual: currentSequence[i] || 'N/A',
                match: match
            });
        }
        
        console.log('%c      COMPARAÃ‡ÃƒO DETALHADA (posiÃ§Ã£o por posiÃ§Ã£o):', 'color: #FFD700;');
        matchDetails.forEach(detail => {
            const status = detail.match ? 'âœ…' : 'âŒ';
            const color = detail.match ? '#00FF88' : '#FF6666';
            const expectedSymbol = detail.expected === 'red' ? 'ğŸ”´' : detail.expected === 'black' ? 'âš«' : 'âšª';
            const actualSymbol = detail.actual === 'red' ? 'ğŸ”´' : detail.actual === 'black' ? 'âš«' : detail.actual === 'white' ? 'âšª' : 'â“';
            console.log(`%c      ${status} ${detail.position}Âº giro: esperado ${expectedSymbol} (${detail.expected}) | real ${actualSymbol} (${detail.actual})`, `color: ${color};`);
        });
        
        const isCurrentMatch = matchDetails.every(d => d.match);
        console.log(`%c   ${isCurrentMatch ? 'âœ… SEQUÃŠNCIA BATE PERFEITAMENTE!' : 'âŒ SequÃªncia NÃƒO bate'}`, `color: ${isCurrentMatch ? '#00FF88' : '#FF6666'}; font-weight: bold;`);
        
        if (isCurrentMatch) {
            // Verificar cor anterior (se especificada)
            // Lembrar: colors[patternLength] Ã© a cor que veio ANTES da sequÃªncia (no histÃ³rico invertido)
            const colorBefore = (patternLength < colors.length) ? colors[patternLength] : null;
            const colorBeforeSymbol = colorBefore === 'red' ? 'ğŸ”´' : colorBefore === 'black' ? 'âš«' : colorBefore === 'white' ? 'âšª' : 'â“';
            
            console.log(`\n   ğŸ” VALIDANDO COR ANTERIOR (que veio ANTES da sequÃªncia):`);
            
            const beforeColorExpected = customPattern.beforeColor === 'red-white' ? 'ğŸ”´/âšª (vermelho OU branco)' :
                                       customPattern.beforeColor === 'black-white' ? 'âš«/âšª (preto OU branco)' :
                                       customPattern.beforeColor === 'red' ? 'ğŸ”´ (vermelho)' :
                                       customPattern.beforeColor === 'black' ? 'âš« (preto)' :
                                       customPattern.beforeColor === 'white' ? 'âšª (branco)' :
                                       customPattern.beforeColor === 'any' ? 'â“ (qualquer)' : customPattern.beforeColor;
            
            console.log(`      Esperado: ${beforeColorExpected}`);
            console.log(`      Real: ${colorBeforeSymbol} (${colorBefore || 'N/A'})`);
            
            // ğŸ”¥ VALIDAÃ‡ÃƒO CRÃTICA: Cor de disparo DEVE ser DIFERENTE da primeira cor do padrÃ£o
            const firstPatternColor = customPattern.sequence[0];
            const colorBeforeNormalized = normalizeColorName(colorBefore);
            const firstPatternColorNormalized = normalizeColorName(firstPatternColor);
            const disparoValidation = validateDisparoColor(firstPatternColorNormalized, colorBeforeNormalized);
            
            if (colorBeforeNormalized && !disparoValidation.valid) {
                console.log(`%c   âŒ PADRÃƒO REJEITADO: Cor de disparo (${colorBeforeSymbol}) IGUAL Ã  primeira cor do padrÃ£o!`, 'color: #FF6666; font-weight: bold;');
                console.log(`%c      Isso corrompe o padrÃ£o! Se padrÃ£o Ã© ${firstPatternColor.toUpperCase()} e disparo tambÃ©m Ã© ${colorBefore.toUpperCase()}, o padrÃ£o fica diferente!`, 'color: #FF6666;');
                console.log(`%c      ValidaÃ§Ã£o: ${disparoValidation.reason}`, 'color: #FF6666;');
                continue; // âŒ PULAR este padrÃ£o
            }
            
            // âœ… Validar cor anterior com as novas opÃ§Ãµes
            let isBeforeColorValid = false;
            if (customPattern.beforeColor === 'red-white') {
                isBeforeColorValid = (colorBefore === 'red' || colorBefore === 'white');
                console.log(`      ${isBeforeColorValid ? 'âœ…' : 'âŒ'} ${colorBefore} Ã© vermelho OU branco? ${isBeforeColorValid ? 'SIM' : 'NÃƒO'}`);
            } else if (customPattern.beforeColor === 'black-white') {
                isBeforeColorValid = (colorBefore === 'black' || colorBefore === 'white');
                console.log(`      ${isBeforeColorValid ? 'âœ…' : 'âŒ'} ${colorBefore} Ã© preto OU branco? ${isBeforeColorValid ? 'SIM' : 'NÃƒO'}`);
            } else {
                // Retrocompatibilidade com modelos antigos
                isBeforeColorValid = (customPattern.beforeColor === 'any' || colorBefore === customPattern.beforeColor);
                console.log(`      ${isBeforeColorValid ? 'âœ…' : 'âŒ'} ${colorBefore} Ã© ${customPattern.beforeColor}? ${isBeforeColorValid ? 'SIM' : 'NÃƒO'}`);
            }
            
            if (isBeforeColorValid) {
                console.log(`%câœ… PADRÃƒO CUSTOMIZADO ATIVO DETECTADO!`, 'color: #00ff88; font-weight: bold;');
                console.log(`   Nome: ${customPattern.name}`);
                console.log(`   SequÃªncia: ${customPattern.sequence.join(' â†’ ')}`);
                console.log(`   Cor anterior esperada: ${customPattern.beforeColor}`);
                console.log(`   Cor anterior real: ${colorBefore || 'N/A'}`);
                
                // Buscar no histÃ³rico o que geralmente vem depois
                const matches = findCustomPatternInHistory(customPattern, history);
                const stats = analyzeCustomPatternStatistics(matches);
                
                console.log('%câ•‘  ğŸ“Š ANÃLISE SIMPLES DO PADRÃƒO                            â•‘', 'color: #FFD700; font-weight: bold;');
                
                // âœ… LÃ“GICA SIMPLES: Encontrou pelo menos 1x? Recomenda a cor com maior %
                if (stats && stats.occurrences >= 1) {
                    console.log(`ğŸ“ˆ Total de ocorrÃªncias encontradas: ${stats.occurrences}`);
                    console.log(`ğŸ”´ Vermelho veio depois: ${stats.nextColor.redPercent}%`);
                    console.log(`âš« Preto veio depois: ${stats.nextColor.blackPercent}%`);
                    console.log(`âšª Branco veio depois: ${stats.nextColor.whitePercent}%`);
                    
                    // Determinar cor com maior frequÃªncia (SIMPLES!)
                    const redPercent = stats.nextColor.redPercent;
                    const blackPercent = stats.nextColor.blackPercent;
                    const recommendedColor = redPercent > blackPercent ? 'red' : 'black';
                    const confidence = Math.max(redPercent, blackPercent);
                    
                    console.log(`%câœ… PADRÃƒO CUSTOMIZADO APROVADO!`, 'color: #00FF88; font-weight: bold; font-size: 14px;');
                    console.log(`%cğŸ¯ COR RECOMENDADA: ${recommendedColor === 'red' ? 'ğŸ”´ VERMELHO' : 'âš« PRETO'}`, 'color: #00FF88; font-weight: bold;');
                    console.log(`%cğŸ“Š ConfianÃ§a: ${confidence}%`, 'color: #00FF88; font-weight: bold;');
                    
                    return {
                        pattern: customPattern,
                        stats: stats,
                        recommendedColor: recommendedColor,
                        confidence: confidence,
                        reasoning: `PadrÃ£o customizado "${customPattern.name}" detectado! ` +
                                  `Sistema encontrou ${stats.occurrences} ocorrÃªncia(s) no histÃ³rico. ` +
                                  `A cor ${recommendedColor === 'red' ? 'ğŸ”´ VERMELHA' : 'âš« PRETA'} veio depois em ${confidence}% dos casos.`
                    };
                } else {
                    // PadrÃ£o nunca apareceu no histÃ³rico
                    console.log(`%câš ï¸ ATENÃ‡ÃƒO! PadrÃ£o NUNCA apareceu no histÃ³rico`, 'color: #FFA500; font-weight: bold; font-size: 14px;');
                    console.log(`%c   PadrÃ£o detectado: "${customPattern.name}"`, 'color: #FFA500;');
                    console.log(`%c   Sem dados histÃ³ricos para anÃ¡lise`, 'color: #FFA500;');
                    // Continuar verificando prÃ³ximo padrÃ£o
                }
            } else {
                console.log(`\n   âŒ COR ANTERIOR NÃƒO VÃLIDA!`);
                console.log(`      Esperado: ${customPattern.beforeColor}`);
                console.log(`      Recebido: ${colorBefore}`);
                console.log(`      Este padrÃ£o NÃƒO serÃ¡ usado!\n`);
            }
        }
    }
    
    console.log('\nğŸ“Š Resultado final: Nenhum padrÃ£o customizado vÃ¡lido encontrado no momento');
    return null;
}

// Listener para atualizaÃ§Ã£o de padrÃµes customizados
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.type === 'CUSTOM_PATTERNS_UPDATED') {
        console.log('%câ•‘  ğŸ”„ PADRÃ•ES CUSTOMIZADOS ATUALIZADOS!                    â•‘', 'color: #00FF88; font-weight: bold;');
        
        const oldCache = [...customPatternsCache];
        customPatternsCache = request.data || [];
        
        console.log(`ğŸ“Š PadrÃµes no cache ANTIGO: ${oldCache.length}`);
        if (oldCache.length > 0) {
            oldCache.forEach((p, idx) => {
                console.log(`   ${idx + 1}. "${p.name}" (ID: ${p.id})`);
            });
        }
        
        console.log(`ğŸ“Š PadrÃµes no cache NOVO: ${customPatternsCache.length}`);
        if (customPatternsCache.length > 0) {
            customPatternsCache.forEach((p, idx) => {
                console.log(`   ${idx + 1}. "${p.name}" (ID: ${p.id})`);
            });
        }
        
        // Detectar padrÃµes REMOVIDOS
        const removedPatterns = oldCache.filter(old => !customPatternsCache.find(p => p.id === old.id));
        if (removedPatterns.length > 0) {
            console.log('%cğŸ—‘ï¸ PADRÃ•ES REMOVIDOS:', 'color: #FF6666; font-weight: bold;');
            removedPatterns.forEach(p => {
                console.log(`   âœ• "${p.name}" (ID: ${p.id}) | SequÃªncia: ${p.sequence.join(' â†’ ')}`);
            });
        }
        
        // Detectar padrÃµes NOVOS
        const newPatterns = customPatternsCache.filter(p => !oldCache.find(old => old.id === p.id));
        if (newPatterns.length > 0) {
            console.log('%câœ¨ PADRÃ•ES NOVOS:', 'color: #00FF88; font-weight: bold;');
            newPatterns.forEach(p => {
                console.log(`   + "${p.name}" (ID: ${p.id}) | SequÃªncia: ${p.sequence.join(' â†’ ')}`);
            });
        }
        
        // Detectar padrÃµes EDITADOS
        const editedPatterns = customPatternsCache.filter(p => {
            const old = oldCache.find(old => old.id === p.id);
            return old && (old.name !== p.name || 
                          JSON.stringify(old.sequence) !== JSON.stringify(p.sequence) ||
                          old.beforeColor !== p.beforeColor);
        });
        if (editedPatterns.length > 0) {
            console.log('%câœï¸ PADRÃ•ES EDITADOS:', 'color: #FFD700; font-weight: bold;');
            editedPatterns.forEach(p => {
                console.log(`   âœï¸ "${p.name}" (ID: ${p.id})`);
            });
        }
        
        console.log('%câœ… CACHE ATUALIZADO - PrÃ³ximo sinal usarÃ¡ os padrÃµes mais recentes!', 'color: #00FF88; font-weight: bold;');
        console.log('%câš ï¸ IMPORTANTE: PadrÃµes removidos NÃƒO gerarÃ£o mais sinais!', 'color: #FFD700; font-weight: bold;');
        
        sendResponse({ success: true });
        return true;
    }
});

/**
 * DETECTAR TODOS OS TIPOS DE PADRÃ•ES VARIADOS
 * Cria exemplos de alternÃ¢ncia simples, dupla, tripla, sequÃªncias, etc.
 */
function detectAllPatternTypes(history) {
    const patterns = [];
    
    if (history.length < 2) return patterns;
    
    // Converter histÃ³rico para array de cores simples
    const colors = history.map(spin => spin.color);
    
    console.log('%cğŸ” DETECTANDO TODOS OS PADRÃ•ES POSSÃVEIS', 'color: #00BFFF; font-weight: bold;');
    
    // 1. ALTERNÃ‚NCIA SIMPLES (V-P-V-P...)
    console.log('%cğŸ“Š Buscando: AlternÃ¢ncia Simples (tamanhos 2-20)', 'color: #00FF88;');
    for (let size = 2; size <= Math.min(20, colors.length); size += 2) {
        for (let i = 0; i <= colors.length - size; i++) {
            const sequence = colors.slice(i, i + size);
            const isAlternating = checkAlternatingPattern(sequence, 1);
            
            if (isAlternating && !sequence.includes('white')) {
                // âœ… CORREÃ‡ÃƒO CRÃTICA: Array[0]=recente, [1]=antigo
                // O que veio DEPOIS Ã© [i-1] (mais recente), nÃ£o [i+size] (mais antigo)!
                if (i > 0) { // Precisa ter um giro seguinte
                    const whatCameNext = colors[i - 1]; // âœ… Giro SEGUINTE
                    const contextBefore = (i + size < colors.length - 4) ? colors.slice(i + size, i + size + 4).join('-') : 'inicio';
                    patterns.push({
                        type: 'alternancia_simples',
                        size: size,
                        sequence: sequence.join('-'),
                        index: i,
                        whatCameNext: whatCameNext,
                        contextBefore: contextBefore
                    });
                }
            }
        }
    }
    
    // 2. ALTERNÃ‚NCIA DUPLA (V-V-P-P-V-V...)
    console.log('%cğŸ“Š Buscando: AlternÃ¢ncia Dupla (tamanhos 4-20)', 'color: #00FF88;');
    for (let size = 4; size <= Math.min(20, colors.length); size += 4) {
        for (let i = 0; i <= colors.length - size; i++) {
            const sequence = colors.slice(i, i + size);
            const isAlternating = checkAlternatingPattern(sequence, 2);
            
            if (isAlternating && !sequence.includes('white')) {
                // âœ… CORREÃ‡ÃƒO: O que veio DEPOIS Ã© [i-1], nÃ£o [i+size]
                if (i > 0) {
                    const whatCameNext = colors[i - 1]; // âœ… Giro SEGUINTE
                    const contextBefore = (i + size < colors.length - 4) ? colors.slice(i + size, i + size + 4).join('-') : 'inicio';
                    patterns.push({
                        type: 'alternancia_dupla',
                        size: size,
                        sequence: sequence.join('-'),
                        index: i,
                        whatCameNext: whatCameNext,
                        contextBefore: contextBefore
                    });
                }
            }
        }
    }
    
    // 3. ALTERNÃ‚NCIA TRIPLA (V-V-V-P-P-P...)
    console.log('%cğŸ“Š Buscando: AlternÃ¢ncia Tripla (tamanhos 6-18)', 'color: #00FF88;');
    for (let size = 6; size <= Math.min(18, colors.length); size += 6) {
        for (let i = 0; i <= colors.length - size; i++) {
            const sequence = colors.slice(i, i + size);
            const isAlternating = checkAlternatingPattern(sequence, 3);
            
            if (isAlternating && !sequence.includes('white')) {
                // âœ… CORREÃ‡ÃƒO: O que veio DEPOIS Ã© [i-1], nÃ£o [i+size]
                if (i > 0) {
                    const whatCameNext = colors[i - 1]; // âœ… Giro SEGUINTE
                    const contextBefore = (i + size < colors.length - 4) ? colors.slice(i + size, i + size + 4).join('-') : 'inicio';
                    patterns.push({
                        type: 'alternancia_tripla',
                        size: size,
                        sequence: sequence.join('-'),
                        index: i,
                        whatCameNext: whatCameNext,
                        contextBefore: contextBefore
                    });
                }
            }
        }
    }
    
    // 4. SEQUÃŠNCIAS (mesma cor consecutiva)
    console.log('%cğŸ“Š Buscando: SequÃªncias (tamanhos 2-15)', 'color: #00FF88;');
    for (let size = 2; size <= Math.min(15, colors.length); size++) {
        for (let i = 0; i <= colors.length - size; i++) {
            const sequence = colors.slice(i, i + size);
            const firstColor = sequence[0];
            const isSequence = sequence.every(c => c === firstColor) && firstColor !== 'white';
            
            if (isSequence) {
                // âœ… CORREÃ‡ÃƒO: O que veio DEPOIS Ã© [i-1], nÃ£o [i+size]
                if (i > 0) {
                    const whatCameNext = colors[i - 1]; // âœ… Giro SEGUINTE
                    const contextBefore = (i + size < colors.length - 4) ? colors.slice(i + size, i + size + 4).join('-') : 'inicio';
                    patterns.push({
                        type: 'sequencia_' + firstColor,
                        size: size,
                        sequence: sequence.join('-'),
                        index: i,
                        whatCameNext: whatCameNext,
                        contextBefore: contextBefore
                    });
                }
            }
        }
    }
    
    console.log('%câœ… Total de padrÃµes detectados: ' + patterns.length, 'color: #00BFFF; font-weight: bold;');
    
    return patterns;
}

/**
 * Verificar se uma sequÃªncia segue um padrÃ£o de alternÃ¢ncia
 * @param {Array} sequence - Array de cores
 * @param {Number} groupSize - Tamanho do grupo (1=simples, 2=dupla, 3=tripla)
 */
function checkAlternatingPattern(sequence, groupSize) {
    if (sequence.length < groupSize * 2) return false;
    
    for (let i = 0; i < sequence.length; i++) {
        const groupIndex = Math.floor(i / groupSize);
        const expectedColor = groupIndex % 2 === 0 ? sequence[0] : (sequence[0] === 'red' ? 'black' : 'red');
        
        if (sequence[i] !== expectedColor) {
            return false;
        }
    }
    
    return true;
}

/**
 * âœ¨ DETECTAR PADRÃ•ES IRREGULARES/CUSTOMIZADOS
 * Exemplos:
 * - P-V-V-V-P â†’ PadrÃ£o 1-3-1 (1 preto, 3 vermelhos, repete)
 * - B-P-P-V-P-P â†’ PadrÃ£o com branco (B/V-P-P repete)
 * - V-V-P-V-V-P â†’ PadrÃ£o 2-1-2 (2 vermelhos, 1 preto, repete)
 */
function detectIrregularPattern(colors) {
    console.log('%cğŸ” Buscando padrÃµes irregulares nos Ãºltimos 10 giros...', 'color: #FF00FF;');
    
    // Ignorar brancos para simplificar anÃ¡lise inicial
    const nonWhite = colors.filter(c => c !== 'white');
    
    // Tentar detectar ciclos de tamanhos diferentes (2-6 giros por ciclo)
    for (let cycleSize = 2; cycleSize <= 6; cycleSize++) {
        // Precisa de pelo menos 2 ciclos completos para confirmar padrÃ£o
        const minGiros = cycleSize * 2;
        if (nonWhite.length < minGiros) continue;
        
        const cycle1 = nonWhite.slice(0, cycleSize);
        const cycle2 = nonWhite.slice(cycleSize, cycleSize * 2);
        
        // Verificar se os dois ciclos sÃ£o idÃªnticos
        const isSameCycle = cycle1.every((color, i) => color === cycle2[i]);
        
        if (isSameCycle) {
            // Encontrou padrÃ£o irregular repetido!
            const patternStr = cycle1.map(c => c === 'red' ? 'V' : 'P').join('-');
            
            console.log(`%c   âœ… PadrÃ£o irregular detectado: ${patternStr}`, 'color: #FF00FF; font-weight: bold;');
            console.log(`%c      Ciclo se repete a cada ${cycleSize} giros`, 'color: #FF00FF;');
            
            return {
                type: 'irregular_pattern',
                size: cycleSize * 2,
                sequence: cycle1.join('-'),
                name: `PadrÃ£o Irregular (${patternStr} repetido)`,
                cycleSize: cycleSize,
                contextBefore: colors.slice(cycleSize * 2, cycleSize * 2 + 4).join('-')
            };
        }
    }
    
    // Tentar detectar padrÃµes com branco incluÃ­do
    if (colors.includes('white')) {
        for (let cycleSize = 2; cycleSize <= 6; cycleSize++) {
            const minGiros = cycleSize * 2;
            if (colors.length < minGiros) continue;
            
            const cycle1 = colors.slice(0, cycleSize);
            const cycle2 = colors.slice(cycleSize, cycleSize * 2);
            
            const isSameCycle = cycle1.every((color, i) => color === cycle2[i]);
            
            if (isSameCycle) {
                const patternStr = cycle1.map(c => c === 'red' ? 'V' : c === 'black' ? 'P' : 'B').join('-');
                
                console.log(`%c   âœ… PadrÃ£o irregular COM BRANCO: ${patternStr}`, 'color: #FF00FF; font-weight: bold;');
                
                return {
                    type: 'irregular_pattern_with_white',
                    size: cycleSize * 2,
                    sequence: cycle1.join('-'),
                    name: `PadrÃ£o com Branco (${patternStr} repetido)`,
                    cycleSize: cycleSize,
                    contextBefore: colors.slice(cycleSize * 2, cycleSize * 2 + 4).join('-')
                };
            }
        }
    }
    
    console.log('%c   âŒ Nenhum padrÃ£o irregular encontrado', 'color: #FF00FF;');
    return null;
}

/**
 * ğŸ” VALIDADOR RIGOROSO DE PADRÃƒO
 * Verifica se o padrÃ£o detectado estÃ¡ REALMENTE correto
 * Analisa o contexto completo antes e depois do padrÃ£o
 */
function validatePatternDetection(colors, patternStartIndex, patternSize, patternType, groupSize, patternName) {
    const patternSequence = colors.slice(patternStartIndex, patternStartIndex + patternSize);
    
    console.log('%cğŸ” VALIDADOR RIGOROSO DE PADRÃƒO', 'color: #FF1493; font-weight: bold; font-size: 14px;');
    console.log(`%cğŸ“‹ PadrÃ£o detectado: ${patternName}`, 'color: #FF69B4; font-weight: bold;');
    console.log(`%c   Tipo: ${patternType}`, 'color: #FF69B4;');
    console.log(`%c   Tamanho: ${patternSize} giros`, 'color: #FF69B4;');
    console.log(`%c   SequÃªncia: ${patternSequence.map(c => c === 'red' ? 'V' : c === 'black' ? 'P' : 'B').join('-')}`, 'color: #FF69B4;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 1: MOSTRAR CONTEXTO COMPLETO (10 giros)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const contextSize = Math.min(10, colors.length);
    const contextColors = colors.slice(0, contextSize).map((c, i) => {
        const symbol = c === 'red' ? 'V' : c === 'black' ? 'P' : 'B';
        if (i >= patternStartIndex && i < patternStartIndex + patternSize) {
            return `[${symbol}]`; // Marcar padrÃ£o com colchetes
        }
        return symbol;
    }).join('-');
    
    console.log(`%cğŸ“Š CONTEXTO COMPLETO (Ãºltimos ${contextSize} giros):`, 'color: #00CED1; font-weight: bold;');
    console.log(`%c   ${contextColors}`, 'color: #00CED1;');
    console.log(`%c   (PadrÃ£o marcado com [ ])`, 'color: #888;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 2: ANÃLISE DO CONTEXTO ANTERIOR (O que veio ANTES)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const contextBefore = [];
    for (let i = patternStartIndex + patternSize; i < Math.min(patternStartIndex + patternSize + 5, colors.length); i++) {
        if (colors[i] && colors[i] !== 'white') {
            contextBefore.push(colors[i]);
        }
    }
    
    if (contextBefore.length > 0) {
        console.log(`%cğŸ”™ CONTEXTO ANTERIOR (antes do padrÃ£o):`, 'color: #FFA500; font-weight: bold;');
        console.log(`%c   Giros anteriores: ${contextBefore.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #FFA500;');
        
        // VALIDAÃ‡ÃƒO CRÃTICA: Se Ã© alternÃ¢ncia, verificar se nÃ£o Ã© sequÃªncia quebrando
        if (patternType.includes('alternancia')) {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LÃ“GICA CORRETA: Pegar os ÃšLTIMOS N giros do padrÃ£o (onde N = groupSize)
            // e ver se essa cor continua ANTES do padrÃ£o
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Para alternÃ¢ncia DUPLA P-P-V-V:
            // - Ãšltimos 2 giros (groupSize=2): P-P (posiÃ§Ãµes 2,3 do padrÃ£o)
            // - Se antes veio mais P, entÃ£o P-P faz parte de P-P-P!
            // - REJEITAR!
            
            // Pegar os Ãºltimos N giros do padrÃ£o
            const lastGroupColors = patternSequence.slice(patternSize - groupSize, patternSize);
            const lastGroupColor = lastGroupColors[0]; // Cor do Ãºltimo grupo
            
            console.log(`%c      Cor: ${lastGroupColor === 'red' ? 'VERMELHO' : 'PRETO'}`, 'color: #FFA500;');
            
            // Verificar se essa mesma cor continua ANTES do padrÃ£o
            if (contextBefore.length > 0 && contextBefore[0] === lastGroupColor) {
                console.log('%c   âŒ ERRO DETECTADO: PadrÃ£o INCORRETO!', 'color: #FF0000; font-weight: bold;');
                console.log(`%c   Motivo: A cor ${lastGroupColor === 'red' ? 'VERMELHO' : 'PRETO'} continua ANTES do padrÃ£o!`, 'color: #FF0000;');
                console.log(`%c   O Ãºltimo grupo (${lastGroupColors.map(c => c === 'red' ? 'V' : 'P').join('-')}) faz parte de uma SEQUÃŠNCIA maior!`, 'color: #FF0000;');
                console.log(`%c   Isso NÃƒO Ã© ${patternName}! Ã‰ uma SEQUÃŠNCIA quebrando!`, 'color: #FF0000; font-weight: bold;');
                return { valid: false, reason: `Ãšltimo grupo do padrÃ£o (${lastGroupColor === 'red' ? 'V' : 'P'}) continua antes - Ã© sequÃªncia quebrando!` };
            }
            
            // VALIDAÃ‡ÃƒO ADICIONAL: Verificar os PRIMEIROS N giros do padrÃ£o tambÃ©m
            const firstGroupColors = patternSequence.slice(0, groupSize);
            const firstGroupColor = firstGroupColors[0];
            
            console.log(`%c      Cor: ${firstGroupColor === 'red' ? 'VERMELHO' : 'PRETO'}`, 'color: #FFA500;');
            
            // Verificar quantas vezes essa cor aparece ANTES do padrÃ£o
            let sameColorCountBefore = 0;
            for (let i = 0; i < contextBefore.length; i++) {
                if (contextBefore[i] === lastGroupColor) {
                    sameColorCountBefore++;
                } else {
                    break;
                }
            }
            
            if (sameColorCountBefore > 0) {
                console.log('%c   âŒ ERRO DETECTADO: PadrÃ£o INCORRETO!', 'color: #FF0000; font-weight: bold;');
                console.log(`%c   Motivo: ${sameColorCountBefore} cor(es) ${lastGroupColor === 'red' ? 'VERMELHO' : 'PRETO'} continuam antes!`, 'color: #FF0000;');
                console.log(`%c   Isso cria uma sequÃªncia de ${sameColorCountBefore + groupSize} cores iguais!`, 'color: #FF0000;');
                console.log(`%c   Isso NÃƒO Ã© ${patternName}! Ã‰ uma SEQUÃŠNCIA quebrando!`, 'color: #FF0000; font-weight: bold;');
                return { valid: false, reason: `${sameColorCountBefore} cor(es) continuam antes - sequÃªncia de ${sameColorCountBefore + groupSize} total!` };
            } else {
                console.log(`%c   âœ… OK: NÃ£o hÃ¡ continuaÃ§Ã£o da cor antes do padrÃ£o`, 'color: #00FF00;');
            }
        }
        
        // VALIDAÃ‡ÃƒO: Se Ã© sequÃªncia, nÃ£o pode ter a mesma cor logo antes
        if (patternType.includes('sequencia')) {
            const firstColor = getInitialPatternColor(patternSequence);
            if (contextBefore[0] === firstColor) {
                console.log('%c   âŒ ERRO DETECTADO: PadrÃ£o INCORRETO!', 'color: #FF0000; font-weight: bold;');
                console.log(`%c   Motivo: SequÃªncia continua ANTES do padrÃ£o detectado`, 'color: #FF0000;');
                console.log(`%c   Isso nÃ£o Ã© uma nova sequÃªncia, Ã© continuaÃ§Ã£o!`, 'color: #FF0000; font-weight: bold;');
                return { valid: false, reason: 'SequÃªncia continua antes do padrÃ£o' };
            } else {
                console.log(`%c   âœ… OK: Cor anterior (${contextBefore[0] === 'red' ? 'V' : 'P'}) Ã© diferente da sequÃªncia (${firstColor === 'red' ? 'V' : 'P'})`, 'color: #00FF00;');
            }
        }
        
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 3: ANÃLISE DO CONTEXTO POSTERIOR (O que veio DEPOIS)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (patternStartIndex >= 1) {
        const contextAfter = [];
        for (let i = patternStartIndex - 1; i >= Math.max(0, patternStartIndex - 5); i--) {
            if (colors[i] && colors[i] !== 'white') {
                contextAfter.push(colors[i]);
            }
        }
        
        if (contextAfter.length > 0) {
            console.log(`%cğŸ”œ CONTEXTO POSTERIOR (depois do padrÃ£o):`, 'color: #9370DB; font-weight: bold;');
            console.log(`%c   Giros seguintes: ${contextAfter.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #9370DB;');
            
            const nextColor = contextAfter[0];
            const lastColorOfPattern = patternSequence[patternSize - 1];
            
            // VALIDAÃ‡ÃƒO: Ãšltimo giro do padrÃ£o nÃ£o pode continuar depois
            if (nextColor === lastColorOfPattern) {
                console.log('%c   âŒ ERRO DETECTADO: PadrÃ£o INCORRETO!', 'color: #FF0000; font-weight: bold;');
                console.log(`%c   Motivo: Ãšltimo giro do padrÃ£o (${lastColorOfPattern === 'red' ? 'V' : 'P'}) continua depois`, 'color: #FF0000;');
                console.log(`%c   O padrÃ£o detectado faz parte de um padrÃ£o MAIOR!`, 'color: #FF0000; font-weight: bold;');
                return { valid: false, reason: 'Ãšltimo giro do padrÃ£o continua depois (padrÃ£o maior)' };
            } else {
                console.log(`%c   âœ… OK: PrÃ³ximo giro (${nextColor === 'red' ? 'V' : 'P'}) quebra o padrÃ£o`, 'color: #00FF00;');
            }
            
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONCLUSÃƒO: PADRÃƒO VÃLIDO!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%câœ… PADRÃƒO VALIDADO COM SUCESSO!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
    console.log('%c   Todas as verificaÃ§Ãµes passaram!', 'color: #00FF88;');
    console.log('%c   O padrÃ£o estÃ¡ LIMPO e CORRETO!', 'color: #00FF88;');
    
    return { valid: true, reason: 'PadrÃ£o validado com sucesso' };
}

/**
 * âœ… VALIDAÃ‡ÃƒO CRÃTICA: Verificar se o padrÃ£o estÃ¡ "limpo"
 * Um padrÃ£o sÃ³ Ã© vÃ¡lido se:
 * 1. O giro ANTERIOR (antes do primeiro giro do padrÃ£o) quebra o padrÃ£o
 * 2. O giro POSTERIOR (depois do Ãºltimo giro do padrÃ£o) tambÃ©m quebra
 * 
 * Exemplo CORRETO:
 * Giros: P-V-P-V (posiÃ§Ãµes 3,2,1,0)
 * PadrÃ£o: V-P (posiÃ§Ãµes 1,0)
 * - Giro anterior (2): V (se continuasse: V-V-P = nÃ£o Ã© alternÃ¢ncia) âœ…
 * - Giro posterior (3): P (se continuasse: V-P-P = nÃ£o Ã© alternÃ¢ncia) âœ…
 * 
 * Exemplo ERRADO:
 * Giros: P-P-V-P (posiÃ§Ãµes 3,2,1,0)
 * PadrÃ£o: V-P (posiÃ§Ãµes 1,0)
 * - Giro anterior (2): P âœ… OK
 * - Giro posterior (3): P âŒ ERRO! O P do giro 1 faz parte de sequÃªncia P-P
 */
function isPatternClean(colors, patternStartIndex, patternSize, patternType, groupSize) {
    const patternSequence = colors.slice(patternStartIndex, patternStartIndex + patternSize);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VERIFICAÃ‡ÃƒO 1: Giro ANTERIOR ao padrÃ£o (apÃ³s o Ãºltimo giro)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const previousColorIndex = patternStartIndex + patternSize;
    const previousColor = colors[previousColorIndex];
    
    if (previousColor) {
        // Para alternÃ¢ncias, verificar se o giro anterior quebraria o padrÃ£o
        if (patternType.includes('alternancia')) {
            const firstColor = getInitialPatternColor(patternSequence);
			if (!firstColor) return false;
            const groupIndex = Math.floor(patternSize / groupSize);
            const expectedColor = groupIndex % 2 === 0 ? firstColor : (firstColor === 'red' ? 'black' : 'red');
            
            if (previousColor === expectedColor) {
                return false; // âŒ PadrÃ£o continua antes
            }
        }
        
        // Para sequÃªncias, verificar se o giro anterior Ã© diferente
        if (patternType.includes('sequencia')) {
            const firstColor = getInitialPatternColor(patternSequence);
			if (!firstColor) return false;
            if (previousColor === firstColor) {
                return false; // âŒ SequÃªncia continua antes
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VERIFICAÃ‡ÃƒO 2: Giro POSTERIOR ao padrÃ£o (depois do primeiro giro)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âš ï¸ CRÃTICO: Para alternÃ¢ncias e sequÃªncias de 2+ giros
    if (patternSize >= 2 && patternStartIndex >= 1) {
        const nextColorIndex = patternStartIndex - 1; // Giro DEPOIS do padrÃ£o (mais recente)
        const nextColor = colors[nextColorIndex];
        
        if (nextColor && nextColor !== 'white') {
            const lastColorOfPattern = patternSequence[patternSize - 1];
            
            // Para alternÃ¢ncias, o Ãºltimo giro do padrÃ£o NÃƒO pode continuar depois
            if (patternType.includes('alternancia')) {
                // Se o Ãºltimo giro do padrÃ£o for P, e o prÃ³ximo tambÃ©m for P,
                // significa que o P do padrÃ£o faz parte de uma sequÃªncia maior
                if (nextColor === lastColorOfPattern) {
                    return false; // âŒ Ãšltimo giro do padrÃ£o continua depois
                }
            }
            
            // Para sequÃªncias, verificar se continua depois
            if (patternType.includes('sequencia')) {
                if (nextColor === lastColorOfPattern) {
                    return false; // âŒ SequÃªncia continua depois
                }
            }
        }
    }
    
    return true; // âœ… PadrÃ£o estÃ¡ limpo dos dois lados
}

/**
 * BUSCAR PADRÃƒO ATIVO NOS ÃšLTIMOS 20 GIROS
 * Identifica qual padrÃ£o estÃ¡ acontecendo AGORA (comeÃ§ando do giro 1)
 */
function findActivePattern(last20Spins) {
    const colors = last20Spins.map(spin => spin.color);
    
    console.log('%cğŸ¯ IDENTIFICANDO PADRÃƒO ATIVO (comeÃ§ando do giro 1)', 'color: #FFD700; font-weight: bold;');
    
    console.log('%cÃšltimos 20 giros:', 'color: #FFD700;');
    last20Spins.slice(0, 10).forEach((spin, index) => {
        console.log(`  ${index + 1}. ${spin.color} (${spin.roll})`);
    });
    console.log('  ... (+ 10 giros mais antigos)');
    
    // Tentar detectar padrÃµes do MAIOR para o MENOR
    // ComeÃ§ar sempre do giro 1 (mais recente)
    
    let bestPattern = null;
    let bestSize = 0;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ TAMANHOS MÃNIMOS PARA PADRÃ•ES CONFIÃVEIS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ CALIBRAÃ‡Ã•ES BASEADAS EM 10.000 GIROS REAIS DA BLAZE
    // Data: 31/10/2025 - 03/11/2025 | AnÃ¡lise cientÃ­fica correta
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // âœ… CORRIGIDO: MÃ­nimos mais inteligentes para detecÃ§Ã£o precoce
    const MIN_ALTERNANCIA_TRIPLA = 8;  // 2 ciclos + 2 giros (P-P-P-V-V-V-P-P) â†’ prÃ³ximo: P
    const MIN_ALTERNANCIA_DUPLA = 6;   // 3 ciclos completos (P-P-V-V-P-P) â†’ prÃ³ximo: V
    const MIN_ALTERNANCIA_SIMPLES = 4; // 2 ciclos completos (P-V-P-V) â†’ prÃ³ximo: P
    const MIN_SEQUENCIA = 3;           // 3 da mesma cor (P-P-P) â†’ detecta tendÃªncia
    
    // ğŸ”¥ DADOS REAIS: Pontos de quebra crÃ­ticos (>60% probabilidade)
    const QUEBRA_CRITICA_RED_5 = 5;    // âœ… Vermelho 5: 62.4% quebra (83/133)
    const QUEBRA_CRITICA_RED_8 = 8;    // âœ… Vermelho 8: 66.7% quebra (8/12)
    const QUEBRA_CRITICA_BLACK_7 = 7;  // âœ… Preto 7: 76.0% quebra (19/25) â¬…ï¸ FORTE!
    const MAX_SEQUENCIA_HISTORICO = 11; // âœ… MÃ¡ximo visto: 11 (1x cada cor em 10k)
    
    // ğŸ“Š DISTRIBUIÃ‡ÃƒO REAL (QUASE 50/50!)
    const REAL_RED_PERCENT = 46.77;    // âœ… Vermelho: 4677/10000
    const REAL_BLACK_PERCENT = 46.87;  // âœ… Preto: 4687/10000 (apenas 0.1% a mais!)
    const REAL_WHITE_PERCENT = 6.36;   // âœ… Branco: 636/10000 (1 a cada 15.7)
    
    console.log('%câš™ï¸ TAMANHOS MÃNIMOS PARA PADRÃ•ES:', 'color: #FFD700; font-weight: bold;');
    console.log(`%c   AlternÃ¢ncia Tripla: ${MIN_ALTERNANCIA_TRIPLA}+ giros (ex: P-P-P-V-V-V-P-P)`, 'color: #FFD700;');
    console.log(`%c   AlternÃ¢ncia Dupla: ${MIN_ALTERNANCIA_DUPLA}+ giros (ex: P-P-V-V-P-P)`, 'color: #FFD700;');
    console.log(`%c   AlternÃ¢ncia Simples: ${MIN_ALTERNANCIA_SIMPLES}+ giros (ex: P-V-P-V)`, 'color: #FFD700;');
    console.log(`%c   SequÃªncia: ${MIN_SEQUENCIA}+ giros (ex: P-P-P)`, 'color: #FFD700;');
    
    // Tentar alternÃ¢ncia tripla (8, 9, 12, 15, 18)
    // âœ… ComeÃ§a em 18 e vai descendo atÃ© o mÃ­nimo (8)
    for (let size = 18; size >= MIN_ALTERNANCIA_TRIPLA; size -= 3) {
        if (size > colors.length) continue;
        const sequence = colors.slice(0, size);
        if (checkAlternatingPattern(sequence, 3) && !sequence.includes('white')) {
            const patternName = `AlternÃ¢ncia Tripla de ${size} giros`;
            // ğŸ” VALIDAÃ‡ÃƒO RIGOROSA: Verificar se o padrÃ£o estÃ¡ REALMENTE correto
            const validation = validatePatternDetection(colors, 0, size, 'alternancia_tripla', 3, patternName);
            if (validation.valid) {
                bestPattern = {
                    type: 'alternancia_tripla',
                    size: size,
                    sequence: sequence.join('-'),
                    name: patternName
                };
                bestSize = size;
                break;
            } else {
                console.log(`%câŒ PadrÃ£o "${patternName}" rejeitado: ${validation.reason}`, 'color: #FF0000; font-weight: bold;');
            }
        }
    }
    
    // Tentar alternÃ¢ncia dupla (6, 10, 14, 18) - incremento de 4
    // âœ… MÃ­nimo reduzido para 6 giros (P-P-V-V-P-P)
    if (!bestPattern || bestSize < MIN_ALTERNANCIA_DUPLA) {
        for (let size = 20; size >= MIN_ALTERNANCIA_DUPLA; size -= 4) {
            if (size > colors.length) continue;
            const sequence = colors.slice(0, size);
            if (checkAlternatingPattern(sequence, 2) && !sequence.includes('white')) {
                const patternName = `AlternÃ¢ncia Dupla de ${size} giros`;
                // ğŸ” VALIDAÃ‡ÃƒO RIGOROSA: Verificar se o padrÃ£o estÃ¡ REALMENTE correto
                const validation = validatePatternDetection(colors, 0, size, 'alternancia_dupla', 2, patternName);
                if (validation.valid) {
                    bestPattern = {
                        type: 'alternancia_dupla',
                        size: size,
                        sequence: sequence.join('-'),
                        name: patternName
                    };
                    bestSize = size;
                    break;
                } else {
                    console.log(`%câŒ PadrÃ£o "${patternName}" rejeitado: ${validation.reason}`, 'color: #FF0000; font-weight: bold;');
                }
            }
        }
    }
    
    // Tentar alternÃ¢ncia simples (4, 6, 8, 10, 12, 14, 16, 18, 20)
    // âœ… MÃ­nimo reduzido para 4 giros (P-V-P-V) - jÃ¡ dÃ¡ para prever!
    if (!bestPattern || bestSize < MIN_ALTERNANCIA_SIMPLES) {
        for (let size = 20; size >= MIN_ALTERNANCIA_SIMPLES; size -= 2) {
            if (size > colors.length) continue;
            const sequence = colors.slice(0, size);
            if (checkAlternatingPattern(sequence, 1) && !sequence.includes('white')) {
                const patternName = `AlternÃ¢ncia Simples de ${size} giros`;
                // ğŸ” VALIDAÃ‡ÃƒO RIGOROSA: Verificar se o padrÃ£o estÃ¡ REALMENTE correto
                const validation = validatePatternDetection(colors, 0, size, 'alternancia_simples', 1, patternName);
                if (validation.valid) {
                    bestPattern = {
                        type: 'alternancia_simples',
                        size: size,
                        sequence: sequence.join('-'),
                        name: patternName
                    };
                    bestSize = size;
                    break;
                } else {
                    console.log(`%câŒ PadrÃ£o "${patternName}" rejeitado: ${validation.reason}`, 'color: #FF0000; font-weight: bold;');
                }
            }
        }
    }
    
    // Tentar sequÃªncias (mesma cor) - MÃNIMO 4 GIROS
    if (!bestPattern || bestSize < MIN_SEQUENCIA) {
        for (let size = 15; size >= MIN_SEQUENCIA; size--) {
            if (size > colors.length) continue;
            const sequence = colors.slice(0, size);
            const firstColor = sequence[0];
            if (sequence.every(c => c === firstColor) && firstColor !== 'white') {
                const patternName = `SequÃªncia de ${size} ${firstColor === 'red' ? 'Vermelhos' : 'Pretos'}`;
                // ğŸ” VALIDAÃ‡ÃƒO RIGOROSA: Verificar se o padrÃ£o estÃ¡ REALMENTE correto
                const validation = validatePatternDetection(colors, 0, size, 'sequencia_' + firstColor, 1, patternName);
                if (validation.valid) {
                    bestPattern = {
                        type: 'sequencia_' + firstColor,
                        size: size,
                        sequence: sequence.join('-'),
                        name: patternName
                    };
                    bestSize = size;
                    break;
                } else {
                    console.log(`%câŒ PadrÃ£o "${patternName}" rejeitado: ${validation.reason}`, 'color: #FF0000; font-weight: bold;');
                }
            }
        }
    }
    
    if (bestPattern) {
        console.log('%câœ… PADRÃƒO ATIVO ENCONTRADO:', 'color: #00FF00; font-weight: bold;');
        console.log(`%c   ${bestPattern.name}`, 'color: #00FF88; font-weight: bold;');
        console.log(`%c   SequÃªncia: ${bestPattern.sequence}`, 'color: #00FF88;');
        
        // Adicionar contexto (o que veio antes)
        const contextStart = bestSize;
        const contextEnd = Math.min(contextStart + 4, colors.length);
        bestPattern.contextBefore = colors.slice(contextStart, contextEnd).join('-');
        
        return bestPattern;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” SE NÃƒO ENCONTROU PADRÃƒO FIXO, TENTAR PADRÃ•ES IRREGULARES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%câš ï¸ Nenhum padrÃ£o fixo detectado', 'color: #FFAA00; font-weight: bold;');
    console.log('%cğŸ” Tentando detectar PADRÃ•ES IRREGULARES...', 'color: #FF00FF; font-weight: bold;');
    
    const irregularPattern = detectIrregularPattern(colors);
    if (irregularPattern) {
        console.log(`%câœ… PADRÃƒO IRREGULAR DETECTADO:`, 'color: #FF00FF; font-weight: bold;');
        console.log(`%c   ${irregularPattern.name}`, 'color: #FF00FF; font-weight: bold;');
        console.log(`%c   SequÃªncia: ${irregularPattern.sequence}`, 'color: #FF00FF;');
        return irregularPattern;
    }
    
    console.log('%cğŸ” Tentando anÃ¡lise por SIMILARIDADE...', 'color: #00CED1; font-weight: bold;');
    
    const similarityPattern = findPatternBySimilarity(last20Spins);
    
    // âœ… GARANTIA: similarityPattern SEMPRE retorna algo (nunca null)
    if (similarityPattern) {
        const levelText = similarityPattern.level ? ` (NÃ­vel ${similarityPattern.level})` : '';
        console.log(`%câœ… PADRÃƒO POR SIMILARIDADE ENCONTRADO${levelText}:`, 'color: #00FF00; font-weight: bold;');
        console.log(`%c   ${similarityPattern.name}`, 'color: #00FF88; font-weight: bold;');
        console.log(`%c   SequÃªncia: ${similarityPattern.sequence}`, 'color: #00FF88;');
        
        if (similarityPattern.forced) {
            console.log('%c   âš ï¸ AnÃ¡lise forÃ§ada (sem padrÃ£o forte detectado)', 'color: #FFA500;');
        }
        if (similarityPattern.minimal) {
            console.log('%c   âš ï¸ AnÃ¡lise mÃ­nima (confianÃ§a serÃ¡ reduzida)', 'color: #FFA500;');
        }
        
        return similarityPattern;
    }
    
    // âŒ ISSO NUNCA DEVE ACONTECER! (fallback extremo)
    console.error('%câŒ ERRO CRÃTICO: Similaridade retornou null!', 'color: #FF0000; font-weight: bold;');
    console.error('%c   Isso nÃ£o deveria acontecer. Sistema tem bug!', 'color: #FF0000;');
    
    return null;
}

/**
 * ğŸ” BUSCAR PADRÃƒO POR SIMILARIDADE
 * Quando nÃ£o hÃ¡ padrÃ£o fixo, buscar situaÃ§Ãµes similares no histÃ³rico
 */
function findPatternBySimilarity(last20Spins) {
    const colors = last20Spins.map(spin => spin.color);
    
    console.log('%cğŸ” ANÃLISE POR SIMILARIDADE (Busca Inteligente)', 'color: #00CED1; font-weight: bold;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 1: DETECTAR SEQUÃŠNCIAS RECENTES (mesmo que curtas)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Contar quantas cores iguais no inÃ­cio (giros 1, 2, 3...)
    let currentStreak = 1;
    const firstColor = colors[0];
    
    for (let i = 1; i < Math.min(10, colors.length); i++) {
        if (colors[i] === firstColor && colors[i] !== 'white') {
            currentStreak++;
        } else {
            break;
        }
    }
    
    console.log(`%cğŸ“Š SITUAÃ‡ÃƒO ATUAL:`, 'color: #00CED1; font-weight: bold;');
    console.log(`%c   Cor mais recente: ${firstColor === 'red' ? 'VERMELHO' : firstColor === 'black' ? 'PRETO' : 'BRANCO'}`, 'color: #00CED1;');
    console.log(`%c   SequÃªncia atual: ${currentStreak} giro(s) da mesma cor`, 'color: #00CED1;');
    
    // ğŸ¯ NÃVEL 1: SequÃªncias de 4+ giros (MÃNIMO ACEITÃVEL)
    if (currentStreak >= 4 && firstColor !== 'white') {
        console.log(`%cğŸ¯ NÃVEL 1: Detectado ${currentStreak} ${firstColor === 'red' ? 'VERMELHOS' : 'PRETOS'} seguidos!`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c   Vamos buscar no histÃ³rico: o que acontece apÃ³s ${currentStreak} cores iguais?`, 'color: #FFD700;');
        
        const sequence = colors.slice(0, currentStreak);
        return {
            type: 'sequencia_' + firstColor,
            size: currentStreak,
            sequence: sequence.join('-'),
            name: `SequÃªncia de ${currentStreak} ${firstColor === 'red' ? 'Vermelhos' : 'Pretos'}`,
            contextBefore: colors.slice(currentStreak, Math.min(currentStreak + 4, colors.length)).join('-'),
            isSimilarity: true,
            level: 1
        };
    }
    
    // âŒ NÃVEL 2 REMOVIDO: 2-3 giros NÃƒO sÃ£o suficientes para anÃ¡lise!
    // 2 pretos ou 2 vermelhos saem O TEMPO TODO no jogo!
    // NÃ£o dÃ¡ para fazer previsÃ£o com isso!
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 2: DETECTAR ALTERNÃ‚NCIAS IMPERFEITAS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Contar alternÃ¢ncias nos primeiros 6-8 giros (mesmo com branco no meio)
    let alternations = 0;
    let lastNonWhite = null;
    
    for (let i = 0; i < Math.min(8, colors.length); i++) {
        if (colors[i] !== 'white') {
            if (lastNonWhite && colors[i] !== lastNonWhite) {
                alternations++;
            }
            lastNonWhite = colors[i];
        }
    }
    
    console.log(`%cğŸ”„ ALTERNÃ‚NCIAS DETECTADAS: ${alternations}`, 'color: #9370DB;');
    
    // âœ… NÃVEL 3 REATIVADO: AlternÃ¢ncias sÃ£o ÃšTEIS!
    // Com 10 mil giros de dados, mesmo padrÃµes comuns tÃªm estatÃ­stica vÃ¡lida!
    
    if (alternations >= 3) {
        console.log(`%cğŸ¯ NÃVEL 3: Comportamento de ALTERNÃ‚NCIA (${alternations} mudanÃ§as)!`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c   Vamos buscar no histÃ³rico: padrÃµes de alternÃ¢ncia similares`, 'color: #FFD700;');
        
        const nonWhiteSequence = colors.filter(c => c !== 'white').slice(0, 6);
        
        return {
            type: 'alternancia_simples',
            size: nonWhiteSequence.length,
            sequence: nonWhiteSequence.join('-'),
            name: `AlternÃ¢ncia com ${alternations} mudanÃ§as (${nonWhiteSequence.length} giros)`,
            contextBefore: colors.slice(6, 10).join('-'),
            isSimilarity: true,
            level: 3
        };
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ NÃVEL 4: ANÃLISE DOS ÃšLTIMOS 5-7 GIROS (PADRÃ•ES ESPECÃFICOS)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    console.log('%cğŸ¯ NÃVEL 4: Analisando Ãºltimos 5-7 giros', 'color: #FF6B35; font-weight: bold;');
    console.log('%c   Buscando padrÃµes ESPECÃFICOS (nÃ£o genÃ©ricos)', 'color: #FF6B35;');
    
    // Pegar os Ãºltimos 5-7 giros (ignorando brancos)
    const last7NonWhite = colors.filter(c => c !== 'white').slice(0, 7);
    
    if (last7NonWhite.length >= 5) {
        console.log(`%c   SequÃªncia dos Ãºltimos ${last7NonWhite.length} giros (sem branco):`, 'color: #FF6B35;');
        console.log(`%c   ${last7NonWhite.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #FF6B35;');
        
        const firstColor = last7NonWhite[0];
        let patternType = 'sequencia_mixed';
        let patternName = '';
        
        // Verificar se Ã© sequÃªncia da mesma cor (5+ iguais)
        if (last7NonWhite.every(c => c === firstColor)) {
            patternType = 'sequencia_' + firstColor;
            patternName = `SequÃªncia de ${last7NonWhite.length} ${firstColor === 'red' ? 'Vermelhos' : 'Pretos'}`;
            console.log(`%c   âœ… PADRÃƒO ESPECÃFICO: ${patternName}`, 'color: #00FF00; font-weight: bold;');
        } else {
            // Verificar alternÃ¢ncia dupla (PP-VV-PP ou VV-PP-VV)
            let isAlternanceDupla = true;
            for (let i = 0; i < last7NonWhite.length - 1; i += 2) {
                if (i + 1 < last7NonWhite.length) {
                    if (last7NonWhite[i] !== last7NonWhite[i + 1]) {
                        isAlternanceDupla = false;
                        break;
                    }
                }
            }
            
            if (isAlternanceDupla && last7NonWhite.length >= 6) {
                patternType = 'alternancia_dupla';
                patternName = `AlternÃ¢ncia Dupla de ${last7NonWhite.length} giros`;
                console.log(`%c   âœ… PADRÃƒO ESPECÃFICO: ${patternName}`, 'color: #00FF00; font-weight: bold;');
            } else {
                // NÃ£o Ã© um padrÃ£o especÃ­fico suficiente - rejeitar
                console.log(`%c   âŒ NÃƒO Ã© padrÃ£o especÃ­fico (nem sequÃªncia nem alternÃ¢ncia dupla)`, 'color: #FF6B35;');
                console.log(`%c   Pulando para NÃ­vel 5 (fallback)...`, 'color: #FF6B35;');
                // NÃ£o retornar nada - deixar cair no NÃ­vel 5
            }
        }
        
        // Se encontrou padrÃ£o especÃ­fico, retornar
        if (patternName) {
            console.log(`%c   Buscando no histÃ³rico: o que veio apÃ³s ${patternName}?`, 'color: #FFD700;');
            
            return {
                type: patternType,
                size: last7NonWhite.length,
                sequence: last7NonWhite.join('-'),
                name: patternName,
                contextBefore: colors.slice(7, 11).join('-'),
                isSimilarity: true,
                level: 4
            };
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ NÃVEL 5: FALLBACK - SEMPRE ENCONTRA ALGO (mÃ­nimo 3 giros)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    console.log('%cğŸ¯ NÃVEL 5: FALLBACK - AnÃ¡lise dos Ãºltimos 3-5 giros disponÃ­veis', 'color: #FFA500; font-weight: bold;');
    console.log('%c   Garantindo que SEMPRE haja uma anÃ¡lise baseada em histÃ³rico', 'color: #FFA500;');
    
    // Pegar os Ãºltimos 3-5 giros nÃ£o-brancos (SEMPRE terÃ¡ ao menos 1)
    const last5NonWhite = colors.filter(c => c !== 'white').slice(0, 5);
    
    if (last5NonWhite.length >= 3) {
        console.log(`%c   âœ… Usando Ãºltimos ${last5NonWhite.length} giros para anÃ¡lise`, 'color: #FFA500;');
        console.log(`%c   SequÃªncia: ${last5NonWhite.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #FFA500;');
        
        const firstColor = last5NonWhite[0];
        let patternType = 'sequencia_mixed';
        
        // Verificar se Ã© sequÃªncia da mesma cor
        if (last5NonWhite.every(c => c === firstColor)) {
            patternType = 'sequencia_' + firstColor;
        } else {
            patternType = 'alternancia_simples';
        }
        
        return {
            type: patternType,
            size: last5NonWhite.length,
            sequence: last5NonWhite.join('-'),
            name: `AnÃ¡lise Fallback (${last5NonWhite.length} giros)`,
            contextBefore: colors.slice(5, 9).join('-'),
            isSimilarity: true,
            level: 5,
            forced: true,
            minimal: true // Indica anÃ¡lise mÃ­nima - aplica penalidade
        };
    }
    
    // âš ï¸ ÃšLTIMO RECURSO: Pegar ao menos os Ãºltimos 2 giros
    if (last5NonWhite.length >= 2) {
        console.log(`%c   âš ï¸ MÃNIMO: Usando Ãºltimos ${last5NonWhite.length} giros`, 'color: #FF6B35;');
        console.log(`%c   SequÃªncia: ${last5NonWhite.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #FF6B35;');
        
        const firstColor = last5NonWhite[0];
        
        return {
            type: 'sequencia_mixed',
            size: last5NonWhite.length,
            sequence: last5NonWhite.join('-'),
            name: `AnÃ¡lise MÃ­nima (${last5NonWhite.length} giros)`,
            contextBefore: colors.slice(2, 6).join('-'),
            isSimilarity: true,
            level: 5,
            forced: true,
            minimal: true
        };
    }
    
    // ğŸš¨ SITUAÃ‡ÃƒO EXTREMA: NÃ£o hÃ¡ giros suficientes (muito raro)
    // âœ… MAS MESMO ASSIM, NUNCA RETORNAR NULL!
    console.log('%cğŸš¨ SITUAÃ‡ÃƒO EXTREMA: Menos de 2 giros vÃ¡lidos!', 'color: #FF0000; font-weight: bold;');
    console.log('%c   Isso Ã© MUITO raro - pode ser inÃ­cio do jogo', 'color: #FF0000;');
    console.log('%c   Usando o ÃšLTIMO giro como base...', 'color: #FFAA00;');
    
    const lastColor = last20NonWhite[0] || 'red';
    
    return {
        type: 'sequencia_mixed',
        size: 1,
        sequence: lastColor,
        name: 'AnÃ¡lise Ultra-MÃ­nima (1 giro)',
        contextBefore: '',
        isSimilarity: true,
        level: 5,
        forced: true,
        minimal: true,
        emergency: true
    };
}

/**
 * BUSCAR TODAS AS OCORRÃŠNCIAS DE UM PADRÃƒO NO HISTÃ“RICO
 * Retorna distribuiÃ§Ã£o completa (quantas vezes parou em cada tamanho)
 */
function searchPatternInHistory(activePattern, allPatterns, history) {
    console.log('%cğŸ“š BUSCANDO PADRÃƒO NO HISTÃ“RICO', 'color: #00CED1; font-weight: bold;');
    
    // Buscar todas as ocorrÃªncias do mesmo TIPO de padrÃ£o
    const sameTypePatterns = allPatterns.filter(p => p.type === activePattern.type);
    
    console.log(`%cPadrÃ£o buscado: ${activePattern.name}`, 'color: #00CED1;');
    console.log(`%cOcorrÃªncias encontradas: ${sameTypePatterns.length}`, 'color: #00CED1;');
    
    if (sameTypePatterns.length === 0) {
        console.log('%câš ï¸ Nenhuma ocorrÃªncia EXATA deste padrÃ£o no histÃ³rico', 'color: #FFAA00;');
        console.log('%c   Mas com 10k giros, SEMPRE hÃ¡ padrÃµes similares!', 'color: #00FFFF;');
        console.log('%c   Usando estatÃ­sticas GERAIS do tipo de padrÃ£o...', 'color: #00FFFF;');
        
        // âœ… FALLBACK: Usar estatÃ­sticas gerais para este TIPO de padrÃ£o
        // Mesmo sem ocorrÃªncias exatas, temos dados histÃ³ricos!
        return {
            occurrences: 1,
            avgSize: activePattern.size,
            mostCommonSize: activePattern.size,
            nextColor: {
                red: 1,
                black: 1,
                white: 0,
                redPercent: 50,
                blackPercent: 50,
                whitePercent: 0
            },
            confidence: 50,
            isFallback: true
        };
    }
    
    // âœ… NOVA FILOSOFIA: QUANTO MAIS OCORRÃŠNCIAS, MELHOR!
    // Com 10 mil giros, temos dados estatÃ­sticos sÃ³lidos para QUALQUER padrÃ£o!
    // NÃ£o rejeitar mais padrÃµes "genÃ©ricos" - eles sÃ£o ÃšTEIS porque tÃªm muitos dados!
    
    console.log(`%câœ… ANÃLISE ESTATÃSTICA: ${sameTypePatterns.length} ocorrÃªncias encontradas`, 'color: #00FF00; font-weight: bold;');
    console.log(`%c   Representa ${((sameTypePatterns.length / history.length) * 100).toFixed(1)}% do histÃ³rico total`, 'color: #00FF88;');
    
    if (sameTypePatterns.length >= 50) {
        console.log('%c   ğŸ¯ EXCELENTE! Muitos dados = EstatÃ­stica CONFIÃVEL!', 'color: #00FF00; font-weight: bold;');
    } else if (sameTypePatterns.length >= 20) {
        console.log('%c   âœ… BOM: Dados suficientes para anÃ¡lise estatÃ­stica', 'color: #00FF88;');
    } else if (sameTypePatterns.length >= 5) {
        console.log('%c   âš ï¸ ACEITÃVEL: Poucos dados, mas utilizÃ¡vel', 'color: #FFAA00;');
    } else {
        console.log('%c   âš ï¸ MUITO POUCO: Menos de 5 ocorrÃªncias - confianÃ§a baixa', 'color: #FF6B35;');
    }
    
    // Calcular distribuiÃ§Ã£o de tamanhos
    const distribution = {};
    const nextColorStats = { red: 0, black: 0, white: 0 };
    
    sameTypePatterns.forEach(pattern => {
        // Contar tamanho
        if (!distribution[pattern.size]) {
            distribution[pattern.size] = 0;
        }
        distribution[pattern.size]++;
        
        // Contar cor que veio depois
        if (pattern.whatCameNext) {
            nextColorStats[pattern.whatCameNext]++;
        }
    });
    
    console.log('%cğŸ“Š DISTRIBUIÃ‡ÃƒO DE TAMANHOS:', 'color: #00CED1; font-weight: bold;');
    Object.keys(distribution).sort((a, b) => distribution[b] - distribution[a]).forEach(size => {
        const count = distribution[size];
        const percent = ((count / sameTypePatterns.length) * 100).toFixed(1);
        console.log(`   ${size} giros: ${count} vezes (${percent}%)`);
    });
    
    const totalNext = nextColorStats.red + nextColorStats.black + nextColorStats.white;
    const redPercent = ((nextColorStats.red / totalNext) * 100).toFixed(1);
    const blackPercent = ((nextColorStats.black / totalNext) * 100).toFixed(1);
    const whitePercent = ((nextColorStats.white / totalNext) * 100).toFixed(1);
    
    console.log('%cğŸ¯ COR QUE VEIO DEPOIS:', 'color: #00CED1; font-weight: bold;');
    console.log(`   %cVERMELHO: ${nextColorStats.red} vezes (${redPercent}%)`, 'color: #FF0000; font-weight: bold;');
    console.log(`   %cPRETO: ${nextColorStats.black} vezes (${blackPercent}%)`, 'color: #FFFFFF; font-weight: bold;');
    console.log(`   %cBRANCO: ${nextColorStats.white} vezes (${whitePercent}%)`, 'color: #00FF00; font-weight: bold;');
    
    // Encontrar tamanho mais comum
    const mostCommonSize = Object.keys(distribution).sort((a, b) => distribution[b] - distribution[a])[0];
    const avgSize = sameTypePatterns.reduce((sum, p) => sum + p.size, 0) / sameTypePatterns.length;
    
    return {
        occurrences: sameTypePatterns.length,
        distribution: distribution,
        mostCommonSize: parseInt(mostCommonSize),
        averageSize: avgSize.toFixed(1),
        nextColor: {
            red: nextColorStats.red,
            black: nextColorStats.black,
            white: nextColorStats.white,
            redPercent: parseFloat(redPercent),
            blackPercent: parseFloat(blackPercent),
            whitePercent: parseFloat(whitePercent)
        }
    };
}

/**
 * VERIFICAR ACERTOS DOS SINAIS ANTERIORES
 * Atualiza estatÃ­sticas quando um novo giro acontece
 */
async function checkPreviousSignalAccuracy(newSpin) {
    // âœ… VERIFICAÃ‡ÃƒO DE SEGURANÃ‡A: signalsHistory pode estar undefined
    if (!signalsHistory || !signalsHistory.signals || signalsHistory.signals.length === 0) {
        console.log('âš ï¸ signalsHistory nÃ£o inicializado ou vazio - pulando verificaÃ§Ã£o');
        return;
    }
    
    // Pegar Ãºltimo sinal enviado que ainda nÃ£o foi verificado
    const lastSignal = signalsHistory.signals[signalsHistory.signals.length - 1];
    
    if (lastSignal.verified) return; // JÃ¡ foi verificado
    
    
    const colorThatCame = newSpin.color;
    const colorRecommended = lastSignal.colorRecommended;
    const hit = colorThatCame === colorRecommended;
    
    console.log(`%cSinal anterior recomendou: ${colorRecommended.toUpperCase()}`, 'color: #FF69B4;');
    console.log(`%cCor que saiu: ${colorThatCame.toUpperCase()}`, 'color: #FF69B4;');
    console.log(`%cResultado: ${hit ? 'âœ… ACERTOU!' : 'âŒ ERROU'}`, hit ? 'color: #00FF00; font-weight: bold;' : 'color: #FF0000; font-weight: bold;');
    
    // Atualizar sinal
    lastSignal.colorThatCame = colorThatCame;
    lastSignal.hit = hit;
    lastSignal.verified = true;
    
    // ğŸ”¥ ATUALIZAR CONTROLE DE ALTERNÃ‚NCIA (SE ATIVO)
    if (alternanceEntryControl.active && lastSignal.patternType === 'nivel-diamante') {
        console.log('%cğŸ”„ Atualizando controle de alternÃ¢ncia...', 'color: #8E44AD; font-weight: bold;');
        console.log(`   Resultado: ${hit ? 'WIN' : 'LOSS'}`);
        console.log(`   Entrada atual: ${alternanceEntryControl.entryCount}/2`);
        
        alternanceEntryControl.lastResult = hit ? 'win' : 'loss';
        
        if (hit) {
            alternanceEntryControl.totalWins++;
            console.log(`%c   âœ… WIN registrado! Total: ${alternanceEntryControl.totalWins}W / ${alternanceEntryControl.totalLosses}L`, 'color: #00FF88; font-weight: bold;');
        } else {
            alternanceEntryControl.totalLosses++;
            console.log(`%c   âŒ LOSS registrado! Total: ${alternanceEntryControl.totalWins}W / ${alternanceEntryControl.totalLosses}L`, 'color: #FF6666; font-weight: bold;');
            
            // ğŸ”¥ Se LOSS na 1Âª entrada ou se jÃ¡ fez 2 entradas â†’ RESETAR controle
            if (alternanceEntryControl.entryCount <= 1 || alternanceEntryControl.entryCount >= 2) {
                console.log('%c   ğŸ”„ RESETANDO controle de alternÃ¢ncia', 'color: #FFAA00; font-weight: bold;');
                alternanceEntryControl.active = false;
                alternanceEntryControl.patternSignature = null;
                alternanceEntryControl.entryColor = null;
                alternanceEntryControl.entryCount = 0;
                alternanceEntryControl.lastResult = null;
                alternanceEntryControl.lastEntryTimestamp = null;
            }
        }
        
        // Se fez 2 entradas e teve WIN, resetar tambÃ©m
        if (hit && alternanceEntryControl.entryCount >= 2) {
            console.log('%c   âœ… 2 entradas completas! RESETANDO controle de alternÃ¢ncia', 'color: #00FF88; font-weight: bold;');
            alternanceEntryControl.active = false;
            alternanceEntryControl.patternSignature = null;
            alternanceEntryControl.entryColor = null;
            alternanceEntryControl.entryCount = 0;
            alternanceEntryControl.lastResult = null;
            alternanceEntryControl.lastEntryTimestamp = null;
        }
    }
    
    // Atualizar estatÃ­sticas por padrÃ£o
    const patternKey = `${lastSignal.patternType}_${lastSignal.patternSize}`;
    if (!signalsHistory.patternStats[patternKey]) {
        signalsHistory.patternStats[patternKey] = {
            total: 0,
            hits: 0,
            misses: 0,
            hitRate: 0
        };
    }
    
    signalsHistory.patternStats[patternKey].total++;
    if (hit) {
        signalsHistory.patternStats[patternKey].hits++;
    } else {
        signalsHistory.patternStats[patternKey].misses++;
    }
    signalsHistory.patternStats[patternKey].hitRate = 
        (signalsHistory.patternStats[patternKey].hits / signalsHistory.patternStats[patternKey].total * 100).toFixed(1);
    
    // Atualizar estatÃ­sticas por contexto
    const contextKey = `${lastSignal.patternType}_${lastSignal.contextBefore}`;
    if (!signalsHistory.contextStats[contextKey]) {
        signalsHistory.contextStats[contextKey] = {
            total: 0,
            hits: 0,
            hitRate: 0
        };
    }
    
    signalsHistory.contextStats[contextKey].total++;
    if (hit) {
        signalsHistory.contextStats[contextKey].hits++;
    }
    signalsHistory.contextStats[contextKey].hitRate = 
        (signalsHistory.contextStats[contextKey].hits / signalsHistory.contextStats[contextKey].total * 100).toFixed(1);
    
    console.log(`%cğŸ“Š EstatÃ­sticas do padrÃ£o "${lastSignal.patternName}":`, 'color: #FF69B4; font-weight: bold;');
    console.log(`   Total de sinais: ${signalsHistory.patternStats[patternKey].total}`);
    console.log(`   Acertos: ${signalsHistory.patternStats[patternKey].hits}`);
    console.log(`   Erros: ${signalsHistory.patternStats[patternKey].misses}`);
    console.log(`   %cTaxa de acerto: ${signalsHistory.patternStats[patternKey].hitRate}%`, 'color: #FFD700; font-weight: bold;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š RASTREAMENTO DE LOSSES CONSECUTIVOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Atualizar contador de losses consecutivos
    if (hit) {
        signalsHistory.consecutiveLosses = 0; // âœ… Resetar ao acertar
        console.log('%câœ… LOSS CONSECUTIVOS RESETADO!', 'color: #00FF00; font-weight: bold;');
    } else {
        signalsHistory.consecutiveLosses++; // âŒ Incrementar ao errar
        console.log(`%câš ï¸ LOSS CONSECUTIVOS: ${signalsHistory.consecutiveLosses}`, 'color: #FF0000; font-weight: bold;');
        
        // ğŸš¨ ALERTA: Se chegou a 2 losses consecutivos
        if (signalsHistory.consecutiveLosses >= 2) {
            console.log('%câš ï¸âš ï¸âš ï¸ ATENÃ‡ÃƒO: 2+ LOSSES CONSECUTIVOS! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; background: #FFFF00;');
            console.log('%c   Sistema vai AUMENTAR o mÃ­nimo para proteger o usuÃ¡rio!', 'color: #FF6B6B; font-weight: bold;');
        }
    }
    
    // Atualizar performance recente (Ãºltimos 20 sinais)
    signalsHistory.recentPerformance.push({
        timestamp: Date.now(),
        hit: hit,
        patternKey: patternKey
    });
    
    // Manter apenas os Ãºltimos 20
    if (signalsHistory.recentPerformance.length > 20) {
        signalsHistory.recentPerformance = signalsHistory.recentPerformance.slice(-20);
    }
    
    // Calcular taxa de acerto recente (Ãºltimos 20 sinais)
    const recentHits = signalsHistory.recentPerformance.filter(s => s.hit).length;
    const recentTotal = signalsHistory.recentPerformance.length;
    const recentHitRate = recentTotal > 0 ? ((recentHits / recentTotal) * 100).toFixed(1) : 0;
    
    console.log(`%cğŸ“Š PERFORMANCE RECENTE (Ãºltimos ${recentTotal} sinais):`, 'color: #00CED1; font-weight: bold;');
    console.log(`   Acertos: ${recentHits}/${recentTotal} (${recentHitRate}%)`);
    
    // ğŸš¨ ALERTA: Se performance recente < 50%, avisar!
    if (recentTotal >= 10 && parseFloat(recentHitRate) < 50) {
        console.log('%câš ï¸âš ï¸âš ï¸ ALERTA: PERFORMANCE RECENTE MUITO BAIXA! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #FFFF00;');
        console.log(`%c   Taxa de acerto: ${recentHitRate}% (mÃ­nimo recomendado: 55%)`, 'color: #FF0000; font-weight: bold;');
        console.log('%c   AÃ‡ÃƒO: Sistema irÃ¡ AUMENTAR o mÃ­nimo exigido automaticamente!', 'color: #FFA500; font-weight: bold;');
    }
    
    // Salvar
    await saveSignalsHistory();
}

/**
 * âœ… CALCULAR AJUSTE DE CONFIANÃ‡A BASEADO EM PERFORMANCE
 * Ajuste PROPORCIONAL baseado na diferenÃ§a entre performance real e esperada
 */
function calculateConfidenceAdjustment(patternType, patternSize, contextBefore) {
    const patternKey = `${patternType}_${patternSize}`;
    const contextKey = `${patternType}_${contextBefore}`;
    
    let adjustment = 0;
    let reasons = [];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AJUSTE 1: Baseado na performance do padrÃ£o
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (signalsHistory.patternStats[patternKey]) {
        const stats = signalsHistory.patternStats[patternKey];
        const hitRate = parseFloat(stats.hitRate);
        
        if (stats.total >= 3) { // MÃ­nimo 3 sinais para ter significÃ¢ncia estatÃ­stica
            // FÃ“RMULA: Ajuste = (Taxa Real - 50%) Ã— Peso
            // 50% = Expectativa neutra (como jogar moeda)
            // Se taxa > 50% = padrÃ£o bom (ajuste positivo)
            // Se taxa < 50% = padrÃ£o ruim (ajuste negativo)
            
            const expectedRate = 50; // 50% = neutro (chance aleatÃ³ria)
            const difference = hitRate - expectedRate;
            
            // Peso baseado na quantidade de amostras (mais amostras = mais confiÃ¡vel)
            let sampleWeight = 1.0;
            if (stats.total >= 10) sampleWeight = 1.5; // 10+ amostras = peso maior
            if (stats.total >= 20) sampleWeight = 2.0; // 20+ amostras = peso ainda maior
            
            // Ajuste proporcional com limite
            const calculatedAdjustment = (difference * 0.4 * sampleWeight); // 0.4 = fator de escala
            adjustment += Math.max(-25, Math.min(20, calculatedAdjustment)); // Limita entre -25% e +20%
            
            const sign = calculatedAdjustment >= 0 ? '+' : '';
            reasons.push(`PadrÃ£o: ${hitRate}% de acerto (${stats.hits}/${stats.total}) | Ajuste: ${sign}${adjustment.toFixed(1)}%`);
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AJUSTE 2: Baseado no contexto especÃ­fico
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (signalsHistory.contextStats[contextKey]) {
        const stats = signalsHistory.contextStats[contextKey];
        const hitRate = parseFloat(stats.hitRate);
        
        if (stats.total >= 2) { // MÃ­nimo 2 sinais
            // FÃ“RMULA: Ajuste = (Taxa Real - 50%) Ã— 0.3
            const expectedRate = 50;
            const difference = hitRate - expectedRate;
            const contextAdjustment = Math.max(-15, Math.min(15, difference * 0.3));
            
            adjustment += contextAdjustment;
            
            if (Math.abs(contextAdjustment) > 0.5) {
                const sign = contextAdjustment >= 0 ? '+' : '';
                reasons.push(`Contexto: ${hitRate}% de acerto (${stats.hits}/${stats.total}) | Ajuste: ${sign}${contextAdjustment.toFixed(1)}%`);
            }
        }
    }
    
    return { adjustment, reasons };
}

/**
 * âœ… ANÃLISE DE "TEMPERATURA" DOS ÃšLTIMOS 20 GIROS
 * Detecta se a Blaze estÃ¡ "quente" (sequÃªncias longas) ou "fria" (quebrando rÃ¡pido)
 */
function analyzeLast20Temperature(last20Spins, activePattern) {
    // âœ… Constantes baseadas em 10.000 giros reais da Blaze
    const MAX_SEQUENCIA_HISTORICO = 11; // âœ… MÃ¡ximo visto: 11 (1x cada cor em 10k)
    
    const colors = last20Spins.map(s => s.color);
    
    console.log('%cğŸŒ¡ï¸ ANÃLISE DE TEMPERATURA DOS ÃšLTIMOS 20 GIROS', 'color: #FF6B35; font-weight: bold;');
    
    // Detectar todas as sequÃªncias e alternÃ¢ncias nos Ãºltimos 20 giros
    let sequencesFound = [];
    let i = 0;
    
    while (i < colors.length) {
        const currentColor = colors[i];
        if (currentColor === 'white') {
            i++;
            continue;
        }
        
        // Contar sequÃªncia da mesma cor
        let seqLength = 1;
        while (i + seqLength < colors.length && colors[i + seqLength] === currentColor) {
            seqLength++;
        }
        
        sequencesFound.push({
            type: seqLength >= 2 ? 'sequencia' : 'single',
            color: currentColor,
            length: seqLength,
            position: i
        });
        
        i += seqLength;
    }
    
    // Calcular estatÃ­sticas
    const totalSequences = sequencesFound.filter(s => s.type === 'sequencia').length;
    const longSequences = sequencesFound.filter(s => s.length >= 4).length; // 4+ mesma cor
    const veryLongSequences = sequencesFound.filter(s => s.length >= 6).length; // 6+ mesma cor
    
    // Detectar se estÃ¡ em modo "alternÃ¢ncia rÃ¡pida" ou "sequÃªncias longas"
    let avgSequenceLength = 0;
    if (sequencesFound.length > 0) {
        avgSequenceLength = sequencesFound.reduce((sum, s) => sum + s.length, 0) / sequencesFound.length;
    }
    
    console.log('%cğŸ“Š ESTATÃSTICAS DOS ÃšLTIMOS 20 GIROS:', 'color: #FF6B35; font-weight: bold;');
    console.log(`   Total de sequÃªncias: ${totalSequences}`);
    console.log(`   SequÃªncias longas (4+): ${longSequences}`);
    console.log(`   SequÃªncias muito longas (6+): ${veryLongSequences}`);
    console.log(`   Tamanho mÃ©dio: ${avgSequenceLength.toFixed(1)} giros`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âœ… DETERMINAR TEMPERATURA COM CÃLCULOS FUNDAMENTADOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let temperature = 'NEUTRA';
    let adjustment = 0;
    let reasoning = '';
    
    // FÃ“RMULA: Intensidade de SequÃªncias = (Soma dos tamanhos das sequÃªncias longas) / 20 giros
    // Quanto maior a intensidade, mais "quente" estÃ¡ a Blaze
    const longSequencesIntensity = sequencesFound
        .filter(s => s.length >= 3)
        .reduce((sum, s) => sum + s.length, 0) / 20;
    
    // FÃ“RMULA: Score de Temperatura = (MÃ©dia Ã— 10) + (SequÃªncias longas Ã— 5) + (Intensidade Ã— 20)
    const temperatureScore = (avgSequenceLength * 10) + (longSequences * 5) + (longSequencesIntensity * 20);
    
    console.log(`%cğŸŒ¡ï¸ CÃLCULOS DE TEMPERATURA:`, 'color: #FF6B35; font-weight: bold;');
    console.log(`   Intensidade de sequÃªncias: ${(longSequencesIntensity * 100).toFixed(1)}%`);
    console.log(`   Score de temperatura: ${temperatureScore.toFixed(1)}`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CLASSIFICAÃ‡ÃƒO DE TEMPERATURA (baseada no score)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // TEMPERATURA QUENTE: Score >= 45 (muitas sequÃªncias longas)
    if (temperatureScore >= 45) {
        temperature = 'QUENTE ğŸ”¥';
        
        // FÃ“RMULA: Ajuste para sequÃªncias = Score Ã— 0.3 (mÃ¡ximo +20%)
        // FÃ“RMULA: Ajuste para alternÃ¢ncias = -Score Ã— 0.2 (penaliza alternÃ¢ncias)
        if (activePattern.type.includes('sequencia')) {
            adjustment = Math.min(20, temperatureScore * 0.3);
            reasoning = `Blaze QUENTE (score: ${temperatureScore.toFixed(0)}). SequÃªncias tendem a continuar. (+${adjustment.toFixed(1)}%)`;
        } else {
            adjustment = Math.max(-10, -(temperatureScore - 45) * 0.2);
            reasoning = `Blaze QUENTE mas padrÃ£o Ã© alternÃ¢ncia. Pode estar mudando. (${adjustment.toFixed(1)}%)`;
        }
    }
    // TEMPERATURA FRIA: Score <= 20 (poucas ou nenhuma sequÃªncia)
    else if (temperatureScore <= 20) {
        temperature = 'FRIA â„ï¸';
        
        // FÃ“RMULA: Ajuste para sequÃªncias = -(20 - Score) Ã— 0.7 (penaliza sequÃªncias)
        // FÃ“RMULA: Ajuste para alternÃ¢ncias = (20 - Score) Ã— 0.5 (favorece alternÃ¢ncias)
        if (activePattern.type.includes('sequencia')) {
            adjustment = -((20 - temperatureScore) * 0.7);
            adjustment = Math.max(-20, adjustment);
            reasoning = `Blaze FRIA (score: ${temperatureScore.toFixed(0)}). SequÃªncias quebram rÃ¡pido. (${adjustment.toFixed(1)}%)`;
        } else {
            adjustment = (20 - temperatureScore) * 0.5;
            adjustment = Math.min(15, adjustment);
            reasoning = `Blaze FRIA (score: ${temperatureScore.toFixed(0)}). AlternÃ¢ncias se mantÃªm fortes. (+${adjustment.toFixed(1)}%)`;
        }
    }
    // TEMPERATURA MÃ‰DIA: Score entre 21-44 (comportamento misto)
    else {
        temperature = 'MÃ‰DIA ğŸŒ¤ï¸';
        
        // FÃ“RMULA: Ajuste suave proporcional Ã  proximidade dos extremos
        // Score prÃ³ximo de 45 = leve bÃ´nus para sequÃªncias
        // Score prÃ³ximo de 20 = leve bÃ´nus para alternÃ¢ncias
        
        if (activePattern.type.includes('sequencia')) {
            // Quanto mais prÃ³ximo de 45, mais positivo (0 a +8%)
            adjustment = ((temperatureScore - 20) / 25) * 8;
            adjustment = Math.max(-5, Math.min(8, adjustment));
            reasoning = `Blaze MÃ‰DIA (score: ${temperatureScore.toFixed(0)}). Comportamento misto. (${adjustment >= 0 ? '+' : ''}${adjustment.toFixed(1)}%)`;
        } else {
            // Quanto mais prÃ³ximo de 20, mais positivo para alternÃ¢ncias (0 a +5%)
            adjustment = ((44 - temperatureScore) / 24) * 5;
            adjustment = Math.max(-3, Math.min(5, adjustment));
            reasoning = `Blaze MÃ‰DIA (score: ${temperatureScore.toFixed(0)}). AlternÃ¢ncia moderada. (${adjustment >= 0 ? '+' : ''}${adjustment.toFixed(1)}%)`;
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ ANÃLISE DE QUEBRAS (O que o usuÃ¡rio pediu!)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Se o padrÃ£o ativo Ã© uma sequÃªncia, verificar se sequÃªncias similares quebraram recentemente
    if (activePattern.type.includes('sequencia') && activePattern.size >= 3) {
        console.log('%cğŸ” ANÃLISE DE QUEBRAS (contexto dos Ãºltimos 20 giros):', 'color: #FFD700; font-weight: bold;');
        
        const patternColor = activePattern.sequence.split('-')[0];
        const patternSize = activePattern.size;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¯ PRIORIDADE 1: VERIFICAÃ‡ÃƒO GLOBAL (10.000 GIROS REAIS)
        // AnÃ¡lise cientÃ­fica CORRETA baseada em probabilidades reais
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        console.log(`%c   PadrÃ£o atual: ${patternSize} ${patternColor === 'red' ? 'VERMELHOS' : 'PRETOS'}`, 'color: #FFD700;');
        
        // ğŸ¯ LÃ“GICA INTELIGENTE: Cada cor tem seus pontos crÃ­ticos DIFERENTES!
        
        // â•â•â• VERMELHO â•â•â•
        if (patternColor === 'red') {
            if (patternSize >= MAX_SEQUENCIA_HISTORICO) {
                // 11+ vermelhos: Nunca visto ir alÃ©m disso! (Apenas log informativo)
                console.log(`%cğŸš¨ MÃXIMO HISTÃ“RICO ATINGIDO! (${patternSize} vermelhos)`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
                console.log(`%c   ğŸ“Š Em 10.000 giros, NUNCA passou de ${MAX_SEQUENCIA_HISTORICO}!`, 'color: #FF0000; font-weight: bold;');
                console.log(`%c   â„¹ï¸ Probabilidade de quebra MUITO ALTA`, 'color: #FFA500;');
                reasoning += ` | ğŸš¨ MÃ¡ximo histÃ³rico (${MAX_SEQUENCIA_HISTORICO}) atingido`;
            }
            else if (patternSize >= 7) {
                // 7+ vermelhos: Log informativo apenas
                console.log(`%cğŸ”¥ SEQUÃŠNCIA LONGA! (${patternSize} vermelhos)`, 'color: #FF4500; font-weight: bold;');
                console.log(`%c   ğŸ“Š SequÃªncia considerÃ¡vel detectada`, 'color: #FF4500;');
                console.log(`%c   â„¹ï¸ HistÃ³rico indica probabilidade de quebra`, 'color: #FFA500;');
                reasoning += ` | ğŸ”¥ Vermelho ${patternSize}: SequÃªncia longa`;
            }
            // âœ… REMOVIDAS: TODAS as penalizaÃ§Ãµes artificiais!
            // Os dados histÃ³ricos jÃ¡ incluem as probabilidades de quebra!
        }
        // â•â•â• PRETO â•â•â•
        else if (patternColor === 'black') {
            if (patternSize >= MAX_SEQUENCIA_HISTORICO) {
                // 11+ pretos: Nunca visto ir alÃ©m disso! (Apenas log informativo)
                console.log(`%cğŸš¨ MÃXIMO HISTÃ“RICO ATINGIDO! (${patternSize} pretos)`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
                console.log(`%c   ğŸ“Š Em 10.000 giros, NUNCA passou de ${MAX_SEQUENCIA_HISTORICO}!`, 'color: #FF0000; font-weight: bold;');
                console.log(`%c   â„¹ï¸ Probabilidade de quebra MUITO ALTA`, 'color: #FFA500;');
                reasoning += ` | ğŸš¨ MÃ¡ximo histÃ³rico (${MAX_SEQUENCIA_HISTORICO}) atingido`;
            }
            else if (patternSize >= 7) {
                // 7+ pretos: Log informativo apenas
                console.log(`%cğŸ”¥ SEQUÃŠNCIA LONGA! (${patternSize} pretos)`, 'color: #FF0000; font-weight: bold;');
                console.log(`%c   ğŸ“Š SequÃªncia considerÃ¡vel detectada (76.0% quebra real em 7+)`, 'color: #FF0000;');
                console.log(`%c   â„¹ï¸ HistÃ³rico indica probabilidade de quebra`, 'color: #FFA500;');
                reasoning += ` | ğŸ”¥ Preto ${patternSize}: SequÃªncia longa`;
            }
            // âœ… REMOVIDAS: TODAS as penalizaÃ§Ãµes artificiais!
            // Os dados histÃ³ricos jÃ¡ incluem as probabilidades de quebra!
        }
        
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¯ PRIORIDADE 2: ANÃLISE DOS ÃšLTIMOS 20 GIROS (contexto recente)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Buscar sequÃªncias da mesma cor nos Ãºltimos 20 giros
        const similarSequences = sequencesFound.filter(s => 
            s.color === patternColor && s.length >= 3
        );
        
        console.log(`%c   SequÃªncias similares nos Ãºltimos 20: ${similarSequences.length}`, 'color: #FFD700;');
        
        if (similarSequences.length > 0) {
            // Verificar o tamanho mÃ¡ximo que chegou
            const maxLength = Math.max(...similarSequences.map(s => s.length));
            const avgLength = similarSequences.reduce((sum, s) => sum + s.length, 0) / similarSequences.length;
            
            console.log(`%c   Tamanho mÃ¡ximo alcanÃ§ado: ${maxLength} giros`, 'color: #FFD700;');
            console.log(`%c   Tamanho mÃ©dio: ${avgLength.toFixed(1)} giros`, 'color: #FFD700;');
            
            // ğŸ¯ LÃ“GICA INTELIGENTE DO USUÃRIO:
            // Se jÃ¡ estamos no giro X e nenhuma sequÃªncia recente passou de X,
            // MUITO PROVÃVEL que vai quebrar!
            
            // â„¹ï¸ AnÃ¡lise informativa apenas - SEM penalizaÃ§Ãµes artificiais
            if (patternSize >= maxLength) {
                console.log(`%câš ï¸ ALERTA: PadrÃ£o atual (${patternSize}) jÃ¡ atingiu o mÃ¡ximo recente (${maxLength})!`, 'color: #FF0000; font-weight: bold;');
                console.log(`%c   â„¹ï¸ Probabilidade de QUEBRA pode ser alta`, 'color: #FFA500;');
                console.log(`%c   ğŸ“Š HistÃ³rico jÃ¡ reflete esta probabilidade`, 'color: #00FF88;');
                reasoning += ` | PadrÃ£o atingiu mÃ¡ximo recente (${maxLength})`;
            } else if (patternSize >= avgLength) {
                console.log(`%câš ï¸ PadrÃ£o atual (${patternSize}) estÃ¡ acima da mÃ©dia recente (${avgLength.toFixed(1)})`, 'color: #FFA500; font-weight: bold;');
                console.log(`%c   â„¹ï¸ SequÃªncia acima do normal nos Ãºltimos 20 giros`, 'color: #FFA500;');
                reasoning += ` | Acima da mÃ©dia recente (${avgLength.toFixed(1)})`;
            } else {
                console.log(`%câœ… PadrÃ£o atual (${patternSize}) estÃ¡ abaixo do mÃ¡ximo (${maxLength}) e mÃ©dia (${avgLength.toFixed(1)})`, 'color: #00FF00;');
                console.log(`%c   âœ… Ainda hÃ¡ espaÃ§o para crescer!`, 'color: #00FF88;');
            }
            // âœ… REMOVIDAS: TODAS as penalizaÃ§Ãµes artificiais (-15%, -10%)
            // Os dados histÃ³ricos de 2000 giros jÃ¡ incluem essas probabilidades!
        } else {
            console.log(`%c   â„¹ï¸ Nenhuma sequÃªncia similar encontrada nos Ãºltimos 20 giros`, 'color: #888;');
            console.log(`%c   NÃ£o hÃ¡ dados recentes para comparaÃ§Ã£o`, 'color: #888;');
        }
        
    }
    
    console.log(`%cğŸŒ¡ï¸  TEMPERATURA: ${temperature}`, 'color: #FF6B35; font-weight: bold; font-size: 14px;');
    console.log(`%c   ${reasoning}`, 'color: #FF8C00;');
    
    // âœ… CALCULAR COR DOMINANTE NOS ÃšLTIMOS 20 GIROS
    let colorCounts = { red: 0, black: 0, white: 0 };
    last20Spins.forEach(spin => {
        colorCounts[spin.color]++;
    });
    
    const total20 = last20Spins.length;
    const colorPercents = {
        red: ((colorCounts.red / total20) * 100).toFixed(1),
        black: ((colorCounts.black / total20) * 100).toFixed(1),
        white: ((colorCounts.white / total20) * 100).toFixed(1)
    };
    
    // Encontrar cor dominante
    let dominantColor = 'red';
    let dominantCount = colorCounts.red;
    let dominantPercent = parseFloat(colorPercents.red);
    
    if (colorCounts.black > dominantCount) {
        dominantColor = 'black';
        dominantCount = colorCounts.black;
        dominantPercent = parseFloat(colorPercents.black);
    }
    if (colorCounts.white > dominantCount) {
        dominantColor = 'white';
        dominantCount = colorCounts.white;
        dominantPercent = parseFloat(colorPercents.white);
    }
    
    // Considerar "dominante" se for >=55% (11+ em 20 giros)
    const hasDominantColor = dominantPercent >= 55;
    
    return {
        temperature,
        adjustment,
        reasoning,
        stats: {
            totalSequences,
            longSequences,
            veryLongSequences,
            avgSequenceLength
        },
        // âœ… InformaÃ§Ãµes de cor dominante
        colorCounts,
        colorPercents,
        dominantColor,
        dominantCount,
        dominantPercent,
        hasDominantColor
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  FUNÃ‡Ã•ES DE MEMÃ“RIA ATIVA - SISTEMA INCREMENTAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ğŸ”§ INICIALIZAR MEMÃ“RIA ATIVA
 * Analisa todo o histÃ³rico UMA VEZ e armazena em memÃ³ria
 * Deve ser chamado apenas na primeira vez ou apÃ³s reset
 */
async function inicializarMemoriaAtiva(history) {
    // âš ï¸ Evitar inicializaÃ§Ãµes simultÃ¢neas
    if (memoriaAtivaInicializando) {
        console.log('%câ³ MemÃ³ria Ativa jÃ¡ estÃ¡ sendo inicializada...', 'color: #FFA500;');
        return false;
    }
    
    memoriaAtivaInicializando = true;
    const inicio = performance.now();
    
    console.log('%câ•‘  ğŸ§  INICIALIZANDO MEMÃ“RIA ATIVA                          â•‘', 'color: #00CED1; font-weight: bold; font-size: 14px;');
    
    try {
        // 1. COPIAR HISTÃ“RICO
        console.log('%cğŸ“Š ETAPA 1/5: Copiando histÃ³rico...', 'color: #00CED1; font-weight: bold;');
        memoriaAtiva.giros = [...history].slice(0, 2000);
        memoriaAtiva.ultimos20 = memoriaAtiva.giros.slice(0, 20);
        memoriaAtiva.estatisticas.totalGiros = memoriaAtiva.giros.length;
        console.log(`%c   âœ… ${memoriaAtiva.giros.length} giros copiados`, 'color: #00FF88;');
        
        // 2. CALCULAR DISTRIBUIÃ‡ÃƒO
        console.log('%cğŸ“Š ETAPA 2/5: Calculando distribuiÃ§Ã£o de cores...', 'color: #00CED1; font-weight: bold;');
        const distribuicao = { red: 0, black: 0, white: 0 };
        for (const giro of memoriaAtiva.giros) {
            if (giro.color) {
                distribuicao[giro.color]++;
            }
        }
        const total = memoriaAtiva.giros.length;
        memoriaAtiva.estatisticas.distribuicao = {
            red: { count: distribuicao.red, percent: (distribuicao.red / total) * 100 },
            black: { count: distribuicao.black, percent: (distribuicao.black / total) * 100 },
            white: { count: distribuicao.white, percent: (distribuicao.white / total) * 100 }
        };
        console.log(`%c   ğŸ”´ Vermelho: ${distribuicao.red} (${memoriaAtiva.estatisticas.distribuicao.red.percent.toFixed(2)}%)`, 'color: #FF6B6B;');
        console.log(`%c   âš« Preto: ${distribuicao.black} (${memoriaAtiva.estatisticas.distribuicao.black.percent.toFixed(2)}%)`, 'color: #888;');
        console.log(`%c   âšª Branco: ${distribuicao.white} (${memoriaAtiva.estatisticas.distribuicao.white.percent.toFixed(2)}%)`, 'color: #FFF;');
        
        // 3. DETECTAR TODOS OS PADRÃ•ES NO HISTÃ“RICO
        console.log('%cğŸ” ETAPA 3/5: Detectando todos os padrÃµes...', 'color: #00CED1; font-weight: bold;');
        const todosOsPadroes = detectAllPatternTypes(memoriaAtiva.giros);
        
        // Organizar por tipo
        memoriaAtiva.padroesDetectados = {
            alternanciaSimples: todosOsPadroes.filter(p => p.type === 'alternancia_simples'),
            alternanciasDupla: todosOsPadroes.filter(p => p.type === 'alternancia_dupla'),
            alternanciasTripla: todosOsPadroes.filter(p => p.type === 'alternancia_tripla'),
            sequenciasRed: todosOsPadroes.filter(p => p.type === 'sequencia_red'),
            sequenciasBlack: todosOsPadroes.filter(p => p.type === 'sequencia_black')
        };
        
        console.log(`%c   ğŸ”„ AlternÃ¢ncia Simples: ${memoriaAtiva.padroesDetectados.alternanciaSimples.length}`, 'color: #00FF88;');
        console.log(`%c   ğŸ”„ AlternÃ¢ncia Dupla: ${memoriaAtiva.padroesDetectados.alternanciasDupla.length}`, 'color: #00FF88;');
        console.log(`%c   ğŸ”„ AlternÃ¢ncia Tripla: ${memoriaAtiva.padroesDetectados.alternanciasTripla.length}`, 'color: #00FF88;');
        console.log(`%c   ğŸ”´ SequÃªncias Vermelhas: ${memoriaAtiva.padroesDetectados.sequenciasRed.length}`, 'color: #FF6B6B;');
        console.log(`%c   âš« SequÃªncias Pretas: ${memoriaAtiva.padroesDetectados.sequenciasBlack.length}`, 'color: #888;');
        
        // 4. CALCULAR ESTATÃSTICAS POR PADRÃƒO
        console.log('%cğŸ“Š ETAPA 4/5: Calculando estatÃ­sticas por padrÃ£o...', 'color: #00CED1; font-weight: bold;');
        memoriaAtiva.estatisticas.porPadrao = {};
        
        // Para cada padrÃ£o detectado, calcular o que veio depois
        for (const padroes of Object.values(memoriaAtiva.padroesDetectados)) {
            for (const padrao of padroes) {
                const chave = `${padrao.type}_${padrao.size}`;
                
                if (!memoriaAtiva.estatisticas.porPadrao[chave]) {
                    memoriaAtiva.estatisticas.porPadrao[chave] = {
                        type: padrao.type,
                        size: padrao.size,
                        ocorrencias: 0,
                        proximaCor: { red: 0, black: 0, white: 0 }
                    };
                }
                
                memoriaAtiva.estatisticas.porPadrao[chave].ocorrencias++;
                
                // Registrar o que veio depois
                if (padrao.whatCameNext) {
                    memoriaAtiva.estatisticas.porPadrao[chave].proximaCor[padrao.whatCameNext]++;
                }
            }
        }
        
        // Calcular percentuais
        for (const stats of Object.values(memoriaAtiva.estatisticas.porPadrao)) {
            const total = stats.proximaCor.red + stats.proximaCor.black + stats.proximaCor.white;
            if (total > 0) {
                stats.proximaCor.redPercent = (stats.proximaCor.red / total) * 100;
                stats.proximaCor.blackPercent = (stats.proximaCor.black / total) * 100;
                stats.proximaCor.whitePercent = (stats.proximaCor.white / total) * 100;
            }
        }
        
        const totalPadroesCadastrados = Object.keys(memoriaAtiva.estatisticas.porPadrao).length;
        console.log(`%c   âœ… ${totalPadroesCadastrados} tipos de padrÃµes cadastrados`, 'color: #00FF88;');
        
        // 5. MARCAR COMO INICIALIZADA
        memoriaAtiva.inicializada = true;
        memoriaAtiva.ultimaAtualizacao = new Date();
        memoriaAtiva.tempoInicializacao = performance.now() - inicio;
        memoriaAtiva.totalAtualizacoes = 0;
        
        console.log('%câ•‘  âœ… MEMÃ“RIA ATIVA INICIALIZADA COM SUCESSO!              â•‘', 'color: #00FF00; font-weight: bold; font-size: 14px;');
        console.log(`%câ•‘  â±ï¸  Tempo: ${memoriaAtiva.tempoInicializacao.toFixed(2)}ms                                    â•‘`, 'color: #00FF88;');
        console.log(`%câ•‘  ğŸ“Š Giros: ${memoriaAtiva.giros.length}                                          â•‘`, 'color: #00FF88;');
        console.log(`%câ•‘  ğŸ¯ PadrÃµes detectados: ${todosOsPadroes.length}                             â•‘`, 'color: #00FF88;');
        console.log(`%câ•‘  ğŸ“ˆ Tipos Ãºnicos: ${totalPadroesCadastrados}                                      â•‘`, 'color: #00FF88;');
        
        memoriaAtivaInicializando = false;
        return true;
        
    } catch (error) {
        console.error('%câŒ ERRO ao inicializar memÃ³ria ativa:', 'color: #FF0000; font-weight: bold;');
        console.error(error);
        memoriaAtivaInicializando = false;
        memoriaAtiva.inicializada = false;
        return false;
    }
}

/**
 * âš¡ ATUALIZAR MEMÃ“RIA INCREMENTALMENTE
 * Adiciona novo giro e atualiza apenas o necessÃ¡rio (RÃPIDO!)
 */
function atualizarMemoriaIncrementalmente(novoGiro) {
    if (!memoriaAtiva.inicializada) {
        console.warn('%câš ï¸ MemÃ³ria Ativa nÃ£o inicializada! NÃ£o Ã© possÃ­vel atualizar.', 'color: #FFA500;');
        return false;
    }
    
    const inicio = performance.now();
    
    try {
        // 1. ADICIONAR NOVO GIRO NO INÃCIO
        memoriaAtiva.giros.unshift(novoGiro);
        
        // 2. REMOVER O MAIS ANTIGO (manter 2000)
        if (memoriaAtiva.giros.length > 2000) {
            const removido = memoriaAtiva.giros.pop();
            
            // Atualizar distribuiÃ§Ã£o (decrementar cor removida)
            if (removido && removido.color) {
                memoriaAtiva.estatisticas.distribuicao[removido.color].count--;
            }
        }
        
        // 3. ATUALIZAR DISTRIBUIÃ‡ÃƒO (incrementar nova cor)
        if (novoGiro.color) {
            memoriaAtiva.estatisticas.distribuicao[novoGiro.color].count++;
        }
        
        // Recalcular percentuais
        const total = memoriaAtiva.giros.length;
        for (const cor of ['red', 'black', 'white']) {
            memoriaAtiva.estatisticas.distribuicao[cor].percent = 
                (memoriaAtiva.estatisticas.distribuicao[cor].count / total) * 100;
        }
        
        // 4. ATUALIZAR ÃšLTIMOS 20
        memoriaAtiva.ultimos20 = memoriaAtiva.giros.slice(0, 20);
        
        // 5. DETECTAR NOVO PADRÃƒO ATIVO (apenas nos Ãºltimos 20)
        // Isso Ã© rÃ¡pido porque sÃ³ analisa 20 giros!
        memoriaAtiva.padraoAtual = findActivePattern(memoriaAtiva.ultimos20);
        
        // 6. ATUALIZAR MÃ‰TRICAS
        memoriaAtiva.ultimaAtualizacao = new Date();
        memoriaAtiva.tempoUltimaAtualizacao = performance.now() - inicio;
        memoriaAtiva.totalAtualizacoes++;
        
        // âœ… Log resumido (apenas se demorar muito)
        if (memoriaAtiva.tempoUltimaAtualizacao > 50) {
            console.log(`%câš¡ MemÃ³ria atualizada em ${memoriaAtiva.tempoUltimaAtualizacao.toFixed(2)}ms`, 'color: #FFD700;');
        }
        
        return true;
        
    } catch (error) {
        console.error('%câŒ ERRO ao atualizar memÃ³ria incrementalmente:', 'color: #FF0000; font-weight: bold;');
        console.error(error);
        return false;
    }
}

/**
 * ğŸ” VALIDAR MEMÃ“RIA ATIVA
 * Verifica integridade e sincronizaÃ§Ã£o com cachedHistory
 */
function validarMemoriaAtiva() {
    if (!memoriaAtiva.inicializada) {
        return { valida: false, motivo: 'NÃ£o inicializada' };
    }
    
    // Verificar se tem giros
    if (memoriaAtiva.giros.length === 0) {
        return { valida: false, motivo: 'Sem giros na memÃ³ria' };
    }
    
    // Verificar sincronizaÃ§Ã£o com cachedHistory
    if (cachedHistory.length > 0 && memoriaAtiva.giros.length > 0) {
        const ultimoGiroMemoria = memoriaAtiva.giros[0];
        const ultimoGiroCache = cachedHistory[0];
        
        if (ultimoGiroMemoria.number !== ultimoGiroCache.number || 
            ultimoGiroMemoria.color !== ultimoGiroCache.color) {
            return { 
                valida: false, 
                motivo: 'Dessincronizado com cachedHistory',
                detalhes: {
                    memoria: ultimoGiroMemoria,
                    cache: ultimoGiroCache
                }
            };
        }
    }
    
    // Verificar se estatÃ­sticas fazem sentido
    const totalDist = memoriaAtiva.estatisticas.distribuicao.red.count +
                      memoriaAtiva.estatisticas.distribuicao.black.count +
                      memoriaAtiva.estatisticas.distribuicao.white.count;
    
    if (totalDist !== memoriaAtiva.giros.length) {
        return { 
            valida: false, 
            motivo: 'DistribuiÃ§Ã£o inconsistente',
            detalhes: {
                totalDistribuicao: totalDist,
                totalGiros: memoriaAtiva.giros.length
            }
        };
    }
    
    return { valida: true };
}

/**
 * ğŸ”„ RESETAR MEMÃ“RIA ATIVA
 * Limpa tudo e forÃ§a reinicializaÃ§Ã£o
 */
function resetarMemoriaAtiva() {
    console.log('%cğŸ”„ Resetando MemÃ³ria Ativa...', 'color: #FFA500; font-weight: bold;');
    
    memoriaAtiva = {
        inicializada: false,
        ultimaAtualizacao: null,
        versao: memoriaAtiva.versao + 1,
        giros: [],
        ultimos20: [],
        padroesDetectados: {
            alternanciaSimples: [],
            alternanciasDupla: [],
            alternanciasTripla: [],
            sequenciasRed: [],
            sequenciasBlack: []
        },
        estatisticas: {
            totalGiros: 0,
            distribuicao: {
                red: { count: 0, percent: 0 },
                black: { count: 0, percent: 0 },
                white: { count: 0, percent: 0 }
            },
            porPadrao: {}
        },
        padraoAtual: null,
        tempoInicializacao: 0,
        tempoUltimaAtualizacao: 0,
        totalAtualizacoes: 0
    };
    
    memoriaAtivaInicializando = false;
    
    console.log('%câœ… MemÃ³ria Ativa resetada!', 'color: #00FF88;');
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ§  ANÃLISE CONTEXTUAL INTELIGENTE - SISTEMA DE GRADIENTE
 * Analisa os ÃšLTIMOS 20 GIROS com peso gradual (mais recente = mais importante)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
function analyzeCurrentContext(last20Spins, activePattern) {
    const colors = last20Spins.map(s => s.color);
    const nonWhite = colors.filter(c => c !== 'white');
    
    let description = '';
    let insight = '';
    
    console.log('%câ•‘  ğŸŒ¡ï¸ ANÃLISE CONTEXTUAL COM GRADIENTE QUENTE/FRIO         â•‘', 'color: #00FFFF; font-weight: bold;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸŒ¡ï¸ GRADIENTE DE TEMPERATURA (20 giros)
    // Giro 20 (antigo) = FRIO (peso 1.0x)
    // Giro 1 (recente) = FERVENDO (peso 3.0x)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const last20NonWhite = nonWhite.slice(0, Math.min(20, nonWhite.length));
    
    console.log(`%cğŸ“Š Analisando ${last20NonWhite.length} giros (ignorando brancos)`, 'color: #00FFFF;');
    console.log(`%c   Do mais antigo (FRIO) ao mais recente (QUENTE)`, 'color: #00FFFF;');
    
    // Mostrar sequÃªncia completa com gradiente visual
    let gradientDisplay = '';
    for (let i = last20NonWhite.length - 1; i >= 0; i--) {
        const color = last20NonWhite[i];
        const position = last20NonWhite.length - i;
        const colorSymbol = color === 'red' ? 'V' : 'P';
        
        // Gradiente de cor no console
        let tempEmoji = '';
        if (position <= 5) {
            tempEmoji = 'ğŸ§Š'; // Muito frio (giros antigos)
        } else if (position <= 10) {
            tempEmoji = 'â„ï¸'; // Frio
        } else if (position <= 15) {
            tempEmoji = 'ğŸŒ¡ï¸'; // Morno
        } else {
            tempEmoji = 'ğŸ”¥'; // Quente (giros recentes)
        }
        
        gradientDisplay += `${tempEmoji}${colorSymbol} `;
    }
    
    console.log(`%cğŸŒ¡ï¸ Gradiente: ${gradientDisplay}`, 'color: #00FFFF;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” ANÃLISE 1: SEQUÃŠNCIA ATUAL (Ãºltimos giros mais recentes)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const firstColor = last20NonWhite[0];
    let currentSequenceLength = 1;
    
    for (let i = 1; i < last20NonWhite.length; i++) {
        if (last20NonWhite[i] === firstColor) {
            currentSequenceLength++;
        } else {
            break;
        }
    }
    
    console.log(`%cğŸ”¥ ANÃLISE DA SEQUÃŠNCIA ATUAL (giros mais recentes):`, 'color: #FFD700; font-weight: bold;');
    console.log(`%c   Cor atual: ${firstColor === 'red' ? 'VERMELHO' : 'PRETO'}`, 'color: #FFD700;');
    console.log(`%c   SequÃªncia: ${currentSequenceLength} giros consecutivos`, 'color: #FFD700;');
    
    if (currentSequenceLength >= 7) {
        const colorName = firstColor === 'red' ? 'VERMELHOS' : 'PRETOS';
        description = `ğŸ”¥ SEQUÃŠNCIA MUITO LONGA! ${currentSequenceLength} ${colorName} consecutivos. `;
        insight = `ATENÃ‡ÃƒO: SequÃªncia de ${currentSequenceLength} giros estÃ¡ MUITO longa! Probabilidade de quebra ALTA.`;
        console.log(`%c   âš ï¸ SEQUÃŠNCIA MUITO LONGA! Risco de quebra ALTO!`, 'color: #FF0000; font-weight: bold;');
    } else if (currentSequenceLength >= 5) {
        const colorName = firstColor === 'red' ? 'VERMELHOS' : 'PRETOS';
        description = `ğŸ“Š SequÃªncia de ${currentSequenceLength} ${colorName}. `;
        insight = `SequÃªncia moderada (${currentSequenceLength} giros). Pode continuar ou quebrar.`;
        console.log(`%c   âœ… SequÃªncia moderada`, 'color: #FFAA00;');
    } else if (currentSequenceLength >= 3) {
        const colorName = firstColor === 'red' ? 'vermelhos' : 'pretos';
        description = `ğŸ“ˆ SequÃªncia curta de ${currentSequenceLength} ${colorName}. `;
        insight = `SequÃªncia ainda curta (${currentSequenceLength} giros).`;
        console.log(`%c   â„¹ï¸ SequÃªncia curta`, 'color: #00FF88;');
    } else {
        console.log(`%c   â„¹ï¸ Sem sequÃªncia clara (apenas ${currentSequenceLength} giro)`, 'color: #00FF88;');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” ANÃLISE 2: COMPORTAMENTO NOS ÃšLTIMOS 20 GIROS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    console.log(`%cğŸ”„ ANÃLISE GERAL DOS 20 GIROS:`, 'color: #9370DB; font-weight: bold;');
    
    const redCount = last20NonWhite.filter(c => c === 'red').length;
    const blackCount = last20NonWhite.filter(c => c === 'black').length;
    const total = last20NonWhite.length;
    
    console.log(`%c   VERMELHO: ${redCount} giros (${((redCount/total)*100).toFixed(1)}%)`, 'color: #FF0000;');
    console.log(`%c   PRETO: ${blackCount} giros (${((blackCount/total)*100).toFixed(1)}%)`, 'color: #FFFFFF;');
    
    // Detectar alternÃ¢ncia nos Ãºltimos 10 giros (zona quente)
    const last10 = last20NonWhite.slice(0, 10);
    let alternations = 0;
    for (let i = 0; i < last10.length - 1; i++) {
        if (last10[i] !== last10[i + 1]) {
            alternations++;
        }
    }
    
    console.log(`%c   MudanÃ§as de cor (Ãºltimos 10): ${alternations}`, 'color: #9370DB;');
    
    if (alternations >= 7) {
        description += `ğŸ”„ ALTERNÃ‚NCIA MUITO ATIVA nos Ãºltimos 10 giros (${alternations} mudanÃ§as). `;
        insight = `Forte padrÃ£o de alternÃ¢ncia. Cores trocando frequentemente.`;
        console.log(`%c   âœ… ALTERNÃ‚NCIA MUITO ATIVA!`, 'color: #00FF00; font-weight: bold;');
    } else if (alternations >= 5) {
        description += `ğŸ”„ AlternÃ¢ncia moderada (${alternations} mudanÃ§as em 10 giros). `;
        insight = `PadrÃ£o de alternÃ¢ncia presente.`;
        console.log(`%c   â„¹ï¸ AlternÃ¢ncia moderada`, 'color: #00FF88;');
    } else {
        console.log(`%c   â„¹ï¸ Pouca alternÃ¢ncia (${alternations} mudanÃ§as)`, 'color: #FFAA00;');
    }
    
    // âš ï¸ NÃƒO RECOMENDAR BASEADO EM DOMINÃ‚NCIA DE COR!
    // A recomendaÃ§Ã£o vem do PADRÃƒO e do HISTÃ“RICO, nÃ£o da quantidade!
    // Apenas DESCREVER o contexto atual para o usuÃ¡rio entender
    if (currentSequenceLength < 3 && alternations < 5) {
        if (redCount > blackCount + 3) {
            description = `ğŸ“Š Contexto: ${redCount} vermelhos vs ${blackCount} pretos nos Ãºltimos 20 giros. `;
            insight = `Vermelho apareceu mais recentemente. A decisÃ£o virÃ¡ do padrÃ£o detectado e do histÃ³rico.`;
            console.log(`%c   ğŸ“Š Contexto: Vermelho mais frequente (${redCount} vs ${blackCount})`, 'color: #00FFFF;');
            console.log(`%c   âš ï¸ MAS: DecisÃ£o baseada no PADRÃƒO e HISTÃ“RICO, nÃ£o na quantidade!`, 'color: #FFAA00; font-weight: bold;');
        } else if (blackCount > redCount + 3) {
            description = `ğŸ“Š Contexto: ${blackCount} pretos vs ${redCount} vermelhos nos Ãºltimos 20 giros. `;
            insight = `Preto apareceu mais recentemente. A decisÃ£o virÃ¡ do padrÃ£o detectado e do histÃ³rico.`;
            console.log(`%c   ğŸ“Š Contexto: Preto mais frequente (${blackCount} vs ${redCount})`, 'color: #00FFFF;');
            console.log(`%c   âš ï¸ MAS: DecisÃ£o baseada no PADRÃƒO e HISTÃ“RICO, nÃ£o na quantidade!`, 'color: #FFAA00; font-weight: bold;');
        } else {
            description = `ğŸ“Š Contexto: Equilibrado nos Ãºltimos 20 giros (V:${redCount} vs P:${blackCount}). `;
            insight = `DistribuiÃ§Ã£o equilibrada. A decisÃ£o virÃ¡ do padrÃ£o detectado e do histÃ³rico.`;
            console.log(`%c   ğŸ“Š Contexto: Jogo equilibrado (${redCount} vs ${blackCount})`, 'color: #00FFFF;');
        }
    }
    
    
    return {
        description: description,
        insight: insight,
        currentSequenceLength: currentSequenceLength,
        alternations: alternations,
        redDominance: redCount,
        blackDominance: blackCount
    };
}

/**
 * FUNÃ‡ÃƒO AUXILIAR: Buscar sequÃªncia de 10 giros no histÃ³rico
 * Retorna a cor que mais saiu apÃ³s essa sequÃªncia
 * @param {Array} targetSequence - SequÃªncia de 10 giros a buscar
 * @param {Array} searchHistory - HistÃ³rico onde buscar
 * @param {number} spinsToAnalyze - Quantos giros analisar apÃ³s encontrar a sequÃªncia
 * @returns {Object} - {color, confidence, occurrences, similarity}
 */
function buscarSequenciaNoHistorico(targetSequence, searchHistory, spinsToAnalyze = 100) {
    console.log(`%cğŸ“Š PARÃ‚METROS DA BUSCA:`, 'color: #00D4FF; font-weight: bold;');
    console.log(`   â¤ Tamanho do histÃ³rico de busca: ${searchHistory.length} giros`);
    console.log(`   â¤ Tamanho da sequÃªncia alvo: ${targetSequence.length} giros`);
    console.log(`   â¤ Giros para analisar apÃ³s match: ${spinsToAnalyze}`);
    
    // Extrair apenas as cores da sequÃªncia alvo
    const targetColors = targetSequence.map(spin => spin.color);
    
    console.log('%cğŸ¯ SEQUÃŠNCIA ALVO (Ãšltimos 10 giros):', 'color: #FFD700; font-weight: bold;');
    for (let i = 0; i < targetSequence.length; i++) {
        const spin = targetSequence[i];
        const colorEmoji = spin.color === 'red' ? 'ğŸ”´' : spin.color === 'black' ? 'âš«' : 'âšª';
        console.log(`   ${i + 1}. ${colorEmoji} ${spin.color.toUpperCase()} (#${spin.number || '?'})`);
    }
    console.log(`   â†’ PadrÃ£o: ${targetColors.map(c => c === 'red' ? 'ğŸ”´' : c === 'black' ? 'âš«' : 'âšª').join(' ')}`);
    
    let exactMatches = [];
    let similarMatches = []; // Matches com 60%+ de similaridade
    let highMatches = [];    // Matches com 80%+ de similaridade
    
    console.log('%cğŸ” INICIANDO VARREDURA DO HISTÃ“RICO...', 'color: #00D4FF; font-weight: bold;');
    console.log(`   Analisando ${searchHistory.length - spinsToAnalyze - 10} posiÃ§Ãµes no histÃ³rico`);
    
    // Buscar no histÃ³rico (comeÃ§ando do Ã­ndice 10, pois precisamos de 10 giros anteriores)
    for (let i = 10; i < searchHistory.length - spinsToAnalyze; i++) {
        const historySlice = searchHistory.slice(i - 10, i).map(spin => spin.color);
        
        // Calcular similaridade
        let matchCount = 0;
        for (let j = 0; j < 10; j++) {
            if (historySlice[j] === targetColors[j]) {
                matchCount++;
            }
        }
        
        const similarity = (matchCount / 10) * 100;
        
        if (similarity === 100) {
            // Match exato!
            exactMatches.push(i);
            console.log(`%c   âœ… MATCH EXATO encontrado na posiÃ§Ã£o ${i}! (100% similaridade)`, 'color: #00FF00; font-weight: bold;');
        } else if (similarity >= 80) {
            // Match com 80%+ de similaridade
            highMatches.push({ index: i, similarity: similarity });
            console.log(`%c   â­ MATCH ALTO encontrado na posiÃ§Ã£o ${i} (${similarity}% similaridade)`, 'color: #FFD700;');
        } else if (similarity >= 60) {
            // Match com 60%+ de similaridade
            similarMatches.push({ index: i, similarity: similarity });
        }
    }
    
    console.log('%cğŸ“Š RESULTADO DA VARREDURA:', 'color: #00FF88; font-weight: bold; font-size: 14px;');
    console.log(`%c   âœ… Matches EXATOS (100%): ${exactMatches.length}`, exactMatches.length > 0 ? 'color: #00FF00; font-weight: bold;' : 'color: #FF6666;');
    console.log(`%c   â­ Matches ALTOS (80-99%): ${highMatches.length}`, highMatches.length > 0 ? 'color: #FFD700; font-weight: bold;' : 'color: #FF6666;');
    console.log(`%c   âš¡ Matches SIMILARES (60-79%): ${similarMatches.length}`, similarMatches.length > 0 ? 'color: #00FF88;' : 'color: #FF6666;');
    console.log(`%c   ğŸ“Š TOTAL de matches com 60%+: ${exactMatches.length + highMatches.length + similarMatches.length}`, 'color: #00D4FF; font-weight: bold;');
    
    // Analisar o que veio DEPOIS dessas ocorrÃªncias
    let nextColorCounts = { red: 0, black: 0, white: 0 };
    let totalOccurrences = 0;
    let avgSimilarity = 0;
    let matchesUsed = [];
    
    console.log('%cğŸ¯ ANALISANDO O QUE VEIO DEPOIS DOS MATCHES...', 'color: #FFD700; font-weight: bold;');
    
    if (exactMatches.length > 0) {
        // PRIORIDADE 1: Usar matches exatos (100%)
        console.log(`%c   âœ… USANDO ${exactMatches.length} MATCH(ES) EXATO(S) (100% similaridade)`, 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
        exactMatches.forEach((matchIndex, idx) => {
            console.log(`%c   ğŸ“ Match ${idx + 1}/${exactMatches.length} (posiÃ§Ã£o ${matchIndex})`, 'color: #00FF88;');
            
            // Analisar os prÃ³ximos X giros apÃ³s o match
            const nextSpins = searchHistory.slice(matchIndex, matchIndex + spinsToAnalyze);
            console.log(`      â¤ Analisando ${nextSpins.length} giros apÃ³s este match`);
            
            let localCounts = { red: 0, black: 0, white: 0 };
            nextSpins.forEach(spin => {
                if (spin.color in nextColorCounts) {
                    nextColorCounts[spin.color]++;
                    localCounts[spin.color]++;
                }
            });
            
            console.log(`      â¤ DistribuiÃ§Ã£o: ğŸ”´ ${localCounts.red} | âš« ${localCounts.black} | âšª ${localCounts.white}`);
        });
        
        totalOccurrences = exactMatches.length;
        avgSimilarity = 100;
        matchesUsed = exactMatches.map(i => ({ index: i, similarity: 100 }));
        
        console.log(`%c   âœ… TOTAL DE OCORRÃŠNCIAS EXATAS: ${totalOccurrences}`, 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
    } else if (highMatches.length > 0) {
        // PRIORIDADE 2: Usar matches altos (80-99%)
        console.log(`%c   â­ USANDO ${highMatches.length} MATCH(ES) DE ALTA SIMILARIDADE (80-99%)`, 'color: #FFD700; font-weight: bold; font-size: 14px;');
        
        highMatches.forEach((match, idx) => {
            console.log(`%c   ğŸ“ Match ${idx + 1}/${highMatches.length} (posiÃ§Ã£o ${match.index}, ${match.similarity}% similar)`, 'color: #FFD700;');
            
            const nextSpins = searchHistory.slice(match.index, match.index + spinsToAnalyze);
            console.log(`      â¤ Analisando ${nextSpins.length} giros apÃ³s este match`);
            
            let localCounts = { red: 0, black: 0, white: 0 };
            nextSpins.forEach(spin => {
                if (spin.color in nextColorCounts) {
                    nextColorCounts[spin.color]++;
                    localCounts[spin.color]++;
                }
            });
            
            console.log(`      â¤ DistribuiÃ§Ã£o: ğŸ”´ ${localCounts.red} | âš« ${localCounts.black} | âšª ${localCounts.white}`);
        });
        
        totalOccurrences = highMatches.length;
        avgSimilarity = Math.round(highMatches.reduce((sum, m) => sum + m.similarity, 0) / highMatches.length);
        matchesUsed = highMatches;
        
        console.log(`%c   â­ TOTAL DE OCORRÃŠNCIAS DE ALTA SIMILARIDADE: ${totalOccurrences}`, 'color: #FFD700; font-weight: bold; font-size: 14px;');
        console.log(`%c   ğŸ“Š Similaridade mÃ©dia: ${avgSimilarity}%`, 'color: #FFD700; font-weight: bold;');
        
    } else if (similarMatches.length > 0) {
        // PRIORIDADE 3: Usar matches similares (60-79%)
        console.log(`%c   âš¡ USANDO ${similarMatches.length} MATCH(ES) DE MÃ‰DIA SIMILARIDADE (60-79%)`, 'color: #00FF88; font-weight: bold; font-size: 14px;');
        
        // Usar no mÃ¡ximo os 10 melhores matches similares (para nÃ£o poluir demais)
        const topSimilarMatches = similarMatches
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, 10);
        
        console.log(`%c   ğŸ“Š Usando os ${topSimilarMatches.length} melhores matches (dos ${similarMatches.length} encontrados)`, 'color: #00FF88;');
        
        topSimilarMatches.forEach((match, idx) => {
            console.log(`%c   ğŸ“ Match ${idx + 1}/${topSimilarMatches.length} (posiÃ§Ã£o ${match.index}, ${match.similarity}% similar)`, 'color: #00FF88;');
            
            const nextSpins = searchHistory.slice(match.index, match.index + spinsToAnalyze);
            
            let localCounts = { red: 0, black: 0, white: 0 };
            nextSpins.forEach(spin => {
                if (spin.color in nextColorCounts) {
                    nextColorCounts[spin.color]++;
                    localCounts[spin.color]++;
                }
            });
            
            if (idx < 3) { // Mostrar detalhes sÃ³ dos 3 primeiros
                console.log(`      â¤ Analisando ${nextSpins.length} giros apÃ³s este match`);
                console.log(`      â¤ DistribuiÃ§Ã£o: ğŸ”´ ${localCounts.red} | âš« ${localCounts.black} | âšª ${localCounts.white}`);
            }
        });
        
        totalOccurrences = topSimilarMatches.length;
        avgSimilarity = Math.round(topSimilarMatches.reduce((sum, m) => sum + m.similarity, 0) / topSimilarMatches.length);
        matchesUsed = topSimilarMatches;
        
        console.log(`%c   âš¡ TOTAL DE OCORRÃŠNCIAS SIMILARES USADAS: ${totalOccurrences}`, 'color: #00FF88; font-weight: bold; font-size: 14px;');
        console.log(`%c   ğŸ“Š Similaridade mÃ©dia: ${avgSimilarity}%`, 'color: #00FF88; font-weight: bold;');
        
    } else {
        // âŒ NENHUM MATCH ENCONTRADO â†’ REJEITAR SINAL!
        console.log(`%c   âŒâŒâŒ NENHUM MATCH ENCONTRADO! âŒâŒâŒ`, 'color: #FF0000; font-weight: bold; font-size: 16px;');
        console.log(`%c   â¤ O padrÃ£o dos Ãºltimos 10 giros NUNCA apareceu no histÃ³rico!`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ Sem dados histÃ³ricos para basear a previsÃ£o!`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   ğŸš« DECISÃƒO: REJEITAR SINAL!`, 'color: #FF0000; font-weight: bold; font-size: 16px;');
        console.log(`%c   â¤ NÃƒO vamos usar "frequÃªncia geral" (isso nÃ£o funciona!)`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ SÃ³ enviamos sinal quando encontramos PADRÃƒO REAL no histÃ³rico!`, 'color: #00FF88; font-weight: bold;');
        
        totalOccurrences = 0;
        avgSimilarity = 0;
        
        // âœ… NÃƒO PREENCHER nextColorCounts - deixar zerado!
        // Isso farÃ¡ com que a confianÃ§a seja 0% e o sinal seja rejeitado
    }
    
    // Determinar cor recomendada baseada na distribuiÃ§Ã£o
    console.log('%cğŸ“Š CALCULANDO COR RECOMENDADA...', 'color: #FFD700; font-weight: bold;');
    console.log(`%c   DistribuiÃ§Ã£o total apÃ³s todos os matches:`, 'color: #00D4FF; font-weight: bold;');
    console.log(`%c      ğŸ”´ VERMELHO: ${nextColorCounts.red} giros`, 'color: #FF0000; font-weight: bold;');
    console.log(`%c      âš« PRETO: ${nextColorCounts.black} giros`, 'color: #FFFFFF; font-weight: bold;');
    console.log(`%c      âšª BRANCO: ${nextColorCounts.white} giros`, 'color: #00FF00;');
    
    let recommendedColor = 'red';
    let maxCount = nextColorCounts.red;
    
    if (nextColorCounts.black > maxCount) {
        recommendedColor = 'black';
        maxCount = nextColorCounts.black;
    }
    
    console.log(`%c   ğŸ¯ Cor com MAIOR frequÃªncia: ${recommendedColor.toUpperCase()} (${maxCount} giros)`, 
        `color: ${recommendedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 14px;`);
    
    // Calcular confianÃ§a baseada na distribuiÃ§Ã£o
    const totalColors = nextColorCounts.red + nextColorCounts.black + nextColorCounts.white;
    let confidence = totalColors > 0 ? Math.round((maxCount / totalColors) * 100) : 50;
    
    console.log(`%c   ğŸ“ˆ CÃ¡lculo de confianÃ§a:`, 'color: #00D4FF; font-weight: bold;');
    console.log(`%c      Total de giros analisados: ${totalColors}`, 'color: #00D4FF;');
    console.log(`%c      FrequÃªncia da cor vencedora: ${maxCount}/${totalColors}`, 'color: #00D4FF;');
    console.log(`%c      ConfianÃ§a inicial: ${confidence}%`, 'color: #00D4FF; font-weight: bold;');
    
    // âœ… NÃƒO AJUSTAR CONFIANÃ‡A AQUI - jÃ¡ serÃ¡ ajustada para 0% na validaÃ§Ã£o abaixo
    
    // âœ… VALIDAÃ‡ÃƒO RIGOROSA: ALERTAR SE POUCOS MATCHES
    console.log('%cğŸ” VALIDAÃ‡ÃƒO DE QUALIDADE DA ANÃLISE:', 'color: #FFD700; font-weight: bold;');
    
    const MIN_OCCURRENCES_WARNING = 5;
    const MIN_OCCURRENCES_CRITICAL = 2;
    
    if (totalOccurrences === 0) {
        console.log(`%c   âŒâŒâŒ CRÃTICO: NENHUM MATCH ENCONTRADO! âŒâŒâŒ`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
        console.log(`%c   â¤ O padrÃ£o dos Ãºltimos 10 giros NUNCA apareceu no histÃ³rico`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ SEM PADRÃƒO REAL â†’ CONFIANÃ‡A = 0%`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
        console.log(`%c   â¤ ESTE SINAL SERÃ REJEITADO!`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
        
        // âœ… FORÃ‡AR CONFIANÃ‡A = 0% PARA GARANTIR REJEIÃ‡ÃƒO
        confidence = 0;
    } else if (totalOccurrences < MIN_OCCURRENCES_CRITICAL) {
        console.log(`%c   âš ï¸ ALERTA: MUITO POUCOS MATCHES!`, 'color: #FF6666; font-weight: bold; font-size: 14px;');
        console.log(`%c   â¤ Matches encontrados: ${totalOccurrences}`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ Recomendado: pelo menos ${MIN_OCCURRENCES_WARNING}+ matches`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ Base estatÃ­stica MUITO FRACA!`, 'color: #FF0000; font-weight: bold;');
        
        const oldConfidence = confidence;
        confidence = Math.min(confidence, 45);
        console.log(`%c   âš ï¸ PENALIDADE: ConfianÃ§a limitada a ${confidence}% (era ${oldConfidence}%)`, 'color: #FFA500; font-weight: bold;');
    } else if (totalOccurrences < MIN_OCCURRENCES_WARNING) {
        console.log(`%c   âš ï¸ ATENÃ‡ÃƒO: Poucos matches encontrados`, 'color: #FFA500; font-weight: bold;');
        console.log(`%c   â¤ Matches encontrados: ${totalOccurrences}`, 'color: #FFA500;');
        console.log(`%c   â¤ Recomendado: pelo menos ${MIN_OCCURRENCES_WARNING}+ matches`, 'color: #FFA500;');
        console.log(`%c   â¤ Base estatÃ­stica razoÃ¡vel, mas nÃ£o ideal`, 'color: #FFA500;');
        
        const oldConfidence = confidence;
        confidence = Math.min(confidence, 50);
        console.log(`%c   âš ï¸ ConfianÃ§a limitada a ${confidence}% (era ${oldConfidence}%)`, 'color: #FFA500;');
    } else {
        console.log(`%c   âœ… Base estatÃ­stica SÃ“LIDA!`, 'color: #00FF00; font-weight: bold; font-size: 14px;');
        console.log(`%c   â¤ Matches encontrados: ${totalOccurrences}`, 'color: #00FF88; font-weight: bold;');
        console.log(`%c   â¤ Similaridade mÃ©dia: ${avgSimilarity}%`, 'color: #00FF88; font-weight: bold;');
        console.log(`%c   â¤ AnÃ¡lise baseada em dados REAIS do histÃ³rico!`, 'color: #00FF00; font-weight: bold;');
    }
    
    console.log('%cğŸ RESULTADO FINAL DA BUSCA:', 'color: #00FF00; font-weight: bold; font-size: 16px;');
    console.log(`%c   ğŸ¯ Cor recomendada: ${recommendedColor.toUpperCase()}`, `color: ${recommendedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 16px;`);
    console.log(`%c   ğŸ“Š ConfianÃ§a: ${confidence}%`, 'color: #FFD700; font-weight: bold; font-size: 16px;');
    console.log(`%c   ğŸ”¢ OcorrÃªncias do padrÃ£o: ${totalOccurrences}x`, 'color: #00FF88; font-weight: bold; font-size: 16px;');
    console.log(`%c   ğŸ“ˆ Similaridade mÃ©dia: ${avgSimilarity}%`, 'color: #00FF88; font-weight: bold; font-size: 16px;');
    
    const result = {
        color: recommendedColor,
        confidence: confidence,
        occurrences: totalOccurrences,
        similarity: avgSimilarity,
        distribution: nextColorCounts,
        // Dados extras para debug
        matchesBreakdown: {
            exact: exactMatches.length,
            high: highMatches.length,
            similar: similarMatches.length,
            used: matchesUsed.length
        }
    };
    
    console.log('%cğŸ“¦ Objeto retornado:', 'color: #00FFFF; font-weight: bold;');
    console.log(result);
    
    return result;
}

/**
 * ğŸ§  FASE 4 (NOVA): ValidaÃ§Ã£o de Viabilidade de SequÃªncia
 * Analisa se a sequÃªncia sugerida Ã© viÃ¡vel baseado no histÃ³rico recente
 */
function analyzeSequenceViability(history, suggestedColor) {
    console.log('%cğŸ§  Analisando viabilidade da sequÃªncia...', 'color: #9C27B0; font-weight: bold;');
    console.log(`%c   â¤ Cor sugerida pelas fases anteriores: ${suggestedColor.toUpperCase()}`, `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    
    // Detectar sequÃªncia atual (quantas cores consecutivas da mesma cor)
    let currentSequence = [];
    let currentColor = null;
    
    // ğŸ” MOSTRAR OS ÃšLTIMOS 10 GIROS PARA DEBUG
    console.log('%c   ğŸ“Š Ãšltimos 10 giros (para debug):', 'color: #9C27B0;');
    const last10 = history.slice(0, 10);
    let debugString = '';
    for (let i = 0; i < last10.length; i++) {
        const spin = last10[i];
        const colorSymbol = spin.color === 'red' ? 'ğŸ”´' : (spin.color === 'black' ? 'âš«' : 'âšª');
        const number = spin.number !== undefined ? spin.number : spin.roll;
        debugString += `${colorSymbol}${number} `;
    }
    console.log(`%c      ${debugString}`, 'color: #9C27B0;');
    
    for (let i = 0; i < history.length; i++) {
        const spin = history[i];
        
        // Brancos QUEBRAM a sequÃªncia!
        if (spin.color === 'white') {
            break;
        }
        
        if (currentColor === null) {
            currentColor = spin.color;
            currentSequence.push(spin);
        } else if (spin.color === currentColor) {
            currentSequence.push(spin);
        } else {
            break; // Quebrou a sequÃªncia (cor diferente)
        }
    }
    
    const currentSequenceLength = currentSequence.length;
    const currentSequenceColor = currentColor;
    
    console.log(`%c   ğŸ¯ SequÃªncia atual detectada: ${currentSequenceLength} ${currentSequenceColor?.toUpperCase() || 'NENHUMA'}(s) CONSECUTIVO(S)`, 
        `color: ${currentSequenceColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 14px;`);
    console.log(`%c   ğŸ” Detalhes da sequÃªncia:`, 'color: #9C27B0;');
    currentSequence.forEach((spin, idx) => {
        const number = spin.number !== undefined ? spin.number : spin.roll;
        console.log(`%c      ${idx + 1}Âº: ${spin.color.toUpperCase()} (${number})`, `color: ${spin.color === 'red' ? '#FF0000' : '#FFFFFF'};`);
    });
    
    // Se sinal sugere a MESMA cor da sequÃªncia atual, significa que quer CONTINUAR a sequÃªncia
    const isExtendingSequence = (currentSequenceColor === suggestedColor);
    
    console.log(`%c   ğŸ¤” Sinal sugere CONTINUAR a sequÃªncia? ${isExtendingSequence ? 'SIM âš ï¸' : 'NÃƒO âœ…'}`, 'color: #9C27B0; font-weight: bold;');
    
    if (!isExtendingSequence) {
        console.log('%c   âœ… Sinal sugere QUEBRA de sequÃªncia (inverter cor)', 'color: #00FF88; font-weight: bold;');
        console.log('%c   ğŸ“Œ NÃ£o precisa validar resistÃªncia (jÃ¡ estÃ¡ invertendo)', 'color: #00FF88;');
        return {
            shouldInvert: false,
            reason: 'Sinal jÃ¡ sugere inversÃ£o de cor',
            maxHistorical: 0,
            currentLength: currentSequenceLength,
            isViable: true
        };
    }
    
    // Sinal quer CONTINUAR a sequÃªncia (ex: 3 pretos â†’ sugerir 4Âº preto)
    const targetSequenceLength = currentSequenceLength + 1;
    console.log(`%c   âš ï¸ âš ï¸ âš ï¸ ATENÃ‡ÃƒO! Sinal quer CONTINUAR a sequÃªncia! âš ï¸ âš ï¸ âš ï¸`, 'color: #FF0000; font-weight: bold; font-size: 14px; background: #FFFF00;');
    console.log(`%c   â¤ SequÃªncia ATUAL: ${currentSequenceLength} ${suggestedColor.toUpperCase()}(s) consecutivo(s)`, `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    console.log(`%c   â¤ Sinal pede: ${targetSequenceLength}Âº ${suggestedColor.toUpperCase()} (${targetSequenceLength} consecutivos!)`, `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    
    // Buscar no histÃ³rico: qual foi a MAIOR sequÃªncia dessa cor nos Ãºltimos giros?
    const analysisWindow = Math.min(history.length, 500); // Analisar atÃ© 500 giros
    console.log(`%c   ğŸ” Buscando no histÃ³rico dos Ãºltimos ${analysisWindow} giros...`, 'color: #9C27B0; font-weight: bold;');
    console.log(`%c   ğŸ” Pergunta: JÃ ACONTECEU ${targetSequenceLength}+ ${suggestedColor.toUpperCase()}(s) consecutivos antes?`, 'color: #9C27B0; font-weight: bold;');
    
    let maxConsecutive = 0;
    let resistances = []; // Armazenar todas as resistÃªncias encontradas
    let currentStreak = 0;
    let lastColor = null;
    let streakStartGiro = 0;
    
    for (let i = 0; i < analysisWindow; i++) {
        const spin = history[i];
        
        if (spin.color === suggestedColor) {
            if (lastColor !== suggestedColor) {
                currentStreak = 1;
                streakStartGiro = i;
            } else {
                currentStreak++;
            }
            
            if (currentStreak > maxConsecutive) {
                maxConsecutive = currentStreak;
            }
            
            lastColor = suggestedColor;
        } else {
            // Cor diferente (black, white, ou outra) QUEBRA a sequÃªncia!
            if (currentStreak >= currentSequenceLength && currentStreak < targetSequenceLength) {
                resistances.push({
                    length: currentStreak,
                    startGiro: streakStartGiro,
                    girosAgo: i
                });
            }
            currentStreak = 0;
            lastColor = spin.color;
        }
    }
    
    console.log(`%c   ğŸ“Š RESULTADO DA BUSCA HISTÃ“RICA:`, 'color: #9C27B0; font-weight: bold; font-size: 13px;');
    console.log(`%c      â¤ MÃ¡ximo de ${suggestedColor.toUpperCase()}(s) consecutivos jÃ¡ encontrado: ${maxConsecutive}`, 
        `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    console.log(`%c      â¤ Sinal quer: ${targetSequenceLength} ${suggestedColor.toUpperCase()}(s) consecutivos`, 
        `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    
    // DECISÃƒO: A sequÃªncia sugerida Ã© viÃ¡vel?
    if (targetSequenceLength > maxConsecutive) {
        // NUNCA aconteceu uma sequÃªncia tÃ£o grande!
        console.log('%c   âŒâŒâŒ DECISÃƒO: SEQUÃŠNCIA INVIÃVEL! âŒâŒâŒ', 'color: #FFFFFF; font-weight: bold; font-size: 14px; background: #FF0000;');
        console.log('%c   ğŸ“Œ NUNCA aconteceu no histÃ³rico analisado!', 'color: #FF0000; font-weight: bold;');
        console.log(`%c      â¤ MÃ¡ximo histÃ³rico: ${maxConsecutive} ${suggestedColor.toUpperCase()}(s)`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c      â¤ Sinal pede: ${targetSequenceLength} ${suggestedColor.toUpperCase()}(s)`, 'color: #FF6666; font-weight: bold;');
        console.log('%c   ğŸš« AÃ‡ÃƒO: CANCELAR SINAL (NÃƒO INVERTER)!', 'color: #FFFF00; font-weight: bold; font-size: 14px; background: #FF0000;');
        console.log('%c   ğŸ’¡ Seria burrice apostar em algo que NUNCA aconteceu!', 'color: #FF6666; font-weight: bold;');
        
        return {
            shouldInvert: false,  // âœ… NÃƒO inverte
            shouldReject: true,   // âœ… NOVO: Flag para rejeitar o sinal
            reason: `SequÃªncia NUNCA aconteceu - mÃ¡ximo histÃ³rico: ${maxConsecutive}, sinal pede: ${targetSequenceLength}`,
            maxHistorical: maxConsecutive,
            currentLength: currentSequenceLength,
            isViable: false
        };
    }
    
    // SequÃªncia JÃ aconteceu no passado - mas QUANDO foi a Ãºltima vez?
    // Buscar quando foi a ÃšLTIMA ocorrÃªncia de uma sequÃªncia >= targetSequenceLength
    let lastOccurrenceGirosAgo = null;
    let tempStreak = 0;
    let tempLastColor = null;
    
    for (let i = 0; i < analysisWindow; i++) {
        const spin = history[i];
        
        if (spin.color === suggestedColor) {
            if (tempLastColor !== suggestedColor) {
                tempStreak = 1;
            } else {
                tempStreak++;
            }
            
            // Se atingiu ou ultrapassou o tamanho alvo, registrar
            if (tempStreak >= targetSequenceLength && lastOccurrenceGirosAgo === null) {
                lastOccurrenceGirosAgo = i;
            }
            
            tempLastColor = suggestedColor;
        } else {
            // Qualquer cor diferente QUEBRA a sequÃªncia!
            tempStreak = 0;
            tempLastColor = spin.color;
        }
    }
    
    
    if (lastOccurrenceGirosAgo === null) {
        // NUNCA aconteceu essa sequÃªncia!
        console.log('%c   âŒ NUNCA aconteceu sequÃªncia de ' + targetSequenceLength + '+ ' + suggestedColor.toUpperCase() + '(s) no histÃ³rico!', 'color: #FF0000; font-weight: bold;');
        console.log('%c   ğŸ’¡ DecisÃ£o: CANCELAR sinal (padrÃ£o inexistente)', 'color: #FFD700; font-weight: bold;');
        
        return {
            shouldInvert: false,  // âœ… NÃƒO inverte
            shouldReject: true,   // âœ… REJEITA
            reason: `NUNCA aconteceu ${targetSequenceLength}+ ${suggestedColor}(s) nos Ãºltimos ${analysisWindow} giros`,
            maxHistorical: maxConsecutive,
            currentLength: currentSequenceLength,
            isViable: false
        };
    }
    
    // Encontrou! Agora decidir baseado em QUANDO foi
    console.log(`%c   ğŸ•’ Ãšltima sequÃªncia de ${targetSequenceLength}+ ${suggestedColor.toUpperCase()}(s): hÃ¡ ${lastOccurrenceGirosAgo} giros atrÃ¡s`, 'color: #9C27B0; font-weight: bold;');
    
    // âœ… OPÃ‡ÃƒO 1: Aconteceu nos Ãºltimos 20 giros (RECENTE - padrÃ£o ATIVO)
    if (lastOccurrenceGirosAgo < 20) {
        console.log('%c   âœ… OPÃ‡ÃƒO 1: Aconteceu RECENTEMENTE (< 20 giros)', 'color: #00FF00; font-weight: bold; font-size: 14px;');
        console.log('%c      PadrÃ£o estÃ¡ ATIVO! Pode acontecer de novo!', 'color: #00FF88;');
        console.log('%c   ğŸ’¡ DecisÃ£o: MANTER sinal original', 'color: #FFD700; font-weight: bold;');
        
        return {
            shouldInvert: false,
            reason: `SequÃªncia aconteceu recentemente (hÃ¡ ${lastOccurrenceGirosAgo} giros) - padrÃ£o ativo`,
            maxHistorical: maxConsecutive,
            currentLength: currentSequenceLength,
            isViable: true
        };
    }
    
    // âš ï¸ OPÃ‡ÃƒO 2: Aconteceu entre 20-50 giros (ZONA CINZENTA - analisar mais)
    if (lastOccurrenceGirosAgo >= 20 && lastOccurrenceGirosAgo <= 50) {
        console.log('%c   âš ï¸ OPÃ‡ÃƒO 2: Aconteceu na ZONA CINZENTA (20-50 giros)', 'color: #FFA500; font-weight: bold; font-size: 14px;');
        console.log('%c      Analisando mais profundamente...', 'color: #FFAA00;');
        
        // Buscar TODAS as ocorrÃªncias dessa sequÃªncia
        let allOccurrences = [];
        tempStreak = 0;
        tempLastColor = null;
        
        for (let i = 0; i < analysisWindow; i++) {
            const spin = history[i];
            
            if (spin.color === suggestedColor) {
                if (tempLastColor !== suggestedColor) {
                    tempStreak = 1;
                } else {
                    tempStreak++;
                }
                
                if (tempStreak >= targetSequenceLength) {
                    if (allOccurrences.length === 0 || allOccurrences[allOccurrences.length - 1] !== i) {
                        allOccurrences.push(i);
                    }
                }
                
                tempLastColor = suggestedColor;
            } else {
                // Qualquer cor diferente QUEBRA a sequÃªncia!
                tempStreak = 0;
                tempLastColor = spin.color;
            }
        }
        
        console.log(`%c      ğŸ“Š Total de ocorrÃªncias encontradas: ${allOccurrences.length}`, 'color: #FFAA00;');
        
        if (allOccurrences.length >= 2) {
            // Calcular intervalo mÃ©dio entre ocorrÃªncias
            let intervals = [];
            for (let i = 1; i < allOccurrences.length; i++) {
                intervals.push(allOccurrences[i] - allOccurrences[i - 1]);
            }
            const avgInterval = intervals.reduce((sum, val) => sum + val, 0) / intervals.length;
            
            console.log(`%c      ğŸ“ˆ Intervalo mÃ©dio entre ocorrÃªncias: ${Math.round(avgInterval)} giros`, 'color: #FFAA00;');
            
            // Se o intervalo atual estÃ¡ ABAIXO da mÃ©dia, pode quebrar em breve
            if (lastOccurrenceGirosAgo < avgInterval * 0.8) {
                console.log('%c      âœ… Intervalo atual < 80% da mÃ©dia â†’ PODE QUEBRAR!', 'color: #00FF88; font-weight: bold;');
                console.log('%c   ğŸ’¡ DecisÃ£o: MANTER sinal', 'color: #FFD700; font-weight: bold;');
                
                return {
                    shouldInvert: false,
                    reason: `Intervalo atual (${lastOccurrenceGirosAgo}) < mÃ©dia histÃ³rica (${Math.round(avgInterval)}) - pode quebrar`,
                    maxHistorical: maxConsecutive,
                    currentLength: currentSequenceLength,
                    isViable: true
                };
            } else {
                console.log('%c      âŒ Intervalo atual > 80% da mÃ©dia â†’ AINDA CEDO!', 'color: #FF6666; font-weight: bold;');
                console.log('%c   ğŸ’¡ DecisÃ£o: CANCELAR sinal (ainda cedo)', 'color: #FFD700; font-weight: bold;');
                
                return {
                    shouldInvert: false,  // âœ… NÃƒO inverte
                    shouldReject: true,   // âœ… REJEITA
                    reason: `Intervalo atual (${lastOccurrenceGirosAgo}) > mÃ©dia histÃ³rica (${Math.round(avgInterval)}) - ainda cedo`,
                    maxHistorical: maxConsecutive,
                    currentLength: currentSequenceLength,
                    isViable: false
                };
            }
        } else {
            // SÃ³ aconteceu 1 vez no histÃ³rico - muito raro!
            console.log('%c      âš ï¸ Apenas 1 ocorrÃªncia no histÃ³rico â†’ RARO!', 'color: #FFA500; font-weight: bold;');
            console.log('%c   ğŸ’¡ DecisÃ£o: CANCELAR sinal (evento raro)', 'color: #FFD700; font-weight: bold;');
            
            return {
                shouldInvert: false,  // âœ… NÃƒO inverte
                shouldReject: true,   // âœ… REJEITA
                reason: `Apenas 1 ocorrÃªncia nos Ãºltimos ${analysisWindow} giros - evento raro`,
                maxHistorical: maxConsecutive,
                currentLength: currentSequenceLength,
                isViable: false
            };
        }
    }
    
    // âŒ OPÃ‡ÃƒO 3: Aconteceu hÃ¡ MAIS de 50 giros (MUITO TEMPO - resistÃªncia forte)
    console.log('%c   âŒ OPÃ‡ÃƒO 3: Aconteceu hÃ¡ MUITO TEMPO (> 50 giros)', 'color: #FF0000; font-weight: bold; font-size: 14px;');
    console.log('%c      Faz muito tempo! ResistÃªncia forte!', 'color: #FF6666;');
    console.log('%c   ğŸ’¡ DecisÃ£o: CANCELAR sinal (faz muito tempo)', 'color: #FFD700; font-weight: bold;');
    
    return {
        shouldInvert: false,  // âœ… NÃƒO inverte
        shouldReject: true,   // âœ… REJEITA
        reason: `Ãšltima ocorrÃªncia hÃ¡ ${lastOccurrenceGirosAgo} giros - resistÃªncia forte (> 50 giros)`,
        maxHistorical: maxConsecutive,
        currentLength: currentSequenceLength,
        isViable: false
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ FUNÃ‡Ã•ES AUXILIARES PARA SISTEMA DE 5 NÃVEIS - MODO DIAMANTE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Identifica se Ã© Giro 1 ou Giro 2 baseado no timestamp
 * Cada minuto tem 2 giros (aproximadamente a cada 30 segundos)
 */
function identifySpinPosition(timestamp) {
    const date = new Date(timestamp);
    const seconds = date.getSeconds();
    
    // Giro 1: segundos 0-29
    // Giro 2: segundos 30-59
    return seconds < 30 ? 1 : 2;
}

function normalizeSpinColorValue(input) {
    if (input == null) return null;
    const color = typeof input === 'string' ? input : input.color;
    if (!color) return null;
    const normalized = String(color).toLowerCase();
    if (normalized === 'red' || normalized === 'black' || normalized === 'white') {
        return normalized;
    }
    return null;
}

function toColorEmoji(color) {
    switch (color) {
        case 'red':
            return 'ğŸ”´';
        case 'black':
            return 'âš«';
        case 'white':
            return 'âšª';
        default:
            return 'â”';
    }
}

function formatNgramWindowDisplay(windowSequence = []) {
    if (!Array.isArray(windowSequence) || windowSequence.length === 0) {
        return 'N/A';
    }
    return windowSequence.map(toColorEmoji).join(' â†’ ');
}

function summarizeNgramCounts(counts = {}) {
    const summary = Object.entries(counts)
        .filter(([, value]) => Number(value) > 0)
        .map(([color, value]) => `${toColorEmoji(color)} ${color.toUpperCase()} (${value})`);
    return summary.length > 0 ? summary.join(' | ') : 'Nenhuma ocorrÃªncia registrada';
}

function computeNgramStats(sequence, targetWindow, length) {
    if (!Array.isArray(sequence) || !Array.isArray(targetWindow)) {
        return { total: 0, counts: {} };
    }
    if (sequence.length <= length || targetWindow.length !== length) {
        return { total: 0, counts: {} };
    }
    let total = 0;
    const counts = { red: 0, black: 0, white: 0 };
    for (let i = 0; i + length < sequence.length; i++) {
        let matches = true;
        for (let j = 0; j < length; j++) {
            if (sequence[i + j] !== targetWindow[j]) {
                matches = false;
                break;
            }
        }
        if (!matches) continue;
        const nextColor = sequence[i + length];
        if (!nextColor) continue;
        if (!counts[nextColor]) {
            counts[nextColor] = 0;
        }
        counts[nextColor] += 1;
        total += 1;
    }
    return { total, counts };
}

/**
 * NÃVEL 1: AnÃ¡lise de Cor Dominante
 * Analisa os Ãºltimos 15 giros e retorna a cor que mais saiu
 */
function analyzeDominantColor(history) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #9C27B0; font-weight: bold;');
    console.log('%câ”‚ ğŸ” NÃVEL 1: ANÃLISE DE COR DOMINANTE (15 GIROS)       â”‚', 'color: #9C27B0; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #9C27B0; font-weight: bold;');
    
    const last15 = history.slice(0, Math.min(15, history.length));
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${history.length}`);
    console.log(`   ğŸ“Š Analisando Ãºltimos: ${last15.length} giros`);
    
    let counts = { red: 0, black: 0, white: 0 };
    last15.forEach(spin => {
        if (spin.color in counts) {
            counts[spin.color]++;
        }
    });
    
    console.log(`   ğŸ”´ Vermelhos: ${counts.red} (${(counts.red / last15.length * 100).toFixed(1)}%)`);
    console.log(`   âš« Pretos: ${counts.black} (${(counts.black / last15.length * 100).toFixed(1)}%)`);
    console.log(`   âšª Brancos: ${counts.white} (${(counts.white / last15.length * 100).toFixed(1)}%)`);
    
    // Determinar cor dominante (ignorar branco)
    const dominantColor = counts.red > counts.black ? 'red' : 'black';
    console.log(`   ğŸ—³ï¸ VOTA: ${dominantColor.toUpperCase()} (cor dominante)`);
    
    return {
        color: dominantColor,
        counts: counts,
        total: last15.length,
        percentage: {
            red: (counts.red / last15.length * 100).toFixed(1),
            black: (counts.black / last15.length * 100).toFixed(1),
            white: (counts.white / last15.length * 100).toFixed(1)
        }
    };
}

/**
 * NÃVEL 2: AnÃ¡lise de PosiÃ§Ã£o do Giro
 * Analisa qual cor mais saiu na posiÃ§Ã£o especÃ­fica (Giro 1 ou Giro 2)
 * targetPosition: 1 ou 2 (qual giro queremos analisar)
 */
function analyzeSpinPosition(history, targetPosition) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #00D4FF; font-weight: bold;');
    console.log(`%câ”‚ ğŸ” NÃVEL 2: POSIÃ‡ÃƒO DO GIRO (GIRO ${targetPosition})                  â”‚`, 'color: #00D4FF; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #00D4FF; font-weight: bold;');
    
    const last30 = history.slice(0, Math.min(30, history.length));
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${history.length}`);
    console.log(`   ğŸ“Š Analisando Ãºltimos: ${last30.length} giros`);
    console.log(`   ğŸ¯ Filtrando apenas: Giro ${targetPosition} de cada minuto`);
    
    let counts = { red: 0, black: 0, white: 0 };
    let analyzed = 0;
    
    last30.forEach(spin => {
        if (!spin.timestamp) return;
        
        const position = identifySpinPosition(spin.timestamp);
        if (position === targetPosition) {
            if (spin.color in counts) {
                counts[spin.color]++;
                analyzed++;
            }
        }
    });
    
    console.log(`   ğŸ“Š Total de Giro ${targetPosition} encontrados: ${analyzed}`);
    console.log(`   ğŸ”´ Vermelhos: ${counts.red} (${analyzed > 0 ? (counts.red / analyzed * 100).toFixed(1) : '0.0'}%)`);
    console.log(`   âš« Pretos: ${counts.black} (${analyzed > 0 ? (counts.black / analyzed * 100).toFixed(1) : '0.0'}%)`);
    console.log(`   âšª Brancos: ${counts.white} (${analyzed > 0 ? (counts.white / analyzed * 100).toFixed(1) : '0.0'}%)`);
    
    // Determinar cor dominante nessa posiÃ§Ã£o (ignorar branco)
    const dominantColor = counts.red > counts.black ? 'red' : 'black';
    console.log(`   ğŸ—³ï¸ VOTA: ${dominantColor.toUpperCase()} (mais frequente no Giro ${targetPosition})`);
    
    return {
        color: dominantColor,
        counts: counts,
        analyzed: analyzed,
        percentage: analyzed > 0 ? {
            red: (counts.red / analyzed * 100).toFixed(1),
            black: (counts.black / analyzed * 100).toFixed(1),
            white: (counts.white / analyzed * 100).toFixed(1)
        } : { red: '0.0', black: '0.0', white: '0.0' }
    };
}

/**
 * NÃVEL 3: AnÃ¡lise de Soma dos Minutos
 * Analisa minutos com mesmo final (ex: :11, :21, :31, :41, :51)
 * Faz duas contas: 1) Cor dominante no minuto, 2) Cor dominante na posiÃ§Ã£o do giro
 */
function analyzeMinuteSum(history, currentMinute, targetPosition) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #FF6B35; font-weight: bold;');
    console.log(`%câ”‚ ğŸ” NÃVEL 3: SOMA DOS MINUTOS (X${currentMinute % 10})                  â”‚`, 'color: #FF6B35; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #FF6B35; font-weight: bold;');
    
    const last30 = history.slice(0, Math.min(30, history.length));
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${history.length}`);
    console.log(`   ğŸ“Š Analisando Ãºltimos: ${last30.length} giros`);
    console.log(`   ğŸ• Filtrando minutos terminados em: ${currentMinute % 10} (:${currentMinute % 10}, :1${currentMinute % 10}, :2${currentMinute % 10}...)`);
    console.log(`   ğŸ¯ Giro alvo: Giro ${targetPosition}`);
    
    // Primeira conta: Qual cor domina no minuto especÃ­fico
    let minuteCounts = { red: 0, black: 0, white: 0 };
    
    // Segunda conta: Qual cor domina na posiÃ§Ã£o do giro desse minuto
    let positionCounts = { red: 0, black: 0, white: 0 };
    
    last30.forEach(spin => {
        if (!spin.timestamp) return;
        
        const date = new Date(spin.timestamp);
        const minute = date.getMinutes();
        const minuteDigit = minute % 10; // Pegar Ãºltimo dÃ­gito
        
        if (minuteDigit === (currentMinute % 10)) {
            // Conta 1: Cor no minuto
            if (spin.color in minuteCounts) {
                minuteCounts[spin.color]++;
            }
            
            // Conta 2: Cor na posiÃ§Ã£o especÃ­fica desse minuto
            const position = identifySpinPosition(spin.timestamp);
            if (position === targetPosition && spin.color in positionCounts) {
                positionCounts[spin.color]++;
            }
        }
    });
    
    console.log(`   ğŸ“Š CONTA 1 - Cor dominante no minuto X${currentMinute % 10}:`);
    console.log(`      ğŸ”´ Vermelhos: ${minuteCounts.red} | âš« Pretos: ${minuteCounts.black} | âšª Brancos: ${minuteCounts.white}`);
    
    console.log(`   ğŸ“Š CONTA 2 - Cor dominante no Giro ${targetPosition} do minuto X${currentMinute % 10}:`);
    console.log(`      ğŸ”´ Vermelhos: ${positionCounts.red} | âš« Pretos: ${positionCounts.black} | âšª Brancos: ${positionCounts.white}`);
    
    // Determinar vencedores
    const minuteWinner = minuteCounts.red > minuteCounts.black ? 'red' : 'black';
    const positionWinner = positionCounts.red > positionCounts.black ? 'red' : 'black';
    
    console.log(`   ğŸ† Vencedor Conta 1: ${minuteWinner.toUpperCase()}`);
    console.log(`   ğŸ† Vencedor Conta 2: ${positionWinner.toUpperCase()}`);
    
    // Voto final: se ambos concordam, usar consenso. Se divergem, usar primeira conta
    const finalVote = minuteWinner === positionWinner ? minuteWinner : minuteWinner;
    
    if (minuteWinner === positionWinner) {
        console.log(`   âœ… CONSENSO! Ambas as contas concordam`);
    } else {
        console.log(`   âš ï¸ DIVERGÃŠNCIA! Usando Conta 1 (desempate)`);
    }
    console.log(`   ğŸ—³ï¸ VOTA: ${finalVote.toUpperCase()}`);
    
    return {
        color: finalVote,
        minuteCounts: minuteCounts,
        positionCounts: positionCounts,
        minuteWinner: minuteWinner,
        positionWinner: positionWinner,
        consensus: minuteWinner === positionWinner
    };
}

/**
 * NÃVEL 2 (novo): Ritmo AutÃ´nomo (duplas e sequÃªncia)
 * O usuÃ¡rio define uma janela base W e o N2 ajusta automaticamente para encolher/expandir,
 * validando pelo histÃ³rico (ocorrÃªncias) e reiniciando apÃ³s BRANCO.
 */
function analyzeMomentum(history) {
    // âœ… NOVO N2 (final): janela base Ãºnica W (usuÃ¡rio) + liberdade do cÃ³digo para encolher/expandir
    // Config: n2Recent = W (janela base)
    const baseW = Math.max(6, Math.min(200, getDiamondWindow('n2Recent', 10)));

    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #00AAFF; font-weight: bold;');
    console.log(`%câ”‚ ğŸ” N2: RITMO AUTÃ”NOMO (DUPLAS/SEQUÃŠNCIA) â€¢ W=${baseW} â”‚`, 'color: #00AAFF; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #00AAFF; font-weight: bold;');
    
    return analyzeMomentumWithSizes(history, baseW, 0);
}

function analyzeMomentumWithSizes(history, recentSize, previousSize) {
    // âœ… NOVO N2 (ritmo autÃ´nomo): recentSize = W (janela base); previousSize ignorado
    const clampIntLocal = (n, min, max) => {
        const v = Math.floor(Number(n));
        if (!Number.isFinite(v)) return min;
        return Math.max(min, Math.min(max, v));
    };
    const clamp01Local = (v) => Math.max(0, Math.min(1, Number(v) || 0));
    const opp = (c) => c === 'red' ? 'black' : c === 'black' ? 'red' : null;

    const W = clampIntLocal(recentSize, 6, 200);
    const available = Array.isArray(history) ? history.length : 0;

    const currentColor = normalizeSpinColorValue(Array.isArray(history) ? history[0] : null);
    if (currentColor !== 'red' && currentColor !== 'black') {
        return {
            color: null,
            momentum: { red: '0.0', black: '0.0' },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'ultimo_nao_rb',
            details: 'NULO â€¢ Ãºltimo giro nÃ£o Ã© vermelho/preto'
        };
    }

    if (available < 6) {
        return {
            color: null,
            momentum: { red: '0.0', black: '0.0' },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'historico_insuficiente',
            details: `NULO â€¢ histÃ³rico insuficiente (${available}/6)`
        };
    }

    // Base histÃ³rica (para ocorrÃªncias): maior que W, mas com limite para performance
    const historyCap = Math.min(
        available,
        Math.max(120, Math.min(800, Math.floor(W * 30)))
    );
    const baseSpins = history.slice(0, historyCap).reverse(); // antigo -> recente
    const baseSeq = baseSpins.map(spin => normalizeSpinColorValue(spin)); // red/black/white/null

    const buildRuns = (seqChron) => {
        const by = { red: [], black: [] };
        let cur = null;
        let len = 0;
        for (const c of seqChron) {
            if (c !== 'red' && c !== 'black') {
                if (cur) {
                    by[cur].push(len);
                    cur = null;
                    len = 0;
                }
                continue; // branco quebra
            }
            if (c === cur) {
                len += 1;
    } else {
                if (cur) by[cur].push(len);
                cur = c;
                len = 1;
            }
        }
        if (cur) by[cur].push(len);
        return by;
    };

    const percentile = (arr, p) => {
        const list = Array.isArray(arr) ? arr.slice().filter(n => Number.isFinite(Number(n)) && Number(n) > 0).map(n => Number(n)) : [];
        if (list.length === 0) return 0;
        list.sort((a, b) => a - b);
        const idx = Math.max(0, Math.min(list.length - 1, Math.floor((list.length - 1) * p)));
        return list[idx];
    };

    const baseRunsBy = buildRuns(baseSeq);

    const evalWindow = (w) => {
        const windowSpins = history.slice(0, w).reverse(); // antigo -> recente
        const seq = windowSpins.map(spin => normalizeSpinColorValue(spin)); // red/black/white/null

        const minConfirm = Math.max(6, Math.floor(W * 0.6));

        // âœ… Regra principal do N2 (como vocÃª descreveu):
        // A cor-alvo sÃ³ Ã© vÃ¡lida se, desde o Ãºltimo "singleton" (run=1) COMPLETO dela,
        // ela NÃƒO tiver mais aparecido sozinha (apenas em duplas+). Se sair sÃ³, reinicia dali.
        const findLastSingletonBreak = (seqArr, targetColor) => {
            let cur = null;
            let len = 0;
            let start = 0;
            let lastBreakAt = -1;
            for (let i = 0; i < seqArr.length; i++) {
                const c = seqArr[i];
                const isRB = (c === 'red' || c === 'black');
                if (isRB) {
                    if (c === cur) {
                        len += 1;
                    } else {
                        // fechar run anterior
                        if (cur === targetColor && len === 1) {
                            lastBreakAt = start; // singleton confirmado (porque mudou)
                        }
                        cur = c;
                        len = 1;
                        start = i;
                    }
                } else {
                    // fechar run anterior (branco/preenchimento tambÃ©m confirma a quebra se a run era singleton)
                    if (cur === targetColor && len === 1) {
                        lastBreakAt = start;
                    }
                    cur = null;
                    len = 0;
                    start = i + 1;
                }
            }
            // NÃ£o marcar o Ãºltimo run (mais recente) como quebra: ele ainda estÃ¡ "em andamento"
            return lastBreakAt;
        };

        const pairRate = (lens) => {
            const n = lens.length;
            if (!n) return 0;
            const pairs = lens.filter(v => v >= 2).length;
            return pairs / n;
        };
        const maxLen = (lens) => lens.length ? Math.max(...lens) : 0;
        const singleRate = (lens) => {
            const n = lens.length;
            if (!n) return 0;
            const singles = lens.filter(v => v === 1).length;
            return singles / n;
        };
        const meanLen = (lens) => lens.length ? (lens.reduce((a, b) => a + b, 0) / lens.length) : 0;

        const buildCandidate = (targetColor) => {
            const lastBreakAt = findLastSingletonBreak(seq, targetColor);
            const segment = lastBreakAt >= 0 ? seq.slice(lastBreakAt + 1) : seq;
            const segLen = segment.filter(c => c === 'red' || c === 'black').length;
            if (segLen < minConfirm) return null;

            const runsBy = buildRuns(segment);
            const targetRuns = runsBy[targetColor] || [];
            const other = opp(targetColor);
            const otherRuns = other ? (runsBy[other] || []) : [];

            const rRuns = runsBy.red || [];
            const bRuns = runsBy.black || [];
            const totalRuns = rRuns.length + bRuns.length;
            if (totalRuns < 4) return null;
            if (rRuns.length < 1 || bRuns.length < 1) return null;

            // âœ… â€œNunca sai sÃ³â€: todas as runs COMPLETAS da cor-alvo devem ser >= 2.
            // A Ãºltima run (mais recente) pode estar "em andamento" e pode ser 1 (vamos apostar no 2Âº),
            // mas somente depois de existir "prova suficiente" (ver regra abaixo).
            const isCurrentTarget = currentColor === targetColor;
            const completedTargetRuns = isCurrentTarget ? targetRuns.slice(0, -1) : targetRuns.slice(0);
            if (completedTargetRuns.length === 0) return null; // sem evidÃªncia do padrÃ£o na janela atual
            if (completedTargetRuns.some(v => v < 2)) return null; // houve singleton => deveria ter resetado, logo invÃ¡lido

            // AmeaÃ§a: outra cor com 3+ seguidos derruba totalmente (vocÃª pediu)
            const otherMax = maxLen(otherRuns);
            if (otherMax >= 3) return null;

            const otherSingles = singleRate(otherRuns);
            const completedMean = meanLen(completedTargetRuns);
            const redPair = pairRate(rRuns);
            const blackPair = pairRate(bRuns);

            // Score: quanto mais a outra cor aparece "picada" (singles) e quanto mais a cor-alvo tem runs longas,
            // maior a confianÃ§a do regime "duplas+".
            const evidence = Math.min(1, completedTargetRuns.length / 6);
            const score = clamp01Local(
                (otherSingles * 0.45 + Math.min(1, completedMean / 6) * 0.35 + evidence * 0.20)
            );

            return {
                windowSize: w,
                score,
                target: targetColor,
                other,
                redPair,
                blackPair,
                otherMax,
                totalRuns,
                targetRuns,
                completedTargetRuns,
                segmentLen: segLen,
                lastBreakAt
            };
        };

        const redC = buildCandidate('red');
        const blackC = buildCandidate('black');
        if (!redC && !blackC) return null;
        if (redC && !blackC) return redC;
        if (!redC && blackC) return blackC;
        // desempate: maior score; se empatar, mais prÃ³ximo do W
        if (Math.abs((redC.score || 0) - (blackC.score || 0)) > 1e-9) {
            return (redC.score > blackC.score) ? redC : blackC;
        }
        const dr = Math.abs(redC.windowSize - W);
        const db = Math.abs(blackC.windowSize - W);
        return dr <= db ? redC : blackC;
    };

    // Faixa de busca dinÃ¢mica ao redor de W (sem travar em 6..14)
    const span = Math.max(6, Math.floor(W * 0.55));
    let wMin = Math.max(6, W - span);
    let wMax = Math.min(Math.min(200, available), W + span);
    if (wMax < wMin) { wMin = Math.max(6, Math.min(W, available)); wMax = wMin; }

    const base = W;
    let best = null;
    for (let w = wMin; w <= wMax; w++) {
        const c = evalWindow(w);
        if (!c) continue;
        if (!best) {
            best = c;
            continue;
        }
        if (c.score > best.score + 1e-9) best = c;
        else if (Math.abs(c.score - best.score) <= 1e-9) {
            // tie-break: mais prÃ³ximo do "meio" e mais recente (janela menor)
            const dc = Math.abs(c.windowSize - base);
            const db = Math.abs(best.windowSize - base);
            if (dc < db) best = c;
            else if (dc === db && c.windowSize < best.windowSize) best = c;
        }
    }

    if (!best) {
    return {
            color: null,
            momentum: { red: '0.0', black: '0.0' },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'sem_ritmo',
            details: `NULO â€¢ sem ritmo vÃ¡lido (W=${W} â€¢ busca ${wMin}-${wMax})`
        };
    }

    // tamanho da sequÃªncia atual (sem atravessar branco)
    let currentRunLen = 0;
    for (let i = 0; i < Math.min(best.windowSize, history.length); i++) {
        const c = normalizeSpinColorValue(history[i]);
        if (c !== currentColor) break;
        currentRunLen++;
    }

    // O N2 sÃ³ aposta na cor-alvo quando ela aparece (aposta Ã©: "vai repetir")
    if (currentColor !== best.target) {
        const details = `NULO â€¢ aguardando ${best.target.toUpperCase()} â€¢ W=${W} â€¢ jan ${best.windowSize}`;
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'aguardando_cor_alvo',
            details
        };
    }

    // âœ… REGRA NOVA (pedido): sÃ³ entrar depois de ter "provas" suficientes de que a cor NÃƒO sai sozinha.
    // Prova = ocorrÃªncia de uma run COMPLETA >= 2. A run atual conta como prova sÃ³ quando jÃ¡ estÃ¡ em 2+.
    const completedProofs = Array.isArray(best.completedTargetRuns)
        ? best.completedTargetRuns.filter(v => Number(v) >= 2).length
        : 0;
    const currentProof = (currentRunLen >= 2) ? 1 : 0;
    const proofsTotal = completedProofs + currentProof;
    const PROOFS_REQUIRED = 2;
    if (proofsTotal < PROOFS_REQUIRED) {
        const details = `NULO â€¢ poucas provas (${proofsTotal}/${PROOFS_REQUIRED}) â€¢ run ${currentRunLen} â€¢ W=${W} â€¢ jan ${best.windowSize}`;
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'poucas_provas_duplas',
            details
        };
    }

    // âœ… REGRA NOVA (pedido): se o regime histÃ³rico mostra sequÃªncias longas (4+),
    // nÃ£o entrar no "2Âº" (run=1â†’2). Esperar a dupla se formar e entrar no 3Âº (run>=2).
    const maxCompleted = Array.isArray(best.completedTargetRuns) && best.completedTargetRuns.length
        ? Math.max(...best.completedTargetRuns.map(v => Number(v) || 0))
        : 0;
    const longRegime = maxCompleted >= 4;
    if (longRegime && currentRunLen < 2) {
        const details = `NULO â€¢ regime longo (mÃ¡x ${maxCompleted}) â€¢ aguarde dupla â€¢ run ${currentRunLen} â€¢ W=${W} â€¢ jan ${best.windowSize}`;
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'regime_longo_aguarda_dupla',
            details
        };
    }

    // NÃ£o entrar no "topo" da sequÃªncia: usa p80 para limitar
    // Anti-topo: baseado no "regime atual" (janela apÃ³s reset). Evita apostar em 2â†’3 quando o regime Ã© sÃ³ duplas.
    const topoRuns = Array.isArray(best.completedTargetRuns) ? best.completedTargetRuns.slice() : [];
    // incluir a run atual como evidÃªncia de regime (se jÃ¡ estÃ¡ em 2+)
    if (currentColor === best.target && currentRunLen >= 2) topoRuns.push(currentRunLen);
    const p90Seg = Math.max(1, percentile(topoRuns, 0.9) || 1);
    const maxEnterLen = Math.max(1, p90Seg - 1);
    if (currentRunLen > maxEnterLen) {
        const details = `NULO â€¢ topo seq (${currentRunLen}>${maxEnterLen}) â€¢ W=${W} â€¢ jan ${best.windowSize}`;
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'topo_sequencia',
            details
        };
    }

    // Prob. empÃ­rica de continuar 1 passo: combina base histÃ³rica + janela recente (com suavizaÃ§Ã£o)
    const atRiskRecent = best.targetRuns.filter(len => len >= currentRunLen).length;
    const contRecent = best.targetRuns.filter(len => len >= (currentRunLen + 1)).length;

    // âœ… base histÃ³rica para p(continuar): usar runs da cor-alvo na BASE (Ãºltimos historyCap giros)
    const targetBaseRuns = best.target === 'red'
        ? (baseRunsBy.red || [])
        : (baseRunsBy.black || []);
    const atRiskBase = targetBaseRuns.filter(len => len >= currentRunLen).length;
    const contBase = targetBaseRuns.filter(len => len >= (currentRunLen + 1)).length;

    // Cap base para nÃ£o esmagar o "momento" atual (mantÃ©m o nÃ­vel adaptativo)
    const capBase = 20;
    const atRiskBaseC = Math.min(capBase, atRiskBase);
    const contBaseC = Math.min(atRiskBaseC, contBase);

    const atRisk = atRiskBaseC + atRiskRecent;
    const cont = contBaseC + contRecent;

    if (atRisk < 4) {
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'poucas_ocorrencias',
            details: `NULO â€¢ poucas ocorrÃªncias (n=${atRisk}) â€¢ W=${W} â€¢ jan ${best.windowSize}`
        };
    }
    const pContinue = (cont + 1) / (atRisk + 2); // suavizaÃ§Ã£o

    // Quanto mais avanÃ§ado na sequÃªncia, mais rigoroso (mas o histÃ³rico dita se vale)
    const threshold = currentRunLen <= 1 ? 0.6 : (currentRunLen === 2 ? 0.68 : 0.74);
    if (pContinue < threshold) {
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'pcontinue_baixo',
            details: `NULO â€¢ pCont ${(pContinue * 100).toFixed(0)}% < ${(threshold * 100).toFixed(0)}% â€¢ run ${currentRunLen} â€¢ W=${W}`
        };
    }

    // confianÃ§a: mistura forÃ§a do padrÃ£o + prob. de continuar + amostra
    const contConf = clamp01Local((pContinue - threshold) / Math.max(0.05, 1 - threshold));
    const pairDiff = Math.abs(best.redPair - best.blackPair);
    const pairConf = clamp01Local((Math.max(best.redPair, best.blackPair) - 0.55) / 0.45);
    const diffConf = clamp01Local(pairDiff / 0.5);
    const nConf = clamp01Local(best.totalRuns / 12);
    let confidence = clamp01Local(contConf * 0.45 + pairConf * 0.25 + diffConf * 0.20 + nConf * 0.10);
    confidence = clamp01Local(confidence * (0.9 + best.score * 0.2));

    const details =
        `Alvo ${best.target.toUpperCase()} â€¢ W=${W} â€¢ jan ${best.windowSize} â€¢ seg ${best.segmentLen} â€¢ provas ${proofsTotal}/${PROOFS_REQUIRED} â€¢ ` +
        `P2+ R ${(best.redPair * 100).toFixed(0)}% â€¢ B ${(best.blackPair * 100).toFixed(0)}% â€¢ ` +
        `run ${currentRunLen}â†’${currentRunLen + 1} (${(pContinue * 100).toFixed(0)}%)`;

    return {
        color: best.target,
        momentum: {
            red: (best.redPair * 100).toFixed(1),
            black: (best.blackPair * 100).toFixed(1)
        },
        trending: best.target === 'red' ? 'paired_red' : 'paired_black',
        confidence: Number(confidence.toFixed(3)),
        confidencePct: Math.round(confidence * 100),
        reason: 'ok',
        details
    };
}

/**
 * NÃVEL 5 (novo): Ritmo por Giro e Minuto
 * Mede a cor dominante para o prÃ³ximo giro (1 ou 2) dentro do minuto alvo
 * Examina atÃ© windowSize ocorrÃªncias recentes com mesmo minuto e posiÃ§Ã£o
 */
function analyzeMinuteSpinBias(history, targetMinute, targetPosition, windowSize = 60) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #1ABC9C; font-weight: bold;');
    console.log(`%câ”‚ ğŸ” NÃVEL 5: RITMO POR GIRO (min:${String(targetMinute).padStart(2, '0')} â€¢ giro ${targetPosition}) â”‚`, 'color: #1ABC9C; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #1ABC9C; font-weight: bold;');
    
    // windowSize aqui representa "quantas ocorrÃªncias do mesmo minuto/posiÃ§Ã£o" vamos coletar (nÃ£o giros totais)
    const MAX_WINDOW = Math.max(10, Math.min(200, windowSize));
    const counts = { red: 0, black: 0, white: 0, other: 0 };
    const samples = [];
    
    for (let i = 0; i < history.length && samples.length < MAX_WINDOW; i++) {
        const spin = history[i];
        if (!spin || !spin.timestamp) continue;
        
        const pos = identifySpinPosition(spin.timestamp);
        if (pos !== targetPosition) continue;
        
        const date = new Date(spin.timestamp);
        if (date.getMinutes() !== targetMinute) continue;
        
        const c = spin && spin.color ? String(spin.color).toLowerCase() : '';
        if (c === 'red') counts.red++;
        else if (c === 'black') counts.black++;
        else if (c === 'white') counts.white++;
        else counts.other++;
        samples.push({
            color: spin.color,
            number: spin.number,
            timestamp: date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        });
    }
    
    const totalSamples = samples.length;
    const effectiveSamples = counts.red + counts.black;
    
    console.log(`   ğŸ“Š Amostras encontradas: ${totalSamples} (mÃ¡x ${MAX_WINDOW})`);
    console.log(`      ğŸ”´ Vermelhos: ${counts.red}`);
    console.log(`      âš« Pretos: ${counts.black}`);
    console.log(`      âšª Brancos: ${counts.white}`);
    if (counts.other) console.log(`      â“ Outros: ${counts.other}`);
    
    if (totalSamples === 0 || effectiveSamples <= 0) {
        console.log('   âŒ Dados insuficientes para este minuto/giro');
        return {
            color: null,
            confidence: 0,
            dominantPercent: 0,
            totalSamples,
            effectiveSamples,
            reason: 'no_data',
            details: 'Sem dados suficientes para este minuto/giro'
        };
    }
    
    // âœ… Regras de seguranÃ§a (mas ajustadas para janelas pequenas):
    // Aqui o usuÃ¡rio escolhe "quantas ocorrÃªncias" vamos coletar (ex.: 20).
    // EntÃ£o o rigor deve ser compatÃ­vel com N pequeno.
    const MAX_WHITE_RATIO = 0.25; // se muitos brancos, a amostra fica enviesada

    // âœ… Rigor pedido: detectar viÃ©s pequeno (â‰ˆ 6â€“7pp) sem exigir 67% (17pp).
    // edge = |p - 0.5|. Ex.: 56.5% vs 43.5% => edge=6.5pp
    const MIN_EDGE = 0.065;

    // âœ… Amostra mÃ­nima proporcional ao window escolhido (evita exigir 18 quando window=20)
    const MIN_EFFECTIVE_SAMPLES = Math.max(8, Math.min(30, Math.floor(MAX_WINDOW * 0.5)));

    // z-score mÃ­nimo bem mais baixo (compatÃ­vel com N pequeno).
    // ObservaÃ§Ã£o: isto NÃƒO garante que seja "estatisticamente forte"; apenas evita votar com ruÃ­do total.
    const Z_THRESHOLD = 0.6;

    const whiteRatio = totalSamples > 0 ? (counts.white / totalSamples) : 0;
    if (effectiveSamples < MIN_EFFECTIVE_SAMPLES) {
        return {
            color: null,
            confidence: 0,
            dominantPercent: effectiveSamples > 0 ? (Math.max(counts.red, counts.black) / effectiveSamples) : 0,
            totalSamples,
            effectiveSamples,
            reason: 'low_samples',
            details: `NULO â€¢ poucas amostras Ãºteis (${effectiveSamples}/${MIN_EFFECTIVE_SAMPLES})`
        };
    }
    if (whiteRatio > MAX_WHITE_RATIO) {
        return {
            color: null,
            confidence: 0,
            dominantPercent: Math.max(counts.red, counts.black) / effectiveSamples,
            totalSamples,
            effectiveSamples,
            reason: 'too_many_whites',
            details: `NULO â€¢ muitos brancos (${Math.round(whiteRatio * 100)}%)`
        };
    }

    // Empate => NULO (remove viÃ©s)
    if (counts.red === counts.black) {
        return {
            color: null,
            confidence: 0,
            dominantPercent: 0.5,
            totalSamples,
            effectiveSamples,
            reason: 'tie',
            details: `NULO â€¢ empate (${counts.red}/${counts.black})`
        };
    }

    const dominantColor = counts.red > counts.black ? 'red' : 'black';
    const dominantCount = Math.max(counts.red, counts.black);
    const dominantPercent = dominantCount / Math.max(1, effectiveSamples);
    const edge = Math.abs(dominantPercent - 0.5);

    // z-score para diferenÃ§a de proporÃ§Ãµes contra 50/50 (sem odds, sÃ³ histÃ³rico)
    const z = (dominantPercent - 0.5) / Math.sqrt(0.25 / Math.max(1, effectiveSamples));
    const zAbs = Math.abs(z);

    if (edge < MIN_EDGE) {
        return {
            color: null,
            confidence: 0,
            dominantPercent,
            totalSamples,
            effectiveSamples,
            reason: 'edge_low',
            details: `NULO â€¢ viÃ©s < ${Math.round(MIN_EDGE * 100)}pp (${Math.round(edge * 100)}pp)`
        };
    }
    if (zAbs < Z_THRESHOLD) {
        return {
            color: null,
            confidence: 0,
            dominantPercent,
            totalSamples,
            effectiveSamples,
            reason: 'z_low',
            details: `NULO â€¢ z ${zAbs.toFixed(2)} < ${Z_THRESHOLD}`
        };
    }

    // ConfianÃ§a: combina dominÃ¢ncia com significÃ¢ncia + fator de amostra
    const zConf = Math.max(0, Math.min(1, (zAbs - Z_THRESHOLD) / (2.5 - Z_THRESHOLD)));
    const edgeConf = Math.max(0, Math.min(1, (edge - MIN_EDGE) / (0.25 - MIN_EDGE))); // 25pp jÃ¡ seria extremo
    const sampleConf = Math.max(0, Math.min(1, effectiveSamples / 60));
    const confidence = Math.max(0, Math.min(1, zConf * 0.35 + edgeConf * 0.45 + sampleConf * 0.20));

    const dominantPercentFormatted = (dominantPercent * 100).toFixed(1);
    console.log(`   ğŸ† Cor dominante: ${dominantColor.toUpperCase()} (${dominantPercentFormatted}%)`);
    console.log(`   ğŸ—³ï¸ ConfianÃ§a final: ${(confidence * 100).toFixed(0)}% (viÃ©s ${Math.round(edge * 100)}pp â€¢ z ${zAbs.toFixed(2)} â€¢ n=${effectiveSamples})`);
    
    return {
        color: dominantColor,
        confidence,
        dominantPercent,
        totalSamples,
        effectiveSamples,
        zScore: Number(z.toFixed(3)),
        reason: 'ok',
        details: `${dominantPercentFormatted}% ${dominantColor === 'red' ? 'vermelho' : 'preto'} â€¢ viÃ©s ${Math.round(edge * 100)}pp â€¢ z ${zAbs.toFixed(2)} â€¢ n=${effectiveSamples}`
    };
}

function analyzeHistoricalRetracement(history, windowSize = 80, intensity = 'aggressive') {
    const windowCap = Math.max(30, Math.min(200, Number(windowSize) || 80));
    const rawWindow = Array.isArray(history) ? history.slice(0, Math.min(windowCap, history.length)) : [];

    // âš ï¸ CorreÃ§Ã£o crÃ­tica: branco NÃƒO pode ser "ignorado" aqui.
    // Se filtrarmos branco fora, a sequÃªncia pode "atravessar" branco e virar falsa.
    const norm = rawWindow.map(spin => normalizeSpinColorValue(spin)); // red/black/white/null
    const rb = norm.filter(c => c === 'red' || c === 'black');
    const whiteCount = norm.filter(c => c === 'white').length;
    const total = norm.filter(c => c === 'red' || c === 'black' || c === 'white').length;
    const whiteRatio = total > 0 ? (whiteCount / total) : 0;

    const MIN_EFFECTIVE = 30;
    const MAX_WHITE_RATIO = 0.18;
    if (rb.length < MIN_EFFECTIVE) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            ratio: 0,
            reason: 'amostra_insuficiente',
            details: `NULO â€¢ amostra Ãºtil ${rb.length}/${MIN_EFFECTIVE}`
        };
    }
    if (whiteRatio > MAX_WHITE_RATIO) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            ratio: 0,
            reason: 'muito_branco',
            details: `NULO â€¢ muitos brancos (${Math.round(whiteRatio * 100)}%)`
        };
    }

    const first = norm[0];
    if (first !== 'red' && first !== 'black') {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            ratio: 0,
            reason: 'ultimo_nao_rb',
            details: 'NULO â€¢ Ãºltimo giro nÃ£o Ã© vermelho/preto'
        };
    }

    const currentColor = first;
    let currentStreak = 0;
    for (let i = 0; i < norm.length; i++) {
        const c = norm[i];
        if (c === currentColor) currentStreak++;
        else break; // QUALQUER outra cor (inclui branco) quebra
    }

    // Mapear runs dentro da janela (branco quebra)
    const runsByColor = { red: [], black: [] };
    for (let i = 0; i < norm.length;) {
        const c = norm[i];
        if (c !== 'red' && c !== 'black') {
            i++;
            continue;
        }
        let j = i + 1;
        while (j < norm.length && norm[j] === c) j++;
        runsByColor[c].push(j - i);
        i = j;
    }

    const runs = runsByColor[currentColor] || [];
    const maxStreakFound = runs.length > 0 ? Math.max(...runs) : currentStreak;
    const historicalMax = Math.max(1, maxStreakFound);
    const ratioPct = Math.min(100, Math.round((currentStreak / historicalMax) * 100));

    // Probabilidade empÃ­rica de continuar 1 passo (sem olhar futuro, sÃ³ runs histÃ³ricos da janela)
    const MIN_AT_RISK = 5;
    const atRisk = runs.filter(len => len >= currentStreak).length;
    const cont = runs.filter(len => len >= (currentStreak + 1)).length;
    const pContinue = atRisk > 0 ? (cont / atRisk) : 0;

    if (atRisk < MIN_AT_RISK) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            ratio: ratioPct,
            reason: 'poucas_ocorrencias',
            details: `NULO â€¢ poucas ocorrÃªncias (${atRisk}/${MIN_AT_RISK}) â€¢ seq ${currentStreak}/${historicalMax}`
        };
    }

    const thresholds = {
        aggressive: { inversion: 70, minDelta: 0.28, z: 2.33 },
        conservative: { inversion: 85, minDelta: 0.35, z: 2.58 }
    };
    const t = thresholds[intensity] || thresholds.aggressive;

    let color = null;
    let strength = 0;
    let status = 'âš–ï¸ Neutra';
    let reason = 'neutral';

    // Regra 1: reversÃ£o sÃ³ faz sentido com sequÃªncia mÃ­nima
    const MIN_STREAK_REV = 3;
    const MIN_STREAK_CONT = 2;

    // z-score contra 50/50 da "continuaÃ§Ã£o" (aproximaÃ§Ã£o binomial) para evitar ruÃ­do
    const pHat = pContinue;
    const se = Math.sqrt(Math.max(0, 0.25 / Math.max(1, atRisk)));
    const z = se > 0 ? (pHat - 0.5) / se : 0;
    const zAbs = Math.abs(z);

    if (currentStreak >= MIN_STREAK_REV && ratioPct >= t.inversion && pContinue <= (0.5 - t.minDelta) && zAbs >= t.z) {
        color = currentColor === 'red' ? 'black' : 'red';
        const edge = Math.min(1, ((0.5 - t.minDelta) - pContinue) / 0.5);
        const prox = Math.min(1, (ratioPct - t.inversion) / (100 - t.inversion));
        strength = clamp01(edge * 0.65 + prox * 0.35);
        status = 'ğŸ”„ ReversÃ£o provÃ¡vel';
        reason = 'reversion';
    } else if (currentStreak >= MIN_STREAK_CONT && ratioPct <= 40 && pContinue >= (0.5 + t.minDelta) && zAbs >= t.z) {
        color = currentColor;
        const edge = Math.min(1, (pContinue - (0.5 + t.minDelta)) / 0.5);
        const room = Math.min(1, (40 - ratioPct) / 40);
        strength = clamp01(edge * 0.7 + room * 0.3);
        status = 'âœ… ContinuaÃ§Ã£o';
        reason = 'continuation';
    } else {
        status = 'âš–ï¸ Zona neutra';
        reason = 'neutral_thresholds';
    }

    const details = color
        ? `${status} â€¢ seq ${currentStreak}/${historicalMax} (${ratioPct}%) â€¢ pCont ${(pContinue * 100).toFixed(0)}% (${cont}/${atRisk}) â€¢ z ${zAbs.toFixed(2)}`
        : `NULO â€¢ ${status} â€¢ seq ${currentStreak}/${historicalMax} (${ratioPct}%) â€¢ pCont ${(pContinue * 100).toFixed(0)}% (${cont}/${atRisk})`;

    return {
        color,
        strength,
        status,
        ratio: ratioPct,
        reason,
        details
    };
}

function analyzeBayesianCalibration(history, baseWindow = 100, priorConfig = { red: 1, black: 1, white: 0.5 }, nullDiff = 0.08) {
    const sanitizedBase = Math.max(20, Math.min(500, Number(baseWindow) || 100));
    const windowSize = Math.min(history.length, sanitizedBase);
    const windowSpins = history.slice(0, windowSize);

    const counts = { red: 0, black: 0, white: 0 };
    windowSpins.forEach(spin => {
        if (spin && typeof spin.color === 'string' && Object.prototype.hasOwnProperty.call(counts, spin.color)) {
            counts[spin.color]++;
        }
    });

    const totalSamples = counts.red + counts.black + counts.white;
    const coverage = Math.min(1, totalSamples / Math.max(1, sanitizedBase));

    const prior = {
        red: Math.max(0.01, Number(priorConfig.red) || 1),
        black: Math.max(0.01, Number(priorConfig.black) || 1),
        white: Math.max(0.01, Number(priorConfig.white) || Math.max(0.01, (Number(priorConfig.red) || 1) * 0.5))
    };

    const posterior = {
        red: prior.red + counts.red,
        black: prior.black + counts.black,
        white: prior.white + counts.white
    };
    const posteriorTotal = posterior.red + posterior.black + posterior.white;

    const probabilities = {
        red: posteriorTotal > 0 ? posterior.red / posteriorTotal : 1 / 3,
        black: posteriorTotal > 0 ? posterior.black / posteriorTotal : 1 / 3,
        white: posteriorTotal > 0 ? posterior.white / posteriorTotal : 1 / 3
    };

    const sorted = Object.entries(probabilities).sort(([, a], [, b]) => b - a);
    const [topColor, topProb] = sorted[0] || ['red', 1 / 3];
    const [, secondProb] = sorted[1] || ['black', 1 / 3];
    const gap = topProb - secondProb;
    const effectiveThreshold = Math.max(0.01, Number(nullDiff) || 0.08);
    const normalizedGap = Math.min(1, gap / effectiveThreshold);
    const strength = coverage * normalizedGap;
    const shouldStayNeutral = gap < effectiveThreshold || coverage < 0.3;
    const selectedColor = shouldStayNeutral ? null : topColor;

    const maxProb = Math.max(probabilities.red, probabilities.black, probabilities.white, 0.0001);
    const adjustments = {};
    ['red', 'black', 'white'].forEach(color => {
        const ratio = maxProb > 0 ? probabilities[color] / maxProb : 1;
        let factor = (ratio * coverage) + (1 - coverage);
        if (color === topColor) {
            factor = Math.min(1.05, factor + Math.min(0.05, gap * 0.25));
        }
        factor = Math.max(0.35, Math.min(1.05, factor));
        adjustments[color] = factor;
    });

    const toPct = value => `${(value * 100).toFixed(1)}%`;
    const diffPct = (gap * 100).toFixed(1);
    const detailsParts = [
        `ğŸ”´ ${toPct(probabilities.red)}`,
        `âš« ${toPct(probabilities.black)}`,
        `âšª ${toPct(probabilities.white)}`,
        `Î” ${diffPct}%`,
        `jan ${totalSamples}/${sanitizedBase}`
    ];

    if (shouldStayNeutral) {
        detailsParts.push(`nulo < ${(effectiveThreshold * 100).toFixed(0)}%`);
    } else {
        detailsParts.push(`lider ${topColor.toUpperCase()}`);
    }

    return {
        color: selectedColor,
        probabilities,
        strength,
        gap,
        coverage,
        adjustments,
        details: detailsParts.join(' â€¢ '),
        totalSamples,
        baseWindow: sanitizedBase,
        threshold: effectiveThreshold,
        nullVote: shouldStayNeutral
    };
}

function analyzeGlobalContinuity(signalData, decisionWindow = 20, historyLimit = 100, intensity = 'aggressive') {
    if (!signalData || !Array.isArray(signalData.signals) || signalData.signals.length === 0) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            details: 'Sem decisÃµes registradas'
        };
    }

    const relevantSignals = signalData.signals
        .slice(-Math.max(decisionWindow, Math.min(800, Number(historyLimit) || 100)))
        .filter(sig => sig && typeof sig.hit === 'boolean' && (sig.colorRecommended === 'red' || sig.colorRecommended === 'black'));

    const minBase = Math.max(12, Math.min(decisionWindow, 25));
    if (relevantSignals.length < minBase) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            details: `HistÃ³rico de decisÃµes insuficiente (${relevantSignals.length}/${minBase})`
        };
    }

    const windowSignals = relevantSignals.slice(-decisionWindow);
    const colorStats = {
        red: { attempts: 0, hits: 0 },
        black: { attempts: 0, hits: 0 }
    };

    windowSignals.forEach(sig => {
        const color = sig.colorRecommended;
        if (!colorStats[color]) return;
        colorStats[color].attempts++;
        if (sig.hit) colorStats[color].hits++;
    });

    const totalAttempts = windowSignals.length;
    const totalHits = windowSignals.filter(sig => sig.hit).length;
    const overallRate = totalAttempts > 0 ? (totalHits / totalAttempts) * 100 : 0;

    const thresholds = {
        aggressive: { high: 55, low: 40 },
        conservative: { high: 65, low: 50 }
    };
    const { high } = thresholds[intensity] || thresholds.aggressive;

    // âœ… Se a taxa geral estÃ¡ baixa, esse nÃ­vel NÃƒO deve "forÃ§ar" voto (evita ruÃ­do)
    if (overallRate < high) {
        return {
            color: null,
            strength: 0,
            status: 'âš ï¸ Instabilidade',
            reason: 'overall_low',
            details: `NULO â€¢ taxa geral ${overallRate.toFixed(1)}% < ${high}% â€¢ n=${totalAttempts}`
        };
    }

    const rAtt = colorStats.red.attempts;
    const bAtt = colorStats.black.attempts;
    const rHit = colorStats.red.hits;
    const bHit = colorStats.black.hits;

    // âœ… Para comparar cores, precisamos de amostra mÃ­nima em AMBAS.
    const MIN_PER_COLOR = 6;
    if (rAtt < MIN_PER_COLOR || bAtt < MIN_PER_COLOR) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            reason: 'per_color_low',
            details: `NULO â€¢ poucas amostras por cor (R ${rAtt}/${MIN_PER_COLOR} â€¢ B ${bAtt}/${MIN_PER_COLOR})`
        };
    }

    const pR = rAtt > 0 ? rHit / rAtt : 0;
    const pB = bAtt > 0 ? bHit / bAtt : 0;
    const delta = pR - pB;
    const deltaAbs = Math.abs(delta);

    // CritÃ©rio de rigor: diferenÃ§a mÃ­nima (15-20pp) + significÃ¢ncia
    const MIN_DELTA = intensity === 'conservative' ? 0.20 : 0.15;
    const Z_THRESHOLD = intensity === 'conservative' ? 2.58 : 2.33;

    if (deltaAbs < MIN_DELTA) {
        return {
            color: null,
            strength: 0,
            status: 'âš–ï¸ Neutra',
            reason: 'delta_low',
            details: `NULO â€¢ Î” ${(deltaAbs * 100).toFixed(0)}pp < ${(MIN_DELTA * 100).toFixed(0)}pp â€¢ R ${(pR * 100).toFixed(0)}% â€¢ B ${(pB * 100).toFixed(0)}%`
        };
    }

    const pooled = (rHit + bHit) / Math.max(1, rAtt + bAtt);
    const se = Math.sqrt(Math.max(0, pooled * (1 - pooled)) * (1 / rAtt + 1 / bAtt));
    const z = se > 0 ? delta / se : 0;
    const zAbs = Math.abs(z);
    if (zAbs < Z_THRESHOLD) {
        return {
            color: null,
            strength: 0,
            status: 'âš–ï¸ Neutra',
            reason: 'z_low',
            details: `NULO â€¢ z ${zAbs.toFixed(2)} < ${Z_THRESHOLD} â€¢ Î” ${(deltaAbs * 100).toFixed(0)}pp`
        };
    }

    const voteColor = delta > 0 ? 'red' : 'black';
    const zConf = Math.max(0, Math.min(1, (zAbs - Z_THRESHOLD) / (4 - Z_THRESHOLD)));
    const dConf = Math.max(0, Math.min(1, (deltaAbs - MIN_DELTA) / (0.45 - MIN_DELTA)));
    const nConf = Math.max(0, Math.min(1, totalAttempts / 40));
    const strength = clamp01(zConf * 0.55 + dConf * 0.35 + nConf * 0.10);
    const status = strength >= 0.85 ? 'ğŸ”¥ Alta confianÃ§a' : 'âœ… Continuidade';

    const details = `${status} â€¢ Î” ${(delta * 100).toFixed(0)}pp â€¢ z ${zAbs.toFixed(2)} â€¢ geral ${overallRate.toFixed(1)}% â€¢ R ${rHit}/${rAtt} â€¢ B ${bHit}/${bAtt}`;

    return {
        color: voteColor,
        strength,
        status,
        reason: 'ok',
        details
    };
}

/**
 * NÃVEL 6: Barreira/Freio - Valida se a sequÃªncia Ã© viÃ¡vel historicamente
 * Usa somente os Ãºltimos 50 giros para garantir proteÃ§Ã£o recente
 */
function validateSequenceBarrier(history, predictedColor, configuredSize, alternanceInfo = null) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #FF0000; font-weight: bold;');
    console.log('%câ”‚ ğŸ” NÃVEL 6: BARREIRA (FREIO DE SEGURANÃ‡A)             â”‚', 'color: #FF0000; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #FF0000; font-weight: bold;');
    
    const barrierWindowConfigured = Math.max(1, configuredSize || 50);
    const effectiveWindow = Math.min(barrierWindowConfigured, history.length);
    const last = history.slice(0, effectiveWindow);
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${history.length}`);
    console.log(`   ğŸ“Š HistÃ³rico configurado: ${configuredSize} giros`);
    console.log(`   ğŸ“Š Janela da barreira: ${barrierWindowConfigured} giros`);
    console.log(`   ğŸ“Š Analisando Ãºltimos: ${last.length} giros`);
    console.log(`   ğŸ¯ Cor prevista pelos outros nÃ­veis: ${predictedColor.toUpperCase()}`);
    
    // Contar quantos da cor prevista jÃ¡ saÃ­ram consecutivamente
    // âš ï¸ IMPORTANTE: BRANCO QUEBRA A SEQUÃŠNCIA!
    let currentStreak = 0;
    for (let i = 0; i < last.length; i++) {
        if (last[i].color === predictedColor) {
            currentStreak++;
        } else {
            // âœ… QUALQUER outra cor (incluindo BRANCO) quebra a sequÃªncia!
            break;
        }
    }
    
    console.log(`   ğŸ“Š SequÃªncia atual de ${predictedColor.toUpperCase()}: ${currentStreak} giro(s)`);
    
    // Verificar se sequÃªncia de (currentStreak + 1) jÃ¡ aconteceu
    const targetStreak = currentStreak + 1;
    console.log(`   ğŸ¯ Se entrar agora, teremos: ${targetStreak} ${predictedColor.toUpperCase()} consecutivos`);
    
    let maxStreakFound = 0;
    let streakCount = 0;
    let currentColor = null;
    
    for (let i = 0; i < last.length; i++) {
        if (last[i].color === predictedColor) {
            if (currentColor === predictedColor) {
                streakCount++;
            } else {
                streakCount = 1;
                currentColor = predictedColor;
            }
            maxStreakFound = Math.max(maxStreakFound, streakCount);
        } else {
            // âœ… QUALQUER outra cor (incluindo BRANCO) quebra a sequÃªncia!
            currentColor = last[i].color;
            streakCount = 1;
        }
    }
    
    console.log(`   ğŸ“Š Maior sequÃªncia de ${predictedColor.toUpperCase()} encontrada: ${maxStreakFound} giro(s)`);
    
    let allowed = targetStreak <= maxStreakFound;
    let alternanceBlocked = false;
    let reasonText = allowed
        ? `âœ… SequÃªncia de ${targetStreak} ${predictedColor} jÃ¡ aconteceu ${maxStreakFound >= targetStreak ? 'antes' : ''}`
        : `âŒ SequÃªncia de ${targetStreak} ${predictedColor} NUNCA aconteceu (mÃ¡x: ${maxStreakFound})`;
    
    if (allowed) {
        console.log(`   âœ… APROVADO! SequÃªncia de ${targetStreak} Ã© historicamente viÃ¡vel`);
        console.log(`   ğŸš¦ Sinal LIBERADO para prosseguir`);
    } else {
        console.log(`   âŒ BLOQUEADO! SequÃªncia de ${targetStreak} NUNCA aconteceu antes (mÃ¡x: ${maxStreakFound})`);
        console.log(`   ğŸ›‘ Sinal BLOQUEADO por seguranÃ§a (sem precedente histÃ³rico)`);
    }
    
    if (alternanceInfo && alternanceInfo.override) {
        const targetRuns = alternanceInfo.targetRuns || 0;
        const maxRuns = alternanceInfo.maxRuns || 0;
        if (maxRuns && targetRuns && targetRuns > maxRuns) {
            console.log(`   âŒ BLOQUEADO! AlternÃ¢ncia excede histÃ³rico (${targetRuns} blocos > ${maxRuns})`);
            allowed = false;
            alternanceBlocked = true;
            reasonText = `âŒ AlternÃ¢ncia excede histÃ³rico (${targetRuns} > ${maxRuns})`;
        } else {
            console.log(`   âœ… AlternÃ¢ncia dentro do histÃ³rico (${targetRuns}/${maxRuns || 'âˆ'})`);
        }
    }
    
    return {
        allowed,
        currentStreak: currentStreak,
        targetStreak: targetStreak,
        maxStreakFound: maxStreakFound,
        reason: reasonText,
        alternanceBlocked
    };
}

/**
 * NÃVEL 3: AlternÃ¢ncia (REAL) â€” simples/dupla/tripla
 *
 * DefiniÃ§Ã£o (sem branco):
 * - Simples:   P-V-P-V-...
 * - Dupla:     P-P-V-V-P-P-...
 * - Tripla:    P-P-P-V-V-V-P-P-P-...
 *
 * Regras:
 * - Branco SEMPRE quebra a alternÃ¢ncia (nÃ£o Ã© vÃ¡lido)
 * - O tamanho (L) Ã© em "blocos" (runs), nÃ£o em giros:
 *   - Simples (g=1):  L blocos = L giros
 *   - Dupla   (g=2):  L blocos = 2L giros
 *   - Tripla  (g=3):  L blocos = 3L giros
 *
 * Config:
 * - historySize: janela analisada (giros)
 * - minOccurrences: mÃ­nimo de ocorrÃªncias histÃ³ricas no recorte
 * - threshold: rigor mÃ­nimo (taxa de continuaÃ§Ã£o do padrÃ£o) no recorte
 */
function analyzeAlternancePattern(history, options = {}) {
    logSection('[N3] AlternÃ¢ncia (simples/dupla/tripla)');

    const defaultSettings = {
        historySize: 60,
        threshold: 0.75,
        minOccurrences: 1,
        allowBackoff: false,
        ignoreWhite: false // mantido por compatibilidade, mas branco sempre quebra alternÃ¢ncia
    };

    const settings = {
        historySize: Number(options.historySize) > 0 ? Number(options.historySize) : defaultSettings.historySize,
        threshold: typeof options.threshold === 'number' ? options.threshold : defaultSettings.threshold,
        minOccurrences: Number(options.minOccurrences) > 0 ? Number(options.minOccurrences) : defaultSettings.minOccurrences,
        allowBackoff: !!options.allowBackoff,
        ignoreWhite: !!options.ignoreWhite
    };

    // Comprimento Ã© AUTOMÃTICO (nÃ£o depende do usuÃ¡rio). historySize Ã© a Ãºnica janela obrigatÃ³ria.
    settings.historySize = Math.max(4, Math.floor(Math.max(1, settings.historySize)));
    settings.threshold = clamp01(settings.threshold);
    settings.minOccurrences = Math.max(1, Math.min(100, Math.floor(settings.minOccurrences)));

    const trimmedHistory = Array.isArray(history) ? history.slice(0, settings.historySize) : [];
    const chronologicalSpins = trimmedHistory.slice().reverse();
    const seq = chronologicalSpins.map(spin => normalizeSpinColorValue(spin)); // red/black/white/null
    const totalAvailable = seq.filter(c => c === 'red' || c === 'black' || c === 'white').length;

    const isRB = (c) => c === 'red' || c === 'black';
    const oppositeRB = (c) => (c === 'red' ? 'black' : (c === 'black' ? 'red' : null));

    const buildRunsBackward = (endIdx, groupSize) => {
        if (endIdx < 0 || endIdx >= seq.length) return null;
        const lastColor = seq[endIdx];
        if (!isRB(lastColor)) return null;

        const runs = [];
        let curColor = lastColor;
        let len = 0;
        for (let i = endIdx; i >= 0; i--) {
            const c = seq[i];
            if (!isRB(c)) break; // branco (ou invÃ¡lido) quebra
            if (c === curColor) {
                len += 1;
                if (len > groupSize) return null; // excedeu bloco â†’ nÃ£o Ã© alternÃ¢ncia desse tipo
            } else {
                runs.push({ color: curColor, len });
                curColor = c;
                len = 1;
            }
        }
        runs.push({ color: curColor, len });
        return runs; // newest-to-oldest
    };

    const checkAlternanceRuns = (runsNewestFirst, groupSize, neededBlocks) => {
        if (!Array.isArray(runsNewestFirst) || runsNewestFirst.length < neededBlocks) return null;
        const runs = runsNewestFirst.slice(0, neededBlocks);
        if (runs.length < 2) return null;

        // âœ… REGRA CRÃTICA (pedido do usuÃ¡rio):
        // AlternÃ¢ncia sÃ³ existe quando estÃ¡ CONCRETIZADA (blocos completos), ex:
        // - Simples:  R B R B  (g=1)
        // - Dupla:    RR BB    (g=2)
        // - Tripla:   RRR BBB  (g=3)
        // Se um bloco quebra antes de completar (len < groupSize), NÃƒO Ã© alternÃ¢ncia (ainda nÃ£o formou).
        // Branco jÃ¡ quebra antes (buildRunsBackward para em branco).
        if (groupSize > 1) {
            for (const r of runs) {
                if (r.len !== groupSize) return null;
            }
        }

        const newest = runs[0];
        // âœ… ApÃ³s completar o ciclo (bloco cheio), a prÃ³xima "cabeÃ§a" Ã© sempre a cor oposta.
        const expectedNext = oppositeRB(newest.color);
        if (!isRB(expectedNext)) return null;

        const spinsUsed = runs.reduce((acc, r) => acc + (r.len || 0), 0);
        return {
            runs,
            blocks: runs.length,
            groupSize,
            spinsUsed,
            currentRunLen: newest.len,
            expectedNext
        };
    };

    const detectCurrentAlternance = () => {
        const endIdx = seq.length - 1;
        if (endIdx < 0) return null;

        const groupSizes = [3, 2, 1];

        // âœ… Pedido do usuÃ¡rio: sÃ³ considerar alternÃ¢ncia quando o padrÃ£o jÃ¡ FORMOU (ciclo completo).
        // - simples: precisa de 4 blocos (R B R B)
        // - dupla/tripla: precisa de 2 blocos completos (RR BB / RRR BBB)
        const minBlocksFor = (g) => (g === 1 ? 4 : 2);

        let bestStructural = null;
        let bestPassing = null;

        for (const g of groupSizes) {
            const runsAll = buildRunsBackward(endIdx, g);
            if (!runsAll) continue;

            const maxBlocks = runsAll.length;
            const minBlocks = minBlocksFor(g);
            // âœ… Comprimento automÃ¡tico: sempre tenta do maior para o menor para nÃ£o "bicar" alternÃ¢ncias menores.
            const blocksToTry = [];
            for (let b = maxBlocks; b >= minBlocks; b--) blocksToTry.push(b);

            // estrutural (apenas para dizer "existe alternÃ¢ncia")
            let structuralBlocksForG = null;
            for (let b of blocksToTry) {
                const det = checkAlternanceRuns(runsAll, g, b);
                if (!det) continue;
                structuralBlocksForG = b;
                if (!bestStructural ||
                    det.groupSize > bestStructural.groupSize ||
                    (det.groupSize === bestStructural.groupSize && det.blocks > bestStructural.blocks)
                ) {
                    bestStructural = { ...det, backoffApplied: b !== maxBlocks };
                }
                // Como tentamos do maior -> menor, o primeiro match Ã© o melhor "comprimento"
            break;
        }

            // passando critÃ©rios (rigor + ocorrÃªncias)
            // - se allowBackoff=false, usamos o MAIOR comprimento estrutural vÃ¡lido (nÃ£o o maxBlocks bruto),
            //   porque maxBlocks pode incluir um bloco quebrado que invalida a alternÃ¢ncia.
            const blocksToTryPassing = settings.allowBackoff
                ? blocksToTry
                : (structuralBlocksForG ? [structuralBlocksForG] : []);
            for (let b of blocksToTryPassing) {
                const det = checkAlternanceRuns(runsAll, g, b);
                if (!det) continue;
                const stats = computeContinuationStats(g, b);
                if (stats.occurrences < settings.minOccurrences) continue;
                if (stats.rate < settings.threshold) continue;

                const candidate = {
                    ...det,
                    backoffApplied: b !== maxBlocks,
                    stats
                };

                if (!bestPassing ||
                    candidate.groupSize > bestPassing.groupSize ||
                    (candidate.groupSize === bestPassing.groupSize && candidate.blocks > bestPassing.blocks) ||
                    (candidate.groupSize === bestPassing.groupSize && candidate.blocks === bestPassing.blocks && (candidate.stats.rate > bestPassing.stats.rate))
                ) {
                    bestPassing = candidate;
                }
                // Primeiro match jÃ¡ Ã© o maior "comprimento" vÃ¡lido para esse g (tentamos do maior -> menor)
                break;
            }
        }

        if (bestPassing) return { kind: 'pass', ...bestPassing };
        if (bestStructural) return { kind: 'struct', ...bestStructural };
        return null;
    };

    const detectAtIndex = (idx, groupSize, neededBlocks) => {
        // idx Ã© o "Ãºltimo giro observado"; prever idx+1
        if (idx < 0 || idx >= seq.length) return null;
        if (!isRB(seq[idx])) return null;

        const runsAll = buildRunsBackward(idx, groupSize);
        if (!runsAll) return null;
        return checkAlternanceRuns(runsAll, groupSize, neededBlocks);
    };

    const computeContinuationStats = (groupSize, neededBlocks) => {
        let occurrences = 0;
        let hits = 0;
        for (let i = 0; i < seq.length - 1; i++) {
            const det = detectAtIndex(i, groupSize, neededBlocks);
            if (!det) continue;
            occurrences += 1;
            const actualNext = seq[i + 1];
            if (actualNext === det.expectedNext) hits += 1;
        }
        const rate = occurrences > 0 ? hits / occurrences : 0;
        return { occurrences, hits, rate };
    };

    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${Array.isArray(history) ? history.length : 0}`);
    console.log(`   âš™ï¸ Config â†’ histÃ³rico: ${settings.historySize} | rigor: ${(settings.threshold * 100).toFixed(0)}% | min occ: ${settings.minOccurrences}`);
    console.log(`   âš™ï¸ Branco sempre quebra alternÃ¢ncia (ignorar branco = irrelevante)`);

    if (seq.length < 4) {
        const message = `Apenas ${seq.length} giros na janela (mÃ­nimo: 4)`;
        return {
            color: null,
            pattern: 'Dados insuficientes',
            alternationRate: '0.0',
            alternationSize: 0,
            confidence: 0,
            details: message,
            reason: 'insufficient_history',
            historyUsed: seq.length,
            historyConfigured: settings.historySize,
            override: false,
            alternanceRuns: null,
            alternanceTargetRuns: null,
            alternanceMaxRuns: null,
            alternanceBaseSize: null
        };
    }

    const current = detectCurrentAlternance();
    if (!current) {
        return {
            color: null,
            pattern: 'AlternÃ¢ncia',
            alternationRate: '0.0',
            alternationSize: 0,
            confidence: 0,
            details: 'NULO',
            reason: 'no_alternance_detected',
            historyUsed: totalAvailable,
            historyConfigured: settings.historySize,
            override: false,
            alternanceRuns: null,
            alternanceTargetRuns: null,
            alternanceMaxRuns: null,
            alternanceBaseSize: null
        };
    }

    const typeName = current.groupSize === 1 ? 'Simples' : (current.groupSize === 2 ? 'Dupla' : 'Tripla');

    // se kind === 'pass', jÃ¡ temos stats; senÃ£o calcular stats apenas para exibir (nÃ£o votar)
    const stats = current.kind === 'pass' && current.stats ? current.stats : computeContinuationStats(current.groupSize, current.blocks);
    const occurrences = stats.occurrences || 0;
    const hits = stats.hits || 0;
    const rate = stats.rate || 0;
    const pct = (rate * 100);

    const meetsOcc = occurrences >= settings.minOccurrences;
    const meetsThreshold = rate >= settings.threshold;

    const allowVote = current.kind === 'pass' && meetsOcc && meetsThreshold;
    const finalColor = allowVote ? current.expectedNext : null;

    const occBoost = occurrences > 0 ? Math.min(1, occurrences / Math.max(settings.minOccurrences + 2, 3)) : 0;
    const finalConfidence = allowVote ? clamp01((rate * 0.8) + (occBoost * 0.2)) : 0;

    const details = [
        `Alt ${typeName}`,
        `blocos ${current.blocks}`,
        `fase ${current.currentRunLen}/${current.groupSize}`,
        `rigor ${pct.toFixed(1)}% (${hits}/${occurrences})`,
        current.backoffApplied ? 'backoff' : null
    ].filter(Boolean).join(' â€¢ ');

    const overrideActive = Boolean(
        allowVote &&
        rate >= Math.max(settings.threshold + 0.1, 0.9) &&
        occurrences >= settings.minOccurrences + 1
    );
    
    return {
        color: finalColor,
        pattern: `AlternÃ¢ncia ${typeName}`,
        alternationRate: pct.toFixed(1),
        alternationSize: current.blocks,
        confidence: finalConfidence,
        probability: rate,
        probabilityPct: pct.toFixed(1),
        occurrences,
        window: null,
        windowLabel: null,
        threshold: settings.threshold,
        thresholdPct: (settings.threshold * 100).toFixed(1),
        minOccurrences: settings.minOccurrences,
        allowBackoff: settings.allowBackoff,
        ignoreWhite: settings.ignoreWhite,
        historyUsed: totalAvailable,
        historyConfigured: settings.historySize,
        details,
        reason: allowVote ? null : (!meetsOcc ? 'min_occ_not_met' : 'threshold_not_met'),
        backoffApplied: current.backoffApplied,
        override: overrideActive,
        alternanceRuns: current.blocks,
        alternanceTargetRuns: null,
        alternanceMaxRuns: null,
        alternanceBaseSize: current.groupSize
    };
}

/**
 * NÃVEL 8: AnÃ¡lise de Impacto de Zeros (Brancos)
 * ApÃ³s um branco, a tendÃªncia anterior costuma continuar
 * Analisa os Ãºltimos 15 giros + 5 giros antes do Ãºltimo branco
 */
/**
 * NÃVEL 5 (antigo 8): RADAR DE BRANCOS (ANÃLISE INTELIGENTE DE 2000 GIROS)
 * 
 * FUNÃ‡ÃƒO EXCLUSIVA: Analisar o comportamento dos BRANCOS (zeros)
 * 
 * METODOLOGIA CORRETA:
 * 1. Mapear TODOS os brancos do mais ANTIGO ao mais RECENTE
 * 2. Para cada branco, analisar:
 *    - NÃºmero que "puxou" o branco (giro imediatamente antes)
 *    - Minuto que o branco saiu (timestamp)
 *    - Quantos giros entre este branco e o anterior
 *    - PadrÃ£o dos Ãºltimos 3-5 giros antes do branco
 * 3. Detectar padrÃµes estatÃ­sticos (nÃºmeros favoritos, minutos favoritos, intervalos)
 * 4. PREVER BRANCO quando: nÃºmero atual + minuto atual + intervalo >= mÃ©dia
 * 
 * DOIS MODOS DE OPERAÃ‡ÃƒO:
 * 1ï¸âƒ£ MODO vote_color: Vota na cor que mais sai APÃ“S brancos
 * 2ï¸âƒ£ MODO force_white: FORÃ‡A entrada em BRANCO quando padrÃµes batem
 */
function analyzeWhiteRadar(fullHistory) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #16A085; font-weight: bold;');
    console.log('%câ”‚ ğŸ” NÃVEL 5: RADAR DE BRANCOS (2000 GIROS)             â”‚', 'color: #16A085; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #16A085; font-weight: bold;');
    
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${fullHistory.length}`);
    console.log(`   ğŸ¯ Metodologia: AnÃ¡lise do PRIMEIRO ao ÃšLTIMO branco`);
    
    if (fullHistory.length < 50) {
        console.log(`   âŒ Dados insuficientes! MÃ­nimo: 50 giros`);
        return {
            mode: 'vote_color',
            color: null,
            whiteCount: 0,
            confidence: 0,
            details: 'Menos de 50 giros para anÃ¡lise'
        };
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š ETAPA 1: MAPEAR TODOS OS BRANCOS (DO MAIS ANTIGO AO MAIS RECENTE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%cğŸ“Š ETAPA 1: MAPEANDO BRANCOS DO PRIMEIRO AO ÃšLTIMO', 'color: #FFD700; font-weight: bold;');
    
    const whiteOccurrences = []; // Array de objetos com dados completos de cada branco
    
    // Iterar do mais ANTIGO (final do array) ao mais RECENTE (inÃ­cio)
    for (let i = fullHistory.length - 1; i >= 0; i--) {
        if (fullHistory[i].color === 'white') {
            const whiteData = {
                index: i,
                position: fullHistory.length - i, // PosiÃ§Ã£o do giro (1 = mais antigo)
                timestamp: fullHistory[i].timestamp,
                minute: null,
                numberBefore: null, // NÃºmero que "puxou" o branco
                colorBefore: null,
                girosFromPrevious: null, // Giros entre este e o branco anterior
                last3Pattern: null, // Ãšltimos 3 giros antes do branco
                last5Pattern: null  // Ãšltimos 5 giros antes do branco
            };
            
            // Pegar minuto do timestamp
            if (whiteData.timestamp) {
                const date = new Date(whiteData.timestamp);
                whiteData.minute = date.getMinutes();
            }
            
            // Pegar nÃºmero que "puxou" o branco (giro imediatamente anterior)
            if (i + 1 < fullHistory.length) {
                const spinBefore = fullHistory[i + 1];
                whiteData.numberBefore = spinBefore.number;
                whiteData.colorBefore = spinBefore.color;
            }
            
            // Calcular giros desde o branco anterior
            if (whiteOccurrences.length > 0) {
                const previousWhite = whiteOccurrences[whiteOccurrences.length - 1];
                whiteData.girosFromPrevious = previousWhite.index - i;
            }
            
            // Pegar Ãºltimos 3 giros antes do branco (excluindo brancos)
            const last3 = [];
            for (let j = i + 1; j < fullHistory.length && last3.length < 3; j++) {
                if (fullHistory[j].color !== 'white') {
                    last3.push(fullHistory[j].color);
                }
            }
            whiteData.last3Pattern = last3.join('-');
            
            // Pegar Ãºltimos 5 giros antes do branco (excluindo brancos)
            const last5 = [];
            for (let j = i + 1; j < fullHistory.length && last5.length < 5; j++) {
                if (fullHistory[j].color !== 'white') {
                    last5.push(fullHistory[j].color);
                }
            }
            whiteData.last5Pattern = last5.join('-');
            
            whiteOccurrences.push(whiteData);
        }
    }
    
    console.log(`   âšª Total de brancos encontrados: ${whiteOccurrences.length}`);
    console.log(`   âšª FrequÃªncia: ${((whiteOccurrences.length / fullHistory.length) * 100).toFixed(2)}%`);
    
    if (whiteOccurrences.length < 2) {
        console.log(`   âš ï¸ Poucos brancos para anÃ¡lise confiÃ¡vel (mÃ­nimo: 2)`);
        return {
            mode: 'vote_color',
            color: null,
            whiteCount: whiteOccurrences.length,
            confidence: 0,
            details: 'Poucos brancos para anÃ¡lise'
        };
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ ETAPA 2: ANÃLISE ESTATÃSTICA DOS BRANCOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%cğŸ¯ ETAPA 2: ANÃLISE ESTATÃSTICA', 'color: #00D4FF; font-weight: bold;');
    
    // 2.1: NÃºmeros que "puxam" branco
    const numbersThatPull = {};
    for (const white of whiteOccurrences) {
        if (white.numberBefore !== null) {
            numbersThatPull[white.numberBefore] = (numbersThatPull[white.numberBefore] || 0) + 1;
        }
    }
    
    // Encontrar nÃºmero mais comum
    let mostCommonNumber = null;
    let mostCommonNumberCount = 0;
    for (const [num, count] of Object.entries(numbersThatPull)) {
        if (count > mostCommonNumberCount) {
            mostCommonNumber = parseInt(num);
            mostCommonNumberCount = count;
        }
    }
    
    console.log(`   ğŸ¯ NÃºmeros que "puxam" branco:`);
    const sortedNumbers = Object.entries(numbersThatPull).sort((a, b) => b[1] - a[1]).slice(0, 5);
    sortedNumbers.forEach(([num, count]) => {
        const percentage = ((count / whiteOccurrences.length) * 100).toFixed(1);
        console.log(`      NÂº ${num}: ${count}x (${percentage}%)`);
    });
    
    // 2.2: Minutos favoritos
    const favoriteMinutes = {};
    for (const white of whiteOccurrences) {
        if (white.minute !== null) {
            favoriteMinutes[white.minute] = (favoriteMinutes[white.minute] || 0) + 1;
        }
    }
    
    let mostCommonMinute = null;
    let mostCommonMinuteCount = 0;
    for (const [min, count] of Object.entries(favoriteMinutes)) {
        if (count > mostCommonMinuteCount) {
            mostCommonMinute = parseInt(min);
            mostCommonMinuteCount = count;
        }
    }
    
    console.log(`   ğŸ• Minutos favoritos:`);
    const sortedMinutes = Object.entries(favoriteMinutes).sort((a, b) => b[1] - a[1]).slice(0, 5);
    sortedMinutes.forEach(([min, count]) => {
        const percentage = ((count / whiteOccurrences.length) * 100).toFixed(1);
        console.log(`      :${String(min).padStart(2, '0')}: ${count}x (${percentage}%)`);
    });
    
    // 2.3: Intervalo mÃ©dio entre brancos
    const intervals = whiteOccurrences
        .filter(w => w.girosFromPrevious !== null)
        .map(w => w.girosFromPrevious);
    
    const avgInterval = intervals.length > 0 
        ? intervals.reduce((a, b) => a + b, 0) / intervals.length 
        : 0;
    
    const minInterval = intervals.length > 0 ? Math.min(...intervals) : 0;
    const maxInterval = intervals.length > 0 ? Math.max(...intervals) : 0;
    
    console.log(`   ğŸ“Š Intervalos entre brancos:`);
    console.log(`      MÃ©dia: ${avgInterval.toFixed(0)} giros`);
    console.log(`      MÃ­nimo: ${minInterval} giros`);
    console.log(`      MÃ¡ximo: ${maxInterval} giros`);
    
    // 2.4: PadrÃµes mais comuns antes de brancos
    const pattern3Counts = {};
    const pattern5Counts = {};
    
    for (const white of whiteOccurrences) {
        if (white.last3Pattern) {
            pattern3Counts[white.last3Pattern] = (pattern3Counts[white.last3Pattern] || 0) + 1;
        }
        if (white.last5Pattern) {
            pattern5Counts[white.last5Pattern] = (pattern5Counts[white.last5Pattern] || 0) + 1;
        }
    }
    
    console.log(`   ğŸ“ˆ PadrÃµes comuns (Ãºltimos 3 giros):`);
    const sortedPattern3 = Object.entries(pattern3Counts).sort((a, b) => b[1] - a[1]).slice(0, 3);
    sortedPattern3.forEach(([pattern, count]) => {
        console.log(`      ${pattern}: ${count}x`);
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”® ETAPA 3: SITUAÃ‡ÃƒO ATUAL E PREVISÃƒO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%cğŸ”® ETAPA 3: ANALISANDO SITUAÃ‡ÃƒO ATUAL', 'color: #9C27B0; font-weight: bold;');
    
    // Ãšltimo branco (mais recente)
    const lastWhite = whiteOccurrences[whiteOccurrences.length - 1];
    const girosFromLastWhite = lastWhite.index; // Ãndice 0 = giro mais recente
    
    // Giro atual (mais recente)
    const currentSpin = fullHistory[0];
    const currentNumber = currentSpin.number;
    const currentMinute = currentSpin.timestamp ? new Date(currentSpin.timestamp).getMinutes() : null;
    
    // Ãšltimos 3 giros (excluindo brancos)
    const current3Pattern = fullHistory
        .slice(0, 10)
        .filter(s => s.color !== 'white')
        .slice(0, 3)
        .map(s => s.color)
        .join('-');
    
    console.log(`   ğŸ“ Giros desde Ãºltimo branco: ${girosFromLastWhite}`);
    console.log(`   ğŸ“ NÃºmero atual: ${currentNumber}`);
    console.log(`   ğŸ“ Minuto atual: ${currentMinute !== null ? ':' + String(currentMinute).padStart(2, '0') : 'N/A'}`);
    console.log(`   ğŸ“ PadrÃ£o atual (Ãºltimos 3): ${current3Pattern}`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ§  ETAPA 4: DECISÃƒO - PREVER BRANCO OU VOTAR EM COR?
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%cğŸ§  ETAPA 4: TOMANDO DECISÃƒO', 'color: #FF6B35; font-weight: bold;');
    
    let predictionScore = 0;
    let scoreDetails = [];
    
    // CritÃ©rio 1: NÃºmero atual "puxa" branco?
    if (numbersThatPull[currentNumber] && numbersThatPull[currentNumber] >= 2) {
        const score = (numbersThatPull[currentNumber] / whiteOccurrences.length) * 40; // Max 40 pontos
        predictionScore += score;
        scoreDetails.push(`NÃºmero ${currentNumber} puxou ${numbersThatPull[currentNumber]}x (+${score.toFixed(1)} pts)`);
    }
    
    // CritÃ©rio 2: Minuto atual Ã© favorito?
    if (currentMinute !== null && favoriteMinutes[currentMinute] && favoriteMinutes[currentMinute] >= 2) {
        const score = (favoriteMinutes[currentMinute] / whiteOccurrences.length) * 30; // Max 30 pontos
        predictionScore += score;
        scoreDetails.push(`Minuto :${String(currentMinute).padStart(2, '0')} favorito ${favoriteMinutes[currentMinute]}x (+${score.toFixed(1)} pts)`);
    }
    
    // CritÃ©rio 3: Intervalo >= mÃ©dia?
    if (avgInterval > 0 && girosFromLastWhite >= avgInterval * 0.8) {
        const score = Math.min(30, (girosFromLastWhite / avgInterval) * 20); // Max 30 pontos
        predictionScore += score;
        scoreDetails.push(`Intervalo ${girosFromLastWhite} >= mÃ©dia ${avgInterval.toFixed(0)} (+${score.toFixed(1)} pts)`);
    }
    
    console.log(`   ğŸ¯ Score de previsÃ£o: ${predictionScore.toFixed(1)}/100`);
    scoreDetails.forEach(detail => console.log(`      âœ“ ${detail}`));
    
    // ğŸš¨ MODO FORCE_WHITE: Score >= 60 pontos
    if (predictionScore >= 60 && whiteOccurrences.length >= 3) {
        const confidence = Math.min(0.95, predictionScore / 100);
        console.log(`   ğŸš¨ MODO ATIVADO: FORCE_WHITE`);
        console.log(`   âšª Score alto (${predictionScore.toFixed(1)}/100) â†’ BRANCO previsto!`);
    console.log(`   ğŸ“Š ConfianÃ§a: ${(confidence * 100).toFixed(0)}%`);
        console.log(`   âš ï¸ TODOS OS OUTROS VOTOS SERÃƒO ANULADOS!`);
        
        return {
            mode: 'force_white',
            color: 'white',
            whiteCount: whiteOccurrences.length,
            patternDetected: current3Pattern,
            patternOccurrences: predictionScore,
            confidence: confidence,
            details: `Score: ${predictionScore.toFixed(1)}/100 â†’ BRANCO previsto`
        };
    }
    
    // ğŸ“Š MODO VOTE_COLOR: SÃ“ VOTA SE O ÃšLTIMO GIRO FOI BRANCO!
    console.log(`   ğŸ“Š MODO ATIVADO: VOTE_COLOR`);
    
    // âœ… VERIFICAÃ‡ÃƒO CRÃTICA: O ÃšLTIMO GIRO (mais recente) FOI BRANCO?
    const lastSpinWasWhite = currentSpin.color === 'white';
    
    console.log(`   ğŸ“ Ãšltimo giro: ${currentSpin.color.toUpperCase()} (${currentSpin.number})`);
    console.log(`   ğŸ¯ Foi branco? ${lastSpinWasWhite ? 'âœ… SIM' : 'âŒ NÃƒO'}`);
    
    if (!lastSpinWasWhite) {
        // âŒ ÃšLTIMO GIRO NÃƒO FOI BRANCO â†’ VOTO NULO
        console.log(`   âŒ VOTO NULO: Ãšltimo giro nÃ£o foi branco`);
        console.log(`   âš ï¸ SÃ³ voto em cor se o Ãºltimo giro for branco!`);
        
        return {
            mode: 'vote_color',
            color: null,
            whiteCount: whiteOccurrences.length,
            confidence: 0,
            details: 'Voto nulo - Ãºltimo giro nÃ£o foi branco'
        };
    }
    
    // âœ… ÃšLTIMO GIRO FOI BRANCO! Analisar APENAS os ÃšLTIMOS 5 BRANCOS
    console.log(`   âœ… Ãšltimo giro FOI BRANCO!`);
    console.log(`   ğŸ—³ï¸ Analisando os ÃšLTIMOS 5 BRANCOS para votar...`);
    
    // Pegar apenas os ÃšLTIMOS 5 brancos (mais recentes)
    const last5Whites = whiteOccurrences.slice(-5); // Ãšltimos 5 elementos do array
    
    console.log(`   ğŸ“Š Total de brancos no histÃ³rico: ${whiteOccurrences.length}`);
    console.log(`   ğŸ¯ Analisando Ãºltimos: ${last5Whites.length} brancos`);
    
    const afterWhiteColors = { red: 0, black: 0, white: 0 };
    
    // Para cada um dos ÃšLTIMOS 5 brancos, ver o que saiu logo apÃ³s
    for (const white of last5Whites) {
        if (white.index > 0) {
            const nextSpin = fullHistory[white.index - 1];
            if (nextSpin) {
                afterWhiteColors[nextSpin.color]++;
                console.log(`      Branco â†’ ${nextSpin.color.toUpperCase()}`);
            }
        }
    }
    
    const totalAfterWhite = afterWhiteColors.red + afterWhiteColors.black + afterWhiteColors.white;
    
    if (totalAfterWhite >= 2) {
        let voteColor = null;
        let colorPercentage = 0;
        
        if (afterWhiteColors.red > afterWhiteColors.black) {
            voteColor = 'red';
            colorPercentage = (afterWhiteColors.red / totalAfterWhite) * 100;
        } else if (afterWhiteColors.black > afterWhiteColors.red) {
            voteColor = 'black';
            colorPercentage = (afterWhiteColors.black / totalAfterWhite) * 100;
    } else {
            // Empate - usar tendÃªncia recente (Ãºltimos 20 giros)
            const last20 = fullHistory.slice(0, Math.min(20, fullHistory.length));
            const recent = { red: 0, black: 0 };
            last20.forEach(s => {
                if (s.color === 'red') recent.red++;
                if (s.color === 'black') recent.black++;
            });
            voteColor = recent.red > recent.black ? 'red' : 'black';
            colorPercentage = 50;
        }
        
        const confidence = Math.min(0.85, colorPercentage / 100);
        
        console.log(`   ğŸ“Š Resultado dos Ãºltimos ${last5Whites.length} brancos:`);
        console.log(`      ğŸ”´ VERMELHO: ${afterWhiteColors.red}x (${((afterWhiteColors.red / totalAfterWhite) * 100).toFixed(1)}%)`);
        console.log(`      âš« PRETO: ${afterWhiteColors.black}x (${((afterWhiteColors.black / totalAfterWhite) * 100).toFixed(1)}%)`);
        console.log(`   ğŸ—³ï¸ VOTA: ${voteColor.toUpperCase()} (${(confidence * 100).toFixed(0)}% confianÃ§a)`);
        console.log(`   âœ… Justificativa: Nos Ãºltimos ${last5Whites.length} brancos, ${voteColor.toUpperCase()} saiu ${colorPercentage.toFixed(1)}%`);
    
    return {
            mode: 'vote_color',
        color: voteColor,
            whiteCount: whiteOccurrences.length,
            afterWhiteStats: afterWhiteColors,
            last5WhitesCount: last5Whites.length,
        confidence: confidence,
            details: `Ãšltimos ${last5Whites.length} brancos â†’ ${voteColor.toUpperCase()} (${colorPercentage.toFixed(1)}%)`
        };
    }
    
    // âš ï¸ FALLBACK: Dados insuficientes (mas Ãºltimo giro foi branco)
    console.log(`   âš ï¸ VOTO NULO: Dados insuficientes no histÃ³rico`);
    
    return {
        mode: 'vote_color',
        color: null,
        whiteCount: whiteOccurrences.length,
        confidence: 0,
        details: 'Dados insuficientes para previsÃ£o'
    };
}

/**
 * NÃVEL 9: AnÃ¡lise de Ciclos e PersistÃªncia
 * Detecta ciclos de persistÃªncia e vota pela CONTINUAÃ‡ÃƒO da sequÃªncia
 * Analisa conforme configuraÃ§Ã£o do usuÃ¡rio (aiHistorySize), mÃ­nimo 20 giros
 */
function analyzePersistence(history, configuredSize = 20) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #D35400; font-weight: bold;');
    console.log('%câ”‚ ğŸ” NÃVEL 9: PERSISTÃŠNCIA (CONFIGURÃVEL)               â”‚', 'color: #D35400; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #D35400; font-weight: bold;');
    
    // âœ… Usar o que o usuÃ¡rio configurou, mas com mÃ­nimo de 20 e mÃ¡ximo de 120 (compatÃ­vel com UI)
    const effectiveSize = Math.max(20, Math.min(120, configuredSize));
    const lastN = history.slice(0, Math.min(effectiveSize, history.length));
    
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${history.length}`);
    console.log(`   âš™ï¸ HistÃ³rico configurado pelo usuÃ¡rio: ${configuredSize} giros`);
    console.log(`   ğŸ“Š Tamanho efetivo (20-60): ${effectiveSize} giros`);
    console.log(`   ğŸ“Š Analisando Ãºltimos: ${lastN.length} giros`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âšª Brancos: por seguranÃ§a, "reiniciam" leitura recente.
    // Mantemos o comportamento: se houve branco na janela, usamos apenas os giros MAIS recentes apÃ³s o branco.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let validHistory = lastN;
    const firstWhiteIndex = lastN.findIndex(spin => spin && spin.color === 'white');
    if (firstWhiteIndex !== -1) {
        validHistory = lastN.slice(0, firstWhiteIndex);
        console.log(`   âšª BRANCO ENCONTRADO na posiÃ§Ã£o ${firstWhiteIndex}!`);
        console.log(`   ğŸ”„ RESETANDO anÃ¡lise! Descartando ${lastN.length - validHistory.length} giros`);
        console.log(`   âœ… Giros vÃ¡lidos apÃ³s o reset: ${validHistory.length}`);
    } else {
        console.log(`   âœ… Nenhum BRANCO encontrado - analisando todos os ${validHistory.length} giros`);
    }
    
    // âœ… Rigor: nÃ£o votar com pouco histÃ³rico (evitar ruÃ­do)
    const MIN_VALID_AFTER_WHITE = 12;
    if (validHistory.length < MIN_VALID_AFTER_WHITE) {
        console.log(`   âŒ Dados insuficientes apÃ³s reset! MÃ­nimo: ${MIN_VALID_AFTER_WHITE} giros, disponÃ­vel: ${validHistory.length}`);
        return {
            color: null,
            currentSequence: 0,
            averageSequence: 0,
            confidence: 0,
            mode: 'neutral',
            details: `NULO â€¢ poucos giros apÃ³s branco (${validHistory.length}/${MIN_VALID_AFTER_WHITE})`
        };
    }
    
    // Detectar todas as sequÃªncias (runs) de red/black
    const sequences = { red: [], black: [] };
    let runColor = null;
    let runLen = 0;
    // iterar do mais antigo -> mais recente (validHistory Ã© most-recent-first)
    for (let i = validHistory.length - 1; i >= 0; i--) {
        const spin = validHistory[i];
        const c = spin && spin.color ? String(spin.color).toLowerCase() : '';
        if (c !== 'red' && c !== 'black') {
            // qualquer coisa fora do red/black quebra run
            if (runColor && runLen > 0) sequences[runColor].push(runLen);
            runColor = null;
            runLen = 0;
            continue;
        }
        if (c === runColor) {
            runLen++;
        } else {
            if (runColor && runLen > 0) sequences[runColor].push(runLen);
            runColor = c;
            runLen = 1;
        }
    }
    if (runColor && runLen > 0) sequences[runColor].push(runLen);
    
    // Calcular mÃ©dias (apenas informativo)
    const avgRed = sequences.red.length > 0 
        ? sequences.red.reduce((a, b) => a + b, 0) / sequences.red.length 
        : 0;
    const avgBlack = sequences.black.length > 0 
        ? sequences.black.reduce((a, b) => a + b, 0) / sequences.black.length 
        : 0;
    
    // SequÃªncia atual (streak) no topo do histÃ³rico (mais recente primeiro)
    const last = validHistory[0];
    const lastColor = last && last.color ? String(last.color).toLowerCase() : null;
    if (lastColor !== 'red' && lastColor !== 'black') {
        return {
            color: null,
            currentSequence: 0,
            averageSequence: 0,
            confidence: 0,
            mode: 'neutral',
            details: 'NULO â€¢ Ãºltimo giro nÃ£o Ã© red/black'
        };
    }
    
    let currentSequenceLength = 0;
    for (let i = 0; i < validHistory.length; i++) {
        const c = validHistory[i] && validHistory[i].color ? String(validHistory[i].color).toLowerCase() : '';
        if (c === lastColor) currentSequenceLength++;
        else break;
    }

    const avgForColor = lastColor === 'red' ? avgRed : avgBlack;
    
    console.log(`   ğŸ“Š SequÃªncias de VERMELHO encontradas: ${sequences.red.length} (mÃ©dia: ${avgRed.toFixed(1)} giros)`);
    console.log(`   ğŸ“Š SequÃªncias de PRETO encontradas: ${sequences.black.length} (mÃ©dia: ${avgBlack.toFixed(1)} giros)`);
    console.log(`   ğŸ“Š Ãšltima cor vÃ¡lida: ${lastColor.toUpperCase()}`);
    console.log(`   ğŸ“Š SequÃªncia atual de ${lastColor.toUpperCase()}: ${currentSequenceLength} giro(s)`);
    console.log(`   ğŸ“Š MÃ©dia histÃ³rica de ${lastColor.toUpperCase()}: ${avgForColor.toFixed(1)} giros`);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âœ… MODELO MAIS SEGURO: prob. empÃ­rica de continuar vs reverter
    // p(cont | jÃ¡ cheguei em L) â‰ˆ count(len>=L+1) / count(len>=L)
    // com suavizaÃ§Ã£o para evitar 0/1 com pouca amostra.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const runs = sequences[lastColor] || [];
    const atRisk = runs.filter(len => len >= currentSequenceLength).length;
    const contCount = runs.filter(len => len >= currentSequenceLength + 1).length;
    const pContinue = (contCount + 1) / (atRisk + 2); // Laplace smoothing
    const pReverse = 1 - pContinue;

    // Rigor: exigir base estatÃ­stica mÃ­nima para o "tamanho atual"
    const MIN_AT_RISK = 5;
    if (atRisk < MIN_AT_RISK) {
        return {
            color: null,
            currentSequence: currentSequenceLength,
            averageSequence: Number(avgForColor.toFixed(1)),
            confidence: 0,
            mode: 'neutral',
            details: `NULO â€¢ pouca base (n=${atRisk} < ${MIN_AT_RISK}) â€¢ seq ${currentSequenceLength}`
        };
    }

    // Thresholds conservadores: sÃ³ votar quando a probabilidade Ã© bem clara
    const CONTINUE_MIN = 0.68;
    const REVERSE_MIN = 0.68;

    let voteColor = null;
    let mode = 'neutral';
    if (pContinue >= CONTINUE_MIN) {
        voteColor = lastColor;
        mode = 'continue';
    } else if (pReverse >= REVERSE_MIN) {
        voteColor = lastColor === 'red' ? 'black' : 'red';
        mode = 'reverse';
    } else {
        voteColor = null;
        mode = 'neutral';
    }

    // ConfianÃ§a: distÃ¢ncia de 50% ponderada por tamanho de amostra (atRisk)
    const edge = Math.abs(pContinue - 0.5) * 2; // 0..1
    const sampleFactor = Math.min(1, atRisk / 12);
    const confidence = Math.max(0, Math.min(1, edge * sampleFactor));

    const details = voteColor
        ? `${mode === 'continue' ? 'CONTINUAR' : 'REVERTER'} â€¢ seq ${currentSequenceLength} ${lastColor.toUpperCase()} â€¢ Pcont ${(pContinue * 100).toFixed(0)}% (n=${atRisk})`
        : `NULO â€¢ seq ${currentSequenceLength} ${lastColor.toUpperCase()} â€¢ Pcont ${(pContinue * 100).toFixed(0)}% (n=${atRisk})`;

    console.log(`   ğŸ—³ï¸ VOTA: ${voteColor ? voteColor.toUpperCase() : 'NULO'} (${details})`);
    
    return {
        color: voteColor,
        currentSequence: currentSequenceLength,
        averageSequence: Number(avgForColor.toFixed(1)),
        avgRed: Number(avgRed.toFixed(1)),
        avgBlack: Number(avgBlack.toFixed(1)),
        confidence,
        mode,
        pContinue: Number((pContinue).toFixed(3)),
        sampleAtRisk: atRisk,
        details
    };
}

/**
 * â±ï¸ HELPER: Sleep para delay entre nÃ­veis
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

const N0_DEFAULTS = Object.freeze({
    historySize: 2000,
    windowSize: 100,
    analysesToRun: 1000,
    minWindowsRequired: 4,
    precisionMin: 0.45,
    confidenceGrid: [0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95],
    holdoutEnabled: true,
    holdoutTolerance: 0.2,
    seed: 42,
    softBlockFactor: 0.5
});

const N0_FAMILY_LIST = Object.freeze([
    'freq_threshold',
    'freq_segmented',
    'weighted_recency',
    'last_run',
    'run_stats',
    'markov',
    'n_gram_pattern',
    'burst_detector',
    'entropy_change',
    'lagged_sum',
    'trend_accel',
    'switch_pattern',
    'compound_and',
    'compound_or'
]);

const N0_FAMILY_MIN_PER_TYPE = 20;
const N0_DIVERSITY_MIN_DISTANCE_BASE = 0.2;
const N0_CONFIG_LIBRARY_KEY = 'n0_diverse_configs_cache_v1';

function clamp01(value) {
    return Math.max(0, Math.min(1, Number.isFinite(value) ? value : 0));
}

let n0ConfigLibraryCache = null;
let n0ConfigLibrarySeed = null;

const N8_DEFAULTS = Object.freeze({
    historySize: 1200,
    windowSize: 20,
    analysesToRun: 1000,
    minWindowsRequired: 6,
    precisionMin: 0.55,
    confidenceGrid: [0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95],
    holdoutEnabled: true,
    holdoutTolerance: 0.18,
    seed: 1337,
    confMinLive: 0.58
});

const N8_FAMILY_LIST = Object.freeze([
    'dominance_threshold',
    'segmented_dominance',
    'recency_weighted',
    'momentum_split',
    'markov_chain',
    'pattern_follow',
    'streak_bias',
    'entropy_shift',
    'lagged_correlation',
    'compound_vote'
]);

const N8_FAMILY_MIN_PER_TYPE = 22;
const N8_DIVERSITY_MIN_DISTANCE_BASE = 0.18;
const N8_CONFIG_LIBRARY_KEY = 'n8_diverse_configs_cache_v1';

let n8ConfigLibraryCache = null;
let n8ConfigLibrarySeed = null;

function normalizeN0History(entries) {
    if (!Array.isArray(entries)) return [];
    const normalized = [];
    for (const item of entries) {
        if (item == null) {
            normalized.push('W');
            continue;
        }
        if (typeof item === 'string' || typeof item === 'number') {
            const parsed = String(item).trim().toLowerCase();
            if (parsed.includes('branc') || parsed === 'w' || parsed.includes('white')) {
                normalized.push('W');
                continue;
            }
            if (parsed.includes('verm') || parsed === 'r' || parsed.includes('red')) {
                normalized.push('R');
                continue;
            }
            if (parsed.includes('pret') || parsed === 'b' || parsed.includes('black')) {
                normalized.push('B');
                continue;
            }
            const numeric = Number(parsed);
            if (Number.isFinite(numeric)) {
                normalized.push(Math.abs(numeric) % 2 === 0 ? 'B' : 'R');
                continue;
            }
            normalized.push('W');
            continue;
        }
        if (typeof item === 'object') {
            const colorValue = item.color || item.result || item.Color || item.cor || null;
            if (colorValue != null) {
                const parsed = String(colorValue).trim().toLowerCase();
                if (parsed.includes('branc') || parsed === 'w' || parsed.includes('white')) {
                    normalized.push('W');
                    continue;
                }
                if (parsed.includes('verm') || parsed === 'r' || parsed.includes('red')) {
                    normalized.push('R');
                    continue;
                }
                if (parsed.includes('pret') || parsed === 'b' || parsed.includes('black')) {
                    normalized.push('B');
                    continue;
                }
                const numeric = Number(parsed);
                if (Number.isFinite(numeric)) {
                    normalized.push(Math.abs(numeric) % 2 === 0 ? 'B' : 'R');
                    continue;
                }
            }
            const numberValue = item.number ?? item.numero ?? item.slot ?? null;
            if (Number.isFinite(Number(numberValue))) {
                normalized.push(Math.abs(Number(numberValue)) % 2 === 0 ? 'B' : 'R');
                continue;
            }
        }
        normalized.push('W');
    }
    return normalized;
}

function buildN0Windows(sequence, windowSize) {
    const windows = [];
    if (!Array.isArray(sequence) || sequence.length < windowSize + 1) return windows;
    const total = sequence.length;
    const totalWindows = Math.floor(total / windowSize);
    for (let k = 0; k < totalWindows; k++) {
        const start = k * windowSize;
        const end = start + windowSize;
        const targetIndex = end;
        if (targetIndex >= total) continue;
        windows.push({
            index: k,
            window: sequence.slice(start, end),
            target: sequence[targetIndex],
            start,
            targetIndex
        });
    }
    return windows;
}

function createSeededRandomGenerator(seed) {
    let state = seed >>> 0;
    return function nextRandom() {
        state = Math.imul(state ^ state >>> 11, 0x45d9f3b);
        state ^= state << 7;
        state = Math.imul(state ^ state >>> 15, 0x45d9f3b);
        return ((state ^ state >>> 14) >>> 0) / 4294967296;
    };
}

function generateN0ConfigsLegacy(count, seed = N0_DEFAULTS.seed) {
    const configs = [];

    const addConfig = (cfg) => {
        if (configs.length < count) {
            configs.push(cfg);
        }
    };

    // Grade fixa
    [0.01, 0.02, 0.03, 0.05, 0.08, 0.1, 0.15, 0.2].forEach(thresh => {
        addConfig({ type: 'freq', thresh });
    });

    [2, 3, 4, 5].forEach(L => {
        [0.6, 0.7, 0.8, 0.9].forEach(next_threshold => {
            addConfig({ type: 'pattern', L, next_threshold });
        });
    });

    [1, 2].forEach(k => {
        [0.4, 0.5, 0.6, 0.7].forEach(thresh => {
            addConfig({ type: 'markov', k, thresh });
        });
    });

    [0.7, 0.8, 0.9].forEach(decay => {
        [0.05, 0.1, 0.15, 0.2].forEach(thresh => {
            addConfig({ type: 'recency', decay, thresh });
        });
    });

    [1, 2, 3].forEach(min_run => {
        addConfig({ type: 'lastrun', min_run });
    });

    if (configs.length >= count) {
        return configs.slice(0, count);
    }

    const random = createSeededRandomGenerator(seed);
    const typePool = ['freq', 'pattern', 'markov', 'recency', 'lastrun'];
    while (configs.length < count) {
        const type = typePool[Math.floor(random() * typePool.length)];
        if (type === 'freq') {
            const options = [0.01, 0.02, 0.03, 0.05, 0.08, 0.1, 0.12, 0.15, 0.2];
            addConfig({ type, thresh: options[Math.floor(random() * options.length)] });
        } else if (type === 'pattern') {
            const lengths = [2, 3, 4, 5];
            const thresholds = [0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9];
            addConfig({
                type,
                L: lengths[Math.floor(random() * lengths.length)],
                next_threshold: thresholds[Math.floor(random() * thresholds.length)]
            });
        } else if (type === 'markov') {
            const orders = [1, 2];
            const thresholds = [0.35, 0.4, 0.5, 0.6, 0.7];
            addConfig({
                type,
                k: orders[Math.floor(random() * orders.length)],
                thresh: thresholds[Math.floor(random() * thresholds.length)]
            });
        } else if (type === 'recency') {
            const decays = [0.6, 0.7, 0.8, 0.9];
            const thresholds = [0.03, 0.05, 0.08, 0.1, 0.12, 0.15, 0.2];
            addConfig({
                type,
                decay: decays[Math.floor(random() * decays.length)],
                thresh: thresholds[Math.floor(random() * thresholds.length)]
            });
        } else {
            const runs = [1, 2, 3, 4];
            addConfig({ type, min_run: runs[Math.floor(random() * runs.length)] });
        }
    }

    return configs.slice(0, count);
}

function applyN0AnalysisLegacy(cfg, window) {
    const cleanWindow = Array.isArray(window) ? window.filter(c => c === 'R' || c === 'B' || c === 'W') : [];
    if (cleanWindow.length === 0) {
        return { prediction: null, confidence: 0 };
    }

    switch (cfg.type) {
        case 'freq': {
            const total = cleanWindow.length;
            const whites = cleanWindow.filter(c => c === 'W').length;
            const pW = total > 0 ? whites / total : 0;
            return pW >= (cfg.thresh ?? 0.05)
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, pW)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, pW)) };
        }
        case 'pattern': {
            const L = Math.max(1, Number(cfg.L) || 3);
            const nextThreshold = cfg.next_threshold != null ? Number(cfg.next_threshold) : 0.6;
            if (cleanWindow.length < L + 1) return { prediction: null, confidence: 0 };
            const pattern = cleanWindow.slice(cleanWindow.length - L).join('');
            const followers = [];
            for (let i = 0; i + L < cleanWindow.length; i++) {
                const candidate = cleanWindow.slice(i, i + L).join('');
                if (candidate === pattern) {
                    followers.push(cleanWindow[i + L]);
                }
            }
            if (followers.length === 0) return { prediction: null, confidence: 0 };
            const whites = followers.filter(c => c === 'W').length;
            const pW = whites / followers.length;
            return pW >= nextThreshold
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, pW)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, pW)) };
        }
        case 'markov': {
            const order = Math.max(1, Number(cfg.k) || 1);
            const thresh = cfg.thresh != null ? Number(cfg.thresh) : 0.5;
            if (cleanWindow.length <= order) return { prediction: null, confidence: 0 };
            const transitions = new Map();
            for (let i = 0; i + order < cleanWindow.length; i++) {
                const key = cleanWindow.slice(i, i + order).join('');
                const next = cleanWindow[i + order];
                if (!transitions.has(key)) {
                    transitions.set(key, { R: 0, B: 0, W: 0 });
                }
                const entry = transitions.get(key);
                entry[next] = (entry[next] || 0) + 1;
            }
            const lastKey = cleanWindow.slice(cleanWindow.length - order).join('');
            if (!transitions.has(lastKey)) return { prediction: null, confidence: 0 };
            const counts = transitions.get(lastKey);
            const total = (counts.R || 0) + (counts.B || 0) + (counts.W || 0);
            if (total === 0) return { prediction: null, confidence: 0 };
            const pW = (counts.W || 0) / total;
            return pW >= thresh
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, pW)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, pW)) };
        }
        case 'recency': {
            const decay = cfg.decay != null ? Number(cfg.decay) : 0.9;
            const thresh = cfg.thresh != null ? Number(cfg.thresh) : 0.1;
            let weight = 1;
            let totalWeight = 0;
            let weightedWhite = 0;
            for (let i = cleanWindow.length - 1; i >= 0; i--) {
                const value = cleanWindow[i];
                totalWeight += weight;
                if (value === 'W') {
                    weightedWhite += weight;
                }
                weight *= decay;
            }
            const pW = totalWeight > 0 ? weightedWhite / totalWeight : 0;
            return pW >= thresh
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, pW)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, pW)) };
        }
        case 'lastrun': {
            const minRun = Math.max(1, Number(cfg.min_run) || 1);
            let run = 0;
            for (let i = cleanWindow.length - 1; i >= 0; i--) {
                if (cleanWindow[i] === 'W') {
                    run += 1;
                } else {
                    break;
                }
            }
            const confidence = cleanWindow.length > 0 ? run / cleanWindow.length : 0;
            return run >= minRun
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, confidence)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, confidence)) };
        }
        default:
            return { prediction: null, confidence: 0 };
    }
}

function hashStringToUnit(value) {
    if (value == null) return 0;
    const str = String(value);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
    }
    return Math.abs(hash % 1000) / 1000;
}

function createN0ConfigId(index) {
    return `N0CFG-${String(index + 1).padStart(4, '0')}`;
}

function describeN0Config(cfg) {
    if (!cfg || !cfg.family) return 'config invÃ¡lida';
    const params = cfg.params || {};
    const entries = Object.entries(params)
        .map(([key, value]) => `${key}=${Array.isArray(value) ? JSON.stringify(value) : value}`)
        .join(', ');
    return `${cfg.family}${entries ? ` (${entries})` : ''}`;
}

function encodeN0ConfigVector(cfg) {
    const vectorLength = N0_FAMILY_LIST.length + 15;
    const vector = new Array(vectorLength).fill(0);
    const familyIndex = Math.max(0, N0_FAMILY_LIST.indexOf(cfg.family));
    vector[familyIndex] = 1;
    const baseIndex = N0_FAMILY_LIST.length;
    const params = cfg.params || {};
    vector[baseIndex + 0] = clamp01(params.thresh);
    vector[baseIndex + 1] = clamp01(params.seg_thresh ?? params.thresh);
    vector[baseIndex + 2] = clamp01((params.segments ?? params.segment_count ?? 0) / 6);
    vector[baseIndex + 3] = clamp01(params.decay ?? 0);
    vector[baseIndex + 4] = clamp01((params.min_run ?? params.min_max_run ?? 0) / 15);
    vector[baseIndex + 5] = clamp01((params.min_run_count ?? params.min_occurrences ?? 0) / 12);
    vector[baseIndex + 6] = clamp01((params.order ?? params.k ?? 0) / 5);
    vector[baseIndex + 7] = clamp01(params.prob_thresh ?? params.next_thresh ?? 0);
    vector[baseIndex + 8] = clamp01(hashStringToUnit(params.pattern ?? params.pattern_code));
    vector[baseIndex + 9] = clamp01((params.sub_window ?? params.subW ?? 0) / 50);
    vector[baseIndex + 10] = clamp01(params.frac_thresh ?? params.seg_thresh ?? 0);
    vector[baseIndex + 11] = clamp01(params.delta_thresh ?? params.accel_thresh ?? params.min_switch_rate ?? 0);
    vector[baseIndex + 12] = clamp01((params.lag_k ?? params.lag ?? 0) / 20);
    vector[baseIndex + 13] = clamp01((params.sum_thresh ?? params.switch_count ?? 0) / 30);
    vector[baseIndex + 14] = clamp01((Array.isArray(params.parts) ? params.parts.length : params.component_count ?? 0) / 6);
    return vector;
}

function n0ConfigDistance(vectorA, vectorB) {
    let sum = 0;
    for (let i = 0; i < vectorA.length; i++) {
        const diff = vectorA[i] - vectorB[i];
        sum += diff * diff;
    }
    return Math.sqrt(sum);
}

function maybePersistN0ConfigLibrary(configs) {
    try {
        if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
            chrome.storage.local.set({ [N0_CONFIG_LIBRARY_KEY]: configs });
        }
    } catch (error) {
        console.debug('âš ï¸ [N0] Falha ao persistir biblioteca de configs:', error);
    }
}

function buildN0BaseConfigs() {
    const configs = [];
    const push = (family, params) => configs.push({ family, params });

    [0.06, 0.08, 0.1, 0.12, 0.15, 0.18, 0.2, 0.22, 0.25, 0.3].forEach(thresh => {
        push('freq_threshold', { thresh: Number(thresh.toFixed(3)) });
    });

    [3, 4, 5].forEach(segments => {
        [0.18, 0.22, 0.25, 0.28, 0.3, 0.35].forEach(seg_thresh => {
            push('freq_segmented', { segments, seg_thresh: Number(seg_thresh.toFixed(3)) });
        });
    });

    [0.6, 0.7, 0.8, 0.85, 0.9].forEach(decay => {
        [0.18, 0.2, 0.22, 0.25, 0.28].forEach(thresh => {
            push('weighted_recency', { decay: Number(decay.toFixed(2)), thresh: Number(thresh.toFixed(3)) });
        });
    });

    [2, 3, 4, 5, 6, 7].forEach(min_run => {
        push('last_run', { min_run });
    });

    [
        { min_max_run: 3, min_run_count: 2 },
        { min_max_run: 4, min_run_count: 2 },
        { min_max_run: 4, min_run_count: 3 },
        { min_max_run: 5, min_run_count: 3 },
        { min_max_run: 6, min_run_count: 3 },
        { min_max_run: 6, min_run_count: 4 },
        { min_max_run: 7, min_run_count: 4 }
    ].forEach(params => push('run_stats', params));

    [1, 2, 3].forEach(order => {
        [0.45, 0.5, 0.55, 0.6, 0.65, 0.7].forEach(prob_thresh => {
            push('markov', { order, prob_thresh: Number(prob_thresh.toFixed(2)) });
        });
    });

    const patternLibrary = ['RR', 'RB', 'BR', 'BB', 'RRR', 'RBR', 'BRB', 'BBB', 'RBRB', 'BRBR'];
    patternLibrary.forEach(pattern => {
        [0.55, 0.6, 0.65, 0.7, 0.75].forEach(next_thresh => {
            push('n_gram_pattern', { pattern, next_thresh: Number(next_thresh.toFixed(2)) });
        });
    });

    [8, 10, 12, 15, 20, 25].forEach(sub_window => {
        [0.35, 0.4, 0.45, 0.5, 0.55, 0.6].forEach(frac_thresh => {
            push('burst_detector', { sub_window, frac_thresh: Number(frac_thresh.toFixed(2)) });
        });
    });

    [0.08, 0.1, 0.12, 0.15, 0.18].forEach(delta_thresh => {
        [1.0, 1.1, 1.2].forEach(max_entropy => {
            push('entropy_change', { delta_thresh: Number(delta_thresh.toFixed(2)), max_entropy });
        });
    });

    [2, 3, 4, 5, 6, 7].forEach(lag_k => {
        [3, 4, 5, 6, 7, 8, 9, 10, 12].forEach(sum_thresh => {
            push('lagged_sum', { lag_k, sum_thresh });
        });
    });

    [3, 4, 5, 6].forEach(segments => {
        [0.06, 0.08, 0.1, 0.12, 0.15, 0.18].forEach(accel_thresh => {
            push('trend_accel', { segments, accel_thresh: Number(accel_thresh.toFixed(3)), min_final_pw: 0.25 });
        });
    });

    [0.65, 0.7, 0.75, 0.8, 0.85, 0.9].forEach(min_switch_rate => {
        [6, 8, 10, 12, 14, 16, 18].forEach(min_total_switches => {
            push('switch_pattern', { min_switch_rate: Number(min_switch_rate.toFixed(2)), min_total_switches });
        });
    });

    const compoundParts = [
        [
            { family: 'freq_threshold', params: { thresh: 0.16 } },
            { family: 'last_run', params: { min_run: 3 } }
        ],
        [
            { family: 'weighted_recency', params: { decay: 0.85, thresh: 0.2 } },
            { family: 'trend_accel', params: { segments: 4, accel_thresh: 0.1, min_final_pw: 0.25 } }
        ],
        [
            { family: 'freq_segmented', params: { segments: 4, seg_thresh: 0.25 } },
            { family: 'lagged_sum', params: { lag_k: 3, sum_thresh: 6 } }
        ]
    ];

    compoundParts.forEach((parts, idx) => {
        push('compound_and', { parts, component_count: parts.length, id: `AND_BASE_${idx + 1}` });
        push('compound_or', { parts, component_count: parts.length, min_hits: 1, id: `OR_BASE_${idx + 1}` });
    });

    return configs;
}

function sampleRandomN0Config(rng, forcedFamily) {
    const family = forcedFamily || N0_FAMILY_LIST[Math.floor(rng() * N0_FAMILY_LIST.length)];
    const rFloat = () => rng();
    const randBetween = (min, max, decimals = 3) => {
        const value = min + (max - min) * rFloat();
        const factor = Math.pow(10, decimals);
        return Math.round(value * factor) / factor;
    };
    const randInt = (min, max) => Math.floor(min + (max - min + 1) * rFloat());

    switch (family) {
        case 'freq_threshold':
            return { family, params: { thresh: randBetween(0.05, 0.32) } };
        case 'freq_segmented':
            return {
                family,
                params: {
                    segments: randInt(3, 6),
                    seg_thresh: randBetween(0.18, 0.35)
                }
            };
        case 'weighted_recency':
            return {
                family,
                params: {
                    decay: randBetween(0.6, 0.95, 2),
                    thresh: randBetween(0.18, 0.32)
                }
            };
        case 'last_run':
            return {
                family,
                params: {
                    min_run: randInt(2, 8)
                }
            };
        case 'run_stats':
            return {
                family,
                params: {
                    min_max_run: randInt(3, 9),
                    min_run_count: randInt(2, 5)
                }
            };
        case 'markov':
            return {
                family,
                params: {
                    order: randInt(1, 3),
                    prob_thresh: randBetween(0.45, 0.75, 2)
                }
            };
        case 'n_gram_pattern': {
            const patterns = ['RR', 'RB', 'BB', 'BR', 'RRR', 'RBR', 'BRB', 'BBR', 'RBB', 'RRBR', 'BRRB'];
            const pattern = patterns[Math.floor(rng() * patterns.length)];
            return {
                family,
                params: {
                    pattern,
                    next_thresh: randBetween(0.55, 0.8, 2)
                }
            };
        }
        case 'burst_detector':
            return {
                family,
                params: {
                    sub_window: randInt(6, 30),
                    frac_thresh: randBetween(0.3, 0.7, 2)
                }
            };
        case 'entropy_change':
            return {
                family,
                params: {
                    delta_thresh: randBetween(0.08, 0.2, 3),
                    max_entropy: randBetween(0.9, 1.3, 3)
                }
            };
        case 'lagged_sum':
            return {
                family,
                params: {
                    lag_k: randInt(2, 8),
                    sum_thresh: randInt(4, 12)
                }
            };
        case 'trend_accel':
            return {
                family,
                params: {
                    segments: randInt(3, 6),
                    accel_thresh: randBetween(0.05, 0.2, 3),
                    min_final_pw: randBetween(0.2, 0.35, 3)
                }
            };
        case 'switch_pattern':
            return {
                family,
                params: {
                    min_switch_rate: randBetween(0.6, 0.92, 2),
                    min_total_switches: randInt(6, 20)
                }
            };
        case 'compound_and':
        case 'compound_or': {
            const partCount = randInt(2, 3);
            const partFamilies = ['freq_threshold', 'weighted_recency', 'last_run', 'run_stats', 'lagged_sum', 'trend_accel'];
            const parts = [];
            for (let i = 0; i < partCount; i++) {
                const subFamily = partFamilies[Math.floor(rng() * partFamilies.length)];
                parts.push(sampleRandomN0Config(rng, subFamily));
            }
            const params = {
                parts,
                component_count: parts.length,
                id: `${family.toUpperCase()}_${hashStringToUnit(JSON.stringify(parts)).toString(36).slice(2, 8)}`
            };
            if (family === 'compound_or') {
                params.min_hits = Math.max(1, Math.min(parts.length, Math.round(parts.length * randBetween(0.4, 0.7, 2))));
            }
            return { family, params };
        }
        default:
            return null;
    }
}

function tryAddN0Config(candidate, accepted, acceptedVectors, diversityThreshold) {
    if (!candidate || !candidate.family) return false;
    const vector = encodeN0ConfigVector(candidate);
    for (const existingVector of acceptedVectors) {
        if (n0ConfigDistance(vector, existingVector) < diversityThreshold) {
            return false;
        }
    }
    accepted.push(candidate);
    acceptedVectors.push(vector);
    return true;
}

function generateN0Configs(count, seed = N0_DEFAULTS.seed) {
    if (n0ConfigLibraryCache && n0ConfigLibraryCache.length >= count && n0ConfigLibrarySeed === seed) {
        return n0ConfigLibraryCache.slice(0, count);
    }

    const rng = createSeededRandomGenerator(seed);
    const baseConfigs = buildN0BaseConfigs();
    const accepted = [];
    const acceptedVectors = [];
    const familyCounts = {};
    let diversityThreshold = N0_DIVERSITY_MIN_DISTANCE_BASE;

    const pushWithDiversity = (cfg, allowRelax = false) => {
        if (!cfg) return false;
        const success = tryAddN0Config(cfg, accepted, acceptedVectors, diversityThreshold);
        if (success) {
            familyCounts[cfg.family] = (familyCounts[cfg.family] || 0) + 1;
        } else if (allowRelax && diversityThreshold > 0.08) {
            const relaxedSuccess = tryAddN0Config(cfg, accepted, acceptedVectors, diversityThreshold * 0.9);
            if (relaxedSuccess) {
                familyCounts[cfg.family] = (familyCounts[cfg.family] || 0) + 1;
            }
            return relaxedSuccess;
        }
        return success;
    };

    baseConfigs.forEach(cfg => {
        if (accepted.length < count) {
            pushWithDiversity(cfg, true);
        }
    });

    let attempts = 0;
    const maxAttempts = count * 50;
    while (accepted.length < count && attempts < maxAttempts) {
        const candidateFamily = N0_FAMILY_LIST[Math.floor(rng() * N0_FAMILY_LIST.length)];
        const candidate = sampleRandomN0Config(rng, candidateFamily);
        const added = pushWithDiversity(candidate, true);
        if (!added && attempts % N0_FAMILY_LIST.length === 0 && diversityThreshold > 0.08) {
            diversityThreshold *= 0.97;
        }
        attempts++;
    }

    N0_FAMILY_LIST.forEach(family => {
        while ((familyCounts[family] || 0) < N0_FAMILY_MIN_PER_TYPE && accepted.length < count) {
            const candidate = sampleRandomN0Config(rng, family);
            if (!pushWithDiversity(candidate, true)) {
                break;
            }
        }
    });

    diversityThreshold = Math.max(0.05, diversityThreshold);
    while (accepted.length < count) {
        const candidate = sampleRandomN0Config(rng);
        if (!candidate) continue;
        if (!pushWithDiversity(candidate, true)) {
            if (diversityThreshold > 0.05) {
                diversityThreshold *= 0.95;
            } else {
                accepted.push(candidate);
                acceptedVectors.push(encodeN0ConfigVector(candidate));
                familyCounts[candidate.family] = (familyCounts[candidate.family] || 0) + 1;
            }
        }
    }

    const trimmed = accepted.slice(0, count).map((cfg, index) => ({
        id: createN0ConfigId(index),
        family: cfg.family,
        params: cfg.params || {},
        description: describeN0Config(cfg)
    }));

    n0ConfigLibraryCache = trimmed;
    n0ConfigLibrarySeed = seed;
    maybePersistN0ConfigLibrary(trimmed);

    return trimmed;
}

function computeWindowStats(windowChars) {
    const total = windowChars.length;
    let whites = 0;
    let reds = 0;
    let blacks = 0;
    let currentWhiteRun = 0;
    let maxWhiteRun = 0;
    let whiteRunCount = 0;
    let tailWhiteRun = 0;
    let consecutiveSwitches = 0;
    let nonWhiteTransitions = 0;
    let lastNonWhite = null;
    const whitePrefix = new Array(total + 1).fill(0);
    let entropyFirstHalf = 0;
    let entropySecondHalf = 0;

    for (let i = 0; i < total; i++) {
        const color = windowChars[i];
        whitePrefix[i + 1] = whitePrefix[i] + (color === 'W' ? 1 : 0);
        if (color === 'W') {
            whites += 1;
            currentWhiteRun += 1;
        } else {
            if (currentWhiteRun > 0) {
                whiteRunCount += 1;
                if (currentWhiteRun > maxWhiteRun) {
                    maxWhiteRun = currentWhiteRun;
                }
                currentWhiteRun = 0;
            }
            if (color === 'R') reds += 1;
            if (color === 'B') blacks += 1;
            if (color === 'R' || color === 'B') {
                if (lastNonWhite && lastNonWhite !== color) {
                    consecutiveSwitches += 1;
                }
                if (lastNonWhite) {
                    nonWhiteTransitions += 1;
                }
                lastNonWhite = color;
            }
        }
    }

    if (currentWhiteRun > 0) {
        whiteRunCount += 1;
        if (currentWhiteRun > maxWhiteRun) {
            maxWhiteRun = currentWhiteRun;
        }
    }

    tailWhiteRun = 0;
    for (let i = total - 1; i >= 0; i--) {
        if (windowChars[i] === 'W') tailWhiteRun += 1;
        else if (windowChars[i] === 'R' || windowChars[i] === 'B') break;
    }

    const half = Math.max(1, Math.floor(total / 2));
    const firstHalfCounts = { W: 0, R: 0, B: 0 };
    const secondHalfCounts = { W: 0, R: 0, B: 0 };
    for (let i = 0; i < total; i++) {
        const color = windowChars[i];
        if (i < half) firstHalfCounts[color] = (firstHalfCounts[color] || 0) + 1;
        else secondHalfCounts[color] = (secondHalfCounts[color] || 0) + 1;
    }

    const entropy = (counts) => {
        const sum = Object.values(counts).reduce((acc, val) => acc + val, 0);
        if (sum === 0) return 0;
        let value = 0;
        Object.values(counts).forEach(count => {
            if (count <= 0) return;
            const p = count / sum;
            value -= p * Math.log2(p);
        });
        return value;
    };

    entropyFirstHalf = entropy(firstHalfCounts);
    entropySecondHalf = entropy(secondHalfCounts);

    return {
        total,
        whites,
        reds,
        blacks,
        pW: total > 0 ? whites / total : 0,
        pR: total > 0 ? reds / total : 0,
        pB: total > 0 ? blacks / total : 0,
        maxWhiteRun,
        whiteRunCount,
        tailWhiteRun,
        switches: consecutiveSwitches,
        nonWhiteTransitions,
        whitePrefix,
        entropyFirstHalf,
        entropySecondHalf,
        segmentCache: new Map(),
        weightedCache: new Map()
    };
}

function getSegmentFractions(stats, segments, windowChars) {
    if (stats.segmentCache.has(segments)) {
        return stats.segmentCache.get(segments);
    }
    const fractions = [];
    const len = stats.total;
    const segSize = Math.max(1, Math.floor(len / segments));
    for (let s = 0; s < segments; s++) {
        const start = s * segSize;
        const end = s === segments - 1 ? len : Math.min(len, start + segSize);
        if (start >= len) {
            fractions.push(0);
            continue;
        }
        let whites = 0;
        for (let i = start; i < end; i++) {
            if (windowChars[i] === 'W') whites += 1;
        }
        fractions.push((end - start) > 0 ? whites / (end - start) : 0);
    }
    stats.segmentCache.set(segments, fractions);
    return fractions;
}

function getWeightedWhiteness(stats, windowChars, decay) {
    const key = `decay_${decay}`;
    if (stats.weightedCache.has(key)) {
        return stats.weightedCache.get(key);
    }
    let weightedWhites = 0;
    let totalWeight = 0;
    let currentWeight = 1;
    for (let i = windowChars.length - 1; i >= 0; i--) {
        const color = windowChars[i];
        if (color === 'W') {
            weightedWhites += currentWeight;
        }
        totalWeight += currentWeight;
        currentWeight *= decay;
    }
    const result = totalWeight > 0 ? weightedWhites / totalWeight : 0;
    stats.weightedCache.set(key, result);
    return result;
}

function buildN0WindowContext(windows) {
    const stats = windows.map(entry => computeWindowStats(entry.window));
    const whitenessSeries = stats.map(s => s.pW);
    const whiteCounts = stats.map(s => s.whites);
    return {
        stats,
        whitenessSeries,
        whiteCounts
    };
}

function applyN0Config(cfg, windowChars, idxWindow, windows, context, depth = 0) {
    if (!cfg || !cfg.family || !Array.isArray(windowChars) || windowChars.length === 0) {
        return { prediction: null, confidence: 0 };
    }
    if (depth > 3) {
        return { prediction: null, confidence: 0 };
    }
    const params = cfg.params || {};
    const stats = context.stats[idxWindow];

    switch (cfg.family) {
        case 'freq_threshold': {
            const confidence = stats.pW;
            return {
                prediction: confidence >= (params.thresh ?? 0.2) ? 'W' : null,
                confidence
            };
        }
        case 'freq_segmented': {
            const segments = Math.max(2, Math.min(8, Number(params.segments) || 4));
            const fractions = getSegmentFractions(stats, segments, windowChars);
            const maxSegment = Math.max(...fractions);
            return {
                prediction: maxSegment >= (params.seg_thresh ?? 0.25) ? 'W' : null,
                confidence: clamp01(maxSegment)
            };
        }
        case 'weighted_recency': {
            const decay = clamp01(params.decay ?? 0.85);
            const thresh = params.thresh ?? 0.22;
            const confidence = getWeightedWhiteness(stats, windowChars, Math.max(0.4, Math.min(0.98, decay)));
            return {
                prediction: confidence >= thresh ? 'W' : null,
                confidence: clamp01(confidence)
            };
        }
        case 'last_run': {
            const minRun = Math.max(1, Number(params.min_run) || 3);
            const tail = stats.tailWhiteRun;
            const confidence = clamp01(tail / Math.max(1, minRun));
            return {
                prediction: tail >= minRun ? 'W' : null,
                confidence
            };
        }
        case 'run_stats': {
            const minMaxRun = Math.max(2, Number(params.min_max_run) || 4);
            const minRunCount = Math.max(1, Number(params.min_run_count) || 2);
            const condition = stats.maxWhiteRun >= minMaxRun && stats.whiteRunCount >= minRunCount;
            const confidence = clamp01(
                ((stats.maxWhiteRun / Math.max(1, minMaxRun)) + (stats.whiteRunCount / Math.max(1, minRunCount))) / 2
            );
            return {
                prediction: condition ? 'W' : null,
                confidence
            };
        }
        case 'markov': {
            const order = Math.max(1, Math.min(3, Number(params.order) || 1));
            const probThresh = clamp01(params.prob_thresh ?? 0.55);
            const transitions = {};
            for (let i = 0; i + order < windowChars.length; i++) {
                const key = windowChars.slice(i, i + order).join('');
                const next = windowChars[i + order];
                if (!transitions[key]) transitions[key] = { W: 0, N: 0 };
                if (next === 'W') transitions[key].W += 1;
                else if (next === 'R' || next === 'B') transitions[key].N += 1;
            }
            const lastKey = windowChars.slice(-order).join('');
            const statsKey = transitions[lastKey];
            if (!statsKey) {
                return { prediction: null, confidence: 0 };
            }
            const total = statsKey.W + statsKey.N;
            const confidence = total > 0 ? statsKey.W / total : 0;
            return {
                prediction: confidence >= probThresh ? 'W' : null,
                confidence: clamp01(confidence)
            };
        }
        case 'n_gram_pattern': {
            const pattern = String(params.pattern || '').replace(/[^R BW]/g, '').replace(/\s+/g, '');
            const nextThresh = clamp01(params.next_thresh ?? 0.6);
            const L = pattern.length;
            if (!pattern || L < 2 || windowChars.length <= L) {
                return { prediction: null, confidence: 0 };
            }
            let occurrences = 0;
            let whiteFollowers = 0;
            for (let i = 0; i + L < windowChars.length; i++) {
                const candidate = windowChars.slice(i, i + L).join('');
                if (candidate === pattern) {
                    occurrences += 1;
                    if (windowChars[i + L] === 'W') {
                        whiteFollowers += 1;
                    }
                }
            }
            if (occurrences === 0) {
                return { prediction: null, confidence: 0 };
            }
            const confidence = whiteFollowers / occurrences;
            return {
                prediction: confidence >= nextThresh ? 'W' : null,
                confidence: clamp01(confidence)
            };
        }
        case 'burst_detector': {
            const subWindow = Math.max(3, Math.min(windowChars.length, Number(params.sub_window) || 12));
            const fracThresh = clamp01(params.frac_thresh ?? 0.45);
            let maxFraction = 0;
            for (let start = 0; start + subWindow <= windowChars.length; start++) {
                const whitesInSubWindow = stats.whitePrefix[start + subWindow] - stats.whitePrefix[start];
                const fraction = whitesInSubWindow / subWindow;
                if (fraction > maxFraction) {
                    maxFraction = fraction;
                }
            }
            return {
                prediction: maxFraction >= fracThresh ? 'W' : null,
                confidence: clamp01(maxFraction)
            };
        }
        case 'entropy_change': {
            const deltaThresh = params.delta_thresh ?? 0.1;
            const maxEntropy = params.max_entropy ?? 1.2;
            const delta = stats.entropyFirstHalf - stats.entropySecondHalf;
            const confidence = clamp01(stats.pW + Math.max(0, delta));
            const condition = delta >= deltaThresh && stats.entropySecondHalf <= maxEntropy;
            return {
                prediction: condition ? 'W' : null,
                confidence
            };
        }
        case 'lagged_sum': {
            const lagK = Math.max(1, Number(params.lag_k) || 3);
            if (idxWindow + 1 < lagK) {
                return { prediction: null, confidence: 0 };
            }
            let sumWhites = 0;
            for (let i = idxWindow - lagK + 1; i <= idxWindow; i++) {
                sumWhites += context.whiteCounts[i];
            }
            const sumThresh = Number(params.sum_thresh) || 6;
            const confidence = clamp01(sumWhites / (lagK * windowChars.length));
            return {
                prediction: sumWhites >= sumThresh ? 'W' : null,
                confidence
            };
        }
        case 'trend_accel': {
            const segments = Math.max(3, Math.min(6, Number(params.segments) || 4));
            const fractions = getSegmentFractions(stats, segments, windowChars);
            if (fractions.length < 3) {
                return { prediction: null, confidence: 0 };
            }
            const midIndex = Math.floor(fractions.length / 2);
            const slopeEarly = fractions[midIndex] - fractions[0];
            const slopeLate = fractions[fractions.length - 1] - fractions[midIndex];
            const accel = slopeLate - slopeEarly;
            const accelThresh = params.accel_thresh ?? 0.1;
            const minFinal = params.min_final_pw ?? 0.25;
            const confidence = clamp01(fractions[fractions.length - 1] + Math.max(0, accel));
            const condition = accel >= accelThresh && fractions[fractions.length - 1] >= minFinal;
            return {
                prediction: condition ? 'W' : null,
                confidence
            };
        }
        case 'switch_pattern': {
            const minRate = clamp01(params.min_switch_rate ?? 0.75);
            const minTotal = Math.max(3, Number(params.min_total_switches) || 8);
            const switchRate = stats.nonWhiteTransitions > 0
                ? stats.switches / stats.nonWhiteTransitions
                : 0;
            const confidence = clamp01((switchRate + stats.pW) / 2);
            const condition = stats.switches >= minTotal && switchRate >= minRate;
            return {
                prediction: condition ? 'W' : null,
                confidence
            };
        }
        case 'compound_and':
        case 'compound_or': {
            const parts = Array.isArray(params.parts) ? params.parts : [];
            if (parts.length === 0) {
                return { prediction: null, confidence: 0 };
            }
            const results = parts.map(part => applyN0Config(part, windowChars, idxWindow, windows, context, depth + 1));
            const activeParts = results.filter(res => res.prediction === 'W');
            if (cfg.family === 'compound_and') {
                const condition = activeParts.length === results.length;
                const confidenceAvg = activeParts.length > 0
                    ? activeParts.reduce((acc, item) => acc + item.confidence, 0) / activeParts.length
                    : 0;
                return {
                    prediction: condition ? 'W' : null,
                    confidence: clamp01(confidenceAvg)
                };
            }
            const minHits = Math.max(1, Math.min(results.length, Number(params.min_hits) || 1));
            const condition = activeParts.length >= minHits;
            const confidenceAvg = activeParts.length > 0
                ? activeParts.reduce((acc, item) => acc + item.confidence, 0) / activeParts.length
                : 0;
            return {
                prediction: condition ? 'W' : null,
                confidence: clamp01(confidenceAvg)
            };
        }
        default:
            return { prediction: null, confidence: 0 };
    }
}

function computeN0RecentRecall(confList) {
    if (!Array.isArray(confList) || confList.length === 0) return 0;
    const half = Math.max(1, Math.floor(confList.length / 2));
    const recent = confList.slice(-half);
    let truePositives = 0;
    let falseNegatives = 0;
    recent.forEach(({ confidence, isWhite }) => {
        if (!isWhite) return;
        if (confidence >= 0.5) truePositives += 1;
        else falseNegatives += 1;
    });
    return truePositives + falseNegatives > 0 ? truePositives / (truePositives + falseNegatives) : 0;
}

function evaluateN0Config(windows, cfg, context, options = {}) {
    const { collectLogs = false } = options;
    let TP = 0;
    let FP = 0;
    let FN = 0;
    let nPreds = 0;
    const confList = [];
    const perWindowLog = collectLogs ? [] : null;

    windows.forEach((entry, idx) => {
        const { window, target } = entry;
        const result = applyN0Config(cfg, window, idx, windows, context);
        const confidence = clamp01(result.confidence ?? 0);
        const predictedWhite = result.prediction === 'W';
        const targetIsWhite = target === 'W';

        confList.push({
            confidence,
            isWhite: targetIsWhite,
            predictedWhite
        });

        let logResult = 'nulo';
        if (predictedWhite) {
            nPreds += 1;
            if (targetIsWhite) {
                TP += 1;
                logResult = 'hit';
            } else {
                FP += 1;
                logResult = 'false_positive';
            }
        } else if (targetIsWhite) {
            FN += 1;
            logResult = 'miss_white';
        } else {
            logResult = 'null';
        }

        if (perWindowLog) {
            perWindowLog.push({
                window_index: entry.index,
                start_idx: entry.start,
                prediction: predictedWhite ? 'W' : '-',
                confidence: Number(confidence.toFixed(4)),
                target,
                result: logResult
            });
        }
    });

    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    const coverage = windows.length > 0 ? nPreds / windows.length : 0;
    const accRecent = computeN0RecentRecall(confList);

    return {
        cfg,
        metrics: {
            TP,
            FP,
            FN,
            n_preds: nPreds,
            precision,
            recall,
            f1,
            coverage,
            acc_recent: accRecent,
            n_windows: windows.length
        },
        confList,
        perWindowLog
    };
}

function evaluateN0ConfigLegacy(windows, cfg) {
    let TP = 0;
    let FP = 0;
    let FN = 0;
    let nPreds = 0;
    const confList = [];

    windows.forEach(({ window, target }) => {
        const { prediction, confidence } = applyN0AnalysisLegacy(cfg, window);
        const confValue = Number.isFinite(confidence) ? Math.max(0, Math.min(1, confidence)) : 0;
        confList.push({ confidence: confValue, isWhite: target === 'W' });
        if (prediction === 'W') {
            nPreds += 1;
            if (target === 'W') TP += 1;
            else FP += 1;
        } else if (target === 'W') {
            FN += 1;
        }
    });

    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    const coverage = windows.length > 0 ? nPreds / windows.length : 0;
    const accRecent = computeN0RecentRecall(confList);

    return {
        cfg,
        n_preds: nPreds,
        TP,
        FP,
        FN,
        precision,
        recall,
        f1,
        coverage,
        acc_recent: accRecent,
        confList
    };
}

function calculateN0BlockMetrics(confList, threshold) {
    let TP = 0;
    let FP = 0;
    let FN = 0;
    confList.forEach(({ confidence, isWhite }) => {
        const passes = confidence >= threshold;
        if (passes && isWhite) TP += 1;
        else if (passes && !isWhite) FP += 1;
        else if (!passes && isWhite) FN += 1;
    });
    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    return { TP, FP, FN, precision, recall, f1 };
}

function determineDominantNonWhite(window) {
    if (!Array.isArray(window) || window.length === 0) return null;
    let reds = 0;
    let blacks = 0;
    window.forEach(char => {
        if (char === 'R') reds += 1;
        if (char === 'B') blacks += 1;
    });
    if (reds === blacks) return null;
    if (reds === 0 && blacks === 0) return null;
    return reds > blacks ? 'red' : 'black';
}

function runN0DetectorLegacy(history, options = {}) {
    try {
        const settings = {
            historySize: Number(options.historySize) > 0 ? Math.floor(options.historySize) : N0_DEFAULTS.historySize,
            windowSize: Number(options.windowSize) > 0 ? Math.floor(options.windowSize) : N0_DEFAULTS.windowSize,
            analysesToRun: Number(options.analysesToRun) > 0 ? Math.floor(options.analysesToRun) : N0_DEFAULTS.analysesToRun,
            minWindowsRequired: Number(options.minWindowsRequired) > 0 ? Math.floor(options.minWindowsRequired) : N0_DEFAULTS.minWindowsRequired,
            precisionMin: typeof options.precisionMin === 'number' ? Math.max(0, Math.min(1, options.precisionMin)) : N0_DEFAULTS.precisionMin,
            confidenceGrid: Array.isArray(options.confidenceGrid) && options.confidenceGrid.length > 0
                ? options.confidenceGrid.map(Number).filter(v => Number.isFinite(v) && v > 0 && v < 1).sort((a, b) => a - b)
                : [...N0_DEFAULTS.confidenceGrid],
            holdoutEnabled: options.holdoutEnabled !== undefined ? !!options.holdoutEnabled : N0_DEFAULTS.holdoutEnabled,
            holdoutTolerance: typeof options.holdoutTolerance === 'number'
                ? Math.max(0, Math.min(1, options.holdoutTolerance))
                : N0_DEFAULTS.holdoutTolerance,
            seed: Number.isFinite(Number(options.seed)) ? Number(options.seed) : N0_DEFAULTS.seed
        };

        const chronologicalHistory = Array.isArray(history) ? history.slice().reverse() : [];
        const normalizedHistory = normalizeN0History(chronologicalHistory).slice(-settings.historySize);

        if (normalizedHistory.length < settings.windowSize * 2) {
            return {
                enabled: false,
                reason: `HistÃ³rico insuficiente: ${normalizedHistory.length}/${settings.windowSize * 2}`,
                code: 'insufficient_history'
            };
        }

        const windows = buildN0Windows(normalizedHistory, settings.windowSize);
        if (windows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                reason: `Janelas Ãºteis insuficientes: ${windows.length}/${settings.minWindowsRequired}`,
                code: 'insufficient_windows'
            };
        }

        const holdoutPossible = settings.holdoutEnabled && windows.length >= settings.minWindowsRequired * 2;
        const trainingWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 0) : windows;
        const validationWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 1) : [];

        if (trainingWindows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                reason: `ValidaÃ§Ã£o: menos de ${settings.minWindowsRequired} janelas na amostra de treino`,
                code: 'insufficient_training'
            };
        }

        const candidateConfigs = generateN0Configs(settings.analysesToRun, settings.seed);
        const evaluations = [];
        candidateConfigs.forEach(cfg => {
            const evaluation = evaluateN0Config(trainingWindows, cfg);
            if (evaluation.n_preds >= settings.minWindowsRequired) {
                evaluations.push(evaluation);
            }
        });

        if (evaluations.length === 0) {
            return {
                enabled: false,
                reason: 'Nenhuma configuraÃ§Ã£o elegÃ­vel',
                code: 'no_valid_configs',
                tested_configs: candidateConfigs.length
            };
        }

        evaluations.sort((a, b) => {
            if (b.f1 !== a.f1) return b.f1 - a.f1;
            if (b.recall !== a.recall) return b.recall - a.recall;
            if (b.precision !== a.precision) return b.precision - a.precision;
            if ((b.acc_recent || 0) !== (a.acc_recent || 0)) return (b.acc_recent || 0) - (a.acc_recent || 0);
            if (b.coverage !== a.coverage) return b.coverage - a.coverage;
            return 0;
        });

        const bestEvaluation = evaluations[0];
        const grid = settings.confidenceGrid.length > 0 ? settings.confidenceGrid : [...N0_DEFAULTS.confidenceGrid];

        let chosenThreshold = null;
        let chosenMetrics = null;
        grid.forEach(candidate => {
            const metrics = calculateN0BlockMetrics(bestEvaluation.confList, candidate);
            if (metrics.precision >= settings.precisionMin) {
                if (!chosenMetrics || metrics.f1 > chosenMetrics.f1) {
                    chosenMetrics = metrics;
                    chosenThreshold = candidate;
                }
            }
        });

        if (!chosenMetrics) {
            const confValues = bestEvaluation.confList
                .map(entry => entry.confidence)
                .filter(Number.isFinite)
                .sort((a, b) => a - b);
            const percentileIndex = Math.max(0, Math.min(confValues.length - 1, Math.floor(confValues.length * 0.9)));
            const percentile90 = confValues.length > 0 ? confValues[percentileIndex] : 0.8;
            chosenThreshold = Math.max(0.8, percentile90);
            chosenMetrics = calculateN0BlockMetrics(bestEvaluation.confList, chosenThreshold);
        }

        const holdoutInfo = {
            enabled: holdoutPossible,
            passed: true,
            reason: null,
            training: chosenMetrics,
            validation: null
        };

        if (holdoutPossible && validationWindows.length >= settings.minWindowsRequired) {
            const validationEval = evaluateN0Config(validationWindows, bestEvaluation.cfg);
            const validationMetrics = calculateN0BlockMetrics(validationEval.confList, chosenThreshold);
            holdoutInfo.validation = validationMetrics;
            const trainingF1 = chosenMetrics.f1;
            const validationF1 = validationMetrics.f1;
            if (validationMetrics.precision < settings.precisionMin) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `PrecisÃ£o da validaÃ§Ã£o abaixo do mÃ­nimo (${(validationMetrics.precision * 100).toFixed(1)}% < ${(settings.precisionMin * 100).toFixed(1)}%)`;
            } else if (validationF1 < (trainingF1 - settings.holdoutTolerance)) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `F1 caiu de ${(trainingF1 * 100).toFixed(1)}% para ${(validationF1 * 100).toFixed(1)}%`;
            }
        }

        const liveWindow = normalizedHistory.slice(-settings.windowSize);
        if (liveWindow.length < settings.windowSize) {
            return {
                enabled: false,
                reason: 'Janela incompleta para prediÃ§Ã£o ao vivo',
                code: 'incomplete_live_window'
            };
        }
        const liveAnalysis = applyN0Analysis(bestEvaluation.cfg, liveWindow);
        const liveConfidence = Number.isFinite(liveAnalysis.confidence) ? Math.max(0, Math.min(1, liveAnalysis.confidence)) : 0;
        const livePrediction = liveAnalysis.prediction === 'W' ? 'W' : null;

        let blockingAction = 'no_block';
        if (livePrediction === 'W') {
            if (liveConfidence >= chosenThreshold) {
                blockingAction = 'block_all';
            } else if (liveConfidence >= chosenThreshold * 0.8) {
                blockingAction = 'soft_block';
            }
        }

        if (!holdoutInfo.passed && blockingAction !== 'no_block') {
            blockingAction = 'no_block';
        }

        const dominantNonWhite = determineDominantNonWhite(liveWindow);

        return {
            enabled: true,
            best_config: bestEvaluation.cfg,
            metrics: {
                training: bestEvaluation,
                block: chosenMetrics
            },
            pred_live: livePrediction,
            white_confidence: liveConfidence,
            blocking_action: blockingAction,
            blocking_threshold: chosenThreshold,
            dominant_nonwhite: dominantNonWhite,
            n_windows: windows.length,
            tested_configs: evaluations.length,
            holdout: holdoutInfo
        };
    } catch (error) {
        console.error('âŒ Erro no detector de branco (N0):', error);
        return {
            enabled: false,
            reason: 'Erro interno no detector de branco',
            code: 'internal_error',
            error: String(error)
        };
    }
}

function runN0Detector(history, options = {}) {
    const runTimestamp = Date.now();
    const runId = `N0-${runTimestamp}-${Math.floor(Math.random() * 1e6).toString(16)}`;
    try {
        const settings = {
            historySize: Number(options.historySize) > 0 ? Math.floor(options.historySize) : N0_DEFAULTS.historySize,
            windowSize: Number(options.windowSize) > 0 ? Math.floor(options.windowSize) : N0_DEFAULTS.windowSize,
            analysesToRun: Number(options.analysesToRun) > 0 ? Math.floor(options.analysesToRun) : N0_DEFAULTS.analysesToRun,
            minWindowsRequired: Number(options.minWindowsRequired) > 0 ? Math.floor(options.minWindowsRequired) : N0_DEFAULTS.minWindowsRequired,
            precisionMin: typeof options.precisionMin === 'number' ? clamp01(options.precisionMin) : N0_DEFAULTS.precisionMin,
            confidenceGrid: Array.isArray(options.confidenceGrid) && options.confidenceGrid.length > 0
                ? options.confidenceGrid.map(Number).filter(v => Number.isFinite(v) && v > 0 && v < 1).sort((a, b) => a - b)
                : [...N0_DEFAULTS.confidenceGrid],
            holdoutEnabled: options.holdoutEnabled !== undefined ? !!options.holdoutEnabled : N0_DEFAULTS.holdoutEnabled,
            holdoutTolerance: typeof options.holdoutTolerance === 'number'
                ? clamp01(options.holdoutTolerance)
                : N0_DEFAULTS.holdoutTolerance,
            seed: Number.isFinite(Number(options.seed)) ? Number(options.seed) : N0_DEFAULTS.seed
        };

        const chronologicalHistory = Array.isArray(history) ? history.slice().reverse() : [];
        const normalizedHistory = normalizeN0History(chronologicalHistory).slice(-settings.historySize);

        if (normalizedHistory.length < settings.windowSize * 2) {
            return {
                enabled: false,
                reason: `HistÃ³rico insuficiente: ${normalizedHistory.length}/${settings.windowSize * 2}`,
                code: 'insufficient_history'
            };
        }

        const windows = buildN0Windows(normalizedHistory, settings.windowSize);
        if (windows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                reason: `Janelas Ãºteis insuficientes: ${windows.length}/${settings.minWindowsRequired}`,
                code: 'insufficient_windows'
            };
        }

        const holdoutPossible = settings.holdoutEnabled && windows.length >= settings.minWindowsRequired * 2;
        const trainingWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 0) : windows;
        const validationWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 1) : [];

        if (trainingWindows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                reason: `ValidaÃ§Ã£o: menos de ${settings.minWindowsRequired} janelas na amostra de treino`,
                code: 'insufficient_training'
            };
        }

        const candidateConfigs = generateN0Configs(settings.analysesToRun, settings.seed);
        console.log(`%c   â¤ Biblioteca N0: ${candidateConfigs.length} configs avaliadas`, 'color: #CCCCFF; font-weight: bold;');
        const trainingContext = buildN0WindowContext(trainingWindows);
        const evaluations = [];

        candidateConfigs.forEach(cfg => {
            const evaluation = evaluateN0Config(trainingWindows, cfg, trainingContext);
            if (evaluation.metrics.n_preds >= settings.minWindowsRequired) {
                evaluations.push(evaluation);
            }
        });

        if (evaluations.length === 0) {
            return {
                enabled: false,
                reason: 'Nenhuma configuraÃ§Ã£o elegÃ­vel',
                code: 'no_valid_configs',
                tested_configs: candidateConfigs.length
            };
        }

        evaluations.sort((a, b) => {
            const mA = a.metrics;
            const mB = b.metrics;
            if (mB.f1 !== mA.f1) return mB.f1 - mA.f1;
            if (mB.recall !== mA.recall) return mB.recall - mA.recall;
            if (mB.precision !== mA.precision) return mB.precision - mA.precision;
            if ((mB.acc_recent || 0) !== (mA.acc_recent || 0)) return (mB.acc_recent || 0) - (mA.acc_recent || 0);
            if (mB.coverage !== mA.coverage) return mB.coverage - mA.coverage;
            return 0;
        });

        const TOP_K = Math.min(20, evaluations.length);
        const topEvaluations = evaluations.slice(0, TOP_K);
        const bestEvaluation = topEvaluations[0];
        const bestDetailed = evaluateN0Config(trainingWindows, bestEvaluation.cfg, trainingContext, { collectLogs: true });
        const bestMetrics = bestDetailed.metrics;
        const bestConfList = bestDetailed.confList;
        const perWindowLog = bestDetailed.perWindowLog || [];

        const grid = settings.confidenceGrid.length > 0 ? settings.confidenceGrid : [...N0_DEFAULTS.confidenceGrid];
        let chosenThreshold = null;
        let chosenMetrics = null;
        grid.forEach(candidate => {
            const metrics = calculateN0BlockMetrics(bestConfList, candidate);
            if (metrics.precision >= settings.precisionMin) {
                if (!chosenMetrics || metrics.f1 > chosenMetrics.f1) {
                    chosenMetrics = { ...metrics, threshold: candidate };
                    chosenThreshold = candidate;
                }
            }
        });

        if (!chosenMetrics) {
            const confValues = bestConfList
                .map(entry => entry.confidence)
                .filter(Number.isFinite)
                .sort((a, b) => a - b);
            const percentileIndex = Math.max(0, Math.min(confValues.length - 1, Math.floor(confValues.length * 0.9)));
            const percentile90 = confValues.length > 0 ? confValues[percentileIndex] : 0.8;
            chosenThreshold = Math.max(0.8, percentile90);
            const fallbackMetrics = calculateN0BlockMetrics(bestConfList, chosenThreshold);
            chosenMetrics = { ...fallbackMetrics, threshold: chosenThreshold, fallback: true };
        } else if (!('threshold' in chosenMetrics)) {
            chosenMetrics.threshold = chosenThreshold;
        }

        const holdoutInfo = {
            enabled: holdoutPossible,
            passed: true,
            reason: null,
            training: chosenMetrics,
            validation: null
        };
        const warnings = [];

        if (holdoutPossible && validationWindows.length >= settings.minWindowsRequired) {
            const validationContext = buildN0WindowContext(validationWindows);
            const validationEval = evaluateN0Config(validationWindows, bestDetailed.cfg, validationContext);
            const validationMetrics = calculateN0BlockMetrics(validationEval.confList, chosenThreshold);
            holdoutInfo.validation = { ...validationMetrics, threshold: chosenThreshold };
            const trainingF1 = chosenMetrics.f1 ?? 0;
            const validationF1 = validationMetrics.f1 ?? 0;
            if (validationMetrics.precision < settings.precisionMin) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `PrecisÃ£o da validaÃ§Ã£o abaixo do mÃ­nimo (${(validationMetrics.precision * 100).toFixed(1)}% < ${(settings.precisionMin * 100).toFixed(1)}%)`;
                warnings.push(holdoutInfo.reason);
            } else if (validationF1 < (trainingF1 - settings.holdoutTolerance)) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `F1 caiu de ${(trainingF1 * 100).toFixed(1)}% para ${(validationF1 * 100).toFixed(1)}%`;
                warnings.push(holdoutInfo.reason);
            }
        }

        const liveWindow = normalizedHistory.slice(-settings.windowSize);
        if (liveWindow.length < settings.windowSize) {
            return {
                enabled: false,
                reason: 'Janela incompleta para prediÃ§Ã£o ao vivo',
                code: 'incomplete_live_window'
            };
        }

        const liveWindows = [{
            window: liveWindow,
            target: null,
            index: windows.length,
            start: Math.max(0, normalizedHistory.length - settings.windowSize),
            targetIndex: normalizedHistory.length
        }];
        const liveContext = buildN0WindowContext(liveWindows);
        const liveResult = applyN0Config(bestDetailed.cfg, liveWindow, 0, liveWindows, liveContext);
        const liveConfidence = clamp01(liveResult.confidence ?? 0);
        const livePrediction = liveResult.prediction === 'W' ? 'W' : null;

        let blockingAction = 'no_block';
        if (livePrediction === 'W') {
            if (liveConfidence >= chosenThreshold) {
                blockingAction = 'block_all';
            } else if (liveConfidence >= chosenThreshold * 0.8) {
                blockingAction = 'soft_block';
            }
        }

        if (!holdoutInfo.passed && blockingAction !== 'no_block') {
            blockingAction = 'no_block';
            warnings.push('AÃ§Ã£o de bloqueio suprimida devido Ã  reprovaÃ§Ã£o no holdout.');
        }

        const dominantNonWhite = determineDominantNonWhite(liveWindow);

        const topCandidates = topEvaluations.slice(0, Math.min(10, topEvaluations.length)).map(entry => ({
            id: entry.cfg.id,
            family: entry.cfg.family,
            params: entry.cfg.params,
            metrics: entry.metrics
        }));

        const runSummary = {
            run_id: runId,
            timestamp: runTimestamp,
            history_size: settings.historySize,
            window_size: settings.windowSize,
            analyses_to_run: settings.analysesToRun,
            min_windows_required: settings.minWindowsRequired,
            seed: settings.seed
        };

        const bestDescription = bestDetailed.cfg.description || bestDetailed.cfg.family || 'desconhecido';
        const f1Display = bestMetrics.f1 != null ? (bestMetrics.f1 * 100).toFixed(1) : 'n/d';
        const precisionDisplay = bestMetrics.precision != null ? (bestMetrics.precision * 100).toFixed(1) : 'n/d';
        const recallDisplay = bestMetrics.recall != null ? (bestMetrics.recall * 100).toFixed(1) : 'n/d';
        const coverageDisplay = bestMetrics.coverage != null ? (bestMetrics.coverage * 100).toFixed(1) : 'n/d';
        console.log(`âœ… [N8] Melhor anÃ¡lise: ${bestDescription} | F1 ${f1Display}% | prec ${precisionDisplay}% | rec ${recallDisplay}% | coverage ${coverageDisplay}% | n_preds ${bestMetrics.n_preds}/${bestMetrics.n_windows}`);
        const finalColor = livePrediction === 'W' ? 'white' : null;
        const finalConfidence = liveConfidence;
        const thresholdGate = chosenThreshold;
        if (finalColor) {
            console.log(`ğŸ¯ [N8] Voto ao vivo: ${finalColor.toUpperCase()} (confianÃ§a ${(finalConfidence * 100).toFixed(1)}%) | conf_live ${Math.round(liveConfidence * 100)}% | t* ${Math.round(thresholdGate * 100)}%`);
        } else {
            console.log(`âš ï¸ [N8] Sem voto ao vivo (conf ${Math.round(liveConfidence * 100)}% | limiar ${Math.round(thresholdGate * 100)}%${holdoutInfo.passed ? '' : ' | holdout reprovado'})`);
        }

        return {
            enabled: true,
            run_summary: runSummary,
            best_config: bestDetailed.cfg,
            best_metrics: bestMetrics,
            conf_list: bestConfList,
            per_window_log: perWindowLog,
            blocking_threshold: chosenThreshold,
            blocking_metrics: chosenMetrics,
            pred_live: livePrediction,
            white_confidence: liveConfidence,
            blocking_action: blockingAction,
            dominant_nonwhite: dominantNonWhite,
            tested_configs: candidateConfigs.length,
            effective_configs: evaluations.length,
            top_candidates: topCandidates,
            n_windows: windows.length,
            holdout: holdoutInfo,
            config_library: candidateConfigs,
            warnings
        };
    } catch (error) {
        console.error('âŒ Erro no detector de branco (N0):', error);
        return {
            enabled: false,
            reason: 'Erro interno no detector de branco',
            code: 'internal_error',
            error: String(error),
            run_summary: {
                run_id: runId,
                timestamp: runTimestamp
            }
        };
    }
}

function getN0SettingsFromAnalyzerConfig() {
    const windows = analyzerConfig && analyzerConfig.diamondLevelWindows ? analyzerConfig.diamondLevelWindows : {};
    const historySizeRaw = Number(windows.n0History);
    const windowSizeRaw = Number(windows.n0Window);
    const historySize = Number.isFinite(historySizeRaw) && historySizeRaw > 0 ? Math.floor(historySizeRaw) : N0_DEFAULTS.historySize;
    const windowSize = Number.isFinite(windowSizeRaw) && windowSizeRaw > 0 ? Math.floor(windowSizeRaw) : N0_DEFAULTS.windowSize;
    return {
        historySize: Math.max(200, Math.min(5000, historySize)),
        windowSize: Math.max(25, Math.min(250, windowSize)),
        allowBlockAll: analyzerConfig && analyzerConfig.n0AllowBlockAll !== false
    };
}

/**
 * LEGACY: implementaÃ§Ã£o anterior do walk-forward (mantida apenas para referÃªncia)
 */
function runDiamondLevelN10Legacy(history, options = {}) {
    try {
        const windowSize = Math.max(2, Number(options.windowSize) || 20);   // W
        const historySize = Math.max(windowSize * 2, Number(options.historySize) || 500); // N_total mÃ­nimo 2W
        const analysesToRun = Math.max(50, Number(options.analysesToRun) || 600);
        const minWindowsRequired = Math.max(3, Number(options.minWindows) || 8);
        const confMin = Math.max(0, Math.min(1, Number(options.confMin) || 0.6)); // 0..1
        
        if (!Array.isArray(history) || history.length < windowSize * 2) {
            const available = history ? history.length : 0;
            console.log('âš ï¸ [N10] HistÃ³rico insuficiente para anÃ¡lise:', available, `/< ${windowSize * 2} giros necessÃ¡rios`);
            return {
                enabled: false,
                summaryText: `N10 - Walk-forward â†’ NULO (dados insuficientes: ${available} giros, mÃ­nimo ${windowSize * 2})`
            };
        }
        
        console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #00FFFF; font-weight: bold;');
        console.log('%câ”‚ ğŸ”Ÿ N10: WALK-FORWARD NÃƒO-SOBREPOSTO                    â”‚', 'color: #00FFFF; font-weight: bold;');
        console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #00FFFF; font-weight: bold;');
        console.log(`   ğŸ“Š Janela (W): ${windowSize} giros | HistÃ³rico base alvo: ${historySize} giros`);
        
        // Converter histÃ³rico (mais recente â†’ mais antigo) para ordem cronolÃ³gica (mais antigo â†’ mais recente)
        const chronologicalSpins = history.slice().reverse().filter(s => s && s.color);
        
        const normalizedChars = chronologicalSpins.map(s => {
            if (s.color === 'red') return 'R';
            if (s.color === 'black') return 'B';
            return 'W';
        });
        
        const N_total = Math.min(historySize, normalizedChars.length);
        const seqStart = normalizedChars.length - N_total;
        const seq = normalizedChars.slice(seqStart); // mais antigo â†’ mais recente
        
        const m = Math.floor(N_total / windowSize); // nÃºmero de janelas completas
        if (m < 2) {
            console.log('âš ï¸ [N10] Menos de 2 janelas completas disponÃ­veis:', m);
            return {
                enabled: false,
                summaryText: `N10 - Walk-forward â†’ NULO (menos de 2 janelas completas para W=${windowSize})`
            };
        }
        
        const windows = [];
        for (let k = 0; k < m; k++) {
            const start = k * windowSize;
            const end = start + windowSize;
            const targetIdx = end;
            if (targetIdx >= seq.length) continue;
            const window = seq.slice(start, end);
            const target = seq[targetIdx];
            windows.push({ window, target, start, targetIdx });
        }
        
        const n_windows = windows.length;
        if (n_windows < minWindowsRequired) {
            console.log('âš ï¸ [N10] Poucas janelas Ãºteis:', n_windows, `< minWindowsRequired=${minWindowsRequired}`);
            return {
                enabled: false,
                summaryText: `N10 - Walk-forward â†’ NULO (janelas Ãºteis ${n_windows}, mÃ­nimo exigido ${minWindowsRequired})`
            };
        }
        
        // Helpers de anÃ¡lise bÃ¡sica
        const majority = (window) => {
            let r = 0, b = 0;
            for (const c of window) {
                if (c === 'R') r++;
                else if (c === 'B') b++;
            }
            if (r === 0 && b === 0) return null;
            if (r > b) return 'R';
            if (b > r) return 'B';
            return null;
        };
        
        const majorityThreshold = (window, thresh) => {
            let r = 0, b = 0;
            for (const c of window) {
                if (c === 'R') r++;
                else if (c === 'B') b++;
            }
            const total = r + b;
            if (total === 0) return null;
            const pR = r / total;
            const pB = b / total;
            if (pR >= thresh && pR > pB) return 'R';
            if (pB >= thresh && pB > pR) return 'B';
            return null;
        };
        
        const lastPattern = (window, L, nextThreshold) => {
            const nonWhite = window.filter(c => c !== 'W');
            if (nonWhite.length < L + 1) return null;
            const pattern = nonWhite.slice(nonWhite.length - L); // Ãºltimos L
            const seqNoW = window.filter(c => c !== 'W');
            const followers = [];
            for (let i = 0; i + L < seqNoW.length; i++) {
                const slice = seqNoW.slice(i, i + L);
                if (slice.every((c, idx) => c === pattern[idx])) {
                    const follower = seqNoW[i + L];
                    if (follower === 'R' || follower === 'B') {
                        followers.push(follower);
                    }
                }
            }
            if (followers.length === 0) return null;
            let r = 0, b = 0;
            followers.forEach(c => { if (c === 'R') r++; else if (c === 'B') b++; });
            const total = r + b;
            if (total === 0) return null;
            const pR = r / total;
            const pB = b / total;
            if (pR >= nextThreshold && pR > pB) return 'R';
            if (pB >= nextThreshold && pB > pR) return 'B';
            return null;
        };
        
        const markovOrderK = (window, k) => {
            if (window.length <= k) return null;
            const transitions = {};
            const clean = window.filter(c => c === 'R' || c === 'B'); // ignorar W
            if (clean.length <= k) return null;
            for (let i = 0; i + k < clean.length; i++) {
                const key = clean.slice(i, i + k).join('');
                const next = clean[i + k];
                if (next !== 'R' && next !== 'B') continue;
                if (!transitions[key]) transitions[key] = { R: 0, B: 0 };
                transitions[key][next]++;
            }
            const lastSeq = clean.slice(clean.length - k).join('');
            const stats = transitions[lastSeq];
            if (!stats) return null;
            if (stats.R === 0 && stats.B === 0) return null;
            return stats.R >= stats.B ? 'R' : 'B';
        };
        
        const momentumCompare = (window, splitRatio, delta) => {
            const nonWhite = window.filter(c => c !== 'W');
            if (nonWhite.length < 4) return null;
            const splitIndex = Math.max(1, Math.min(nonWhite.length - 1, Math.floor(nonWhite.length * splitRatio)));
            const prev = nonWhite.slice(0, splitIndex);
            const recent = nonWhite.slice(splitIndex);
            const countStats = arr => {
                let r = 0, b = 0;
                arr.forEach(c => { if (c === 'R') r++; else if (c === 'B') b++; });
                const total = r + b;
                if (total === 0) return { pR: 0, pB: 0 };
                return { pR: r / total, pB: b / total };
            };
            const prevStats = countStats(prev);
            const recentStats = countStats(recent);
            const diffR = recentStats.pR - prevStats.pR;
            const diffB = recentStats.pB - prevStats.pB;
            if (Math.abs(diffR) < delta && Math.abs(diffB) < delta) return null;
            if (diffR > diffB && diffR >= delta) return 'R';
            if (diffB > diffR && diffB >= delta) return 'B';
            return null;
        };
        
        const retraction = (window, upperThresh) => {
            let r = 0, b = 0;
            for (const c of window) {
                if (c === 'R') r++;
                else if (c === 'B') b++;
            }
            const total = r + b;
            if (total === 0) return null;
            const pR = r / total;
            const pB = b / total;
            if (pR >= upperThresh && pR > pB) return 'B';
            if (pB >= upperThresh && pB > pR) return 'R';
            return null;
        };
        
        const weightedRecency = (window, mode) => {
            let score = 0;
            const n = window.length;
            for (let i = 0; i < n; i++) {
                const c = window[i];
                if (c !== 'R' && c !== 'B') continue;
                const pos = i + 1; // mais antigo = menor peso
                let w;
                if (mode === 'exp') {
                    w = Math.pow(1.3, pos);
                } else {
                    w = pos;
                }
                const sign = c === 'R' ? 1 : -1;
                score += sign * w;
            }
            if (score > 0) return 'R';
            if (score < 0) return 'B';
            return null;
        };
        
        // Gerar conjunto determinÃ­stico de configuraÃ§Ãµes
        const configs = [];
        
        // majority simples
        configs.push({ type: 'majority', params: {} });
        
        // majority_threshold
        [0.55, 0.6, 0.65, 0.7].forEach(thresh => {
            configs.push({ type: 'majority_threshold', params: { thresh } });
        });
        
        // last_pattern
        [2, 3, 4, 5].forEach(L => {
            [0.6, 0.7].forEach(next_threshold => {
                configs.push({ type: 'last_pattern', params: { L, next_threshold } });
            });
        });
        
        // markov
        [1, 2, 3].forEach(k => {
            configs.push({ type: 'markov', params: { k } });
        });
        
        // momentum
        [0.3, 0.4, 0.5].forEach(split_ratio => {
            [0.05, 0.1].forEach(delta => {
                configs.push({ type: 'momentum', params: { split_ratio, delta } });
            });
        });
        
        // retraction
        [0.7, 0.75, 0.8].forEach(upper => {
            configs.push({ type: 'retraction', params: { upper } });
        });
        
        // weighted recency
        ['linear', 'exp'].forEach(mode => {
            configs.push({ type: 'weighted_recency', params: { mode } });
        });
        
        // Garantir limite de anÃ¡lises
        const limitedConfigs = configs.slice(0, analysesToRun);
        
        const summary = [];
        const detailsByConfig = new Map();
        
        const applyAnalysis = (cfg, window) => {
            switch (cfg.type) {
                case 'majority': return majority(window);
                case 'majority_threshold': return majorityThreshold(window, cfg.params.thresh);
                case 'last_pattern': return lastPattern(window, cfg.params.L, cfg.params.next_threshold);
                case 'markov': return markovOrderK(window, cfg.params.k);
                case 'momentum': return momentumCompare(window, cfg.params.split_ratio, cfg.params.delta);
                case 'retraction': return retraction(window, cfg.params.upper);
                case 'weighted_recency': return weightedRecency(window, cfg.params.mode);
                default: return null;
            }
        };
        
        for (let idx = 0; idx < limitedConfigs.length; idx++) {
            const cfg = limitedConfigs[idx];
            const cfgId = `${cfg.type}#${idx}`;
            const preds = [];
            const trues = [];
            const details = [];
            
            for (let j = 0; j < n_windows; j++) {
                const { window, target, start, targetIdx } = windows[j];
                const pred = applyAnalysis(cfg, window);
                
                if (pred === null || (target !== 'R' && target !== 'B')) {
                    continue;
                }
                
                preds.push(pred);
                trues.push(target);
                details.push({ start, targetIdx, pred, target });
            }
            
            const n_preds = preds.length;
            let accuracy = null;
            let coverage = 0;
            let acc_recent = null;
            
            if (n_preds > 0) {
                let hits = 0;
                for (let i = 0; i < n_preds; i++) {
                    if (preds[i] === trues[i]) hits++;
                }
                accuracy = hits / n_preds;
                coverage = n_preds / n_windows;
                
                const half = Math.max(1, Math.floor(n_preds / 2));
                let recentHits = 0;
                for (let i = n_preds - half; i < n_preds; i++) {
                    if (preds[i] === trues[i]) recentHits++;
                }
                acc_recent = recentHits / half;
            }
            
            summary.push({
                cfg,
                cfgId,
                n_preds,
                accuracy,
                coverage,
                acc_recent
            });
            detailsByConfig.set(cfgId, details);
        }
        
        const valid = summary.filter(rec => rec.n_preds >= minWindowsRequired && rec.accuracy !== null);
        if (valid.length === 0) {
            console.log('âš ï¸ [N10] Nenhuma anÃ¡lise elegÃ­vel (n_preds < minWindowsRequired)');
            return { enabled: false };
        }
        
        valid.sort((a, b) => {
            if (b.accuracy !== a.accuracy) return b.accuracy - a.accuracy;
            if ((b.acc_recent || 0) !== (a.acc_recent || 0)) return (b.acc_recent || 0) - (a.acc_recent || 0);
            if (b.coverage !== a.coverage) return b.coverage - a.coverage;
            if (b.n_preds !== a.n_preds) return b.n_preds - a.n_preds;
            if (a.cfg.type < b.cfg.type) return -1;
            if (a.cfg.type > b.cfg.type) return 1;
            return 0;
        });
        
        const best = valid[0];
        const bestCfg = best.cfg;
        const bestDetails = detailsByConfig.get(best.cfgId) || [];
        
        const lastWindowStart = (m - 1) * windowSize;
        const lastWindow = seq.slice(lastWindowStart, lastWindowStart + windowSize);
        const pred_live = applyAnalysis(bestCfg, lastWindow);
        
        if (pred_live !== 'R' && pred_live !== 'B') {
            console.log('âš ï¸ [N10] Melhor anÃ¡lise nÃ£o conseguiu votar na Ãºltima janela (voto nulo)');
            return { enabled: false, bestConfig: bestCfg, metrics: best };
        }
        
        const accuracyVal = best.accuracy || 0;
        const accRecentVal = best.acc_recent != null ? best.acc_recent : accuracyVal;
        const coverageVal = best.coverage || 0;
        let conf = 0.5 * accuracyVal + 0.4 * accRecentVal + 0.1 * coverageVal;
        conf = Math.max(0, Math.min(1, conf));
        
        if (conf < confMin) {
            const confPct = (conf * 100).toFixed(1);
            const confMinPct = (confMin * 100).toFixed(1);
            console.log(`âš ï¸ [N10] ConfianÃ§a ${confPct}% abaixo do mÃ­nimo configurado (${confMinPct}%) - voto neutro`);
            return {
                enabled: false,
                bestConfig: bestCfg,
                metrics: {
                    accuracy: accuracyVal,
                    acc_recent: accRecentVal,
                    coverage: coverageVal,
                    n_preds: best.n_preds,
                    n_windows
                },
                summaryText: `N10 - Walk-forward â†’ NULO (conf. ${confPct}% < mÃ­nimo ${confMinPct}% | melhor anÃ¡lise ${bestCfg.type}, W=${windowSize}, hist=${N_total}, acurÃ¡cia ${(accuracyVal * 100).toFixed(1)}%, coverage ${(coverageVal * 100).toFixed(1)}%, n_preds=${best.n_preds}/${n_windows})`
            };
        }
        
        const color = pred_live === 'R' ? 'red' : 'black';
        
        const confPct = (conf * 100).toFixed(1);
        console.log(`âœ… [N10] Melhor anÃ¡lise: ${bestCfg.type} | acurÃ¡cia ${(accuracyVal * 100).toFixed(1)}% | acc_recent ${(accRecentVal * 100).toFixed(1)}% | coverage ${(coverageVal * 100).toFixed(1)}% | n_preds=${best.n_preds}/${n_windows}`);
        console.log(`ğŸ¯ [N10] Voto ao vivo: ${color.toUpperCase()} (confianÃ§a ${confPct}%)`);
        
        const summaryText = `N10 - Walk-forward â†’ ${color.toUpperCase()} (${confPct}% | melhor anÃ¡lise: ${bestCfg.type}, W=${windowSize}, hist=${N_total}, acurÃ¡cia ${(accuracyVal * 100).toFixed(1)}%, coverage ${(coverageVal * 100).toFixed(1)}%, n_preds=${best.n_preds}/${n_windows})`;
        
        return {
            enabled: true,
            color,
            confidence: conf, // 0..1
            metrics: {
                accuracy: accuracyVal,
                acc_recent: accRecentVal,
                coverage: coverageVal,
                n_preds: best.n_preds,
                n_windows
            },
            bestConfig: bestCfg,
            summaryText
        };
    } catch (e) {
        console.error('âŒ Erro em runDiamondLevelN10Legacy:', e);
        return {
            enabled: false,
            summaryText: 'N10 - Walk-forward â†’ NULO (erro interno na anÃ¡lise)'
        };
    }
}

function formatN8Number(value, digits = 2) {
    const num = Number(value);
    if (!Number.isFinite(num)) return 'n/a';
    return num.toFixed(digits);
}

function createN8ConfigId(index) {
    return `N8CFG-${String(index).padStart(4, '0')}`;
}

function describeN8Config(cfg) {
    if (!cfg || !cfg.family) return 'desconhecido';
    const params = cfg.params || {};
    switch (cfg.family) {
        case 'dominance_threshold':
            return `dominance_threshold (thresh=${formatN8Number(params.thresh)}, delta=${formatN8Number(params.delta)})`;
        case 'segmented_dominance':
            return `segmented_dominance (segments=${params.segments ?? 'n/a'}, seg_thresh=${formatN8Number(params.seg_thresh)}, delta=${formatN8Number(params.delta)})`;
        case 'recency_weighted':
            return `recency_weighted (${params.mode || 'linear'}, decay=${formatN8Number(params.decay)}, min_delta=${formatN8Number(params.min_delta)})`;
        case 'momentum_split':
            return `momentum_split (split=${formatN8Number(params.split_ratio)}, delta=${formatN8Number(params.delta)})`;
        case 'markov_chain':
            return `markov_chain (order=${params.order ?? 'n/a'}, prob=${formatN8Number(params.prob_thresh)}, support=${params.min_support ?? 'n/a'})`;
        case 'pattern_follow':
            return `pattern_follow (length=${params.length ?? 'n/a'}, next=${formatN8Number(params.next_threshold)}, min_occ=${params.min_occurrences ?? 'n/a'})`;
        case 'streak_bias':
            return `streak_bias (${params.mode || 'continue'}, min_run=${params.min_run ?? 'n/a'}, tolerance=${formatN8Number(params.tolerance)})`;
        case 'entropy_shift':
            return `entropy_shift (delta=${formatN8Number(params.delta)}, variance=${formatN8Number(params.variance)})`;
        case 'lagged_correlation':
            return `lagged_correlation (lag=${params.lag ?? 'n/a'}, bias=${formatN8Number(params.bias_thresh)}, support=${params.min_support ?? 'n/a'})`;
        case 'compound_vote':
            return `compound_vote (parts=${Array.isArray(params.parts) ? params.parts.length : 0}, min_hits=${params.min_hits ?? 'n/a'})`;
        default:
            return `${cfg.family}`;
    }
}

function encodeN8ConfigVector(cfg) {
    const vector = [];
    if (!cfg || !cfg.family) return [0, 0, 0, 0, 0, 0, 0, 0];
    const familyIndex = Math.max(0, N8_FAMILY_LIST.indexOf(cfg.family));
    vector.push(familyIndex / Math.max(1, N8_FAMILY_LIST.length - 1));
    const params = cfg.params || {};
    switch (cfg.family) {
        case 'dominance_threshold': {
            const thresh = clamp01(params.thresh ?? 0.6);
            const delta = clamp01(params.delta ?? 0.05);
            vector.push(thresh, delta, 0, 0, 0, 0, 0);
            break;
        }
        case 'segmented_dominance': {
            const segments = Math.max(2, Math.min(10, Number(params.segments) || 4));
            const segThresh = clamp01(params.seg_thresh ?? 0.6);
            const delta = clamp01(params.delta ?? 0.05);
            vector.push(segments / 10, segThresh, delta, 0, 0, 0, 0);
            break;
        }
        case 'recency_weighted': {
            const decay = clamp01(params.decay ?? 0.9);
            const minDelta = clamp01(params.min_delta ?? 0.08);
            const modeHash = hashStringToUnit(String(params.mode || 'linear'));
            vector.push(decay, minDelta, modeHash, 0, 0, 0, 0);
            break;
        }
        case 'momentum_split': {
            const split = clamp01(params.split_ratio ?? 0.45);
            const delta = clamp01(params.delta ?? 0.1);
            vector.push(split, delta, 0, 0, 0, 0, 0);
            break;
        }
        case 'markov_chain': {
            const order = Math.max(1, Math.min(4, Number(params.order) || 1));
            const prob = clamp01(params.prob_thresh ?? 0.6);
            const support = Math.max(2, Math.min(20, Number(params.min_support) || (order + 2)));
            vector.push(order / 4, prob, support / 20, 0, 0, 0, 0);
            break;
        }
        case 'pattern_follow': {
            const length = Math.max(2, Math.min(6, Number(params.length) || 3));
            const next = clamp01(params.next_threshold ?? 0.65);
            const minOcc = Math.max(1, Math.min(12, Number(params.min_occurrences) || 2));
            vector.push(length / 6, next, minOcc / 12, 0, 0, 0, 0);
            break;
        }
        case 'streak_bias': {
            const modeHash = hashStringToUnit(String(params.mode || 'continue'));
            const minRun = Math.max(1, Math.min(12, Number(params.min_run) || 3));
            const tolerance = clamp01(params.tolerance ?? 0.25);
            vector.push(modeHash, minRun / 12, tolerance, 0, 0, 0, 0);
            break;
        }
        case 'entropy_shift': {
            const delta = clamp01(params.delta ?? 0.15);
            const variance = clamp01(params.variance ?? 0.08);
            vector.push(delta, variance, 0, 0, 0, 0, 0);
            break;
        }
        case 'lagged_correlation': {
            const lag = Math.max(1, Math.min(10, Number(params.lag) || 2));
            const bias = clamp01(params.bias_thresh ?? 0.12);
            const support = Math.max(2, Math.min(30, Number(params.min_support) || (lag + 2)));
            vector.push(lag / 10, bias, support / 30, 0, 0, 0, 0);
            break;
        }
        case 'compound_vote': {
            const parts = Array.isArray(params.parts) ? params.parts.length : 0;
            const minHits = Math.max(1, Math.min(parts, Number(params.min_hits) || Math.ceil(parts * 0.6)));
            vector.push(parts / 6, minHits / Math.max(1, parts), 0, 0, 0, 0, 0);
            break;
        }
        default:
            vector.push(0, 0, 0, 0, 0, 0, 0);
    }
    while (vector.length < 8) {
        vector.push(0);
    }
    return vector;
}

function n8ConfigDistance(vectorA, vectorB) {
    const len = Math.min(vectorA.length, vectorB.length);
    let sum = 0;
    for (let i = 0; i < len; i++) {
        const diff = vectorA[i] - vectorB[i];
        sum += diff * diff;
    }
    return Math.sqrt(sum);
}

function maybePersistN8ConfigLibrary(configs) {
    try {
        if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
            chrome.storage.local.set({ [N8_CONFIG_LIBRARY_KEY]: configs });
        }
    } catch (error) {
        console.debug('âš ï¸ [N8] Falha ao persistir biblioteca de configs:', error);
    }
}

function buildN8BaseConfigs() {
    const base = [];
    const add = (family, params) => base.push({ family, params });

    [0.56, 0.6, 0.64, 0.68].forEach(thresh => {
        [0.03, 0.05, 0.08].forEach(delta => add('dominance_threshold', { thresh, delta }));
    });

    [3, 4, 5, 6].forEach(segments => {
        [0.58, 0.62, 0.68].forEach(seg_thresh => {
            [0.03, 0.05].forEach(delta => add('segmented_dominance', { segments, seg_thresh, delta }));
        });
    });

    ['linear', 'exp'].forEach(mode => {
        [0.84, 0.88, 0.92, 0.96].forEach(decay => {
            [0.06, 0.1, 0.15].forEach(min_delta => add('recency_weighted', { mode, decay, min_delta }));
        });
    });

    [0.35, 0.4, 0.45, 0.5].forEach(split_ratio => {
        [0.08, 0.12, 0.16].forEach(delta => add('momentum_split', { split_ratio, delta }));
    });

    [1, 2, 3].forEach(order => {
        [0.55, 0.6, 0.66].forEach(prob_thresh => {
            [order + 1, order + 3, order + 5].forEach(min_support =>
                add('markov_chain', { order, prob_thresh, min_support })
            );
        });
    });

    [2, 3, 4].forEach(length => {
        [0.6, 0.68, 0.75].forEach(next_threshold => {
            [2, 3, 4].forEach(min_occurrences =>
                add('pattern_follow', { length, next_threshold, min_occurrences })
            );
        });
    });

    ['continue', 'revert'].forEach(mode => {
        [2, 3, 4].forEach(min_run => {
            [0.2, 0.3, 0.4].forEach(tolerance =>
                add('streak_bias', { mode, min_run, tolerance })
            );
        });
    });

    [0.12, 0.18, 0.24].forEach(delta => {
        [0.06, 0.1, 0.14].forEach(variance =>
            add('entropy_shift', { delta, variance })
        );
    });

    [2, 3, 4, 5].forEach(lag => {
        [0.1, 0.14, 0.18].forEach(bias_thresh => {
            [lag + 1, lag + 3, lag + 5].forEach(min_support =>
                add('lagged_correlation', { lag, bias_thresh, min_support })
            );
        });
    });

    // Compound combinations
    const compoundSeeds = [
        {
            parts: [
                { family: 'dominance_threshold', params: { thresh: 0.6, delta: 0.05 } },
                { family: 'recency_weighted', params: { mode: 'exp', decay: 0.9, min_delta: 0.08 } },
                { family: 'momentum_split', params: { split_ratio: 0.4, delta: 0.12 } }
            ],
            min_hits: 2
        },
        {
            parts: [
                { family: 'markov_chain', params: { order: 2, prob_thresh: 0.6, min_support: 6 } },
                { family: 'pattern_follow', params: { length: 3, next_threshold: 0.68, min_occurrences: 3 } }
            ],
            min_hits: 2
        },
        {
            parts: [
                { family: 'streak_bias', params: { mode: 'continue', min_run: 3, tolerance: 0.25 } },
                { family: 'segmented_dominance', params: { segments: 4, seg_thresh: 0.62, delta: 0.05 } },
                { family: 'lagged_correlation', params: { lag: 3, bias_thresh: 0.14, min_support: 6 } }
            ],
            min_hits: 2
        }
    ];
    compoundSeeds.forEach(seed => add('compound_vote', seed));

    return base;
}

function sampleRandomN8Config(rng, family) {
    const pick = (arr) => arr[Math.floor(rng() * arr.length)];
    switch (family) {
        case 'dominance_threshold':
            return {
                family,
                params: {
                    thresh: 0.53 + rng() * 0.2,
                    delta: 0.02 + rng() * 0.08
                }
            };
        case 'segmented_dominance':
            return {
                family,
                params: {
                    segments: Math.floor(3 + rng() * 4),
                    seg_thresh: 0.55 + rng() * 0.25,
                    delta: 0.02 + rng() * 0.08
                }
            };
        case 'recency_weighted':
            return {
                family,
                params: {
                    mode: rng() < 0.5 ? 'linear' : 'exp',
                    decay: 0.82 + rng() * 0.16,
                    min_delta: 0.05 + rng() * 0.12
                }
            };
        case 'momentum_split':
            return {
                family,
                params: {
                    split_ratio: 0.32 + rng() * 0.26,
                    delta: 0.06 + rng() * 0.14
                }
            };
        case 'markov_chain':
            return {
                family,
                params: {
                    order: Math.floor(1 + rng() * 3),
                    prob_thresh: 0.52 + rng() * 0.25,
                    min_support: Math.floor(3 + rng() * 8)
                }
            };
        case 'pattern_follow':
            return {
                family,
                params: {
                    length: Math.floor(2 + rng() * 4),
                    next_threshold: 0.58 + rng() * 0.25,
                    min_occurrences: Math.floor(2 + rng() * 4)
                }
            };
        case 'streak_bias':
            return {
                family,
                params: {
                    mode: rng() < 0.5 ? 'continue' : 'revert',
                    min_run: Math.floor(2 + rng() * 4),
                    tolerance: 0.15 + rng() * 0.35
                }
            };
        case 'entropy_shift':
            return {
                family,
                params: {
                    delta: 0.1 + rng() * 0.2,
                    variance: 0.05 + rng() * 0.12
                }
            };
        case 'lagged_correlation':
            return {
                family,
                params: {
                    lag: Math.floor(2 + rng() * 4),
                    bias_thresh: 0.08 + rng() * 0.18,
                    min_support: Math.floor(3 + rng() * 10)
                }
            };
        case 'compound_vote': {
            const partFamilies = ['dominance_threshold', 'recency_weighted', 'momentum_split', 'markov_chain', 'pattern_follow', 'streak_bias'];
            const partsCount = Math.floor(2 + rng() * 2);
            const parts = [];
            for (let i = 0; i < partsCount; i++) {
                const fam = pick(partFamilies);
                parts.push(sampleRandomN8Config(rng, fam));
            }
            const min_hits = Math.max(1, Math.min(parts.length, Math.floor(1 + rng() * parts.length)));
            return { family, params: { parts, min_hits } };
        }
        default:
            return null;
    }
}

function tryAddN8Config(candidate, accepted, acceptedVectors, diversityThreshold) {
    if (!candidate || !candidate.family) return false;
    const vector = encodeN8ConfigVector(candidate);
    for (const existing of acceptedVectors) {
        if (n8ConfigDistance(vector, existing) < diversityThreshold) {
            return false;
        }
    }
    accepted.push(candidate);
    acceptedVectors.push(vector);
    return true;
}

function generateN8Configs(count, seed = N8_DEFAULTS.seed) {
    if (n8ConfigLibraryCache && n8ConfigLibraryCache.length >= count && n8ConfigLibrarySeed === seed) {
        return n8ConfigLibraryCache.slice(0, count);
    }

    const rng = createSeededRandomGenerator(seed);
    const baseConfigs = buildN8BaseConfigs();
    const accepted = [];
    const acceptedVectors = [];
    const familyCounts = {};
    let diversityThreshold = N8_DIVERSITY_MIN_DISTANCE_BASE;

    const pushWithDiversity = (cfg, allowRelax = false) => {
        if (!cfg) return false;
        const success = tryAddN8Config(cfg, accepted, acceptedVectors, diversityThreshold);
        if (success) {
            familyCounts[cfg.family] = (familyCounts[cfg.family] || 0) + 1;
        } else if (allowRelax && diversityThreshold > 0.06) {
            const relaxed = tryAddN8Config(cfg, accepted, acceptedVectors, diversityThreshold * 0.9);
            if (relaxed) {
                familyCounts[cfg.family] = (familyCounts[cfg.family] || 0) + 1;
            }
            return relaxed;
        }
        return success;
    };

    baseConfigs.forEach(cfg => {
        if (accepted.length < count) {
            pushWithDiversity(cfg, true);
        }
    });

    let attempts = 0;
    const maxAttempts = count * 60;
    while (accepted.length < count && attempts < maxAttempts) {
        const family = N8_FAMILY_LIST[Math.floor(rng() * N8_FAMILY_LIST.length)];
        const candidate = sampleRandomN8Config(rng, family);
        if (!pushWithDiversity(candidate, true) && attempts % N8_FAMILY_LIST.length === 0 && diversityThreshold > 0.06) {
            diversityThreshold *= 0.97;
        }
        attempts++;
    }

    N8_FAMILY_LIST.forEach(family => {
        while ((familyCounts[family] || 0) < N8_FAMILY_MIN_PER_TYPE && accepted.length < count) {
            const candidate = sampleRandomN8Config(rng, family);
            if (!pushWithDiversity(candidate, true)) {
                break;
            }
        }
    });

    diversityThreshold = Math.max(0.04, diversityThreshold);
    while (accepted.length < count) {
        const candidate = sampleRandomN8Config(rng, N8_FAMILY_LIST[Math.floor(rng() * N8_FAMILY_LIST.length)]);
        if (!candidate) continue;
        if (!pushWithDiversity(candidate, true)) {
            if (diversityThreshold > 0.04) {
                diversityThreshold *= 0.95;
            } else {
                accepted.push(candidate);
                acceptedVectors.push(encodeN8ConfigVector(candidate));
                familyCounts[candidate.family] = (familyCounts[candidate.family] || 0) + 1;
            }
        }
    }

    const trimmed = accepted.slice(0, count).map((cfg, index) => ({
        id: createN8ConfigId(index),
        family: cfg.family,
        params: cfg.params || {},
        description: describeN8Config(cfg)
    }));

    n8ConfigLibraryCache = trimmed;
    n8ConfigLibrarySeed = seed;
    maybePersistN8ConfigLibrary(trimmed);

    return trimmed;
}

function buildN8WindowContext(windows) {
    return {
        stats: windows.map(entry => computeWindowStats(entry.window)),
        clean: windows.map(entry => entry.window.filter(char => char === 'R' || char === 'B')),
        windows
    };
}

function applyN8Config(cfg, windowChars, idxWindow, windows, context, depth = 0) {
    if (!cfg || !cfg.family || !Array.isArray(windowChars) || windowChars.length === 0) {
        return { prediction: null, confidence: 0 };
    }
    if (depth > 3) {
        return { prediction: null, confidence: 0 };
    }

    const params = cfg.params || {};
    const stats = context.stats[idxWindow] || computeWindowStats(windowChars);
    const clean = context.clean[idxWindow] || windowChars.filter(char => char === 'R' || char === 'B');

    switch (cfg.family) {
        case 'dominance_threshold': {
            const thresh = clamp01(params.thresh ?? 0.6);
            const delta = clamp01(params.delta ?? 0.05);
            const pR = stats.pR || 0;
            const pB = stats.pB || 0;
            if (pR >= thresh && (pR - pB) >= delta) {
                return { prediction: 'R', confidence: clamp01(pR) };
            }
            if (pB >= thresh && (pB - pR) >= delta) {
                return { prediction: 'B', confidence: clamp01(pB) };
            }
            const diff = Math.abs(pR - pB);
            if (diff >= delta * 0.7 && (pR + pB) > 0) {
                const color = pR >= pB ? 'R' : 'B';
                return { prediction: color, confidence: clamp01(Math.max(pR, pB)) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'segmented_dominance': {
            const segments = Math.max(2, Math.min(12, Number(params.segments) || 4));
            const segThresh = clamp01(params.seg_thresh ?? 0.6);
            const delta = clamp01(params.delta ?? 0.05);
            const len = windowChars.length;
            const segSize = Math.max(1, Math.floor(len / segments));
            let bestColor = null;
            let bestScore = 0;
            for (let s = 0; s < segments; s++) {
                const start = s * segSize;
                const end = s === segments - 1 ? len : Math.min(len, start + segSize);
                if (start >= len) break;
                let reds = 0;
                let blacks = 0;
                for (let i = start; i < end; i++) {
                    const c = windowChars[i];
                    if (c === 'R') reds++;
                    else if (c === 'B') blacks++;
                }
                const total = reds + blacks;
                if (total === 0) continue;
                const frac = Math.max(reds, blacks) / total;
                if (frac >= segThresh && frac > bestScore) {
                    bestScore = frac;
                    bestColor = reds >= blacks ? 'R' : 'B';
                }
            }
            if (bestColor) {
                return { prediction: bestColor, confidence: clamp01(bestScore + delta) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'recency_weighted': {
            const mode = params.mode === 'linear' ? 'linear' : 'exp';
            const decay = clamp01(params.decay ?? 0.9);
            const minDelta = clamp01(params.min_delta ?? 0.08);
            if (clean.length === 0) return { prediction: null, confidence: 0 };
            let score = 0;
            let totalWeight = 0;
            if (mode === 'exp') {
                let weight = 1;
                for (let i = clean.length - 1; i >= 0; i--) {
                    const color = clean[i];
                    if (color !== 'R' && color !== 'B') continue;
                    const sign = color === 'R' ? 1 : -1;
                    score += sign * weight;
                    totalWeight += Math.abs(weight);
                    weight *= decay;
                }
            } else {
                for (let i = 0; i < clean.length; i++) {
                    const color = clean[i];
                    if (color !== 'R' && color !== 'B') continue;
                    const weight = i + 1;
                    const sign = color === 'R' ? 1 : -1;
                    score += sign * weight;
                    totalWeight += weight;
                }
            }
            if (totalWeight === 0) return { prediction: null, confidence: 0 };
            const normalized = score / totalWeight;
            if (Math.abs(normalized) < minDelta) {
                return { prediction: null, confidence: 0 };
            }
            const color = normalized >= 0 ? 'R' : 'B';
            return { prediction: color, confidence: clamp01(Math.abs(normalized)) };
        }
        case 'momentum_split': {
            const splitRatio = clamp01(params.split_ratio ?? 0.45);
            const delta = clamp01(params.delta ?? 0.1);
            if (clean.length < 4) return { prediction: null, confidence: 0 };
            const splitIndex = Math.max(1, Math.min(clean.length - 1, Math.floor(clean.length * splitRatio)));
            const prev = clean.slice(0, splitIndex);
            const recent = clean.slice(splitIndex);
            const countStats = (arr) => {
                let r = 0;
                let b = 0;
                arr.forEach(c => {
                    if (c === 'R') r++;
                    else if (c === 'B') b++;
                });
                const total = r + b;
                return {
                    pR: total > 0 ? r / total : 0,
                    pB: total > 0 ? b / total : 0
                };
            };
            const prevStats = countStats(prev);
            const recentStats = countStats(recent);
            const diffR = recentStats.pR - prevStats.pR;
            const diffB = recentStats.pB - prevStats.pB;
            if (Math.abs(diffR) < delta && Math.abs(diffB) < delta) {
                return { prediction: null, confidence: 0 };
            }
            if (diffR > diffB && diffR >= delta) {
                return { prediction: 'R', confidence: clamp01(diffR) };
            }
            if (diffB > diffR && diffB >= delta) {
                return { prediction: 'B', confidence: clamp01(diffB) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'markov_chain': {
            const order = Math.max(1, Math.min(4, Number(params.order) || 1));
            const probThresh = clamp01(params.prob_thresh ?? 0.6);
            const minSupport = Math.max(order + 1, Number(params.min_support) || (order + 2));
            if (clean.length <= order) return { prediction: null, confidence: 0 };
            const transitions = {};
            for (let i = 0; i + order < clean.length; i++) {
                const key = clean.slice(i, i + order).join('');
                const next = clean[i + order];
                if (next !== 'R' && next !== 'B') continue;
                if (!transitions[key]) transitions[key] = { R: 0, B: 0 };
                transitions[key][next] += 1;
            }
            const lastKey = clean.slice(-order).join('');
            const statsKey = transitions[lastKey];
            if (!statsKey) return { prediction: null, confidence: 0 };
            const total = statsKey.R + statsKey.B;
            if (total < minSupport) return { prediction: null, confidence: 0 };
            const pR = statsKey.R / total;
            const pB = statsKey.B / total;
            if (pR >= probThresh && pR > pB) {
                return { prediction: 'R', confidence: clamp01(pR) };
            }
            if (pB >= probThresh && pB > pR) {
                return { prediction: 'B', confidence: clamp01(pB) };
            }
            const diff = Math.abs(pR - pB);
            if (diff >= 0.15) {
                const color = pR >= pB ? 'R' : 'B';
                return { prediction: color, confidence: clamp01(Math.max(pR, pB)) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'pattern_follow': {
            const length = Math.max(2, Math.min(6, Number(params.length) || 3));
            const nextThreshold = clamp01(params.next_threshold ?? 0.65);
            const minOccurrences = Math.max(1, Number(params.min_occurrences) || 2);
            if (clean.length <= length) return { prediction: null, confidence: 0 };
            const pattern = clean.slice(clean.length - length);
            let followersR = 0;
            let followersB = 0;
            let occurrences = 0;
            const arraysEqual = (a, b) => a.length === b.length && a.every((val, idx) => val === b[idx]);
            for (let i = 0; i + length < clean.length; i++) {
                const slice = clean.slice(i, i + length);
                if (arraysEqual(slice, pattern)) {
                    occurrences += 1;
                    const follower = clean[i + length];
                    if (follower === 'R') followersR += 1;
                    if (follower === 'B') followersB += 1;
                }
            }
            if (occurrences < minOccurrences) return { prediction: null, confidence: 0 };
            const totalFollowers = followersR + followersB;
            if (totalFollowers === 0) return { prediction: null, confidence: 0 };
            const pR = followersR / totalFollowers;
            const pB = followersB / totalFollowers;
            if (pR >= nextThreshold && pR > pB) {
                return { prediction: 'R', confidence: clamp01(pR) };
            }
            if (pB >= nextThreshold && pB > pR) {
                return { prediction: 'B', confidence: clamp01(pB) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'streak_bias': {
            if (clean.length === 0) return { prediction: null, confidence: 0 };
            const mode = params.mode === 'revert' ? 'revert' : 'continue';
            const minRun = Math.max(1, Number(params.min_run) || 3);
            const tolerance = clamp01(params.tolerance ?? 0.25);
            const lastColor = clean[clean.length - 1];
            let currentRun = 1;
            for (let i = clean.length - 2; i >= 0; i--) {
                if (clean[i] === lastColor) currentRun += 1;
                else break;
            }
            let runSumR = 0;
            let runCountR = 0;
            let runSumB = 0;
            let runCountB = 0;
            let currentColor = clean[0];
            let runLength = 1;
            for (let i = 1; i < clean.length; i++) {
                if (clean[i] === currentColor) {
                    runLength += 1;
                } else {
                    if (currentColor === 'R') {
                        runSumR += runLength;
                        runCountR += 1;
                    } else if (currentColor === 'B') {
                        runSumB += runLength;
                        runCountB += 1;
                    }
                    currentColor = clean[i];
                    runLength = 1;
                }
            }
            if (currentColor === 'R') {
                runSumR += runLength;
                runCountR += 1;
            } else if (currentColor === 'B') {
                runSumB += runLength;
                runCountB += 1;
            }
            const avgR = runCountR > 0 ? runSumR / runCountR : 1;
            const avgB = runCountB > 0 ? runSumB / runCountB : 1;
            const avgForColor = lastColor === 'R' ? avgR : avgB;
            if (mode === 'continue') {
                if (currentRun >= minRun) {
                    const confidence = clamp01((currentRun / Math.max(1, avgForColor)) + tolerance / 2);
                    return { prediction: lastColor, confidence };
                }
            } else {
                const diff = currentRun - avgForColor;
                if (diff >= Math.max(1, avgForColor * tolerance)) {
                    const opposite = lastColor === 'R' ? 'B' : 'R';
                    const confidence = clamp01(diff / Math.max(1, avgForColor + diff));
                    return { prediction: opposite, confidence };
                }
            }
            return { prediction: null, confidence: 0 };
        }
        case 'entropy_shift': {
            const delta = clamp01(params.delta ?? 0.15);
            const variance = clamp01(params.variance ?? 0.08);
            const entropyDiff = (stats.entropyFirstHalf || 0) - (stats.entropySecondHalf || 0);
            if (Math.abs(entropyDiff) < delta) {
                return { prediction: null, confidence: 0 };
            }
            const bias = (stats.pR || 0) - (stats.pB || 0);
            const color = bias >= 0 ? 'R' : 'B';
            const confidence = clamp01(Math.abs(entropyDiff) + Math.abs(bias) - variance);
            if (confidence <= 0) return { prediction: null, confidence: 0 };
            return { prediction: color, confidence };
        }
        case 'lagged_correlation': {
            const lag = Math.max(1, Math.min(6, Number(params.lag) || 2));
            const biasThresh = clamp01(params.bias_thresh ?? 0.12);
            const minSupport = Math.max(lag + 1, Number(params.min_support) || (lag + 2));
            if (clean.length <= lag) return { prediction: null, confidence: 0 };
            const transitions = {};
            for (let i = lag; i < clean.length; i++) {
                const key = clean.slice(i - lag, i).join('');
                const next = clean[i];
                if (next !== 'R' && next !== 'B') continue;
                if (!transitions[key]) transitions[key] = { R: 0, B: 0 };
                transitions[key][next] += 1;
            }
            const lastKey = clean.slice(-lag).join('');
            const statsKey = transitions[lastKey];
            if (!statsKey) return { prediction: null, confidence: 0 };
            const total = statsKey.R + statsKey.B;
            if (total < minSupport) return { prediction: null, confidence: 0 };
            const bias = Math.abs(statsKey.R - statsKey.B) / total;
            if (bias < biasThresh) return { prediction: null, confidence: 0 };
            const color = statsKey.R >= statsKey.B ? 'R' : 'B';
            return { prediction: color, confidence: clamp01(bias) };
        }
        case 'compound_vote': {
            const parts = Array.isArray(params.parts) ? params.parts : [];
            if (parts.length === 0) return { prediction: null, confidence: 0 };
            const minHits = Math.max(1, Math.min(parts.length, Number(params.min_hits) || Math.ceil(parts.length * 0.6)));
            const results = parts.map(part => applyN8Config(part, windowChars, idxWindow, windows, context, depth + 1));
            const votes = results.filter(res => res && (res.prediction === 'R' || res.prediction === 'B'));
            if (votes.length < minHits) return { prediction: null, confidence: 0 };
            const count = votes.reduce((acc, item) => {
                if (item.prediction === 'R') acc.R += 1;
                else if (item.prediction === 'B') acc.B += 1;
                return acc;
            }, { R: 0, B: 0 });
            const color = count.R > count.B ? 'R' : count.B > count.R ? 'B' : null;
            if (!color) return { prediction: null, confidence: 0 };
            const supporters = votes.filter(item => item.prediction === color);
            if (supporters.length < minHits) return { prediction: null, confidence: 0 };
            const confidence = clamp01(supporters.reduce((acc, item) => acc + clamp01(item.confidence ?? 0), 0) / supporters.length);
            return { prediction: color, confidence };
        }
        default:
            return { prediction: null, confidence: 0 };
    }
}

function computeN8RecentAccuracy(confList) {
    if (!Array.isArray(confList) || confList.length === 0) return 0;
    const half = Math.max(1, Math.floor(confList.length / 2));
    const recent = confList.slice(-half);
    let hits = 0;
    let total = 0;
    recent.forEach(entry => {
        if (!entry || !entry.predictedColor) return;
        total += 1;
        if (entry.predictedColor === entry.targetColor) {
            hits += 1;
        }
    });
    return total > 0 ? hits / total : 0;
}

function evaluateN8Config(windows, cfg, context, options = {}) {
    const { collectLogs = false } = options;
    let TP = 0;
    let FP = 0;
    let FN = 0;
    let nPreds = 0;
    let totalTargets = 0;
    const confList = [];
    const perWindowLog = collectLogs ? [] : null;

    windows.forEach((entry, idx) => {
        const target = entry.target === 'R' || entry.target === 'B' ? entry.target : null;
        if (!target) return;
        totalTargets += 1;
        const result = applyN8Config(cfg, entry.window, idx, windows, context);
        const confidence = clamp01(result.confidence ?? 0);
        const predicted = result.prediction === 'R' || result.prediction === 'B' ? result.prediction : null;

        confList.push({
            confidence,
            predictedColor: predicted,
            targetColor: target,
            isHit: predicted != null && predicted === target
        });

        if (predicted) {
            nPreds += 1;
            if (predicted === target) {
                TP += 1;
            } else {
                FP += 1;
            }
        } else {
            FN += 1;
        }

        if (perWindowLog) {
            perWindowLog.push({
                window_index: entry.index,
                start_idx: entry.start,
                prediction: predicted || '-',
                confidence: Number(confidence.toFixed(4)),
                target,
                result: predicted === target ? 'hit' : predicted ? 'miss' : 'null'
            });
        }
    });

    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    const coverage = windows.length > 0 ? nPreds / windows.length : 0;
    const accuracy = totalTargets > 0 ? TP / totalTargets : 0;
    const accRecent = computeN8RecentAccuracy(confList);

    return {
        cfg,
        metrics: {
            TP,
            FP,
            FN,
            n_preds: nPreds,
            precision,
            recall,
            f1,
            coverage,
            accuracy,
            acc_recent: accRecent,
            n_windows: windows.length,
            targets: totalTargets
        },
        confList,
        perWindowLog
    };
}

function calculateN8ThresholdMetrics(confList, threshold) {
    let TP = 0;
    let FP = 0;
    let FN = 0;
    let considered = 0;
    confList.forEach(entry => {
        if (!entry || !entry.targetColor) return;
        considered += 1;
        const passes = entry.predictedColor && entry.confidence >= threshold;
        if (passes && entry.predictedColor === entry.targetColor) {
            TP += 1;
        } else if (passes && entry.predictedColor !== entry.targetColor) {
            FP += 1;
        } else {
            FN += 1;
        }
    });
    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    const coverage = considered > 0 ? (TP + FP) / considered : 0;
    return { TP, FP, FN, precision, recall, f1, coverage };
}

function runN8Detector(history, options = {}) {
    const runTimestamp = Date.now();
    const runId = `N8-${runTimestamp}-${Math.floor(Math.random() * 1e6).toString(16)}`;
    try {
        const settings = {
            historySize: Number(options.historySize) > 0 ? Math.floor(options.historySize) : N8_DEFAULTS.historySize,
            windowSize: Number(options.windowSize) > 0 ? Math.floor(options.windowSize) : N8_DEFAULTS.windowSize,
            analysesToRun: Number(options.analysesToRun) > 0 ? Math.floor(options.analysesToRun) : N8_DEFAULTS.analysesToRun,
            minWindowsRequired: Number(options.minWindows) > 0 ? Math.floor(options.minWindows) : N8_DEFAULTS.minWindowsRequired,
            precisionMin: typeof options.precisionMin === 'number' ? clamp01(options.precisionMin) : N8_DEFAULTS.precisionMin,
            confidenceGrid: Array.isArray(options.confidenceGrid) && options.confidenceGrid.length > 0
                ? options.confidenceGrid.map(Number).filter(v => Number.isFinite(v) && v > 0 && v < 1).sort((a, b) => a - b)
                : [...N8_DEFAULTS.confidenceGrid],
            holdoutEnabled: options.holdoutEnabled !== undefined ? !!options.holdoutEnabled : N8_DEFAULTS.holdoutEnabled,
            holdoutTolerance: typeof options.holdoutTolerance === 'number'
                ? clamp01(options.holdoutTolerance)
                : N8_DEFAULTS.holdoutTolerance,
            seed: Number.isFinite(Number(options.seed)) ? Number(options.seed) : N8_DEFAULTS.seed,
            confMinLive: typeof options.confMinLive === 'number'
                ? clamp01(options.confMinLive)
                : N8_DEFAULTS.confMinLive
        };

        // âœ… Determinismo + ordem correta + dedup:
        // o histÃ³rico pode vir com duplicados e fora de ordem (principalmente em cache).
        const desiredHistory = Math.max(settings.historySize, settings.windowSize * 3);
        const stableWindow = getStableChronologicalHistoryWindow({
            limit: Math.min(desiredHistory, Array.isArray(history) ? history.length : 0),
            sourceHistory: Array.isArray(history) ? history : []
        });
        const chronologicalHistory = stableWindow.chronological; // antigo -> recente
        const normalizedHistory = normalizeN0History(chronologicalHistory);
        const trimmedHistory = normalizedHistory.slice(-desiredHistory);

        if (trimmedHistory.length < settings.windowSize + 1) {
            return {
                enabled: false,
                summaryText: `N8 - Walk-forward â†’ NULO (histÃ³rico insuficiente: ${trimmedHistory.length}/${settings.windowSize + 1})`,
                code: 'insufficient_history',
                run_summary: {
                    run_id: runId,
                    timestamp: runTimestamp,
                    requested_history_size: settings.historySize,
                    used_history_size: stableWindow.meta.usedHistoryLimit,
                    available_history: stableWindow.meta.availableHistory,
                    unique_history: stableWindow.meta.uniqueCount
                }
            };
        }

        const rawWindows = buildN0Windows(trimmedHistory, settings.windowSize);
        const windows = rawWindows.filter(entry => entry.target === 'R' || entry.target === 'B');
        if (windows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                summaryText: `N8 - Walk-forward â†’ NULO (janelas Ãºteis ${windows.length}, mÃ­nimo ${settings.minWindowsRequired})`,
                code: 'insufficient_windows',
                run_summary: {
                    run_id: runId,
                    timestamp: runTimestamp,
                    requested_history_size: settings.historySize,
                    used_history_size: stableWindow.meta.usedHistoryLimit,
                    available_history: stableWindow.meta.availableHistory,
                    unique_history: stableWindow.meta.uniqueCount
                }
            };
        }

        const holdoutPossible = settings.holdoutEnabled && windows.length >= settings.minWindowsRequired * 2;
        const trainingWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 0) : windows;
        const validationWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 1) : [];

        if (trainingWindows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                summaryText: `N8 - Walk-forward â†’ NULO (treino com ${trainingWindows.length} janelas)`,
                code: 'insufficient_training',
                run_summary: {
                    run_id: runId,
                    timestamp: runTimestamp,
                    requested_history_size: settings.historySize,
                    used_history_size: stableWindow.meta.usedHistoryLimit,
                    available_history: stableWindow.meta.availableHistory,
                    unique_history: stableWindow.meta.uniqueCount
                }
            };
        }

        const candidateConfigs = generateN8Configs(settings.analysesToRun, settings.seed);
        console.log(`%c   â¤ Biblioteca N8: ${candidateConfigs.length} configs avaliadas`, 'color: #33CCFF; font-weight: bold;');
        const trainingContext = buildN8WindowContext(trainingWindows);
        const evaluations = [];
        candidateConfigs.forEach(cfg => {
            const evaluation = evaluateN8Config(trainingWindows, cfg, trainingContext);
            if (evaluation.metrics.n_preds >= settings.minWindowsRequired) {
                evaluations.push(evaluation);
            }
        });

        if (evaluations.length === 0) {
            return {
                enabled: false,
                summaryText: 'N8 - Walk-forward â†’ NULO (nenhuma configuraÃ§Ã£o elegÃ­vel)',
                code: 'no_valid_configs',
                tested_configs: candidateConfigs.length,
                run_summary: { run_id: runId, timestamp: runTimestamp }
            };
        }

        evaluations.sort((a, b) => {
            const mA = a.metrics;
            const mB = b.metrics;
            if (mB.f1 !== mA.f1) return mB.f1 - mA.f1;
            if (mB.recall !== mA.recall) return mB.recall - mA.recall;
            if (mB.precision !== mA.precision) return mB.precision - mA.precision;
            if ((mB.acc_recent || 0) !== (mA.acc_recent || 0)) return (mB.acc_recent || 0) - (mA.acc_recent || 0);
            if (mB.coverage !== mA.coverage) return mB.coverage - mA.coverage;
            return 0;
        });

        const TOP_K = Math.min(20, evaluations.length);
        const topEvaluations = evaluations.slice(0, TOP_K);
        const bestEvaluation = topEvaluations[0];
        const bestDetailed = evaluateN8Config(trainingWindows, bestEvaluation.cfg, trainingContext, { collectLogs: true });
        const bestMetrics = bestDetailed.metrics;
        const bestConfList = bestDetailed.confList;
        const perWindowLog = bestDetailed.perWindowLog || [];

        const grid = settings.confidenceGrid.length > 0 ? settings.confidenceGrid : [...N8_DEFAULTS.confidenceGrid];
        let chosenThreshold = null;
        let chosenMetrics = null;
        grid.forEach(candidate => {
            const metrics = calculateN8ThresholdMetrics(bestConfList, candidate);
            if (metrics.precision >= settings.precisionMin) {
                if (!chosenMetrics || metrics.f1 > chosenMetrics.f1) {
                    chosenMetrics = { ...metrics, threshold: candidate };
                    chosenThreshold = candidate;
                }
            }
        });

        if (!chosenMetrics) {
            const confValues = bestConfList
                .map(entry => entry.confidence)
                .filter(Number.isFinite)
                .sort((a, b) => a - b);
            const percentileIndex = Math.max(0, Math.min(confValues.length - 1, Math.floor(confValues.length * 0.85)));
            const fallbackThreshold = confValues.length > 0 ? confValues[percentileIndex] : settings.confMinLive;
            chosenThreshold = clamp01(Math.max(settings.confMinLive, fallbackThreshold));
            chosenMetrics = { ...calculateN8ThresholdMetrics(bestConfList, chosenThreshold), threshold: chosenThreshold, fallback: true };
        }

        const holdoutInfo = {
            enabled: holdoutPossible,
            passed: true,
            reason: null,
            training: chosenMetrics,
            validation: null
        };
        const warnings = [];

        if (holdoutPossible && validationWindows.length >= settings.minWindowsRequired) {
            const validationContext = buildN8WindowContext(validationWindows);
            const validationEval = evaluateN8Config(validationWindows, bestDetailed.cfg, validationContext);
            const validationMetrics = calculateN8ThresholdMetrics(validationEval.confList, chosenThreshold);
            holdoutInfo.validation = { ...validationMetrics, threshold: chosenThreshold };
            const trainingF1 = chosenMetrics.f1 ?? 0;
            const validationF1 = validationMetrics.f1 ?? 0;
            if (validationMetrics.precision < settings.precisionMin) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `PrecisÃ£o da validaÃ§Ã£o abaixo do mÃ­nimo (${(validationMetrics.precision * 100).toFixed(1)}% < ${(settings.precisionMin * 100).toFixed(1)}%)`;
                warnings.push(holdoutInfo.reason);
            } else if (validationF1 < (trainingF1 - settings.holdoutTolerance)) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `F1 caiu de ${(trainingF1 * 100).toFixed(1)}% para ${(validationF1 * 100).toFixed(1)}%`;
                warnings.push(holdoutInfo.reason);
            }
        }

        const liveWindow = trimmedHistory.slice(-settings.windowSize);
        if (liveWindow.length < settings.windowSize) {
            return {
                enabled: false,
                summaryText: 'N8 - Walk-forward â†’ NULO (janela incompleta para previsÃ£o ao vivo)',
                code: 'incomplete_live_window',
                run_summary: {
                    run_id: runId,
                    timestamp: runTimestamp,
                    requested_history_size: settings.historySize,
                    used_history_size: stableWindow.meta.usedHistoryLimit,
                    available_history: stableWindow.meta.availableHistory,
                    unique_history: stableWindow.meta.uniqueCount
                }
            };
        }

        const liveWindows = [{
            window: liveWindow,
            target: null,
            index: windows.length,
            start: Math.max(0, trimmedHistory.length - settings.windowSize),
            targetIndex: trimmedHistory.length
        }];
        const liveContext = buildN8WindowContext(liveWindows);
        const liveResult = applyN8Config(bestDetailed.cfg, liveWindow, 0, liveWindows, liveContext);
        const liveConfidence = clamp01(liveResult.confidence ?? 0);
        const livePrediction = liveResult.prediction === 'R' || liveResult.prediction === 'B' ? liveResult.prediction : null;

        const thresholdGate = Math.max(settings.confMinLive, chosenThreshold ?? settings.confMinLive);
        let finalColor = null;
        if (livePrediction && liveConfidence >= thresholdGate && holdoutInfo.passed) {
            finalColor = livePrediction === 'R' ? 'red' : 'black';
        } else if (!holdoutInfo.passed) {
            warnings.push('PrevisÃ£o ao vivo suprimida devido Ã  reprovaÃ§Ã£o no holdout.');
        } else if (livePrediction && liveConfidence < thresholdGate) {
            warnings.push(`ConfianÃ§a ao vivo ${Math.round(liveConfidence * 100)}% abaixo do limiar ${Math.round(thresholdGate * 100)}%.`);
        }

        const trainingStrength = clamp01(
            (bestMetrics.f1 ?? 0) * 0.5 +
            (bestMetrics.precision ?? 0) * 0.2 +
            (bestMetrics.acc_recent ?? 0) * 0.2 +
            (bestMetrics.coverage ?? 0) * 0.1
        );
        const liveBoost = clamp01(
            thresholdGate < 1
                ? (liveConfidence - thresholdGate) / Math.max(0.05, 1 - thresholdGate)
                : liveConfidence
        );
        let finalConfidence = clamp01(trainingStrength * 0.6 + liveBoost * 0.4);
        if (!holdoutInfo.passed) {
            finalConfidence *= 0.5;
        }
        if (!finalColor) {
            finalConfidence = 0;
        }

        const topCandidates = topEvaluations.slice(0, Math.min(10, topEvaluations.length)).map(entry => ({
            id: entry.cfg.id,
            family: entry.cfg.family,
            params: entry.cfg.params,
            metrics: entry.metrics
        }));

        const summaryParts = [];
        if (finalColor) {
            summaryParts.push(`N8 - Walk-forward â†’ ${finalColor.toUpperCase()} (${Math.round(finalConfidence * 100)}%)`);
        } else {
            summaryParts.push('N8 - Walk-forward â†’ NULO');
        }
        summaryParts.push(`melhor famÃ­lia: ${bestDetailed.cfg.family}`);
        summaryParts.push(`F1 ${(bestMetrics.f1 * 100).toFixed(1)}%`);
        summaryParts.push(`precision ${(bestMetrics.precision * 100).toFixed(1)}%`);
        summaryParts.push(`recall ${(bestMetrics.recall * 100).toFixed(1)}%`);
        const summaryText = summaryParts.join(' | ');

        const runSummary = {
            run_id: runId,
            timestamp: runTimestamp,
            requested_history_size: settings.historySize,
            used_history_size: stableWindow.meta.usedHistoryLimit,
            available_history: stableWindow.meta.availableHistory,
            unique_history: stableWindow.meta.uniqueCount,
            dropped_duplicates: stableWindow.meta.droppedDuplicates,
            dropped_invalid_ts: stableWindow.meta.droppedInvalidTs,
            window_size: settings.windowSize,
            analyses_to_run: settings.analysesToRun,
            min_windows_required: settings.minWindowsRequired,
            seed: settings.seed
        };

        return {
            enabled: true,
            run_summary: runSummary,
            best_config: bestDetailed.cfg,
            best_metrics: bestMetrics,
            conf_list: bestConfList,
            per_window_log: perWindowLog,
            threshold: chosenThreshold,
            threshold_metrics: chosenMetrics,
            color: finalColor,
            confidence: finalConfidence,
            live_confidence: liveConfidence,
            live_threshold_gate: thresholdGate,
            tested_configs: candidateConfigs.length,
            effective_configs: evaluations.length,
            top_candidates: topCandidates,
            n_windows: windows.length,
            holdout: holdoutInfo,
            warnings,
            summaryText,
            metrics: {
                accuracy: bestMetrics.accuracy ?? 0,
                acc_recent: bestMetrics.acc_recent ?? 0,
                coverage: bestMetrics.coverage ?? 0,
                precision: bestMetrics.precision ?? 0,
                recall: bestMetrics.recall ?? 0,
                f1: bestMetrics.f1 ?? 0,
                n_preds: bestMetrics.n_preds ?? 0,
                n_windows: bestMetrics.n_windows ?? windows.length
            }
        };
    } catch (error) {
        console.error('âŒ Erro em runN8Detector:', error);
        return {
            enabled: false,
            summaryText: 'N8 - Walk-forward â†’ NULO (erro interno na anÃ¡lise)',
            code: 'internal_error',
            error: String(error),
            run_summary: { run_id: runId, timestamp: runTimestamp }
        };
    }
}

/**
 * FUNÃ‡ÃƒO PRINCIPAL: AnÃ¡lise AvanÃ§ada - NÃVEL DIAMANTE
 * Fluxo atual: 11 nÃ­veis com pontuaÃ§Ã£o contÃ­nua + barreira final
 * - N0 detecta branco e pode bloquear os demais nÃ­veis
 * - N1..N7 geram votos especializados
 * - N8 valida sequÃªncia (barreira final)
 * - N9 calibra probabilidades bayesianas e ajusta a forÃ§a dos demais nÃ­veis
 */
async function analyzeWithPatternSystem(history) {
    
    const totalDiamondLevels = DIAMOND_LEVEL_IDS.length;
    const diamondLevelEnabledMap = {};
    DIAMOND_LEVEL_IDS.forEach(id => {
        diamondLevelEnabledMap[id] = isDiamondLevelEnabled(id);
    });
    const isLevelEnabledLocal = (id) => !!diamondLevelEnabledMap[id];
    const activeDiamondLevels = DIAMOND_LEVEL_IDS.filter(id => diamondLevelEnabledMap[id]);
    const activeLevelsSummary = `${activeDiamondLevels.length}/${totalDiamondLevels}`;
    
    // âœ… DEBUG: Enviar mensagem inicial
    sendAnalysisStatus(`ğŸ” Iniciando anÃ¡lise (${activeLevelsSummary} nÃ­veis ativos)...`);
    console.log(`âœ… DEBUG: sendAnalysisStatus chamado - Iniciando anÃ¡lise com ${activeLevelsSummary} nÃ­veis ativos...`);

    if (activeDiamondLevels.length === 0) {
        console.warn('âš ï¸ Nenhum nÃ­vel do modo Diamante estÃ¡ ativo. AnÃ¡lise cancelada.');
        await restoreIAStatus();
        return null;
    }
    await sleep(1000);
    
    // VALIDAÃ‡ÃƒO DE DADOS DE ENTRADA
    logSection('ğŸ“Š 1. ValidaÃ§Ã£o de dados de entrada');
    console.log(`   âœ“ history existe? ${!!history ? 'âœ… SIM' : 'âŒ NÃƒO'}`);
    console.log(`   âœ“ history.length = ${history ? history.length : 'N/A'}`);
    
    if (history && history.length > 0) {
        logSection('ğŸ“œ Ãšltimos 20 giros do histÃ³rico (dados reais)');
        const last20 = history.slice(0, 20);
        last20.forEach((spin, idx) => {
            const colorEmoji = spin.color === 'red' ? 'ğŸ”´' : spin.color === 'black' ? 'âš«' : 'âšª';
            const timestamp = spin.timestamp ? new Date(spin.timestamp).toLocaleTimeString('pt-BR') : 'N/A';
            console.log(`   ${idx + 1}. ${colorEmoji} ${spin.color.toUpperCase()} (nÂº ${spin.number}) Ã s ${timestamp}`);
        });
    }
    
        logDivider();
        logSection(`[Diamante] AnÃ¡lise (${activeLevelsSummary} nÃ­veis ativos)`);
        [
            'N0 - Detector de Branco Â· bloqueio dinÃ¢mico',
            'N1 - Zona Segura Â· predominÃ¢ncia confirmada',
            'N2 - Ritmo AutÃ´nomo Â· duplas/sequÃªncia (W Ãºnico)',
            'N3 - AlternÃ¢ncia Inteligente Â· n-grams configurÃ¡veis',
            'N4 - PersistÃªncia / Ciclos',
            'N5 - Ritmo por Giro (minuto alvo)',
            'N6 - RetraÃ§Ã£o HistÃ³rica',
            'N7 - Continuidade Global',
            'N8 - Walk-forward nÃ£o sobreposto',
            'N9 - Barreira Final',
            'N10 - CalibraÃ§Ã£o Bayesiana'
        ].forEach(text => console.log(`   ${text}`));
        logDivider();
        logSection(`[Diamante] ConfiguraÃ§Ãµes atuais`);
    
    // Pegar configuraÃ§Ãµes do analyzerConfig
    const userDiamondWindows = analyzerConfig.diamondLevelWindows || {};
    const n1WindowSize = getDiamondWindow('n1WindowSize', SAFE_ZONE_DEFAULTS.windowSize);
    const n1PrimaryRequirement = getDiamondWindow('n1PrimaryRequirement', SAFE_ZONE_DEFAULTS.primaryRequirement);
    const n1SecondaryRequirement = getDiamondWindow('n1SecondaryRequirement', SAFE_ZONE_DEFAULTS.secondaryRequirement);
    const n2W = getDiamondWindow('n2Recent', 10);
    const n3Window = getDiamondWindow('n3Alternance', 12);
    const n4Window = getDiamondWindow('n4Persistence', 20);
    const n5Window = getDiamondWindow('n5MinuteBias', 60);
    const n6Window = getDiamondWindow('n6RetracementWindow', 80);
    const n7DecisionWindow = getDiamondWindow('n7DecisionWindow', 20);
    const n7HistoryWindow = getDiamondWindow('n7HistoryWindow', 100);
    const n8WalkWindow = getDiamondWindow('n10Window', 20);
    const n8WalkHistory = Number(userDiamondWindows.n10History) > 0 ? Number(userDiamondWindows.n10History) : 500;
    const n9BarrierWindow = getDiamondWindow('n8Barrier', 50);
    const displayValue = (key, fallback, ...legacyKeys) => {
        if (Number.isFinite(Number(userDiamondWindows[key])) && Number(userDiamondWindows[key]) > 0) {
            return Number(userDiamondWindows[key]);
        }
        for (const legacyKey of legacyKeys) {
            if (Number.isFinite(Number(userDiamondWindows[legacyKey])) && Number(userDiamondWindows[legacyKey]) > 0) {
                return Number(userDiamondWindows[legacyKey]);
            }
        }
        return fallback;
    };
    
    const n0HistoryConfigured = displayValue('n0History', N0_DEFAULTS.historySize);
    const n0WindowConfigured = getDiamondWindow('n0Window', N0_DEFAULTS.windowSize);
    
    [
        ['N0', `Hist ${n0HistoryConfigured} | W ${n0WindowConfigured} | BlockAll ${analyzerConfig.n0AllowBlockAll !== false ? 'sim' : 'nÃ£o'}`],
        ['N1', `Zona Segura â†’ W ${n1WindowSize} | minA ${n1PrimaryRequirement} | minB ${n1SecondaryRequirement}`],
        ['N2', `W ${n2W} (auto)`],
        ['N3', `Hist ${n3Window} | Rigor ${getDiamondWindow('n3ThresholdPct', 75)}%`],
        ['N4', `${n4Window} giros`],
        ['N5', `${n5Window} amostras`],
        ['N6', `${n6Window} giros`],
        ['N7', `DecisÃµes ${n7DecisionWindow} | HistÃ³rico ${n7HistoryWindow}`],
        ['N8', `Hist ${n8WalkHistory} | W ${n8WalkWindow}`],
        ['N9', `${n9BarrierWindow} giros`],
        ['N10', `Hist ${getDiamondWindow('n10History', 500)} | W ${getDiamondWindow('n10Window', 20)}`]
    ].forEach(([label, detail]) => logInfo(label, detail));
    logDivider();
    
    // Verificar se os valores sÃ£o padrÃ£o ou personalizados
    const isN0Custom = n0HistoryConfigured !== N0_DEFAULTS.historySize || n0WindowConfigured !== N0_DEFAULTS.windowSize;
    const isN1Custom = n1WindowSize !== SAFE_ZONE_DEFAULTS.windowSize ||
        n1PrimaryRequirement !== SAFE_ZONE_DEFAULTS.primaryRequirement ||
        n1SecondaryRequirement !== SAFE_ZONE_DEFAULTS.secondaryRequirement;
    const isN2Custom = n2W !== 10;
    const isN3Custom = n3Window !== 12;
    const isN4Custom = n4Window !== 20;
    const isN5Custom = n5Window !== 60;
    const isN6Custom = n6Window !== 80;
    const isN7Custom = n7DecisionWindow !== 20 || n7HistoryWindow !== 100;
    const isN8Custom = n8WalkWindow !== 20 || n8WalkHistory !== 500;
    const isN9Custom = n9BarrierWindow !== 50;
    
    const customCount = [
        isN0Custom,
        isN1Custom,
        isN2Custom,
        isN3Custom,
        isN4Custom,
        isN5Custom,
        isN6Custom,
        isN7Custom,
        isN8Custom,
        isN9Custom
    ].filter(Boolean).length;
    
    if (customCount === 0) {
        logInfo('PersonalizaÃ§Ã£o', 'Todos os nÃ­veis usando valores padrÃ£o');
    } else {
        const customLevels = [];
        if (isN0Custom) customLevels.push('N0');
        if (isN1Custom) customLevels.push('N1');
        if (isN2Custom) customLevels.push('N2');
        if (isN3Custom) customLevels.push('N3');
        if (isN4Custom) customLevels.push('N4');
        if (isN5Custom) customLevels.push('N5');
        if (isN6Custom) customLevels.push('N6');
        if (isN7Custom) customLevels.push('N7');
        if (isN8Custom) customLevels.push('N8');
        if (isN9Custom) customLevels.push('N9');
        logInfo('PersonalizaÃ§Ã£o', `${customCount} nÃ­vel(is): ${customLevels.join(', ')}`);
    }
    logInfo('ConfirmaÃ§Ã£o', 'Esses sÃ£o os valores sendo usados na anÃ¡lise atual');
    logDivider();
    console.log('');
    
    try {
        // Logs de debug removidos: reduÃ§Ã£o de verbosidade
        console.log('');
        
        // Verificar acerto do sinal anterior (se houver)
        if (history.length > 0) {
            await checkPreviousSignalAccuracy(history[0]);
        }
        
        console.log('');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â±ï¸ VERIFICAÃ‡ÃƒO DE INTERVALO MÃNIMO ENTRE SINAIS (APENAS MODO DIAMANTE)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const minIntervalSpins = (analyzerConfig.minSignalIntervalSpins ?? analyzerConfig.minIntervalSpins) || 0;
        
        // âœ… FLAG: Guardar se intervalo estÃ¡ bloqueado (MAS CONTINUAR ANÃLISE)
        let intervalBlocked = false;
        let intervalMessage = '';
        
        if (analyzerConfig.aiMode) {
        console.log('');
        logSection('â±ï¸ VerificaÃ§Ã£o de intervalo entre sinais');
        console.log(`ğŸ“Š Intervalo mÃ­nimo configurado: ${minIntervalSpins} giro(s)`);
        console.log(`ğŸ“Š Giro atual: #${history[0]?.number || 'N/A'}`);
        
        if (minIntervalSpins > 0) {
            // âœ… IMPORTANTE (Modo Diamante):
            // O intervalo deve ser contado a partir do FIM DO CICLO (WIN/RET), e nÃ£o do momento do sinal.
            const entriesResult = await chrome.storage.local.get([
                'lastCycleResolvedSpinId',
                'lastCycleResolvedSpinTimestamp',
                'lastCycleResolvedTimestamp',
                // fallback legado:
                'lastSignalSpinNumber',
                'lastSignalTimestamp',
                'lastSignalSpinId',
                'lastSignalSpinTimestamp'
            ]);

            const lastCycleResolvedSpinId = entriesResult.lastCycleResolvedSpinId || null;
            const lastCycleResolvedSpinTimestamp = entriesResult.lastCycleResolvedSpinTimestamp || null;
            const lastCycleResolvedTimestamp = entriesResult.lastCycleResolvedTimestamp || null;

            const lastSignalSpinNumber = entriesResult.lastSignalSpinNumber ?? null;
            const lastSignalTimestamp = entriesResult.lastSignalTimestamp || null;
            const lastSignalSpinId = entriesResult.lastSignalSpinId || null;
            const lastSignalSpinTimestamp = entriesResult.lastSignalSpinTimestamp || null;
            
            const usingCycleMarker = !!(lastCycleResolvedSpinId || lastCycleResolvedSpinTimestamp || lastCycleResolvedTimestamp);

            if (usingCycleMarker) {
                console.log(`ğŸ“Š Ãšltimo ciclo finalizado (WIN/RET): ${lastCycleResolvedSpinId ? `id ${lastCycleResolvedSpinId}` : (lastCycleResolvedSpinTimestamp ? lastCycleResolvedSpinTimestamp : 'registrado')}`);
                if (lastCycleResolvedTimestamp) {
                    const tempoDecorrido = Math.round((Date.now() - lastCycleResolvedTimestamp) / 1000);
                    console.log(`   â±ï¸ Registrado hÃ¡ ${tempoDecorrido}s`);
                }
            } else {
                console.log(`ğŸ“Š Ãšltimo sinal salvo (fallback): ${lastSignalSpinNumber !== null ? '#' + lastSignalSpinNumber : 'Nenhum'}`);
            if (lastSignalTimestamp) {
                const tempoDecorrido = Math.round((Date.now() - lastSignalTimestamp) / 1000);
                console.log(`   â±ï¸ Registrado hÃ¡ ${tempoDecorrido}s`);
                }
            }

            const refSpinId = usingCycleMarker ? lastCycleResolvedSpinId : lastSignalSpinId;
            const refSpinTimestamp = usingCycleMarker ? lastCycleResolvedSpinTimestamp : lastSignalSpinTimestamp;
            const refTimestampMs = usingCycleMarker ? lastCycleResolvedTimestamp : lastSignalTimestamp;

            let spinsSince = null;
            if (history.length > 0) {
                if (refSpinId) {
                    const indexById = history.findIndex(spin => spin && spin.id === refSpinId);
                    spinsSince = indexById >= 0 ? indexById : history.length;
                } else if (refSpinTimestamp) {
                    const referenceTime = new Date(refSpinTimestamp).getTime();
                    if (!Number.isNaN(referenceTime)) {
                        for (let i = 0; i < history.length; i++) {
                            const spinTime = history[i]?.timestamp ? new Date(history[i].timestamp).getTime() : NaN;
                            if (!Number.isNaN(spinTime) && spinTime <= referenceTime) {
                                spinsSince = i;
                                break;
                            }
                        }
                        if (spinsSince === null) spinsSince = history.length;
                    }
                }
            }

            if (spinsSince !== null) {
                console.log(`ğŸ“Š Giros desde o ${usingCycleMarker ? 'fim do ciclo' : 'Ãºltimo sinal'} (histÃ³rico real): ${spinsSince}`);
                if (spinsSince >= minIntervalSpins) {
                    console.log('âœ… Intervalo de giros respeitado!');
                } else {
                    const remaining = minIntervalSpins - spinsSince;
                    intervalBlocked = true;
                    intervalMessage = `â³ Aguardando ${remaining} giro(s)... ${spinsSince}/${minIntervalSpins}`;
                    console.log('âš ï¸ Intervalo insuficiente: anÃ¡lise continua, mas sinal serÃ¡ bloqueado');
                }
            } else if (refTimestampMs && history.length > 0) {
                const timeSince = Date.now() - refTimestampMs;
                const minutosDecorridos = timeSince / 60000;
                const girosEstimados = Math.floor(minutosDecorridos * 2);
                console.log(`ğŸ“Š Giros estimados desde o ${usingCycleMarker ? 'fim do ciclo' : 'Ãºltimo sinal'}: ~${girosEstimados}`);
                
                if (girosEstimados >= minIntervalSpins) {
                    console.log('âœ… Intervalo estimado suficiente (fallback temporal)');
            } else {
                    const remaining = minIntervalSpins - girosEstimados;
                    intervalBlocked = true;
                    intervalMessage = `â³ Aguardando ${remaining} giro(s)... ${girosEstimados}/${minIntervalSpins}`;
                    console.log('âš ï¸ Intervalo insuficiente (estimativa temporal)');
                }
            } else {
                console.log('âœ… Nenhum ciclo anterior registrado â€“ permitido seguir');
            }
        } else {
            console.log('âœ… Sem intervalo configurado â€“ sinais liberados sempre que houver padrÃ£o vÃ¡lido');
            }
        } // âœ… fim do if (analyzerConfig.aiMode)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ’ FLUXO ATUAL - NÃVEL DIAMANTE: 5 NÃVEIS COM PONTUAÃ‡ÃƒO
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // âœ… Obter tamanho REAL do histÃ³rico disponÃ­vel (para NÃ­vel 4 e 6)
        const configuredSize = Math.min(Math.max(analyzerConfig.aiHistorySize || 60, 60), 2000);
        const availableSize = history.length;
        const historySize = Math.min(configuredSize, availableSize); // âœ… Usar o menor entre configurado e disponÃ­vel
        const totalHistory = history.slice(0, historySize);
        
        console.log('%câ•‘  ğŸ“Š VERIFICAÃ‡ÃƒO DO HISTÃ“RICO DISPONÃVEL                          â•‘', 'color: #00BFFF; font-weight: bold;');
        console.log(`%c   ğŸ¯ Configurado pelo usuÃ¡rio: ${configuredSize} giros`, 'color: #00BFFF;');
        console.log(`%c   ğŸ“¦ DisponÃ­vel no servidor: ${availableSize} giros`, availableSize < configuredSize ? 'color: #FFA500; font-weight: bold;' : 'color: #00FF88;');
        console.log(`%c   âœ… ANALISANDO REALMENTE: ${historySize} giros`, 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
        if (availableSize < configuredSize) {
            console.log(`%c   âš ï¸ ATENÃ‡ÃƒO: Servidor tem menos giros que o configurado!`, 'color: #FFA500; font-weight: bold;');
            console.log(`%c   â¤ Sistema usarÃ¡ APENAS os ${historySize} giros disponÃ­veis`, 'color: #FFA500; font-weight: bold;');
            console.log(`%c   â¤ Aguarde mais giros serem coletados para anÃ¡lise completa`, 'color: #FFA500;');
        }
        
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âŒ NÃVEIS 1, 2 e 3 REMOVIDOS (anÃ¡lise superficial baseada apenas em frequÃªncia)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    console.log('%câš ï¸ NÃVEIS 1, 2 e 3 DESATIVADOS (anÃ¡lise superficial de frequÃªncia)', 'color: #888; font-style: italic;');
    
    // âŒ NÃVEL 1 REMOVIDO: Cor Dominante (15 giros) - apenas frequÃªncia simples
    // âŒ NÃVEL 2 REMOVIDO: PosiÃ§Ã£o do Giro (30 giros) - sem base estatÃ­stica sÃ³lida  
    // âŒ NÃVEL 3 REMOVIDO: Soma dos Minutos (30 giros) - aleatoriedade pura
    
    // âœ… Identificar posiÃ§Ã£o do giro (ainda necessÃ¡rio para NÃ­vel 6 - Barreira)
    const lastSpinTimestamp = history[0]?.timestamp || Date.now();
    const lastSpinPosition = history[0]?.timestamp ? identifySpinPosition(lastSpinTimestamp) : 1;
    const nextSpinPosition = lastSpinPosition === 1 ? 2 : 1;
    const lastSpinDate = new Date(lastSpinTimestamp);
    const nextSpinDate = new Date(lastSpinDate);
    if (lastSpinPosition === 2) {
        nextSpinDate.setMinutes(nextSpinDate.getMinutes() + 1);
    }
    const targetMinute = nextSpinDate.getMinutes();
        
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¯ NÃVEL 1: ZONA SEGURA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log('%câ•‘  ğŸ›¡ï¸ NÃVEL 1: ZONA SEGURA                             â•‘', 'color: #FF6B35; font-weight: bold; font-size: 14px;');
        
        let safeZoneVote = null;
        let safeZoneMeta = null;
		let patternDescription = 'AnÃ¡lise NÃ­vel Diamante - 11 NÃ­veis';
        
        const safeZoneSettings = getSafeZoneSettingsFromAnalyzerConfig();
        console.log(`%c   ConfiguraÃ§Ãµes: janela ${safeZoneSettings.windowSize} | mÃ­n A ${safeZoneSettings.minPrimary} | mÃ­n B ${safeZoneSettings.minSecondary} | entradas ${safeZoneSettings.maxEntries}`, 'color: #FF6B35;');
        safeZoneMeta = analyzeSafeZone(history, safeZoneSettings);
        safeZoneMeta.maxEntries = safeZoneSettings.maxEntries;
        safeZoneMeta.entriesUsed = safeZoneEntryState.entriesUsed || 0;
        
        if (!safeZoneMeta.zoneActive) {
            console.log(`%câš ï¸ Zona inativa â†’ ${describeSafeZoneReason(safeZoneMeta.reason)}`, 'color: #888; font-style: italic;');
            safeZoneEntryState = { signature: null, entriesUsed: 0 };
        } else {
            console.log(`%c   Dominante: ${safeZoneMeta.dominant?.toUpperCase() || 'N/A'} (${safeZoneMeta.counts[safeZoneMeta.dominant]}/${safeZoneMeta.windowSize})`, 'color: #FF6B35;');
            console.log(`%c   SecundÃ¡ria: ${safeZoneMeta.secondary ? safeZoneMeta.secondary.toUpperCase() + ` (${safeZoneMeta.counts[safeZoneMeta.secondary]})` : 'N/A'}`, 'color: #FF6B35;');
            console.log(`%c   Ãšltima cor: ${safeZoneMeta.lastColor ? safeZoneMeta.lastColor.toUpperCase() : 'N/A'}`, 'color: #FF6B35;');
            
            if (safeZoneMeta.signal) {
                const signature = buildSafeZoneSignature(safeZoneMeta);
                if (safeZoneEntryState.signature !== signature) {
                    safeZoneEntryState = { signature, entriesUsed: 0 };
                }
                safeZoneMeta.entriesUsed = safeZoneEntryState.entriesUsed;
                if (safeZoneEntryState.entriesUsed >= safeZoneSettings.maxEntries) {
                    console.log(`%c   âš ï¸ Limite de ${safeZoneSettings.maxEntries} entradas atingido para esta zona.`, 'color: #FFAA00; font-weight: bold;');
                    safeZoneMeta.signal = false;
                    safeZoneMeta.reason = 'entry_limit_reached';
                }
            }
            // âœ… NÃƒO resetar aqui - apenas quando zona ficar inativa (linha 12855)
        }
        
        if (safeZoneMeta.zoneActive && safeZoneMeta.signal && safeZoneMeta.dominant) {
            safeZoneVote = {
                color: safeZoneMeta.dominant,
                source: 'safe-zone',
                confidence: safeZoneMeta.strength,
                detail: safeZoneMeta
            };
            const signature = buildSafeZoneSignature(safeZoneMeta);
            safeZoneEntryState = {
                signature,
                entriesUsed: Math.min(safeZoneSettings.maxEntries, (safeZoneEntryState.signature === signature ? safeZoneEntryState.entriesUsed : 0) + 1)
            };
            safeZoneMeta.entriesUsed = safeZoneEntryState.entriesUsed;
            safeZoneMeta.reason = 'zone_active_last_is_dominant';
            patternDescription = JSON.stringify({
                type: 'safe_zone',
                dominant: safeZoneMeta.dominant,
                secondary: safeZoneMeta.secondary,
                counts: safeZoneMeta.counts,
                windowSize: safeZoneMeta.windowSize,
                minPrimary: safeZoneMeta.minPrimary,
                minSecondary: safeZoneMeta.minSecondary,
                lastColor: safeZoneMeta.lastColor,
                status: safeZoneMeta.reason,
                entriesUsed: safeZoneMeta.entriesUsed,
                maxEntries: safeZoneSettings.maxEntries
            });
        } else if (safeZoneMeta.zoneActive) {
            patternDescription = JSON.stringify({
                type: 'safe_zone',
                dominant: safeZoneMeta.dominant,
                secondary: safeZoneMeta.secondary,
                counts: safeZoneMeta.counts,
                windowSize: safeZoneMeta.windowSize,
                minPrimary: safeZoneMeta.minPrimary,
                minSecondary: safeZoneMeta.minSecondary,
                lastColor: safeZoneMeta.lastColor,
                status: safeZoneMeta.reason,
                entriesUsed: safeZoneMeta.entriesUsed,
                maxEntries: safeZoneSettings.maxEntries
            });
        }
        
        if (!safeZoneVote) {
            console.log('%câš ï¸ NÃVEL 1 VOTA: NULO (zona fora de sinal)', 'color: #888; font-weight: bold; font-size: 14px;');
    } else {
            console.log(`%cğŸ—³ï¸ NÃVEL 1 VOTA: ${safeZoneVote.color.toUpperCase()}`, `color: ${safeZoneVote.color === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 14px;`);
    }
    
    // âš¡ NÃƒO EXIBIR na UI ainda (anÃ¡lise rÃ¡pida, mostraremos depois)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // âš¡ N2: RITMO AUTÃ”NOMO (W Ãºnico + ajuste automÃ¡tico)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log('%câ•‘  âš¡ N2: RITMO AUTÃ”NOMO (W Ãºnico â€¢ ajuste automÃ¡tico)   â•‘', 'color: #00AAFF; font-weight: bold; font-size: 14px;');
        
        const nivel5 = analyzeMomentum(history);
        const n2Vote = nivel5 && nivel5.color ? String(nivel5.color).toUpperCase() : 'NULO';
        const p2Red = Number(nivel5?.momentum?.red ?? 0);
        const p2Black = Number(nivel5?.momentum?.black ?? 0);
        const n2Details = (nivel5 && nivel5.details) ? nivel5.details : (nivel5 && nivel5.reason ? `NULO â€¢ ${nivel5.reason}` : 'N/A');

        console.log('%cğŸ“Š ANÃLISE N2 (RITMO):', 'color: #00AAFF; font-weight: bold;');
        console.log(`%c   P(2+ por run): ğŸ”´ ${p2Red.toFixed(1)}% | âš« ${p2Black.toFixed(1)}%`, 'color: #00AAFF;');
        console.log(`%c   Detalhes: ${n2Details}`, 'color: #00AAFF;');
        console.log(`%cğŸ—³ï¸ N2 VOTA: ${n2Vote}`, `color: ${n2Vote === 'RED' ? '#FF0000' : (n2Vote === 'BLACK' ? '#FFFFFF' : '#888888')}; font-weight: bold; font-size: 14px;`);
    
    // âš¡ NÃƒO EXIBIR na UI ainda (anÃ¡lise rÃ¡pida, mostraremos depois)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”· N4 - PADRÃƒO DE ALTERNÃ‚NCIA (CONFIGURÃVEL PELO USUÃRIO)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log('%câ•‘  ğŸ”· N4 - PADRÃƒO DE ALTERNÃ‚NCIA (CONFIGURÃVEL)          â•‘', 'color: #8E44AD; font-weight: bold; font-size: 14px;');
        const n3HistoryWindow = Math.max(1, getDiamondWindow('n3Alternance', historySize));
        const n3ThresholdPctConfigured = Math.max(50, Math.min(95, getDiamondWindow('n3ThresholdPct', 75)));
        const n3MinOccurrencesConfigured = Math.max(1, Math.min(100, getDiamondWindow('n3MinOccurrences', 1)));
        const n3AllowBackoffConfigured = getDiamondBoolean('n3AllowBackoff', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n3AllowBackoff);
        const n3IgnoreWhiteConfigured = getDiamondBoolean('n3IgnoreWhite', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n3IgnoreWhite);
        const nivel7 = analyzeAlternancePattern(history, {
            historySize: n3HistoryWindow,
            threshold: n3ThresholdPctConfigured / 100,
            minOccurrences: n3MinOccurrencesConfigured,
            allowBackoff: n3AllowBackoffConfigured,
            ignoreWhite: n3IgnoreWhiteConfigured
        });
        
        console.log('%cğŸ“Š ANÃLISE DE PADRÃƒO:', 'color: #8E44AD; font-weight: bold;');
        console.log(`%c   HistÃ³rico analisado: ${nivel7.historyUsed || n3HistoryWindow}/${n3HistoryWindow} giros`, 'color: #8E44AD;');
        console.log(`%c   AlternÃ¢ncia detectada: ${nivel7.pattern || 'N/A'} â€¢ ${nivel7.details || 'N/A'}`, 'color: #8E44AD;');
        console.log(`%c   Probabilidade: ${nivel7.alternationRate || '0.0'}% (limiar ${n3ThresholdPctConfigured}%)`, 'color: #8E44AD;');
        console.log(`%c   OcorrÃªncias histÃ³ricas: ${nivel7.occurrences != null ? nivel7.occurrences : 0}`, 'color: #8E44AD;');
        console.log(`%c   Detalhes: ${nivel7.details}`, 'color: #8E44AD;');
        
        if (nivel7.color) {
            console.log(`%cğŸ—³ï¸ N4 VOTA: ${nivel7.color.toUpperCase()}`, `color: ${nivel7.color === 'red' ? '#FF0000' : (nivel7.color === 'black' ? '#FFFFFF' : '#CCCCCC')}; font-weight: bold; font-size: 14px;`);
        } else {
            console.log(`%câš ï¸ N4 VOTA: NULO${nivel7.reason ? ` (${nivel7.reason})` : ''}`, 'color: #888; font-weight: bold; font-size: 14px;');
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”· N4 - PERSISTÃŠNCIA E CICLOS (CONFIGURÃVEL PELO USUÃRIO)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log('%câ•‘  ğŸ”· N4 - PERSISTÃŠNCIA E CICLOS (CONFIGURÃVEL)          â•‘', 'color: #D35400; font-weight: bold; font-size: 14px;');
        
        const nivel9 = analyzePersistence(history, getDiamondWindow('n4Persistence', historySize));
        
        console.log('%cğŸ“Š ANÃLISE DE PERSISTÃŠNCIA:', 'color: #D35400; font-weight: bold;');
        console.log(`%c   HistÃ³rico analisado: ${Math.max(20, Math.min(60, historySize))} giros (configurÃ¡vel)`, 'color: #D35400;');
        console.log(`%c   SequÃªncia atual: ${nivel9.currentSequence} ${nivel9.color ? nivel9.color : 'N/A'}`, 'color: #D35400; font-weight: bold;');
        console.log(`%c   MÃ©dia histÃ³rica: ${nivel9.averageSequence} giros`, 'color: #D35400;');
        console.log(`%c   Detalhes: ${nivel9.details}`, 'color: #D35400;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ§® CONSOLIDAÃ‡ÃƒO DOS NÃVEIS (PONTUAÃ‡ÃƒO CONTÃNUA)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const levelWeights = {
            whiteDetector: 0,
            patterns: 0.19,
            momentum: 0.15,
            alternance: 0.13,
            persistence: 0.11,
            minuteSpin: 0.095,
            retracement: 0.085,
            globalContinuity: 0.11,
            barrier: 0.05,
            bayesianCalibration: 0.08,
            walkForward: 0.12
        };
        const levelMeta = {
            // Mantemos emoji aqui para logs internos, mas o texto exibido na UI (reasoning) NÃƒO usa emoji.
            N0: { emoji: 'âšª', label: 'N0 - Detector de Branco' },
            N1: { emoji: 'ğŸ›¡ï¸', label: 'N1 - Zona Segura' },
            N2: { emoji: 'âš¡', label: 'N2 - Ritmo AutÃ´nomo' },
            N3: { emoji: 'ğŸ”·', label: 'N3 - AlternÃ¢ncia' },
            N4: { emoji: 'ğŸ”·', label: 'N4 - PersistÃªncia' },
            N5: { emoji: 'ğŸ•‘', label: 'N5 - Ritmo por Giro' },
            N6: { emoji: 'ğŸ“‰', label: 'N6 - RetraÃ§Ã£o HistÃ³rica' },
            N7: { emoji: 'ğŸ“ˆ', label: 'N7 - Continuidade Global' },
            N8: { emoji: 'ğŸ”Ÿ', label: 'N8 - Walk-forward' },
            N9: { emoji: 'ğŸ›‘', label: 'N9 - Barreira Final' },
            N10:{ emoji: 'ğŸ§®', label: 'N10 - CalibraÃ§Ã£o Bayesiana' }
        };
        const clamp01 = (value) => Math.max(0, Math.min(1, typeof value === 'number' ? value : 0));
        const directionValue = (color) => color === 'red' ? 1 : color === 'black' ? -1 : 0;
        const levelReports = [];
        const describeLevel = (level, opts = {}) => {
            const meta = levelMeta[level.id] || { emoji: '', label: `${level.id}` };
            const includeEmoji = opts && opts.includeEmoji === false ? false : true;
            const prefix = includeEmoji && meta.emoji ? `${meta.emoji} ` : '';
            if (level.disabled) {
                return `${prefix}${meta.label} â†’ DESATIVADO`;
            }
            // âœ… N9 Ã© validador (nÃ£o vota). Nunca deve aparecer como "NULO" â€” mostrar APROVADO/BLOQUEADO + resumo.
            if (level.id === 'N9') {
                const detail = level.details ? String(level.details) : 'APROVADO';
                return `${prefix}${meta.label} â†’ ${detail}`;
            }
            if (!level.color) {
                return `${prefix}${meta.label} â†’ NULO`;
            }
            const strengthPct = Math.round((level.strength || 0) * 100);
            return `${prefix}${meta.label} â†’ ${level.color.toUpperCase()} (${strengthPct}% â€¢ ${level.details})`;
        };
const displayOrder = ['N0', 'N1', 'N2', 'N3', 'N4', 'N5', 'N6', 'N7', 'N8', 'N9', 'N10'];
        let diamondSequenceDisplayed = false;

        const n0Settings = getN0SettingsFromAnalyzerConfig();
        const n0Options = {
            historySize: n0Settings.historySize,
            windowSize: n0Settings.windowSize,
            analysesToRun: N0_DEFAULTS.analysesToRun,
            minWindowsRequired: N0_DEFAULTS.minWindowsRequired,
            precisionMin: N0_DEFAULTS.precisionMin,
            confidenceGrid: N0_DEFAULTS.confidenceGrid,
            holdoutEnabled: N0_DEFAULTS.holdoutEnabled,
            holdoutTolerance: N0_DEFAULTS.holdoutTolerance,
            seed: N0_DEFAULTS.seed
        };

        let n0Result = null;
        let n0EffectiveAction = 'no_block';
        let n0ForceWhite = false;
        let n0SoftBlockActive = false;
        let n0WhiteStrength = 0;
        let n0ActionSuppressed = false;
        let n0DetailSummary = 'NULO';

        const n0Enabled = isLevelEnabledLocal('N0');
        if (!n0Enabled) {
            console.log('%câ•‘  âšª NÃVEL 0 - DETECTOR DE BRANCO (DESATIVADO PELO USUÃRIO) â•‘', 'color: #777777; font-weight: bold; font-size: 14px;');
            n0Result = {
                enabled: false,
                reason: 'Desativado pelo usuÃ¡rio'
            };
            n0DetailSummary = 'DESATIVADO';
        } else {
            try {
                console.log('%câ•‘  âšª NÃVEL 0 - DETECTOR DE BRANCO                         â•‘', 'color: #FFFFFF; font-weight: bold; font-size: 14px;');
                console.log(`%c   HistÃ³rico analisado: ${n0Options.historySize} giros | Janela: ${n0Options.windowSize} giros`, 'color: #FFFFFF; font-weight: bold;');
                console.log(`%c   Modelos avaliados: ${n0Options.analysesToRun} | Holdout: ${n0Options.holdoutEnabled ? 'ATIVO' : 'DESATIVADO'}`, 'color: #FFFFFF; font-weight: bold;');

                n0Result = runN0Detector(history, n0Options);

                if (n0Result && n0Result.enabled) {
                const actionRequested = n0Result.blocking_action || 'no_block';
                const blockAllAllowed = n0Settings.allowBlockAll;
                n0WhiteStrength = clamp01(n0Result.white_confidence || 0);
                const bestMetrics = n0Result.best_metrics || {};
                const blockMetrics = n0Result.blocking_metrics || {};
                const testedConfigs = n0Result.tested_configs != null ? n0Result.tested_configs : n0Options.analysesToRun;
                const effectiveConfigs = n0Result.effective_configs != null ? n0Result.effective_configs : testedConfigs;
                const holdoutData = n0Result.holdout || {};
                if (n0Result.run_summary) {
                    console.log('%c   â¤ Resumo da execuÃ§Ã£o N0:', 'color: #AAAAAA; font-weight: bold;');
                    console.log(n0Result.run_summary);
                }

                n0EffectiveAction = actionRequested;
                if (actionRequested === 'block_all' && !blockAllAllowed) {
                    n0EffectiveAction = 'no_block';
                    n0ActionSuppressed = true;
                }
                if (n0ActionSuppressed) {
                    console.log('%c   â„¹ï¸ BLOCK ALL desativado pelo usuÃ¡rio (modo informativo)', 'color: #FFAA00; font-weight: bold;');
                }

                n0ForceWhite = n0EffectiveAction === 'block_all' && n0Result.pred_live === 'W';
                n0SoftBlockActive = n0EffectiveAction === 'soft_block' && n0Result.pred_live === 'W';

                const actionLabel = n0ForceWhite
                    ? 'BLOCK ALL'
                    : n0SoftBlockActive
                        ? 'SOFT BLOCK'
                        : (n0Result.pred_live === 'W' ? 'ALERTA' : 'NULO');
                const confidencePct = Math.round(n0WhiteStrength * 100);
                const thresholdPct = n0Result.blocking_threshold != null
                    ? Math.round(n0Result.blocking_threshold * 100)
                    : null;
                const detailsParts = [
                    actionLabel,
                    `conf ${confidencePct}%`
                ];
                if (thresholdPct !== null) {
                    detailsParts.push(`t* ${thresholdPct}%`);
                }
                if (n0Result.dominant_nonwhite) {
                    detailsParts.push(`dom ${n0Result.dominant_nonwhite.toUpperCase()}`);
                }
                if (bestMetrics.f1 != null) {
                    detailsParts.push(`f1 ${(bestMetrics.f1 * 100).toFixed(1)}%`);
                }
                if (blockMetrics.precision != null) {
                    detailsParts.push(`p* ${(blockMetrics.precision * 100).toFixed(1)}%`);
                }
                if (testedConfigs != null) {
                    detailsParts.push(`${testedConfigs} cfgs`);
                    if (effectiveConfigs != null && effectiveConfigs !== testedConfigs) {
                        detailsParts.push(`${effectiveConfigs} vÃ¡lidas`);
                    }
                }
                if (holdoutData.enabled) {
                    detailsParts.push(holdoutData.passed ? 'holdout ok' : 'holdout falhou');
                }
                if (n0ActionSuppressed) {
                    detailsParts.push('informativo');
                }
                n0DetailSummary = detailsParts.join(' â€¢ ');

                console.log(`%c   â¤ AÃ§Ã£o sugerida: ${actionRequested.toUpperCase()}${n0ActionSuppressed ? ' (modo informativo)' : ''}`, 'color: #FFFFFF; font-weight: bold;');
                console.log(`%c   â¤ ConfianÃ§a: ${(n0WhiteStrength * 100).toFixed(2)}% | Threshold: ${(n0Result.blocking_threshold * 100 || 0).toFixed(2)}% | Precision*: ${blockMetrics.precision != null ? (blockMetrics.precision * 100).toFixed(1) + '%' : 'n/d'}`, 'color: #FFFFFF; font-weight: bold;');
                if (n0Result.best_config) {
                    console.log('%c   â¤ Melhor configuraÃ§Ã£o:', 'color: #FFFFFF; font-weight: bold;');
                    console.log(n0Result.best_config);
                }
                console.log(`%c   â¤ MÃ©tricas Treino: F1 ${(bestMetrics.f1 != null ? (bestMetrics.f1 * 100).toFixed(1) : 'n/d')}% | Recall ${(bestMetrics.recall != null ? (bestMetrics.recall * 100).toFixed(1) : 'n/d')}% | Precision ${(bestMetrics.precision != null ? (bestMetrics.precision * 100).toFixed(1) : 'n/d')}% | Cobertura ${(bestMetrics.coverage != null ? (bestMetrics.coverage * 100).toFixed(1) : 'n/d')}%`, 'color: #FFFFFF; font-weight: bold;');
                if (Array.isArray(n0Result.top_candidates) && n0Result.top_candidates.length > 0) {
                    console.log(`%c   â¤ Top configs (F1%%): ${n0Result.top_candidates.slice(0, 3).map(c => `${c.id}:${(c.metrics.f1 * 100).toFixed(1)}`).join(' | ')}`, 'color: #AAAAFF; font-weight: bold;');
                }
                if (Array.isArray(n0Result.per_window_log)) {
                    console.log(`%c   â¤ Audit trail disponÃ­vel (${n0Result.per_window_log.length} linhas)`, 'color: #AAAAFF; font-weight: bold;');
                }
                if (Array.isArray(n0Result.warnings) && n0Result.warnings.length > 0) {
                    n0Result.warnings.forEach(warning => {
                        console.log(`%c   âš ï¸ Aviso: ${warning}`, 'color: #FFAA00; font-weight: bold;');
                    });
                }
                if (n0Result.holdout && n0Result.holdout.enabled) {
                    console.log(`%c   â¤ Holdout: ${n0Result.holdout.passed ? 'APROVADO' : 'REPROVADO'}${n0Result.holdout.reason ? ` (${n0Result.holdout.reason})` : ''}`, n0Result.holdout.passed ? 'color: #00FF88; font-weight: bold;' : 'color: #FFAA00; font-weight: bold;');
                }
                if (n0SoftBlockActive) {
                    console.log('%c   âš ï¸ Soft block: pesos reduzidos em 50% para os demais nÃ­veis', 'color: #FFAA00; font-weight: bold;');
                }
                } else if (n0Result) {
                console.log(`%c   â¤ Detector indisponÃ­vel: ${n0Result.reason || 'motivo nÃ£o informado'}`, 'color: #FFAA00; font-weight: bold;');
                n0DetailSummary = n0Result.reason || 'IndisponÃ­vel';
                } else {
                console.log('%c   â¤ Detector indisponÃ­vel: erro desconhecido', 'color: #FFAA00; font-weight: bold;');
                n0DetailSummary = 'IndisponÃ­vel';
                }
            } catch (error) {
                console.error('âŒ Erro ao executar N0 - Detector de Branco:', error);
                n0Result = {
                    enabled: false,
                    reason: 'Erro interno no detector'
                };
                n0DetailSummary = 'Erro interno';
            }
        }

        levelReports.push({
            id: 'N0',
            name: 'Detector de Branco',
            color: n0Result && n0Result.pred_live === 'W' ? 'white' : null,
            weight: n0Enabled ? levelWeights.whiteDetector : 0,
            strength: n0WhiteStrength,
            score: 0,
            details: n0DetailSummary,
            disabled: !n0Enabled
        });

        const n0WeightModifier = (n0Enabled && n0SoftBlockActive) ? N0_DEFAULTS.softBlockFactor : 1;
        const weightFor = (baseWeight) => baseWeight * n0WeightModifier;
        const emitLevelStatuses = async (reports, options = {}) => {
            const { perLevelDelay = 1500, force = false } = options;
            if (diamondSequenceDisplayed && !force) return;
            if (!force) {
                diamondSequenceDisplayed = true;
            }

            const sequence = displayOrder.map(id => {
                const level = Array.isArray(reports) ? reports.find(lvl => lvl.id === id) : null;
                const meta = levelMeta[id] || {};
                const [idLabel, nameLabel] = (meta.label || id).split(' - ');
                const friendlyName = nameLabel ? `${idLabel} ${nameLabel}` : (meta.label || id);
                const enabled = isLevelEnabledLocal(id);

                if (id === 'N0') {
                    if (!enabled) {
                        return { id, message: `${friendlyName}: DESATIVADO` };
                    }
                    if (!level || !n0Result) {
                        return { id, message: `${friendlyName}: NULO` };
                    }
                    const confPct = Math.round((n0WhiteStrength || 0) * 100);
                    const thresholdPct = n0Result.blocking_threshold != null
                        ? Math.round(n0Result.blocking_threshold * 100)
                        : null;
                    const suffixThreshold = thresholdPct !== null ? ` â€¢ t* ${thresholdPct}%` : '';
                    if (n0ForceWhite) {
                        const suppressedLabel = n0ActionSuppressed ? ' (informativo)' : '';
                        return {
                            id,
                            message: `${friendlyName}: BLOCK ALL (${confPct}%${suffixThreshold})${suppressedLabel}`
                        };
                    }
                    if (n0SoftBlockActive) {
                        return {
                            id,
                            message: `${friendlyName}: SOFT BLOCK (${confPct}%${suffixThreshold})`
                        };
                    }
                    if (level.color === 'white') {
                        const infoSuffix = n0ActionSuppressed ? ' â€¢ informativo' : '';
                        return {
                            id,
                            message: `${friendlyName}: ALERTA (${confPct}%${suffixThreshold})${infoSuffix}`
                        };
                    }
                    if (n0Result.enabled === false) {
                        return { id, message: `${friendlyName}: ${n0Result.reason || 'INDISPONÃVEL'}` };
                    }
                    return { id, message: `${friendlyName}: NULO` };
                }

                if (id === 'N8') {
                    if (!enabled) {
                        return { id, message: `${friendlyName}: DESATIVADO` };
                    }
                    if (level && level.color) {
                        const pct = Math.round((level.strength || 0) * 100);
                        const extra = level.details ? ` â€¢ ${level.details}` : '';
                        return { id, message: `${friendlyName}: ${level.color.toUpperCase()} (${pct}%${extra})` };
                    }
                    return { id, message: `${friendlyName}: NULO` };
                }

                if (id === 'N9') {
                    if (!enabled) {
                        return { id, message: `${friendlyName}: DESATIVADO` };
                    }
                    const status = barrierResult.allowed ? 'APROVADO' : 'BLOQUEADO';
                    return { id, message: `${friendlyName}: ${status}` };
                }

                if (!enabled) {
                    return { id, message: `${friendlyName}: DESATIVADO` };
                }

                if (level && level.color) {
                    const pct = Math.round((level.strength || 0) * 100);
                    const text = pct > 0
                        ? `${friendlyName}: ${level.color.toUpperCase()} (${pct}%)`
                        : `${friendlyName}: ${level.color.toUpperCase()}`;
                    return { id, message: text };
                }

                return { id, message: `${friendlyName}: NULO` };
            });

            for (const item of sequence) {
                sendAnalysisStatus(item.message);
                await sleep(perLevelDelay);
            }
        };

        // N10 - Walk-forward (votante especializado baseado em janelas nÃ£o-sobrepostas)
        const n8Enabled = isLevelEnabledLocal('N8');
        let n8SummaryText = null;
        if (!n8Enabled) {
            console.log('%câ•‘  ğŸ”Ÿ N8 - Walk-forward DESATIVADO (pelo usuÃ¡rio)          â•‘', 'color: #777777; font-weight: bold; font-size: 14px;');
            levelReports.push({
                id: 'N8',
                name: 'Walk-forward',
                color: null,
                weight: 0,
                strength: 0,
                score: 0,
                details: 'DESATIVADO',
                disabled: true
            });
        } else {
            try {
                const windowsCfg = analyzerConfig.diamondLevelWindows || {};
                const n8WindowCfg = getDiamondWindow('n10Window', N8_DEFAULTS.windowSize);
                const n8HistoryCfg = Number(windowsCfg.n10History) > 0 ? Number(windowsCfg.n10History) : N8_DEFAULTS.historySize;
                const n8AnalysesCfg = Number(windowsCfg.n10Analyses) > 0 ? Number(windowsCfg.n10Analyses) : N8_DEFAULTS.analysesToRun;
                const n8MinWindowsCfg = Number(windowsCfg.n10MinWindows) > 0 ? Number(windowsCfg.n10MinWindows) : N8_DEFAULTS.minWindowsRequired;
                const n8ConfMinPctCfg = Number(windowsCfg.n10ConfMin) > 0 ? Number(windowsCfg.n10ConfMin) : N8_DEFAULTS.confMinLive * 100;
                const n8ConfMinCfg = Math.max(0, Math.min(1, n8ConfMinPctCfg / 100));

                const n8Result = runN8Detector(history, {
                    windowSize: n8WindowCfg,
                    historySize: n8HistoryCfg,
                    analysesToRun: n8AnalysesCfg,
                    minWindows: n8MinWindowsCfg,
                    confMinLive: n8ConfMinCfg
                });

                if (n8Result && typeof n8Result.summaryText === 'string') {
                    n8SummaryText = n8Result.summaryText.replace(/^N8 - /, '');
                }

                if (n8Result && Array.isArray(n8Result.warnings) && n8Result.warnings.length > 0) {
                    n8Result.warnings.forEach(warn => console.warn('âš ï¸ [N8]', warn));
                }

                if (n8Result && n8Result.enabled && n8Result.color) {
                    const n8Color = n8Result.color;
                    const n8Strength = clamp01(n8Result.confidence || 0);
                    const metrics = n8Result.best_metrics || {};
                    const f1Pct = metrics.f1 != null ? (metrics.f1 * 100).toFixed(1) : null;
                    const precisionPct = metrics.precision != null ? (metrics.precision * 100).toFixed(1) : null;
                    const recallPct = metrics.recall != null ? (metrics.recall * 100).toFixed(1) : null;
                    const coveragePct = metrics.coverage != null ? (metrics.coverage * 100).toFixed(1) : null;
                    const predsInfo = (metrics.n_preds != null && metrics.n_windows != null)
                        ? `${metrics.n_preds}/${metrics.n_windows} janelas`
                        : null;
                    const bestConfigLabel = n8Result.best_config ? n8Result.best_config.family : null;
                    const detailParts = [];
                    if (bestConfigLabel) detailParts.push(bestConfigLabel);
                    if (f1Pct != null) detailParts.push(`F1 ${f1Pct}%`);
                    if (precisionPct != null) detailParts.push(`prec ${precisionPct}%`);
                    if (recallPct != null) detailParts.push(`rec ${recallPct}%`);
                    if (coveragePct != null) detailParts.push(`coverage ${coveragePct}%`);
                    if (predsInfo) detailParts.push(predsInfo);
                    let n8Details = 'Walk-forward diversificado';
                    if (detailParts.length > 0) {
                        n8Details += ' â€¢ ' + detailParts.join(' â€¢ ');
                    }
                    if (n8Result.holdout && n8Result.holdout.enabled && !n8Result.holdout.passed && n8Result.holdout.reason) {
                        n8Details += ` â€¢ Holdout: ${n8Result.holdout.reason}`;
                    }

                    levelReports.push({
                        id: 'N8',
                        name: 'Walk-forward',
                        color: n8Color,
                        weight: weightFor(levelWeights.walkForward),
                        strength: n8Strength,
                        score: directionValue(n8Color) * n8Strength,
                        details: n8Details,
                        disabled: false
                    });
                } else {
                    levelReports.push({
                        id: 'N8',
                        name: 'Walk-forward',
                        color: null,
                        weight: weightFor(levelWeights.walkForward),
                        strength: 0,
                        score: 0,
                        details: n8SummaryText || 'NULO',
                        disabled: false
                    });
                }
            } catch (e) {
                console.error('âŒ Erro em N8 dentro do modo Diamante:', e);
                levelReports.push({
                    id: 'N8',
                    name: 'Walk-forward',
                    color: null,
                    weight: weightFor(levelWeights.walkForward),
                    strength: 0,
                    score: 0,
                    details: 'Erro interno em N8',
                    disabled: false
                });
            }
        }

        // N1 - Zona Segura
        const n1Enabled = isLevelEnabledLocal('N1');
        let patternStrength = 0;
        let patternColor = null;
        let patternDetailsText = n1Enabled ? 'NULO' : 'DESATIVADO';
        if (n1Enabled && safeZoneMeta) {
            if (!safeZoneMeta.zoneActive) {
                patternDetailsText = safeZoneMeta.reason === 'insufficient_history'
                    ? 'HistÃ³rico insuficiente'
                    : 'Requisitos nÃ£o atendidos';
            } else {
                const dominantLabel = safeZoneMeta.dominant
                    ? `${safeZoneMeta.dominant.toUpperCase()} ${safeZoneMeta.counts[safeZoneMeta.dominant]}/${safeZoneMeta.windowSize}`
                    : 'Zona ativa';
                if (safeZoneMeta.signal && safeZoneVote && safeZoneVote.color) {
                    patternColor = safeZoneVote.color;
                    patternStrength = clamp01(safeZoneVote.confidence ?? safeZoneMeta.strength ?? 0.5);
                    const entriesInfo = safeZoneMeta.maxEntries
                        ? `${safeZoneMeta.entriesUsed}/${safeZoneMeta.maxEntries}`
                        : `${safeZoneMeta.entriesUsed || 0}`;
                    patternDetailsText = `DominÃ¢ncia ${dominantLabel} â€¢ entradas ${entriesInfo}`;
                } else {
                    if (safeZoneMeta.reason === 'entry_limit_reached') {
                        patternDetailsText = `DominÃ¢ncia ${dominantLabel} â€¢ limite atingido (${safeZoneMeta.entriesUsed}/${safeZoneMeta.maxEntries})`;
                    } else {
                        patternDetailsText = `DominÃ¢ncia ${dominantLabel} â€¢ aguardando confirmaÃ§Ã£o`;
                    }
                }
            }
        }
        levelReports.push({
            id: 'N1',
            name: 'Zona Segura',
            color: patternColor,
            weight: n1Enabled ? weightFor(levelWeights.patterns) : 0,
            strength: patternStrength,
            score: patternColor ? directionValue(patternColor) * patternStrength : 0,
            details: patternDetailsText,
            disabled: !n1Enabled,
            meta: safeZoneMeta
        });

        // N2 - Ritmo AutÃ´nomo
        const n2Enabled = isLevelEnabledLocal('N2');
        const redMomentum = Number(nivel5.momentum?.red ?? 0);
        const blackMomentum = Number(nivel5.momentum?.black ?? 0);
        const diffMomentum = (isFinite(redMomentum) && isFinite(blackMomentum)) ? Math.abs(redMomentum - blackMomentum) : 0;
        const momentumColor = n2Enabled ? (nivel5 && nivel5.color ? nivel5.color : null) : null;
        // âœ… forÃ§a do N2 deve refletir o quÃ£o "significativo" foi o ritmo (nÃ£o sÃ³ a diferenÃ§a bruta)
        let momentumStrength = (n2Enabled && momentumColor && typeof nivel5?.confidence === 'number')
            ? clamp01(nivel5.confidence)
            : 0;
        const momentumDetailsText = !n2Enabled
            ? 'DESATIVADO'
            : (nivel5 && nivel5.details ? nivel5.details : `Î” ${diffMomentum.toFixed(1)} pp (P2+)`);
        const momentumScore = (n2Enabled && momentumColor) ? directionValue(momentumColor) * momentumStrength : 0;
        levelReports.push({
            id: 'N2',
            name: 'Ritmo AutÃ´nomo',
            color: momentumColor,
            weight: n2Enabled ? weightFor(levelWeights.momentum) : 0,
            strength: n2Enabled ? momentumStrength : 0,
            score: momentumScore,
            details: momentumDetailsText,
            disabled: !n2Enabled
        });

        // N3 - AlternÃ¢ncia
        const n3Enabled = isLevelEnabledLocal('N3');
        const alternanceColor = n3Enabled && nivel7 && nivel7.color ? nivel7.color : null;
        let alternanceStrength = 0;
        let alternanceDetailsText = n3Enabled
            ? (nivel7 && nivel7.details ? nivel7.details : 'NULO')
            : 'DESATIVADO';
        const alternanceOverrideActive = n3Enabled && Boolean(nivel7 && nivel7.override && alternanceColor);
        if (n3Enabled && alternanceColor) {
            const baseConfidence = typeof nivel7.confidence === 'number' ? nivel7.confidence : (nivel7.probability || 0);
            alternanceStrength = alternanceOverrideActive ? 1 : clamp01(baseConfidence);
            const probLabel = nivel7.probabilityPct ? ` ${nivel7.probabilityPct}%` : ` ${Math.round(alternanceStrength * 100)}%`;
            const occLabel = nivel7.occurrences != null ? ` â€¢ ${nivel7.occurrences} ocorr.` : '';
            const windowLabel = nivel7.windowLabel ? ` â€¢ ${nivel7.windowLabel}` : '';
            alternanceDetailsText = `${(nivel7.pattern || 'AlternÃ¢ncia').toUpperCase()}${probLabel}${occLabel}${windowLabel}` +
                (alternanceOverrideActive ? ' â€¢ Override' : '');
        } else if (n3Enabled && nivel7 && nivel7.reason) {
            alternanceDetailsText = nivel7.reason;
        }
        levelReports.push({
            id: 'N3',
            name: 'AlternÃ¢ncia',
            color: alternanceColor,
            weight: n3Enabled ? weightFor(levelWeights.alternance) : 0,
            strength: n3Enabled ? alternanceStrength : 0,
            score: n3Enabled ? directionValue(alternanceColor) * alternanceStrength : 0,
            details: alternanceDetailsText,
            override: alternanceOverrideActive,
            disabled: !n3Enabled
        });

        // N4 - PersistÃªncia
        const n4Enabled = isLevelEnabledLocal('N4');
        const persistenceColor = n4Enabled && nivel9 && nivel9.color ? nivel9.color : null;
        let persistenceStrength = 0;
        let persistenceDetailsText = n4Enabled ? 'NULO' : 'DESATIVADO';
        if (n4Enabled && persistenceColor) {
            persistenceStrength = clamp01(nivel9.confidence ?? 0.5);
            persistenceDetailsText = `Seq ${nivel9.currentSequence} â€¢ mÃ©dia ${nivel9.averageSequence} (${Math.round(persistenceStrength * 100)}%)`;
        }
        levelReports.push({
            id: 'N4',
            name: 'PersistÃªncia',
            color: persistenceColor,
            weight: n4Enabled ? weightFor(levelWeights.persistence) : 0,
            strength: n4Enabled ? persistenceStrength : 0,
            score: n4Enabled ? directionValue(persistenceColor) * persistenceStrength : 0,
            details: persistenceDetailsText,
            disabled: !n4Enabled
        });

        // N5 - Ritmo por Giro (minuto/posiÃ§Ã£o)
        const n5Enabled = isLevelEnabledLocal('N5');
        const minuteSpinWindow = Math.max(10, Math.min(200, getDiamondWindow('n5MinuteBias', 60)));
        const minuteBiasResult = analyzeMinuteSpinBias(history, targetMinute, nextSpinPosition, minuteSpinWindow);
        const minuteBiasColor = n5Enabled && minuteBiasResult && minuteBiasResult.color ? minuteBiasResult.color : null;
        let minuteBiasStrength = clamp01(minuteBiasResult ? minuteBiasResult.confidence : 0);
        let minuteBiasDetailsText = n5Enabled ? (minuteBiasResult ? minuteBiasResult.details : 'NULO') : 'DESATIVADO';
        if (n5Enabled && minuteBiasResult && minuteBiasResult.totalSamples) {
            minuteBiasDetailsText += ` â€¢ ${minuteBiasResult.totalSamples} amostras`;
        }
		levelReports.push({
			id: 'N5',
			name: 'Ritmo por Giro',
			color: minuteBiasColor,
            weight: n5Enabled ? weightFor(levelWeights.minuteSpin) : 0,
			strength: n5Enabled ? minuteBiasStrength : 0,
			score: n5Enabled ? directionValue(minuteBiasColor) * minuteBiasStrength : 0,
			details: minuteBiasDetailsText,
            disabled: !n5Enabled
		});

		const n6Enabled = isLevelEnabledLocal('N6');
		const retracementWindow = Math.max(30, Math.min(120, getDiamondWindow('n6RetracementWindow', 80)));
		const retracementResult = analyzeHistoricalRetracement(history, retracementWindow, analyzerConfig.signalIntensity || 'aggressive');
		levelReports.push({
			id: 'N6',
			name: 'RetraÃ§Ã£o HistÃ³rica',
			color: n6Enabled ? retracementResult.color : null,
			weight: n6Enabled ? weightFor(levelWeights.retracement) : 0,
			strength: n6Enabled ? (retracementResult.strength || 0) : 0,
			score: n6Enabled ? directionValue(retracementResult.color) * (retracementResult.strength || 0) : 0,
			details: n6Enabled ? retracementResult.details : 'DESATIVADO',
            disabled: !n6Enabled
		});

		const n7Enabled = isLevelEnabledLocal('N7');
		const decisionWindowConfigured = Math.max(10, Math.min(50, getDiamondWindow('n7DecisionWindow', 20)));
		const historyWindowConfigured = Math.max(decisionWindowConfigured, Math.min(200, getDiamondWindow('n7HistoryWindow', 100)));
		const continuityResult = analyzeGlobalContinuity(signalsHistory, decisionWindowConfigured, historyWindowConfigured, analyzerConfig.signalIntensity || 'aggressive');
		levelReports.push({
			id: 'N7',
			name: 'Continuidade Global',
			color: n7Enabled ? continuityResult.color : null,
			weight: n7Enabled ? weightFor(levelWeights.globalContinuity) : 0,
			strength: n7Enabled ? (continuityResult.strength || 0) : 0,
			score: n7Enabled ? directionValue(continuityResult.color) * (continuityResult.strength || 0) : 0,
			details: n7Enabled ? continuityResult.details : 'DESATIVADO',
            disabled: !n7Enabled
		});

        const n10Enabled = isLevelEnabledLocal('N10');
        let bayesResult = null;
        if (!n10Enabled) {
            console.log('%câ•‘  ğŸ§® N10 - CALIBRAÃ‡ÃƒO BAYESIANA DESATIVADA (pelo usuÃ¡rio) â•‘', 'color: #777777; font-weight: bold; font-size: 14px;');
        } else {
            console.log('%câ•‘  ğŸ§® N10 - CALIBRAÃ‡ÃƒO BAYESIANA (PROBABILIDADES)         â•‘', 'color: #1ABC9C; font-weight: bold; font-size: 14px;');
        const bayesHistoryConfigured = Math.max(30, Math.min(400, getDiamondWindow('n9History', 100)));
        const bayesNullThresholdConfigured = Math.max(2, Math.min(20, getDiamondWindow('n9NullThreshold', 8)));
        const bayesPriorStrengthConfigured = Math.max(0.2, Math.min(5, getDiamondWindow('n9PriorStrength', 1)));
        const bayesPriorConfig = {
            red: bayesPriorStrengthConfigured,
            black: bayesPriorStrengthConfigured,
            white: Math.max(0.1, bayesPriorStrengthConfigured * 0.5)
        };
            bayesResult = analyzeBayesianCalibration(
            history,
            bayesHistoryConfigured,
            bayesPriorConfig,
            bayesNullThresholdConfigured / 100
        );

        console.log(`%c   HistÃ³rico base: ${bayesResult.totalSamples}/${bayesHistoryConfigured} giros (cobertura ${(bayesResult.coverage * 100).toFixed(0)}%)`, 'color: #1ABC9C;');
        console.log(`%c   Probabilidades â†’ ğŸ”´ ${(bayesResult.probabilities.red * 100).toFixed(1)}% | âš« ${(bayesResult.probabilities.black * 100).toFixed(1)}% | âšª ${(bayesResult.probabilities.white * 100).toFixed(2)}%`, 'color: #1ABC9C;');
        console.log(`%c   DiferenÃ§a lÃ­der: ${(bayesResult.gap * 100).toFixed(1)}% (limiar ${bayesNullThresholdConfigured.toFixed(1)}%)`, 'color: #1ABC9C;');
        if (!bayesResult.color) {
            console.log('%c   ğŸ›‘ VOTO NULO: Probabilidades prÃ³ximas ou cobertura baixa', 'color: #FFAA00; font-weight: bold;');
        } else {
            console.log(`%c   ğŸ—³ï¸ VOTA: ${bayesResult.color.toUpperCase()} â€¢ ForÃ§a ${(Math.round((bayesResult.strength || 0) * 100))}%`, 'color: #1ABC9C; font-weight: bold;');
            }
        }

        if (n10Enabled && bayesResult && bayesResult.adjustments) {
            levelReports.forEach(level => {
                if (!level.color) return;
                const factor = bayesResult.adjustments[level.color] ?? 1;
                const originalStrength = level.strength;
                const adjustedStrength = clamp01((level.strength || 0) * factor);
                level.strength = adjustedStrength;
                level.score = directionValue(level.color) * adjustedStrength;
                if (level.details) {
                    const factorPct = Math.round(factor * 100);
                    if (factorPct !== 100) {
                        level.details += ` â€¢ N9 ${factorPct}%`;
                    }
                }
                console.log(`%c   â€¢ Ajuste N9 ${level.id}: fator ${(factor * 100).toFixed(0)}% (de ${(originalStrength * 100).toFixed(0)}% â†’ ${(adjustedStrength * 100).toFixed(0)}%)`, 'color: #1ABC9C;');
            });
        }

        // âœ… CORREÃ‡ÃƒO: N10 Ã© apenas calibrador, NÃƒO vota sozinho
        // Ele ajusta a forÃ§a dos outros nÃ­veis, mas nÃ£o gera voto prÃ³prio
        const bayesStrength = clamp01(bayesResult && bayesResult.strength ? bayesResult.strength : 0);
        levelReports.push({
            id: 'N10',
            name: 'CalibraÃ§Ã£o Bayesiana',
            color: null, // âœ… N10 nunca vota, apenas calibra outros nÃ­veis
            weight: 0, // âœ… Peso zero = nÃ£o participa da votaÃ§Ã£o
            strength: 0, // âœ… ForÃ§a zero = nÃ£o influencia diretamente
            score: 0, // âœ… Score zero = nÃ£o vota
            details: n10Enabled ? bayesResult.details : 'DESATIVADO',
            disabled: !n10Enabled
        });

        // ğŸ”¥ NOVA LÃ“GICA: AlternÃ¢ncia precisa de pelo menos 2 outros nÃ­veis concordando
        let alternanceOverride = false;
        let alternanceBlocked = false;
        let alternanceBlockReason = '';
        
        if (alternanceOverrideActive && alternanceColor) {
            // Contar quantos outros nÃ­veis concordam com a cor da alternÃ¢ncia
            const otherLevelsAgreeingCount = levelReports.filter(lvl => 
                lvl.id !== 'N3' && lvl.id !== 'N9' && lvl.color === alternanceColor
            ).length;
            
            console.log('%cğŸ” Validando Override de AlternÃ¢ncia...', 'color: #8E44AD; font-weight: bold;');
            console.log(`   Cor da alternÃ¢ncia: ${alternanceColor.toUpperCase()}`);
			console.log(`   Outros nÃ­veis concordando: ${otherLevelsAgreeingCount}/8 (N1, N2, N4, N5, N6, N7, N9, N10)`);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ›¡ï¸ CONTROLE DE ENTRADAS: MÃ¡ximo 2 entradas por alternÃ¢ncia
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const alternanceSignature = `${nivel7.pattern}-${alternanceColor}`;
            const now = Date.now();
            
            // Verificar se Ã© a mesma alternÃ¢ncia que estÃ¡ ativa
            if (alternanceEntryControl.active && alternanceEntryControl.patternSignature === alternanceSignature) {
                console.log('%c   ğŸ“Š AlternÃ¢ncia jÃ¡ ativa:', 'color: #FFAA00; font-weight: bold;');
                console.log(`      Entradas feitas: ${alternanceEntryControl.entryCount}/2`);
                console.log(`      Ãšltimo resultado: ${alternanceEntryControl.lastResult || 'N/A'}`);
                console.log(`      Total: ${alternanceEntryControl.totalWins}W / ${alternanceEntryControl.totalLosses}L`);
                
                // ğŸ”¥ REGRA 1: Se teve LOSS na primeira entrada â†’ BLOQUEAR IMEDIATAMENTE
                if (alternanceEntryControl.lastResult === 'loss' && alternanceEntryControl.entryCount === 1) {
                    alternanceBlocked = true;
                    alternanceBlockReason = 'LOSS na 1Âª entrada â†’ bloqueado';
                    console.log('%c   âŒ BLOQUEADO: LOSS na primeira entrada!', 'color: #FF0000; font-weight: bold;');
                    console.log('%c      Sistema nÃ£o farÃ¡ mais entradas nesta alternÃ¢ncia.', 'color: #FF6666;');
                }
                // ğŸ”¥ REGRA 2: JÃ¡ fez 2 entradas â†’ LIMITE ATINGIDO
                else if (alternanceEntryControl.entryCount >= 2) {
                    alternanceBlocked = true;
                    alternanceBlockReason = `Limite de 2 entradas atingido`;
                    console.log('%c   âŒ BLOQUEADO: Limite de 2 entradas atingido!', 'color: #FF0000; font-weight: bold;');
                }
                // âœ… REGRA 3: WIN na 1Âª + tem entradas consecutivas configuradas â†’ Pode fazer 2Âª
                else if (alternanceEntryControl.lastResult === 'win' && alternanceEntryControl.entryCount === 1) {
                    const { consecutiveMartingale: allowsConsecutiveEntries } = getMartingaleSettings();
                    if (!allowsConsecutiveEntries) {
                        alternanceBlocked = true;
                        alternanceBlockReason = 'Entradas consecutivas desativadas';
                        console.log('%c   â¸ï¸ BLOQUEADO: Entradas consecutivas desativadas pelo usuÃ¡rio', 'color: #FFAA00; font-weight: bold;');
        } else {
                        console.log('%c   âœ… PERMITIDO: WIN na 1Âª entrada + consecutivas ativas â†’ pode fazer 2Âª', 'color: #00FF88; font-weight: bold;');
                    }
                }
            } else {
                // Nova alternÃ¢ncia detectada
                console.log('%c   ğŸ†• Nova alternÃ¢ncia detectada!', 'color: #00AAFF; font-weight: bold;');
            }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            if (alternanceBlocked) {
                console.log('%c   ğŸš« AlternÃ¢ncia BLOQUEADA:', alternanceBlockReason, 'color: #FF6666; font-weight: bold;');
            } else if (otherLevelsAgreeingCount >= 2) {
                alternanceOverride = true;
                console.log('%c   âœ… Override APROVADO! Pelo menos 2 nÃ­veis concordam.', 'color: #00FF88; font-weight: bold;');
                console.log('%c   âš¡ Anulando outros nÃ­veis...', 'color: #8E44AD; font-weight: bold;');
                
                levelReports.forEach(lvl => {
                    if (lvl.id !== 'N3' && lvl.id !== 'N6') {
                        lvl.details += ' â€¢ Anulado (AlternÃ¢ncia)';
                        lvl.score = 0;
                        lvl.strength = 0;
                    }
                });
                
                // ğŸ¯ ATIVAR CONTROLE DE ALTERNÃ‚NCIA (se ainda nÃ£o estiver ativo)
                if (!alternanceEntryControl.active || alternanceEntryControl.patternSignature !== alternanceSignature) {
                    alternanceEntryControl.active = true;
                    alternanceEntryControl.patternSignature = alternanceSignature;
                    alternanceEntryControl.entryColor = alternanceColor;
                    alternanceEntryControl.entryCount = 1; // Primeira entrada
                    alternanceEntryControl.lastResult = null; // Aguardando resultado
                    alternanceEntryControl.lastEntryTimestamp = now;
                    console.log('%c   ğŸ¯ Controle de alternÃ¢ncia ATIVADO (1Âª entrada)', 'color: #00FF88; font-weight: bold;');
        } else {
                    // Incrementar contador para 2Âª entrada
                    alternanceEntryControl.entryCount = 2;
                    alternanceEntryControl.lastEntryTimestamp = now;
                    console.log('%c   ğŸ¯ Controle de alternÃ¢ncia: 2Âª entrada registrada', 'color: #00FF88; font-weight: bold;');
                }
            } else {
                console.log('%c   âŒ Override REJEITADO! Menos de 2 nÃ­veis concordam.', 'color: #FF6666; font-weight: bold;');
                console.log('%c   â¤ AlternÃ¢ncia detectada, mas sem consenso suficiente dos outros nÃ­veis.', 'color: #FFAA00;');
                console.log('%c   â¤ Sistema continuarÃ¡ com votaÃ§Ã£o normal.', 'color: #FFAA00;');
            }
        }

        if (n0ForceWhite) {
            console.log('%câšª N0 FORÃ‡OU BLOQUEIO TOTAL DOS DEMAIS NÃVEIS - SINAL BRANCO!', 'color: #FFFFFF; font-weight: bold; font-size: 16px; background: #000000;');
            levelReports.sort((a, b) => {
                const aIndex = displayOrder.indexOf(a.id);
                const bIndex = displayOrder.indexOf(b.id);
                const safeA = aIndex === -1 ? displayOrder.length : aIndex;
                const safeB = bIndex === -1 ? displayOrder.length : bIndex;
                return safeA - safeB;
            });

            if (intervalBlocked) {
                sendAnalysisStatus(intervalMessage || 'â³ Aguardando intervalo configurado...');
                await sleep(2000);
                await restoreIAStatus();
                console.log('%c   âŒ SINAL CANCELADO PELO INTERVALO!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
                return null;
            }

            const whiteConfidencePct = Math.max(0, Math.min(100, Math.round(n0WhiteStrength * 100)));
            const thresholdPct = n0Result && n0Result.blocking_threshold != null
                ? Math.round(n0Result.blocking_threshold * 100)
                : null;

            sendAnalysisStatus(`âšª N0 - Detector de Branco: BLOCK ALL (${whiteConfidencePct}%${thresholdPct !== null ? ` â€¢ t* ${thresholdPct}%` : ''})${n0ActionSuppressed ? ' (informativo)' : ''}`);
            await sleep(2000);
            if (analyzerConfig.aiMode) {
                sendAnalysisStatus('Sinal de entrada');
            } else {
                sendAnalysisStatus(`âœ… Sinal aprovado: WHITE (${whiteConfidencePct}%)`);
            }
            await sleep(2000);

            const scoreSummary = levelReports.map(level => ({
                id: level.id,
                name: level.name,
                color: level.color,
                strength: Number((level.strength || 0).toFixed(3)),
                weight: Number((level.weight || 0).toFixed(3)),
                contribution: Number(((level.score || 0) * (level.weight || 0)).toFixed(3)),
                details: level.details
            }));

            const bestMetrics = n0Result && n0Result.best_metrics ? n0Result.best_metrics : {};
            const blockMetrics = n0Result && n0Result.blocking_metrics ? n0Result.blocking_metrics : {};
            const holdoutReasoning = n0Result && n0Result.holdout && n0Result.holdout.enabled
                ? `Holdout: ${n0Result.holdout.passed ? 'OK' : 'Falhou'}${n0Result.holdout.reason ? ` (${n0Result.holdout.reason})` : ''}\n`
                : '';
            const reasoning =
                `${levelReports.map(level => describeLevel(level, { includeEmoji: false })).join('\n')}\n` +
                `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
                `Detector de Branco\n` +
                `ConfianÃ§a: ${whiteConfidencePct}%\n` +
                `t*: ${thresholdPct !== null ? `${thresholdPct}%` : 'n/d'} â€¢ F1 ${(bestMetrics.f1 != null ? (bestMetrics.f1 * 100).toFixed(1) : 'n/d')}% â€¢ Precision* ${(blockMetrics.precision != null ? (blockMetrics.precision * 100).toFixed(1) : 'n/d')}%\n` +
                holdoutReasoning +
                `Configs: ${n0Result && n0Result.effective_configs != null ? `${n0Result.effective_configs}/${n0Result.tested_configs}` : (n0Result && n0Result.tested_configs != null ? n0Result.tested_configs : 'n/d')}\n` +
                `AÃ§Ã£o: BLOCK ALL${n0ActionSuppressed ? ' (modo informativo)' : ''}`;

            const signal = {
                timestamp: Date.now(),
                patternType: 'nivel-diamante',
                patternName: 'Detector de Branco (N0)',
                colorRecommended: 'white',
                normalizedScore: Number(n0WhiteStrength.toFixed(4)),
                scoreMagnitude: Number(n0WhiteStrength.toFixed(4)),
                intensityMode: analyzerConfig.signalIntensity || 'aggressive',
                rawConfidence: whiteConfidencePct,
                finalConfidence: whiteConfidencePct,
                levelBreakdown: scoreSummary,
                reasoning,
                verified: false,
                colorThatCame: null,
                hit: null
            };

            if (signalsHistory && signalsHistory.signals) {
                signalsHistory.signals.push(signal);
                if (signalsHistory.signals.length > 200) {
                    signalsHistory.signals = signalsHistory.signals.slice(-200);
                }
                await saveSignalsHistory();
            }

            if (!memoriaAtiva.inicializada) {
                memoriaAtiva.inicializada = true;
                memoriaAtiva.ultimaAtualizacao = Date.now();
                memoriaAtiva.totalAtualizacoes = 1;
                memoriaAtiva.giros = history.slice(0, 2000);
                console.log('%câœ… MemÃ³ria Ativa marcada como INICIALIZADA!', 'color: #00FF00; font-weight: bold;');
            } else {
                memoriaAtiva.totalAtualizacoes++;
                memoriaAtiva.ultimaAtualizacao = Date.now();
            }

            return {
                color: 'white',
                confidence: whiteConfidencePct,
                probability: whiteConfidencePct,
                reasoning,
                patternDescription: 'Detector de Branco (N0)'
            };
        }

        const scoreWithoutBarrier = levelReports.reduce((sum, lvl) => sum + (lvl.score * lvl.weight), 0);
        if (n0SoftBlockActive) {
            console.log('%câš ï¸ Soft block ativo: pesos dos nÃ­veis reduzidos em 50% para este giro', 'color: #FFAA00; font-weight: bold;');
        }
        let predictedColor = scoreWithoutBarrier === 0
            ? (minuteBiasColor || momentumColor || patternColor || 'red')
            : (scoreWithoutBarrier >= 0 ? 'red' : 'black');

        if (alternanceOverride) {
            predictedColor = alternanceColor;
        }
        const n9Enabled = isLevelEnabledLocal('N9');
        let barrierResult = {
            allowed: true,
            currentStreak: 0,
            targetStreak: 0,
            maxStreakFound: 0,
            reason: 'Desativado pelo usuÃ¡rio',
            alternanceBlocked: false
        };
        let barrierDetailsText = 'DESATIVADO';
        let barrierStrength = 0;

        if (!n9Enabled) {
            console.log('%câ•‘  ğŸ›‘ N9 - BARREIRA FINAL DESATIVADA (pelo usuÃ¡rio)       â•‘', 'color: #777777; font-weight: bold; font-size: 14px;');
        } else {
        console.log('%câ•‘  ğŸ›‘ NÃVEL 6: BARREIRA/FREIO (VALIDAÃ‡ÃƒO FINAL)          â•‘', 'color: #FF0000; font-weight: bold; font-size: 14px;');
        console.log(`%cğŸ¯ Cor candidata antes da barreira: ${predictedColor.toUpperCase()}`, `color: ${predictedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
        console.log(`%cğŸ“Š ConfiguraÃ§Ã£o: ${historySize} giros para anÃ¡lise`, 'color: #FF0000;');

            barrierResult = validateSequenceBarrier(history, predictedColor, getDiamondWindow('n8Barrier', historySize), {
            override: alternanceOverrideActive,
            targetRuns: nivel7 ? nivel7.alternanceTargetRuns : null,
            maxRuns: nivel7 ? nivel7.alternanceMaxRuns : null
        });
            const alternanceSummaryText = nivel7 && nivel7.details ? nivel7.details : 'AlternÃ¢ncia em anÃ¡lise';
            barrierDetailsText = barrierResult.alternanceBlocked
            ? `AlternÃ¢ncia bloqueada â€¢ ${alternanceSummaryText}`
            : `Atual ${barrierResult.currentStreak} â€¢ alvo ${barrierResult.targetStreak} â€¢ mÃ¡x ${barrierResult.maxStreakFound}`;

        // ğŸ”¥ VERIFICAR SE ALTERNÃ‚NCIA ESTÃ BLOQUEADA
        if (alternanceBlocked && alternanceOverrideActive) {
            console.log('%cğŸš«ğŸš«ğŸš« SINAL BLOQUEADO - CONTROLE DE ALTERNÃ‚NCIA! ğŸš«ğŸš«ğŸš«', 'color: #FFFFFF; font-weight: bold; font-size: 16px; background: #FF0000;');
            console.log(`%c   Motivo: ${alternanceBlockReason}`, 'color: #FF6666; font-weight: bold;');
            await emitLevelStatuses(levelReports, { force: true });
            sendAnalysisStatus(`ğŸ›‘ N3 - AlternÃ¢ncia â†’ âŒ BLOQUEADO (${alternanceBlockReason})`);
            await sleep(1500);
            sendAnalysisStatus('âŒ Sinal rejeitado: limite de entradas de alternÃ¢ncia');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }
        const streakGap = barrierResult.maxStreakFound - barrierResult.targetStreak;
        if (barrierResult.allowed) {
            barrierStrength = 0.4;
        if (streakGap >= 2) {
            barrierStrength = 0.6;
        } else if (streakGap === 1) {
            barrierStrength = 0.5;
        }
        }
        }
        const barrierStatusLabel = barrierResult.allowed ? 'APROVADO' : 'BLOQUEADO';
        
        // âœ… CORREÃ‡ÃƒO: N9 Ã© apenas validador, NÃƒO vota
        // Verificar se hÃ¡ votos de outros nÃ­veis (excluindo N0, N9 e N10)
        const otherLevelsVoting = levelReports.filter(lvl => 
            lvl.id !== 'N0' && lvl.id !== 'N9' && lvl.id !== 'N10' && 
            !lvl.disabled && lvl.color && (lvl.strength || 0) > 0
        );
        const hasOtherVotes = otherLevelsVoting.length > 0;
        
        levelReports.push({
            id: 'N9',
            name: 'Barreira Final',
            color: null, // âœ… N9 nunca vota, apenas valida
            weight: 0, // âœ… Peso zero = nÃ£o participa da votaÃ§Ã£o
            strength: 0, // âœ… ForÃ§a zero = nÃ£o influencia
            score: 0, // âœ… Score zero = nÃ£o vota
            details: n9Enabled ? `${barrierStatusLabel} â€¢ ${barrierDetailsText}` : 'DESATIVADO',
            disabled: !n9Enabled
        });

        levelReports.sort((a, b) => {
            const aIndex = displayOrder.indexOf(a.id);
            const bIndex = displayOrder.indexOf(b.id);
            const safeA = aIndex === -1 ? displayOrder.length : aIndex;
            const safeB = bIndex === -1 ? displayOrder.length : bIndex;
            return safeA - safeB;
        });

        const summaryStyle = 'color: #00FFFF; font-weight: bold;';
        console.log('%câ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', summaryStyle);
        console.log('%câ•‘  ğŸ’ NÃVEIS DIAMANTE - CONSOLIDADO                         â•‘', summaryStyle);
        displayOrder.forEach(id => {
            const level = levelReports.find(lvl => lvl.id === id);
            let description;
            if (level) {
                description = describeLevel(level);
            } else {
                const meta = levelMeta[id] || { emoji: 'â–«ï¸', label: `${id}` };
                description = `${meta.emoji} ${meta.label} â†’ N/A`;
            }
            console.log(`%câ•‘  ${description}`, summaryStyle);
        });
        console.log('%câ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', summaryStyle);

        if (!barrierResult.allowed) {
            console.log('%cğŸš«ğŸš«ğŸš« SINAL BLOQUEADO PELA BARREIRA! ğŸš«ğŸš«ğŸš«', 'color: #FFFFFF; font-weight: bold; font-size: 16px; background: #FF0000;');
            console.log('%c   SequÃªncia sem precedente histÃ³rico!', 'color: #FF6666; font-weight: bold;');
        await emitLevelStatuses(levelReports, { force: true });
        sendAnalysisStatus(`N9 - Barreira Final: BLOQUEADO (${barrierDetailsText})`);
        await sleep(2000);
            await restoreIAStatus();
            console.log('%c   âŒ SINAL CANCELADO!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
            return null;
        }

        console.log('%câœ… BARREIRA LIBERADA! SequÃªncia Ã© viÃ¡vel.', 'color: #00FF88; font-weight: bold; font-size: 14px;');
        
        // âœ… VERIFICAÃ‡ÃƒO CRÃTICA: Se apenas N9/N10 estÃ£o ativos (sem outros nÃ­veis votando), cancelar sinal
        const votingLevelsOnly = levelReports.filter(lvl => 
            lvl.id !== 'N0' && lvl.id !== 'N9' && lvl.id !== 'N10' && 
            !lvl.disabled && lvl.color && (lvl.strength || 0) > 0
        );
        
        if (votingLevelsOnly.length === 0) {
            console.log('%cğŸš« NENHUM NÃVEL VOTANTE ATIVO (apenas barreiras N9/N10)', 'color: #FF6666; font-weight: bold; font-size: 16px;');
            console.log('%c   N9 e N10 sÃ£o apenas validadores, nÃ£o podem votar sozinhos!', 'color: #FF6666; font-weight: bold;');
            console.log('%c   âŒ SINAL CANCELADO - sem votos vÃ¡lidos dos nÃ­veis 1-8', 'color: #FF0000; font-weight: bold;');
            sendAnalysisStatus('âŒ Sem votos: apenas barreiras ativas (N9/N10 nÃ£o votam sozinhas)');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }
        
        const totalWeight = levelReports.reduce((sum, lvl) => sum + lvl.weight, 0);
        let weightedScore = totalWeight ? levelReports.reduce((sum, lvl) => sum + (lvl.score * lvl.weight), 0) : 0;
        if (alternanceOverride) {
            weightedScore = directionValue(alternanceColor) * totalWeight;
        }
        let normalizedScore = totalWeight ? weightedScore / totalWeight : 0;
        if (alternanceOverride) {
            normalizedScore = directionValue(alternanceColor);
        }
        const scoreMagnitude = Math.abs(normalizedScore);

        let signalIntensity = analyzerConfig.signalIntensity === 'conservative' ? 'conservative' : 'aggressive';
        const votingLevelIds = ['N1','N2','N3','N4','N5','N6','N7','N8'];
        const allVotingLevelsEnabled = votingLevelIds.every(id => diamondLevelEnabledMap[id]);

        console.log('%câ•‘  ğŸšï¸ INTENSIDADE / CONSENSO                              â•‘', 'color: #9C27B0; font-weight: bold; font-size: 14px;');
        console.log(`%c   Modo selecionado: ${signalIntensity === 'conservative' ? 'Conservador' : 'Agressivo'}`, 'color: #9C27B0; font-weight: bold;');

        if (signalIntensity === 'conservative' && !allVotingLevelsEnabled) {
            console.log('%câš ï¸ Conservador indisponÃ­vel: nem todos os nÃ­veis N1-N8 estÃ£o ativos. Revertendo para Agressivo.', 'color: #FFAA00; font-weight: bold;');
            signalIntensity = 'aggressive';
        }

        if (intervalBlocked) {
            sendAnalysisStatus(intervalMessage || 'â³ Aguardando intervalo configurado...');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }

		const votingLevelsList = levelReports.filter(lvl => lvl.id !== 'N6' && lvl.id !== 'N0' && !lvl.disabled);
		const positiveVotingLevels = votingLevelsList.filter(lvl => lvl.color && (lvl.strength || 0) > 0);
		const negativeVotingLevels = votingLevelsList.filter(lvl => lvl.color && (lvl.strength || 0) < 0);
		const neutralVotingLevels = votingLevelsList.filter(lvl => !lvl.color || (lvl.strength || 0) === 0);

        const voteCounts = { red: 0, black: 0 };
        positiveVotingLevels.forEach(lvl => {
            if (lvl.color === 'red') voteCounts.red++;
            if (lvl.color === 'black') voteCounts.black++;
        });

        const totalVotes = voteCounts.red + voteCounts.black;
        if (totalVotes === 0) {
            console.log('%câŒ Nenhum voto vÃ¡lido dos nÃ­veis votantes. Sinal cancelado.', 'color: #FF6666; font-weight: bold;');
            sendAnalysisStatus('âŒ Sem votos vÃ¡lidos (N1-N8)');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }

        if (voteCounts.red === voteCounts.black) {
            console.log('%câš ï¸ Empate entre as cores. Sinal anulado.', 'color: #FFAA00; font-weight: bold;');
            sendAnalysisStatus('âŒ Empate entre cores');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }

        let consensusColor = voteCounts.red > voteCounts.black ? 'red' : 'black';

        if (signalIntensity === 'conservative') {
            if (voteCounts[consensusColor] < 5) {
                console.log(`%câŒ Conservador: apenas ${voteCounts[consensusColor]}/5 votos para ${consensusColor.toUpperCase()}.`, 'color: #FF6666; font-weight: bold;');
                sendAnalysisStatus(`âŒ Conservador: mÃ­nimo 5 votos (${voteCounts[consensusColor]}/5)`);
                await sleep(2000);
                await restoreIAStatus();
                return null;
            }

            if (!n9Enabled) {
                console.log('%câŒ Conservador: Barreira Final (N9) precisa estar ativa.', 'color: #FF6666; font-weight: bold;');
                sendAnalysisStatus('âŒ Conservador: ative a Barreira Final (N9)');
                await sleep(2000);
                await restoreIAStatus();
                return null;
            }

            if (!barrierResult.allowed) {
                console.log('%câŒ Conservador: Barreira Final bloqueou o sinal.', 'color: #FF6666; font-weight: bold;');
                sendAnalysisStatus('âŒ Conservador: Barreira Final bloqueou');
                await sleep(2000);
                await restoreIAStatus();
                return null;
            }

            const bayesApproves = n10Enabled && bayesResult && bayesResult.color && bayesResult.color === consensusColor;
            if (!n10Enabled || !bayesApproves) {
                console.log('%câŒ Conservador: CalibraÃ§Ã£o Bayesiana (N10) nÃ£o autorizou.', 'color: #FF6666; font-weight: bold;');
                sendAnalysisStatus('âŒ Conservador: N10 nÃ£o autorizou');
                await sleep(2000);
                await restoreIAStatus();
                return null;
            }
        }

        finalColor = consensusColor;
        predictedColor = finalColor;

        const maxVotingSlots = votingLevelsList.length;
        const winningVotes = voteCounts[finalColor];
        const voteTotals = {
            red: voteCounts.red,
            black: voteCounts.black,
            neutral: neutralVotingLevels.length,
            negative: negativeVotingLevels.length
        };

        console.log(`%cğŸ—³ï¸ Contagem de votos â†’ ğŸ”´ ${voteCounts.red} | âš« ${voteCounts.black}`, 'color: #9C27B0; font-weight: bold;');

        let rawConfidence = Math.round((winningVotes / Math.max(1, maxVotingSlots)) * 100);
        rawConfidence = Math.max(0, Math.min(100, rawConfidence));
        let finalConfidence = applyCalibratedConfidence(rawConfidence);
        finalConfidence = Math.max(0, Math.min(100, Math.round(finalConfidence)));

        console.log('%cğŸ“Š SCORE DOS NÃVEIS ATIVOS:', 'color: #FFD700; font-weight: bold; font-size: 16px;');
        levelReports.forEach(level => {
            const contribution = (level.score * level.weight);
            console.log(`%c${describeLevel(level)} â€¢ contribuiÃ§Ã£o ${(contribution >= 0 ? '+' : '')}${contribution.toFixed(3)}`, 'color: #FFD700;');
        });
        console.log(`%cğŸ¯ COR FINAL: ${finalColor.toUpperCase()}`, `color: ${finalColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 16px;`);
        console.log(`%cğŸ“ˆ Score normalizado: ${(normalizedScore * 100).toFixed(1)}%`, 'color: #00FFFF; font-weight: bold;');
        console.log(`%cğŸ“Š ConfianÃ§a bruta: ${rawConfidence}% â€¢ calibrada: ${finalConfidence}%`, 'color: #FFD700; font-weight: bold;');

        if (analyzerConfig.aiMode) {
            sendAnalysisStatus('Sinal de entrada');
        } else {
            sendAnalysisStatus(`âœ… Sinal aprovado: ${finalColor.toUpperCase()} (score ${(scoreMagnitude * 100).toFixed(1)}%)`);
        }

        const scoreSummary = levelReports.map(level => ({
            id: level.id,
            name: level.name,
            color: level.color,
            strength: Number(level.strength.toFixed(3)),
            weight: Number(level.weight.toFixed(3)),
            contribution: Number((level.score * level.weight).toFixed(3)),
            details: level.details
        }));

        const intensityLabel = signalIntensity === 'conservative' ? 'Conservador' : 'Agressivo';
        const reasoning =
            `${levelReports.map(level => describeLevel(level, { includeEmoji: false })).join('\n')}\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `Modo: ${intensityLabel}\n` +
            `Score combinado: ${(normalizedScore * 100).toFixed(1)}%\n` +
            `DECISÃƒO: ${finalColor.toUpperCase()}\n` +
            `ConfianÃ§a: ${finalConfidence}%`;

        console.log('%cğŸ§  RACIOCÃNIO COMPLETO:', 'color: #00FFFF; font-weight: bold; font-size: 14px;');
        console.log(`%c${reasoning}`, 'color: #00FFFF;');
        
        const signal = {
            timestamp: Date.now(),
            patternType: 'nivel-diamante',
            patternName: patternDescription,
            colorRecommended: finalColor,
            normalizedScore: Number(normalizedScore.toFixed(4)),
            scoreMagnitude: Number(scoreMagnitude.toFixed(4)),
            intensityMode: signalIntensity,
            rawConfidence,
            finalConfidence,
            levelBreakdown: scoreSummary,
            reasoning,
            verified: false,
            colorThatCame: null,
            hit: null
        };

        if (signalsHistory && signalsHistory.signals) {
            signalsHistory.signals.push(signal);
            if (signalsHistory.signals.length > 200) {
                signalsHistory.signals = signalsHistory.signals.slice(-200);
            }
            await saveSignalsHistory();
        }

        if (!memoriaAtiva.inicializada) {
            memoriaAtiva.inicializada = true;
            memoriaAtiva.ultimaAtualizacao = Date.now();
            memoriaAtiva.totalAtualizacoes = 1;
            memoriaAtiva.giros = history.slice(0, 2000);
            console.log('%câœ… MemÃ³ria Ativa marcada como INICIALIZADA!', 'color: #00FF00; font-weight: bold;');
        } else {
            memoriaAtiva.totalAtualizacoes++;
            memoriaAtiva.ultimaAtualizacao = Date.now();
        }

        return {
            color: finalColor,
            confidence: finalConfidence,
            probability: finalConfidence,
            reasoning: reasoning,
            patternDescription: patternDescription,
            safeZone: safeZoneMeta
        };

        /* LEGACY VOTING BLOCK (COMENTADO)
        
        console.log(`%cğŸ¯ Cor vencedora da votaÃ§Ã£o: ${finalColor.toUpperCase()}`, `color: ${finalColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
        console.log(`%cğŸ“Š ConfiguraÃ§Ã£o: ${historySize} giros para anÃ¡lise`, 'color: #FF0000;');
        
        const barrierResult = validateSequenceBarrier(history, finalColor, getDiamondWindow('n8Barrier', historySize), {
            override: alternanceOverrideActive,
            targetRuns: nivel7 ? nivel7.alternanceTargetRuns : null,
            maxRuns: nivel7 ? nivel7.alternanceMaxRuns : null
        });
        
        console.log(`%c   SequÃªncia atual: ${barrierResult.currentStreak} ${finalColor} consecutivos`, 'color: #FF0000;');
        console.log(`%c   PrÃ³xima: ${barrierResult.targetStreak} ${finalColor} consecutivos`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c   MÃ¡ximo histÃ³rico: ${barrierResult.maxStreakFound} ${finalColor} consecutivos`, 'color: #FF0000;');
        console.log(`%c${barrierResult.reason}`, barrierResult.allowed ? 'color: #00FF88; font-weight: bold;' : 'color: #FF6666; font-weight: bold;');
        
    // âš¡ VERIFICAÃ‡ÃƒO: Se NÃ­vel 6 bloqueou, MOSTRAR FASES COM DELAY antes de rejeitar
    if (!barrierResult.allowed) {
        console.log('%cğŸš«ğŸš«ğŸš« SINAL BLOQUEADO PELA BARREIRA! ğŸš«ğŸš«ğŸš«', 'color: #FFFFFF; font-weight: bold; font-size: 16px; background: #FF0000;');
        console.log('%c   SequÃªncia sem precedente histÃ³rico!', 'color: #FF6666; font-weight: bold;');
        console.log('%c   âŒ SINAL SERÃ REJEITADO - Mostrando anÃ¡lise ao usuÃ¡rio...', 'color: #FF0000; font-weight: bold; font-size: 14px;');
        
        // âœ… MOSTRAR AS 6 FASES COM DELAY (para o usuÃ¡rio ver o processo)
        // âŒ NÃ­veis 1, 2, 3 removidos (nÃ£o mostrar mais)
        
        if (!safeZoneMeta || !safeZoneMeta.zoneActive) {
            sendAnalysisStatus(`ğŸ¯ N1 - Zona Segura â†’ NULO`);
        } else if (!analyzerConfig.aiMode) {
            const statusLabel = safeZoneMeta.signal && safeZoneVote && safeZoneVote.color
                ? `${safeZoneMeta.dominant?.toUpperCase() || '-'}` 
                : 'Ativa â€¢ aguardando';
            sendAnalysisStatus(`ğŸ¯ N1 - Zona Segura â†’ ${statusLabel}`);
        }
        await sleep(1500);
        
        const trendLabel = nivel5.trending === 'accelerating_red' ? 'Acelerando' : nivel5.trending === 'accelerating_black' ? 'Acelerando' : 'EstÃ¡vel';
            if (!analyzerConfig.aiMode) {
                sendAnalysisStatus(`âš¡ N2 - Ritmo AutÃ´nomo â†’ ${nivel5.color ? nivel5.color.toUpperCase() : 'NULO'} (${nivel5.details || nivel5.reason || 'sem sinal'})`);
            }
        await sleep(1500);
        
        if (nivel7 && nivel7.color) {
            const overrideLabel = nivel7.override ? ' (override)' : '';
            if (!analyzerConfig.aiMode) {
                sendAnalysisStatus(`ğŸ”· N3 - AlternÃ¢ncia${overrideLabel} â†’ ${nivel7.color.toUpperCase()}`);
            }
        } else {
            if (!analyzerConfig.aiMode) {
                sendAnalysisStatus(`ğŸ”· N3 - AlternÃ¢ncia â†’ NULO`);
            }
        }
        await sleep(1500);
        
            if (!analyzerConfig.aiMode) {
            if (!n4Enabled) {
                sendAnalysisStatus(`ğŸ”· N4 - PersistÃªncia â†’ DESATIVADO`);
            } else if (nivel9 && nivel9.color) {
                sendAnalysisStatus(`ğŸ”· N4 - PersistÃªncia â†’ ${nivel9.color.toUpperCase()}`);
        } else {
                sendAnalysisStatus(`ğŸ”· N4 - PersistÃªncia â†’ NULO`);
            }
        }
        await sleep(1500);
        
            if (!analyzerConfig.aiMode) {
            if (!n5Enabled) {
                sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ DESATIVADO`);
            } else if (minuteBiasColor) {
                sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ ${minuteBiasColor.toUpperCase()}`);
        } else {
                sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ NULO`);
            }
        } else if (!minuteBiasColor) {
            sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ NULO`);
        }
        await sleep(1500);
        
        if (!n9Enabled) {
            sendAnalysisStatus(`ğŸ›‘ N9 - Barreira Final â†’ DESATIVADO`);
        } else {
        const barrierStatusText = barrierResult.alternanceBlocked
            ? 'ğŸš« BLOQUEADO (AlternÃ¢ncia)'
            : 'âŒ BLOQUEADO';
            sendAnalysisStatus(`ğŸ›‘ N9 - Barreira Final â†’ ${barrierStatusText}`);
        }
        await sleep(1500);
        
        // âœ… Mostrar motivo do bloqueio
        sendAnalysisStatus(`âŒ Sinal rejeitado: Sem precedente histÃ³rico`);
        await sleep(2000);
        
        // âœ… Restaurar status "IA ativada"
        await restoreIAStatus();
        
        console.log('%c   âŒ SINAL CANCELADO!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
        return null;
    }
    
    // âš¡ Barreira aprovada - NÃƒO EXIBIR ainda (anÃ¡lise rÃ¡pida, mostraremos depois se for rejeitado depois)
        
        console.log('%câœ… BARREIRA LIBERADA! SequÃªncia Ã© viÃ¡vel.', 'color: #00FF88; font-weight: bold; font-size: 14px;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			const prefix = continuityResult.strength > 0 ? 'ReforÃ§o' : 'ReduÃ§Ã£o';
			sendAnalysisStatus(`ğŸ“ˆ N7 - Continuidade Global â†’ ${continuityResult.color.toUpperCase()} (${prefix})`);
		} else {
			sendAnalysisStatus(`ğŸ“ˆ N7 - Continuidade Global â†’ NULO`);
		}
		await sleep(1500);

        if (!n9Enabled) {
            sendAnalysisStatus('ğŸ›‘ N9 - Barreira Final â†’ DESATIVADO');
        } else {
        const barrierStatusText2 = barrierResult.alternanceBlocked
            ? 'ğŸš« BLOQUEADO (AlternÃ¢ncia)'
            : barrierResult.allowed ? 'âœ… APROVADO' : 'ğŸš« BLOQUEADO';
            sendAnalysisStatus(`ğŸ›‘ N9 - Barreira Final â†’ ${barrierStatusText2}`);
        }
        await sleep(1500);
        
        console.log('%câœ… CONSENSO ATINGIDO! Intensidade aprovada.', 'color: #00FF88; font-weight: bold; font-size: 14px;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â±ï¸ VERIFICAÃ‡ÃƒO FINAL: INTERVALO BLOQUEADO?
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (intervalBlocked) {
        console.log('%câ•‘  ğŸš« SINAL BLOQUEADO - INTERVALO INSUFICIENTE!            â•‘', 'color: #FFAA00; font-weight: bold; font-size: 14px;');
        console.log(`%câ•‘  âœ… AnÃ¡lise dos ${activeLevelsSummary} nÃ­veis ativos foi executada com sucesso      â•‘`, 'color: #00FF88;');
        console.log('%câ•‘  âœ… Sistema recomendaria: ' + finalColor.toUpperCase().padEnd(34) + 'â•‘', 'color: #FFD700;');
        console.log('%câ•‘  ğŸš« MAS sinal nÃ£o serÃ¡ enviado (aguarde intervalo)       â•‘', 'color: #FFAA00;');
        
        // âœ… MOSTRAR AS 6 FASES COM DELAY (para o usuÃ¡rio ver o processo)
        // âŒ NÃ­veis 1, 2, 3 removidos (nÃ£o mostrar mais)
        
        if (!safeZoneMeta || !safeZoneMeta.zoneActive) {
            sendAnalysisStatus(`ğŸ¯ N1 - Zona Segura â†’ NULO`);
        } else {
            const statusLabel = safeZoneMeta.signal && safeZoneVote && safeZoneVote.color
                ? `${safeZoneMeta.dominant?.toUpperCase() || '-'}` 
                : 'Ativa â€¢ aguardando';
            sendAnalysisStatus(`ğŸ¯ N1 - Zona Segura â†’ ${statusLabel}`);
        }
        await sleep(1500);
        
        const n2Detail = nivel5 && nivel5.details ? nivel5.details : (nivel5 && nivel5.reason ? nivel5.reason : 'sem sinal');
        sendAnalysisStatus(`âš¡ N2 - Ritmo AutÃ´nomo â†’ ${nivel5 && nivel5.color ? nivel5.color.toUpperCase() : 'NULO'} (${n2Detail})`);
        await sleep(1500);
        
        if (nivel7 && nivel7.color) {
            const overrideLabel = nivel7.override ? ' (override)' : '';
            sendAnalysisStatus(`ğŸ”· N3 - AlternÃ¢ncia${overrideLabel} â†’ ${nivel7.color.toUpperCase()}`);
        } else {
            sendAnalysisStatus(`ğŸ”· N3 - AlternÃ¢ncia â†’ NULO`);
        }
        await sleep(1500);
        
        if (nivel9 && nivel9.color) {
            sendAnalysisStatus(`ğŸ”· N4 - PersistÃªncia â†’ ${nivel9.color.toUpperCase()}`);
        } else {
            sendAnalysisStatus(`ğŸ”· N4 - PersistÃªncia â†’ NULO`);
        }
        await sleep(1500);
        
        if (minuteBiasColor) {
            sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ ${minuteBiasColor.toUpperCase()}`);
        } else {
            sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ NULO`);
        }
        await sleep(1500);
        
        if (retracementResult && retracementResult.color) {
            sendAnalysisStatus(`ğŸ“‰ N6 - RetraÃ§Ã£o HistÃ³rica â†’ ${retracementResult.color.toUpperCase()}`);
        } else {
            sendAnalysisStatus(`ğŸ“‰ N6 - RetraÃ§Ã£o HistÃ³rica â†’ NULO`);
        }
        await sleep(1500);

        if (continuityResult && continuityResult.color && (continuityResult.strength || 0) !== 0) {
            const prefix2 = continuityResult.strength > 0 ? 'ReforÃ§o' : 'ReduÃ§Ã£o';
            sendAnalysisStatus(`ğŸ“ˆ N7 - Continuidade Global â†’ ${continuityResult.color.toUpperCase()} (${prefix2})`);
        } else {
            sendAnalysisStatus(`ğŸ“ˆ N7 - Continuidade Global â†’ NULO`);
        }
        await sleep(1500);
        
        const barrierStatusText3 = barrierResult.alternanceBlocked
            ? 'ğŸš« BLOQUEADO (AlternÃ¢ncia)'
            : barrierResult.allowed ? 'âœ… APROVADO' : 'ğŸš« BLOQUEADO';
        sendAnalysisStatus(`ğŸ›‘ N9 - Barreira Final â†’ ${barrierStatusText3}`);
        await sleep(1500);
        
        // âœ… Mostrar resultado da anÃ¡lise (MODO DIAMANTE: mensagem fixa) e depois o motivo do bloqueio
        if (analyzerConfig.aiMode) {
            sendAnalysisStatus(`Sinal de entrada`);
        } else {
			sendAnalysisStatus(`âœ… AnÃ¡lise: ${finalColor.toUpperCase()} (${winningVotes} de ${maxVotingSlots} votos)`);
        }
        await sleep(2000);
        
		if (intervalMessage) {
        sendAnalysisStatus(intervalMessage);
        await sleep(2000);
		}
        
        // âœ… Restaurar status "IA ativada"
        await restoreIAStatus();
        
        return null;
    }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ“Š CÃLCULO DE CONFIANÃ‡A (BASEADO NA VOTAÃ‡ÃƒO)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
	const totalVotantes = maxVotingSlots;
	const consensusPercent = totalVotantes > 0 ? (winningVotes / totalVotantes) * 100 : 0;
	
    let rawConfidence = Math.round(consensusPercent);
    rawConfidence = Math.max(50, Math.min(100, rawConfidence));
        
		console.log('%cğŸ“Š RESUMO COMPLETO DOS NÃVEIS ATIVOS:', 'color: #FFD700; font-weight: bold; font-size: 16px;');
		levelReports
			.filter(level => level.id !== 'N9')
			.forEach(level => console.log(`   ${describeLevel(level)}`));
		const barrierReport = levelReports.find(level => level.id === 'N9');
		if (barrierReport) {
			console.log(`   ${describeLevel(barrierReport)}`);
		}
		
		const voteSegments = [
			`${voteTotals.red} VERMELHO`,
			`${voteTotals.black} PRETO`
		];
		if (voteTotals.neutral > 0) voteSegments.push(`${voteTotals.neutral} NEUTRO`);
		if (voteTotals.negative > 0) voteSegments.push(`${voteTotals.negative} REDUÃ‡ÃƒO`);
		
        console.log(`%câ•‘  ğŸ¯ DECISÃƒO FINAL: ${finalColor.toUpperCase().padEnd(33)}â•‘`, 'color: #00FF00; font-weight: bold; font-size: 16px;');
		console.log(`%câ•‘  ğŸ—³ï¸ Votos: ${voteSegments.join(' | ').padEnd(42)}â•‘`, 'color: #00FF88;');
        console.log(`%câ•‘  ğŸ“Š Consenso: ${consensusPercent.toFixed(1)}%${''.padEnd(33)}â•‘`, 'color: #00FFFF;');
        console.log(`%câ•‘  ğŸ“ ConfianÃ§a Calculada: ${rawConfidence}%${''.padEnd(28)}â•‘`, 'color: #00FFFF;');
        console.log(`%câ•‘  âœ… SISTEMA DEMOCRÃTICO DE VOTAÃ‡ÃƒO                       â•‘`, 'color: #00FF00; font-weight: bold;');
        console.log(`%câ•‘  âœ… BARREIRA VALIDOU VIABILIDADE HISTÃ“RICA              â•‘`, 'color: #00FF00; font-weight: bold;');
        console.log('%câ•‘  ğŸ”§ APLICANDO CALIBRADOR AUTOMÃTICO...                   â•‘', 'color: #FFD700; font-weight: bold;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”§ APLICAR CALIBRADOR AUTOMÃTICO DE PORCENTAGEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let finalConfidence = applyCalibratedConfidence(rawConfidence);
        
        console.log(`%câ•‘  âœ… CONFIANÃ‡A FINAL (CALIBRADA): ${finalConfidence}%${''.padEnd(19)}â•‘`, 'color: #FFD700; font-weight: bold; font-size: 16px;');
        
        console.log('%câœ… SINAL APROVADO!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		// ğŸ“ MONTAR RACIOCÃNIO DETALHADO (NÃVEIS ATIVOS + VOTAÃ‡ÃƒO)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
		let nivel1Description = '';
        if (!n1Enabled) {
			nivel1Description = `N1 - Zona Segura: DESATIVADO`;
        } else if (!safeZoneMeta || !safeZoneMeta.zoneActive) {
			nivel1Description = `N1 - Zona Segura: NULO`;
        } else if (safeZoneMeta.signal && safeZoneVote && safeZoneVote.color) {
			nivel1Description = `N1 - Zona Segura: ${safeZoneVote.color.toUpperCase()} (${safeZoneMeta.counts[safeZoneMeta.dominant]}/${safeZoneMeta.windowSize})`;
        } else {
			nivel1Description = `N1 - Zona Segura: Ativa â€¢ aguardando confirmaÃ§Ã£o`;
		}
		
		const nivel2Description = !n2Enabled
            ? `N2 - Ritmo AutÃ´nomo: DESATIVADO`
            : `N2 - Ritmo AutÃ´nomo: ${nivel5 && nivel5.color ? nivel5.color.toUpperCase() : 'NULO'} (${nivel5 && nivel5.details ? nivel5.details : (nivel5 && nivel5.reason ? nivel5.reason : 'sem sinal')})`;
		
		const nivel3Description = !n3Enabled
            ? `N3 - AlternÃ¢ncia: DESATIVADO`
			: nivel7 && nivel7.color
			? `N3 - AlternÃ¢ncia${nivel7.override ? ' (override)' : ''}: ${nivel7.color.toUpperCase()} (${nivel7.details || nivel7.pattern})`
			: `N3 - AlternÃ¢ncia: ${nivel7 && nivel7.details ? nivel7.details : 'NULO'}`;
		
		const nivel4Description = !n4Enabled
            ? `N4 - PersistÃªncia: DESATIVADO`
            : nivel9 && nivel9.color ? 
			`N4 - PersistÃªncia: ${nivel9.color.toUpperCase()} (seq. ${nivel9.currentSequence})`
            : `N4 - PersistÃªncia: NULO`;
		
		const nivel5Description = !n5Enabled
            ? `N5 - Ritmo por Giro: DESATIVADO`
			: minuteBiasColor
			? `N5 - Ritmo por Giro: ${minuteBiasColor.toUpperCase()} (${Math.round((minuteBiasResult?.confidence || 0) * 100)}% confianÃ§a)`
			: `N5 - Ritmo por Giro: NULO`;

		const retracementDescription = !n6Enabled
            ? `N6 - RetraÃ§Ã£o HistÃ³rica: DESATIVADO`
			: retracementResult && retracementResult.details
			? `N6 - RetraÃ§Ã£o HistÃ³rica: ${retracementResult.details}`
			: `N6 - RetraÃ§Ã£o HistÃ³rica: NULO`;

		const continuityDescription = !n7Enabled
            ? `N7 - Continuidade Global: DESATIVADO`
			: continuityResult && continuityResult.details
			? `N7 - Continuidade Global: ${continuityResult.details}`
			: `N7 - Continuidade Global: NULO`;

		const walkForwardReport = levelReports.find(level => level.id === 'N8');
		const walkForwardDescription = !n8Enabled
            ? `N8 - Walk-forward: DESATIVADO`
			: walkForwardReport && walkForwardReport.color
			? `N8 - Walk-forward: ${walkForwardReport.color.toUpperCase()} (${Math.round((walkForwardReport.strength || 0) * 100)}% â€¢ ${walkForwardReport.details || 'sem detalhes'})`
			: `N8 - Walk-forward: NULO`;

		const barrierDescription = !n9Enabled
            ? `N9 - Barreira Final: DESATIVADO`
			: barrierResult.allowed
			? `N9 - Barreira Final: LIBERADO`
			: `N9 - Barreira Final: BLOQUEADO`;

		const bayesReport = levelReports.find(level => level.id === 'N10');
		const bayesDescription = !n10Enabled
            ? `N10 - CalibraÃ§Ã£o Bayesiana: DESATIVADO`
			: bayesReport && bayesReport.color
			? `N10 - CalibraÃ§Ã£o Bayesiana: ${bayesReport.color.toUpperCase()} (${Math.round((bayesReport.strength || 0) * 100)}% â€¢ ${bayesReport.details || 'sem detalhes'})`
			: `N10 - CalibraÃ§Ã£o Bayesiana: NULO`;
        
		const votingDescription = (() => {
			const segments = [
			`${voteTotals.red} VERMELHO`,
			`${voteTotals.black} PRETO`
			];
			if (voteTotals.neutral > 0) segments.push(`${voteTotals.neutral} NEUTRO`);
			if (voteTotals.negative > 0) segments.push(`${voteTotals.negative} REDUÃ‡ÃƒO`);
			return `Votos: ${segments.join(' | ')}`;
		})();
        
        const reasoning = `${nivel1Description}\n` +
            `${nivel2Description}\n` +
            `${nivel3Description}\n` +
            `${nivel4Description}\n` +
            `${nivel5Description}\n` +
			`${retracementDescription}\n` +
			`${continuityDescription}\n` +
			`${walkForwardDescription}\n` +
			`${barrierDescription}\n` +
			`${bayesDescription}\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `${votingDescription}\n` +
			`Resultado: ${finalColor.toUpperCase()} (${winningVotes}/${totalVotantes} votos = ${consensusPercent.toFixed(1)}%)\n` +
			`Intensidade: ${intensityLabel} (${signalIntensity === 'conservative' ? 'mÃ­n 5 votos + barreiras' : 'maioria simples'})\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `DECISÃƒO: ${finalColor.toUpperCase()}\n` +
            `ConfianÃ§a: ${finalConfidence}%`;
        
        // Registrar sinal para verificaÃ§Ã£o futura
        const signal = {
            timestamp: Date.now(),
            patternType: 'nivel-diamante',
            patternName: patternDescription,
            colorRecommended: finalColor,
			votesRed: voteTotals.red,
			votesBlack: voteTotals.black,
			votesNeutral: voteTotals.neutral,
			votesNegative: voteTotals.negative,
            consensusPercent: consensusPercent,
            rawConfidence: rawConfidence,        // ConfianÃ§a antes da calibraÃ§Ã£o
            finalConfidence: finalConfidence,    // ConfianÃ§a apÃ³s calibraÃ§Ã£o
            reasoning: reasoning,
            verified: false,
            colorThatCame: null,
            hit: null
        };
        
        if (signalsHistory && signalsHistory.signals) {
            signalsHistory.signals.push(signal);
            if (signalsHistory.signals.length > 200) {
                signalsHistory.signals = signalsHistory.signals.slice(-200);
            }
            await saveSignalsHistory();
        }
        
        // âœ… MARCAR MEMÃ“RIA ATIVA COMO INICIALIZADA (para UI)
        if (!memoriaAtiva.inicializada) {
            memoriaAtiva.inicializada = true;
            memoriaAtiva.ultimaAtualizacao = Date.now();
            memoriaAtiva.totalAtualizacoes = 1;
            memoriaAtiva.giros = history.slice(0, 2000);
            console.log('%câœ… MemÃ³ria Ativa marcada como INICIALIZADA!', 'color: #00FF00; font-weight: bold;');
        } else {
            memoriaAtiva.totalAtualizacoes++;
            memoriaAtiva.ultimaAtualizacao = Date.now();
        }
        
    console.log('%cğŸ§  RACIOCÃNIO COMPLETO:', 'color: #00FFFF; font-weight: bold; font-size: 14px;');
    console.log(`%c${reasoning}`, 'color: #00FFFF;');
    
    // âš¡âš¡âš¡ SINAL APROVADO! MOSTRAR IMEDIATAMENTE! âš¡âš¡âš¡
    console.log('%câš¡âš¡âš¡ SINAL APROVADO! ENVIANDO IMEDIATAMENTE! âš¡âš¡âš¡', 'color: #00FF00; font-weight: bold; font-size: 16px;');
    
    // âœ… NO MODO DIAMANTE: Mensagem FIXA ("Sinal de entrada")
    // âœ… OUTROS MODOS: Mensagem com votos (comportamento antigo)
    if (analyzerConfig.aiMode) {
        sendAnalysisStatus(`Sinal de entrada`);
    } else {
        sendAnalysisStatus(`âœ… Sinal aprovado: ${finalColor.toUpperCase()} (${winningVotes} de 5 votos)`);
    }
    // âš¡ NÃƒO AGUARDAR! UsuÃ¡rio vÃª a cor IMEDIATAMENTE
        
        console.log('%câœ… SINAL APROVADO E PRONTO PARA ENVIO', 'color: #00FF00; font-weight: bold; font-size: 18px;');
        console.log('%cğŸ“Š ANÃLISE COMPLETA:', 'color: #00FFFF; font-weight: bold; font-size: 16px;');
        console.log(`%c   ğŸ¯ Cor Recomendada: ${finalColor.toUpperCase()}`, `color: ${finalColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 18px;`);
        console.log(`%c   ğŸ“ˆ ConfianÃ§a Final: ${finalConfidence}%`, 'color: #FFD700; font-weight: bold; font-size: 16px;');
		console.log(`%c   ğŸ—³ï¸ VotaÃ§Ã£o: ${voteTotals.red} vermelho | ${voteTotals.black} preto${voteTotals.neutral > 0 ? ' | ' + voteTotals.neutral + ' neutro' : ''}${voteTotals.negative > 0 ? ' | ' + voteTotals.negative + ' reduÃ§Ã£o' : ''}`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c   ğŸ” PadrÃ£o: ${patternDescription}`, 'color: #FFD700; font-weight: bold;');
        console.log('%cğŸ“‹ ORIGEM DOS DADOS:', 'color: #00FFFF; font-weight: bold;');
        console.log(`%c   âœ… HistÃ³rico analisado: ${history.length} giros REAIS`, 'color: #00FF88;');
        if (safeZoneMeta && safeZoneMeta.zoneActive) {
            const detail = safeZoneMeta.signal && safeZoneVote && safeZoneVote.color
                ? `${safeZoneMeta.dominant?.toUpperCase() || '-'} confirmado`
                : 'Ativa â€¢ aguardando';
            console.log(`%c   âœ… Zona Segura: ${detail} (${safeZoneMeta.counts[safeZoneMeta.dominant] || 0}/${safeZoneMeta.windowSize})`, 'color: #FF6B35; font-weight: bold;');
        } else {
            console.log(`%c   âœ… Zona Segura: NULO`, 'color: #888;');
        }
        console.log(`%c   âœ… Barreira Validada: ${barrierResult.allowed ? 'SIM (liberado)' : 'BLOQUEADO'}`, barrierResult.allowed ? 'color: #00FF88;' : 'color: #FF6666;');
        console.log('%câœ… GARANTIAS:', 'color: #00FF00; font-weight: bold;');
        console.log('%c   âœ“ Todos os dados vÃªm do histÃ³rico REAL da Blaze', 'color: #00FF88;');
        console.log('%c   âœ“ Nenhum valor foi inventado ou simulado', 'color: #00FF88;');
        console.log(`%c   âœ“ NÃ­veis ativos analisados: ${activeLevelsSummary}`, 'color: #00FF88;');
        console.log('%c   âœ“ Sistema democrÃ¡tico de votaÃ§Ã£o aplicado', 'color: #00FF88;');
        console.log('%c   âœ“ Barreira validou viabilidade histÃ³rica', 'color: #00FF88;');
        console.log('%c   âœ“ PadrÃµes customizados do usuÃ¡rio foram respeitados', 'color: #00FF88;');
        
        return {
            color: finalColor,
            confidence: finalConfidence,
            probability: finalConfidence,
            reasoning: reasoning,
            patternDescription: patternDescription
        };
        
        */
        
    } catch (error) {
        console.error('');
        console.error('âŒâŒâŒ ERRO CRÃTICO EM analyzeWithPatternSystem! âŒâŒâŒ');
        console.error('Erro:', error);
        console.error('Mensagem:', error.message);
        console.error('Stack:', error.stack);
        console.error('Nome:', error.name);
        console.error('');
        return null;
    }
}

/**
 * âŒ REMOVIDO: CÃ³digo de API externa (Groq, OpenAI, etc.) nÃ£o utilizado
 * O sistema usa apenas Modo PadrÃ£o e Modo Diamante (anÃ¡lise local)
 * 
 * Mantido comentado para referÃªncia histÃ³rica
 */
/*
async function analyzeWithAI(history) {
    const startTime = Date.now();
    const timeout = 5000; // âš¡ 5 segundos MÃXIMO para APIs externas
    
    try {
        console.log('%câ•‘  ğŸ¤– INICIANDO ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL        â•‘', 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
        // Verificar chave API
        if (!analyzerConfig.aiApiKey || analyzerConfig.aiApiKey.trim() === '') {
            console.error('%câŒ ERRO: Chave da IA invÃ¡lida ou ausente!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
            console.error('%c   Configure a chave nas ConfiguraÃ§Ãµes da extensÃ£o', 'color: #FF6666;');
            sendAnalysisStatus('âŒ Chave da IA ausente');
            return null;
        }
        console.log('%câœ… Chave API encontrada: ' + analyzerConfig.aiApiKey.substring(0, 15) + '...', 'color: #00FF88;');
        
        // Detectar qual API estÃ¡ sendo usada pela chave
        const apiKey = analyzerConfig.aiApiKey.trim();
        let apiType = 'unknown';
        
        if (apiKey.startsWith('gsk_')) {
            apiType = 'groq';
            console.log('%cğŸ” API Detectada: GROQ (Ultra RÃ¡pido) âš¡', 'color: #00FF00; font-weight: bold; font-size: 14px;');
            console.log('%c   Modelo: Llama 3.3 70B Versatile', 'color: #00FF88;');
        } else if (apiKey.startsWith('sk-or-')) {
            apiType = 'openrouter';
            console.log('%cğŸ” API Detectada: OpenRouter (agregador de IAs)', 'color: #00FF00; font-weight: bold;');
        } else if (apiKey.startsWith('AIzaSy')) {
            apiType = 'gemini';
            console.log('%cğŸ” API Detectada: Google Gemini', 'color: #00FF00; font-weight: bold;');
        } else if (apiKey.startsWith('sk-ant-')) {
            apiType = 'claude';
            console.log('%cğŸ” API Detectada: Anthropic Claude', 'color: #00FF00; font-weight: bold;');
        } else if (apiKey.startsWith('sk-')) {
            apiType = 'openai';
            console.log('%cğŸ” API Detectada: OpenAI GPT', 'color: #00FF00; font-weight: bold;');
        } else {
            // Tentar OpenRouter como padrÃ£o
            console.log('%câš ï¸ Tipo de API nÃ£o detectado. Tentando OpenRouter...', 'color: #FFAA00; font-weight: bold;');
            apiType = 'openrouter';
        }
        
        // âœ… Preparar dados do histÃ³rico para enviar Ã  IA (usar tamanho REAL disponÃ­vel)
        const aiHistorySizeConfigured = Math.min(Math.max(analyzerConfig.aiHistorySize || 50, 20), 2000); // Min: 20, Max: 2000
        const aiHistorySize = Math.min(aiHistorySizeConfigured, history.length); // âœ… Usar o menor entre configurado e disponÃ­vel
        const recentHistory = history.slice(0, aiHistorySize);
        
        // âœ… CRÃTICO: Enviar os Ãºltimos 20 giros em DESTAQUE para a IA
        const last20Spins = history.slice(0, 20);
        
        // Log de debug removido: reduÃ§Ã£o de verbosidade
        
        // Criar texto com DESTAQUE para os Ãºltimos 20 giros
        const last20Text = last20Spins.map((spin, idx) => 
            `${idx + 1}. ${spin.color} (${spin.number})`
        ).join(', ');
        
        const historyText = recentHistory.map((spin, idx) => 
            `${idx + 1}. ${spin.color} (${spin.number})`
        ).join(', ');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ” DETECTAR PADRÃ•ES NO HISTÃ“RICO (ANÃLISE ESTATÃSTICA REAL)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let patternsReport = [];
        try {
            patternsReport = detectPatternsInHistory(recentHistory);
        } catch (patternError) {
            console.error('%câŒ ERRO ao detectar padrÃµes:', 'color: #FF0000; font-weight: bold;', patternError);
            console.log('%câš ï¸ Continuando anÃ¡lise SEM padrÃµes detectados...', 'color: #FFAA00;');
        }
        
        // Montar texto do relatÃ³rio de padrÃµes para enviar Ã  IA
        let patternsText = '';
        if (patternsReport && patternsReport.length > 0) {
            patternsText = 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n';
            patternsText += 'ğŸ“Š PADRÃ•ES DETECTADOS NO HISTÃ“RICO (ESTATÃSTICAS REAIS):\n';
            patternsText += 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n';
            
            patternsReport.forEach((p, index) => {
                patternsText += `PADRÃƒO ${index + 1}: ${p.name}\n`;
                patternsText += `- OcorrÃªncias: ${p.occurrences} vezes no histÃ³rico\n`;
                patternsText += `- ApÃ³s esse padrÃ£o:\n`;
                patternsText += `  â†’ VERMELHO: ${p.afterRed} vezes (${p.redPercent}%)\n`;
                patternsText += `  â†’ PRETO: ${p.afterBlack} vezes (${p.blackPercent}%)\n`;
                patternsText += `  â†’ BRANCO: ${p.afterWhite} vezes (${p.whitePercent}%)\n`;
                patternsText += `\n`;
            });
            
            patternsText += 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n';
        } else {
            patternsText = 'âš ï¸ Nenhum padrÃ£o claro foi detectado no histÃ³rico.\n';
            patternsText += 'Analise os Ãºltimos 20 giros de forma mais livre.\n\n';
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¤– PREPARAR PROMPT (customizado ou padrÃ£o)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let prompt;
        
        if (analyzerConfig.customPrompt && analyzerConfig.customPrompt.trim() !== '') {
            // ğŸ”§ USAR PROMPT CUSTOMIZADO DO USUÃRIO
            console.log('%cğŸ”§ MODO AVANÃ‡ADO: Usando prompt customizado', 'color: #FF00FF; font-weight: bold;');
            
            // Substituir placeholders no prompt customizado
            prompt = analyzerConfig.customPrompt
                .replace(/\$\{recentHistory\.length\}/g, recentHistory.length)
                .replace(/\$\{historyLength\}/g, recentHistory.length)
                .replace(/\$\{historyText\}/g, historyText)
                .replace(/\$\{patternsText\}/g, patternsText);
            
            console.log('%c   Tamanho do prompt: ' + prompt.length + ' caracteres', 'color: #FF00FF;');
            
            // Validar palavras-chave crÃ­ticas
            const requiredKeywords = ['color', 'confidence', 'JSON'];
            const missingKeywords = requiredKeywords.filter(keyword => !prompt.toLowerCase().includes(keyword.toLowerCase()));
            
            if (missingKeywords.length > 0) {
                console.warn('%câš ï¸ AVISO: Prompt customizado pode estar faltando elementos crÃ­ticos:', 'color: #FFAA00; font-weight: bold;');
                console.warn('%c   Palavras-chave ausentes: ' + missingKeywords.join(', '), 'color: #FFAA00;');
                console.warn('%c   Isso pode causar respostas invÃ¡lidas da IA!', 'color: #FFAA00;');
            }
        } else {
            // âœ… USAR PROMPT PADRÃƒO (COM PADRÃ•ES DETECTADOS E ÃšLTIMOS 20 GIROS)
            console.log('%câœ… Usando prompt padrÃ£o com padrÃµes detectados + Ãºltimos 20 giros', 'color: #00FF88;');
            prompt = DEFAULT_AI_PROMPT(recentHistory.length, historyText, patternsText, last20Text);
        }

        console.log('%cğŸ“¤ Enviando dados para API da IA...', 'color: #00FFFF; font-weight: bold; font-size: 13px;');
        console.log('%c   HistÃ³rico: ' + recentHistory.length + ' giros', 'color: #00FFFF;');
        console.log('%c   âš¡ Timeout: 5 segundos MÃXIMO', 'color: #00FFFF; font-weight: bold;');
        sendAnalysisStatus('ğŸ¤– Consultando IA...');
        
        // Fazer chamada REAL para a API
        let aiResponse;
        
        try {
            switch (apiType) {
                case 'groq':
                    aiResponse = await callGroqAPI(apiKey, prompt, timeout);
                    break;
                case 'openrouter':
                    aiResponse = await callOpenRouterAPI(apiKey, prompt, timeout);
                    break;
                case 'gemini':
                    aiResponse = await callGeminiAPI(apiKey, prompt, timeout);
                    break;
                case 'openai':
                    aiResponse = await callOpenAI_API(apiKey, prompt, timeout);
                    break;
                case 'claude':
                    aiResponse = await callClaudeAPI(apiKey, prompt, timeout);
                    break;
                default:
                    throw new Error('Tipo de API nÃ£o suportado');
            }
        } catch (apiError) {
            console.error('%câŒ ERRO AO CHAMAR API!', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #330000; padding: 5px;');
            console.error('%c   Mensagem: ' + apiError.message, 'color: #FF6666; font-weight: bold;');
            sendAnalysisStatus('âŒ API invÃ¡lida');
            return null;
        }
        
        // Validar resposta
        if (!aiResponse || !aiResponse.color) {
            console.error('%câŒ RESPOSTA DA IA INVÃLIDA!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
            console.error('%c   A API nÃ£o retornou dados no formato esperado', 'color: #FF6666;');
            return null;
        }
        
        // Verificar timeout
        const elapsed = Date.now() - startTime;
        if (elapsed > timeout) {
            console.error('â±ï¸ Timeout: AnÃ¡lise IA excedeu o tempo limite');
            return null;
        }
        
        // âœ… VALIDAR CONFIANÃ‡A MÃNIMA (respeitar configuraÃ§Ã£o do usuÃ¡rio)
        const aiConfidence = aiResponse.confidence || 0;
        const minConfidence = analyzerConfig.minOccurrences || 60; // minOccurrences Ã© usado como confianÃ§a mÃ­nima no modo IA
        
        // âš ï¸ ESPECIAL: Se IA retornar confidence: 0, significa que nÃ£o encontrou padrÃ£o confiÃ¡vel
        if (aiConfidence === 0) {
            console.log('%câ•‘  âš ï¸ IA: NENHUM PADRÃƒO CONFIÃVEL DETECTADO                 â•‘', 'color: #FFAA00; font-weight: bold;');
            console.log('%câ•‘  ğŸ” RaciocÃ­nio: ' + (aiResponse.reasoning || 'Sem padrÃ£o com 85%+ de confianÃ§a').substring(0, 48).padEnd(48) + 'â•‘', 'color: #FFAA00;');
            console.log('%câ•‘  â³ Aguardando formaÃ§Ã£o de padrÃ£o claro...                â•‘', 'color: #FFAA00;');
            sendAnalysisStatus('â³ IA aguardando padrÃ£o confiÃ¡vel...');
            return null;
        }
        
        // Validar se atinge confianÃ§a mÃ­nima configurada
        if (aiConfidence < minConfidence) {
            console.log('%câ•‘  âš ï¸ SINAL IA REJEITADO: CONFIANÃ‡A INSUFICIENTE            â•‘', 'color: #FFAA00; font-weight: bold;');
            console.log('%câ•‘  ğŸ“Š ConfianÃ§a da IA: ' + aiConfidence.toFixed(1) + '%                                â•‘', 'color: #FFAA00;');
            console.log('%câ•‘  ğŸ¯ ConfianÃ§a mÃ­nima configurada: ' + minConfidence + '%                    â•‘', 'color: #FFAA00;');
            console.log('%câ•‘  â³ Aguardando prÃ³ximo giro com maior confianÃ§a...        â•‘', 'color: #FFAA00;');
            sendAnalysisStatus('â³ IA aguardando confianÃ§a maior...');
            return null;
        }
        
        // ğŸ“Š RASTREAMENTO DE CORES (detectar viÃ©s)
        const recommendedColor = aiResponse.color.toLowerCase();
        aiColorCounter[recommendedColor] = (aiColorCounter[recommendedColor] || 0) + 1;
        aiColorCounter.total++;
        
        // Alertar se houver viÃ©s evidente (mais de 70% de uma Ãºnica cor apÃ³s 10+ recomendaÃ§Ãµes)
        if (aiColorCounter.total >= 10) {
            const redPercent = (aiColorCounter.red / aiColorCounter.total) * 100;
            const blackPercent = (aiColorCounter.black / aiColorCounter.total) * 100;
            const whitePercent = (aiColorCounter.white / aiColorCounter.total) * 100;
            
            console.log('%cğŸ“Š ESTATÃSTICAS DA IA (Ãºltimas ' + aiColorCounter.total + ' recomendaÃ§Ãµes):', 'color: #00FFFF; font-weight: bold;');
            console.log('%c   ğŸ”´ VERMELHO: ' + aiColorCounter.red + ' (' + redPercent.toFixed(1) + '%)', 
                'color: ' + (redPercent > 70 ? '#FF0000' : '#00FFFF') + '; font-weight: ' + (redPercent > 70 ? 'bold' : 'normal') + ';');
            console.log('%c   âš« PRETO: ' + aiColorCounter.black + ' (' + blackPercent.toFixed(1) + '%)', 
                'color: ' + (blackPercent > 70 ? '#FF0000' : '#00FFFF') + '; font-weight: ' + (blackPercent > 70 ? 'bold' : 'normal') + ';');
            console.log('%c   âšª BRANCO: ' + aiColorCounter.white + ' (' + whitePercent.toFixed(1) + '%)', 
                'color: ' + (whitePercent > 70 ? '#FF0000' : '#00FFFF') + '; font-weight: ' + (whitePercent > 70 ? 'bold' : 'normal') + ';');
            
            if (redPercent > 70 || blackPercent > 70 || whitePercent > 70) {
                console.log('%câš ï¸âš ï¸âš ï¸ ALERTA DE VIÃ‰S DETECTADO! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #330000; padding: 5px;');
                console.log('%c   A IA estÃ¡ recomendando a MESMA cor mais de 70% das vezes!', 'color: #FF6666; font-weight: bold;');
                console.log('%c   Isso pode indicar um problema no modelo ou no prompt.', 'color: #FF6666;');
            }
        }
        
        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: SEMPRE usar dados REAIS do histÃ³rico
        // A IA frequentemente INVENTA os dados em last10Spins, entÃ£o IGNORAMOS completamente
        // e SEMPRE usamos os dados reais do histÃ³rico que foram coletados
        console.log('%cğŸ” USANDO DADOS REAIS DO HISTÃ“RICO (ignorando resposta da IA)', 'color: #FFFF00; font-weight: bold;');
        console.log('%câš ï¸ MOTIVO: A IA frequentemente INVENTA dados no campo last10Spins', 'color: #FFAA00; font-weight: bold;');
        console.log('%câœ… SOLUÃ‡ÃƒO: Sempre extrair do histÃ³rico REAL coletado do site', 'color: #00FF88; font-weight: bold;');
        
        // SEMPRE extrair do histÃ³rico real (ignorar o que a IA retornou)
        const last10SpinsData = recentHistory.slice(0, 10).map(spin => ({
            color: spin.color,
            number: spin.number,
            timestamp: spin.timestamp
        }));
        
        console.log('%cğŸ“Š ÃšLTIMOS 10 GIROS (REAIS do histÃ³rico):', 'color: #00FF88; font-weight: bold;');
        last10SpinsData.forEach((spin, idx) => {
            console.log(`%c   ${idx + 1}. ${spin.color.toUpperCase()} (${spin.number})`, 
                `color: ${spin.color === 'red' ? '#FF0000' : spin.color === 'black' ? '#FFFFFF' : '#00FF00'}; font-weight: bold;`);
        });
        
        // âš ï¸ VALIDAÃ‡ÃƒO: Verificar se a IA retornou dados DIFERENTES dos reais
        if (aiResponse.last10Spins && aiResponse.last10Spins.length > 0) {
            console.log('%cğŸ” VALIDAÃ‡ÃƒO: Comparando dados da IA com histÃ³rico real', 'color: #FFAA00; font-weight: bold;');
            
            let mismatchFound = false;
            for (let i = 0; i < Math.min(5, aiResponse.last10Spins.length); i++) {
                const aiSpin = aiResponse.last10Spins[i];
                const realSpin = last10SpinsData[i];
                
                if (aiSpin.number !== realSpin.number || aiSpin.color !== realSpin.color) {
                    mismatchFound = true;
                    console.log(`%c   âŒ DIVERGÃŠNCIA no giro ${i + 1}:`, 'color: #FF0000; font-weight: bold;');
                    console.log(`%c      IA disse: ${aiSpin.color} (${aiSpin.number})`, 'color: #FF6666;');
                    console.log(`%c      Real Ã©:   ${realSpin.color} (${realSpin.number})`, 'color: #00FF88;');
                }
            }
            
            if (mismatchFound) {
                console.log('%câš ï¸âš ï¸âš ï¸ A IA RETORNOU DADOS FALSOS! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #330000; padding: 5px;');
                console.log('%c   Os dados exibidos ao usuÃ¡rio sÃ£o os REAIS do histÃ³rico', 'color: #00FF88; font-weight: bold;');
                console.log('%c   (Ignoramos os dados inventados pela IA)', 'color: #00FF88;');
            } else {
                console.log('%c   âœ… Dados da IA conferem com o histÃ³rico real', 'color: #00FF88; font-weight: bold;');
            }
        }
        
        // Criar objeto de anÃ¡lise no formato esperado
        const analysis = {
            color: aiResponse.color,
            confidence: aiResponse.confidence,
            probability: aiResponse.probability || 50,
            suggestion: `IA recomenda: ${aiResponse.color === 'red' ? 'ğŸ”´ VERMELHO' : aiResponse.color === 'black' ? 'âš« PRETO' : 'âšª BRANCO'}`,
            patternDescription: aiResponse.reasoning || 'AnÃ¡lise baseada em IA',
            last10Spins: last10SpinsData, // âœ… INCLUIR OS 10 GIROS
            last5Spins: last10SpinsData ? last10SpinsData.slice(0, 10) : [], // âœ… Mostrando Ãºltimos 10 giros
            source: 'AI-REAL',
            apiType: apiType,
            timestamp: Date.now(),
            createdOnTimestamp: history[0]?.timestamp || Date.now(),
            predictedFor: null // SerÃ¡ preenchido pelo prÃ³ximo giro
        };
        
        console.log('%câœ… RESPOSTA DA IA RECEBIDA COM SUCESSO!', 'color: #00FF00; font-weight: bold; font-size: 14px; background: #003300; padding: 5px;');
        console.log('%c   ğŸ¯ Cor prevista: ' + analysis.color.toUpperCase(), 'color: #00FF00; font-weight: bold; font-size: 13px;');
        console.log('%c   ğŸ“Š ConfianÃ§a: ' + analysis.confidence + '%', 'color: #00FF88; font-weight: bold;');
        console.log('%c   ğŸ’­ RaciocÃ­nio (primeiros 200 chars): ' + (aiResponse.reasoning || '').substring(0, 200) + '...', 'color: #00FF88;');
        console.log('%c   âš¡ Tempo de resposta: ' + elapsed + 'ms', 'color: #00FFFF;');
        
        // ğŸ” VALIDAÃ‡ÃƒO: Verificar se a IA analisou os giros corretos
        console.log('%cğŸ” VALIDAÃ‡ÃƒO: Comparando resposta da IA com histÃ³rico real', 'color: #FFFF00; font-weight: bold;');
        console.log('%cğŸ“Š Ãšltimos 10 giros REAIS (do histÃ³rico):', 'color: #FFFF00; font-weight: bold;');
        for (let i = 0; i < Math.min(10, recentHistory.length); i++) {
            const spin = recentHistory[i];
            console.log(`%c   ${i + 1}. ${spin.color.toUpperCase()} (nÃºmero ${spin.number})`, 
                `color: ${spin.color === 'red' ? '#FF0000' : spin.color === 'black' ? '#FFFFFF' : '#00FF00'}; font-weight: bold;`);
        }
        console.log('%cğŸ’­ O que a IA disse sobre os Ãºltimos giros:', 'color: #FFFF00; font-weight: bold;');
        const reasoningSnippet = (aiResponse.reasoning || '').substring(0, 300);
        console.log('%c   ' + reasoningSnippet, 'color: #FFAA00;');
        
        return analysis;
        
    } catch (error) {
        console.error('%câŒ ERRO GERAL NA ANÃLISE IA!', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #330000; padding: 5px;');
        console.error('%c   ' + error.message, 'color: #FF6666; font-weight: bold;');
        console.error('%c   Stack:', error.stack, 'color: #FF3333;');
        sendAnalysisStatus('âŒ Erro na IA');
        return null;
    }
}

/**
 * Chama a API do Groq (Ultra RÃ¡pido)
 */
async function callGroqAPI(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: 'llama-3.3-70b-versatile', // Modelo mais recente e eficiente do Groq
                messages: [
                    { 
                        role: 'system', 
                        content: 'VocÃª Ã© um especialista em anÃ¡lise de padrÃµes do jogo Double da Blaze. Responda APENAS com JSON vÃ¡lido, sem markdown ou texto adicional.' 
                    },
                    { role: 'user', content: prompt }
                ],
                temperature: 0.7,
                max_tokens: 800,
                top_p: 1
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API Groq retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.choices?.[0]?.message?.content;
        
        if (!text) {
            throw new Error('Resposta da API Groq estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta (remover markdown se houver)
        let jsonText = text.trim();
        
        // Remover blocos de cÃ³digo markdown se existirem
        jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');
        
        // Extrair JSON
        const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API Groq');
        }
        throw error;
    }
}

/**
 * Chama a API do OpenRouter (agregador de mÃºltiplas IAs)
 */
async function callOpenRouterAPI(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`,
                'HTTP-Referer': 'https://blaze.com',
                'X-Title': 'Blaze Double Analyzer'
            },
            body: JSON.stringify({
                model: 'anthropic/claude-3.5-sonnet', // Melhor modelo disponÃ­vel
                messages: [
                    { 
                        role: 'system', 
                        content: 'VocÃª Ã© um especialista em anÃ¡lise de padrÃµes do jogo Double da Blaze. Responda APENAS com JSON vÃ¡lido, sem markdown ou texto adicional.' 
                    },
                    { role: 'user', content: prompt }
                ],
                temperature: 0.7,
                max_tokens: 800,
                top_p: 1,
                frequency_penalty: 0,
                presence_penalty: 0
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API OpenRouter retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.choices?.[0]?.message?.content;
        
        if (!text) {
            throw new Error('Resposta da API OpenRouter estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta (remover markdown se houver)
        let jsonText = text.trim();
        
        // Remover blocos de cÃ³digo markdown se existirem
        jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');
        
        // Extrair JSON
        const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API OpenRouter');
        }
        throw error;
    }
}

/**
 * Chama a API do Google Gemini
 */
async function callGeminiAPI(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 1024,
                }
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API Gemini retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!text) {
            throw new Error('Resposta da API Gemini estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API Gemini');
        }
        throw error;
    }
}

/**
 * Chama a API da OpenAI (GPT)
 */
async function callOpenAI_API(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: 'gpt-3.5-turbo',
                messages: [
                    { role: 'system', content: 'VocÃª Ã© um especialista em anÃ¡lise de padrÃµes. Responda APENAS com JSON.' },
                    { role: 'user', content: prompt }
                ],
                temperature: 0.7,
                max_tokens: 500
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API OpenAI retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.choices?.[0]?.message?.content;
        
        if (!text) {
            throw new Error('Resposta da API OpenAI estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API OpenAI');
        }
        throw error;
    }
}

/**
 * Chama a API da Anthropic (Claude)
 */
async function callClaudeAPI(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
                model: 'claude-3-sonnet-20240229',
                max_tokens: 1024,
                messages: [
                    { role: 'user', content: prompt }
                ]
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API Claude retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.content?.[0]?.text;
        
        if (!text) {
            throw new Error('Resposta da API Claude estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API Claude');
        }
        throw error;
    }
}
// */

// UtilitÃ¡rio central para garantir que nenhuma anÃ¡lise rode quando o toggle estiver desligado
async function runAnalysisIfEnabled(history, contextLabel = 'general') {
    if (!analysisEnabled) {
        console.log(`â¸ï¸ [${contextLabel}] AnÃ¡lises pausadas â€“ runAnalysisController() nÃ£o serÃ¡ executado.`);
        return false;
    }

    if (!history || !Array.isArray(history) || history.length === 0) {
        console.log(`âš ï¸ [${contextLabel}] HistÃ³rico indisponÃ­vel para anÃ¡lise.`);
        return false;
    }

    console.log(`â–¶ï¸ [${contextLabel}] Executando runAnalysisController() com ${history.length} giros.`);
    await runAnalysisController(history);
    return true;
}

async function clearActiveAnalysisState(reason = 'manual-toggle') {
    console.log(`ğŸ§¹ [${reason}] Limpando estado de anÃ¡lise e Martingale devido Ã  pausa.`);
    resetMartingaleState();

    try {
        await chrome.storage.local.set({
            analysis: null,
            pattern: null,
            lastBet: null,
            martingaleState
        });
    } catch (error) {
        console.error('âŒ Falha ao sincronizar limpeza de anÃ¡lise no storage:', error);
    }

    sendMessageToContent('CLEAR_ANALYSIS');
}

// NOVO CONTROLADOR: Orquestra VerificaÃ§Ã£o (padrÃµes salvos) + Descoberta (173+ anÃ¡lises) em â‰¤5s
async function runAnalysisController(history) {
	const startTs = Date.now();
	const budgetMs = 5000; // 5s totais

	try {
		if (!history || !Array.isArray(history) || history.length === 0) {
			console.error('âŒ history invÃ¡lido na anÃ¡lise avanÃ§ada.');
			return null;
		}

		logSection('[Controller] Iniciando anÃ¡lise avanÃ§ada');
		logInfo('HistÃ³rico recebido', `${history.length} giros`);

		const storageResult = await chrome.storage.local.get(['analyzerConfig']);
		if (storageResult && storageResult.analyzerConfig) {
			mergeAnalyzerConfig(storageResult.analyzerConfig);
			logInfo('ConfiguraÃ§Ã£o', 'Recarregada do storage');
		}

		emitModeSnapshotToContent('AnÃ¡lise em andamento', history.length);
		
		// âš ï¸ CRÃTICO: Em gales consecutivos (atÃ© o limite configurado), nÃ£o gerar novo sinal.
		const { consecutiveGales } = getMartingaleSettings();
		if (martingaleState.active && isMartingaleStageConsecutive(martingaleState.stage, consecutiveGales)) {
			logSection('â›” Martingale ativo (modo consecutivo)');
			logInfo('EstÃ¡gio', martingaleState.stage);
			logInfo('Cor', martingaleState.entryColor);
			logInfo('AÃ§Ã£o', 'Aguardando resultado anterior');
			return; // âœ… NÃƒO executar nova anÃ¡lise em modo consecutivo com Martingale ativo
		}
		// Log removido: reduÃ§Ã£o de verbosidade
		
		// âœ… VERIFICAR SE JÃ EXISTE UMA ANÃLISE PENDENTE (que ainda nÃ£o foi avaliada)
		const existingAnalysisResult = await chrome.storage.local.get(['analysis']);
		const existingAnalysis = existingAnalysisResult['analysis'];
		
		if (existingAnalysis && existingAnalysis.createdOnTimestamp && history && history.length > 0) {
			const latestSpinTimestamp = history[0].timestamp;
			const isAnalysisPending = existingAnalysis.createdOnTimestamp !== latestSpinTimestamp;
			
			if (isAnalysisPending) {
			console.log('%câš ï¸ AnÃ¡lise pendente | ' + existingAnalysis.color + ' (' + existingAnalysis.confidence + '%)', 'color: #FF9900; font-weight: bold; background: #332200; padding: 4px 8px; border-radius: 4px;');
				return; // âœ… NÃƒO executar nova anÃ¡lise se jÃ¡ hÃ¡ uma pendente
			}
		}
	// Log removido: reduÃ§Ã£o de verbosidade
		
		// 1) VerificaÃ§Ã£o com padrÃµes salvos (rÃ¡pido) - PRIORIDADE MÃXIMA
		// âš ï¸ CRÃTICO: PULAR VERIFICAÃ‡ÃƒO DE PADRÃ•ES SALVOS SE MODO IA ESTIVER ATIVO
		let verifyResult = null;
		if (!analyzerConfig.aiMode) {
			console.log('%cğŸ” Analisando padrÃµes...', 'color: #00AAFF; font-weight: bold; background: #003366; padding: 4px 8px; border-radius: 4px;');
			sendAnalysisStatus('ğŸ” Verificando padrÃµes salvos...');
			verifyResult = await verifyWithSavedPatterns(history);
		} else {
			console.log('%cğŸ¤– Modo IA ativo | Analisando...', 'color: #00FF88; font-weight: bold; background: #003300; padding: 4px 8px; border-radius: 4px;');
		}
		
		if (verifyResult) {
		console.log('%câœ… PadrÃ£o encontrado | ' + verifyResult.color + ' (' + verifyResult.confidence + '%)', 'color: #00FF88; font-weight: bold; background: #003322; padding: 4px 8px; border-radius: 4px;');
			
			// âš ï¸ Martingale ativo:
			// - enquanto estiver dentro do "consecutivo atÃ©", mantÃ©m a cor do ciclo
			// - quando estiver no modo "prÃ³ximo sinal", NÃƒO mantÃ©m a cor (usa a cor do novo sinal)
			if (martingaleState.active) {
				const { consecutiveGales } = getMartingaleSettings();
				console.log('â•‘  ğŸ”„ MARTINGALE ATIVO DETECTADO!                          â•‘');
				console.log(`â•‘  Cor do novo padrÃ£o: ${verifyResult.color}                           â•‘`);
				console.log(`â•‘  Cor da entrada original: ${martingaleState.entryColor}                    â•‘`);
				console.log(`â•‘  EstÃ¡gio atual: ${martingaleState.stage}                              â•‘`);
				
				// âœ… Sempre marcar o estÃ¡gio (stake) do Martingale
				verifyResult.phase = martingaleState.stage;

				// âœ… SÃ³ forÃ§a a cor se este estÃ¡gio for consecutivo
				if (martingaleState.entryColor && isMartingaleStageConsecutive(martingaleState.stage, consecutiveGales)) {
					console.log('â•‘  âœ… COR FORÃ‡ADA (estÃ¡gio consecutivo)                     â•‘');
					verifyResult.color = martingaleState.entryColor;
				} else {
					console.log('â•‘  âœ… COR LIVRE (prÃ³ximo sinal)                             â•‘');
				}

                verifyResult.confidence = calculateGaleConfidenceValue(verifyResult.confidence, verifyResult);
			}
			
			console.log('%câ•‘  ğŸ’¾ SALVANDO SINAL/ENTRADA EM CHROME.STORAGE.LOCAL                         â•‘', 'color: #FFD700; font-weight: bold; font-size: 16px;');
			console.log('%cğŸ“Š DADOS COMPLETOS DO SINAL:', 'color: #FFD700; font-weight: bold;');
			console.log('   â¤ Cor:', verifyResult.color);
			console.log('   â¤ ConfianÃ§a:', verifyResult.confidence + '%');
			console.log('   â¤ Fase:', verifyResult.phase || 'G0');
			console.log('   â¤ CreatedOn (timestamp):', verifyResult.createdOnTimestamp);
			console.log('   â¤ PredictedFor:', verifyResult.predictedFor);
			console.log('   â¤ PatternDescription:', verifyResult.patternDescription);
			console.log('   â¤ Modo:', analyzerConfig.aiMode ? 'NÃVEL DIAMANTE (IA)' : 'ANÃLISE PADRÃƒO');
		console.log('%cğŸ’¾ Salvando objeto analysis no storage...', 'color: #00FFFF; font-weight: bold;');
		
		// âš¡âš¡âš¡ CRÃTICO: VERIFICAR SE O MODO AINDA Ã‰ PADRÃƒO âš¡âš¡âš¡
		// O usuÃ¡rio pode ter ativado o modo Diamante durante a anÃ¡lise de padrÃµes salvos
		const currentConfigPadrao = await chrome.storage.local.get(['analyzerConfig']);
		if (currentConfigPadrao && currentConfigPadrao.analyzerConfig) {
			const currentAiModePadrao = currentConfigPadrao.analyzerConfig.aiMode;
			
			if (currentAiModePadrao) {
				console.log('%câ•‘  ğŸš« MODO FOI ALTERADO PARA DIAMANTE DURANTE ANÃLISE!     â•‘', 'color: #FF0000; font-weight: bold; font-size: 14px;');
				console.log('%câ•‘  âš ï¸ AnÃ¡lise de padrÃ£o salvo foi concluÃ­da                â•‘', 'color: #FFAA00;');
				console.log('%câ•‘  ğŸš« MAS modo agora Ã© Diamante                            â•‘', 'color: #FF0000; font-weight: bold;');
				console.log('%câ•‘  âŒ CANCELANDO envio de sinal do Modo PadrÃ£o             â•‘', 'color: #FF0000; font-weight: bold;');
				console.log('%câŒ SINAL CANCELADO! UsuÃ¡rio ativou Modo Diamante.', 'color: #FF0000; font-weight: bold; font-size: 16px;');
				
				// âœ… Atualizar config global para refletir mudanÃ§a
				analyzerConfig.aiMode = true;
				
				return; // âŒ CANCELAR - nÃ£o enviar sinal de modo diferente
			}
			
			console.log('%câœ… Modo PadrÃ£o ainda ativo - continuando com envio do sinal...', 'color: #00FF88; font-weight: bold;');
		}
		
		await chrome.storage.local.set({
			analysis: verifyResult,
			pattern: { description: verifyResult.patternDescription, confidence: verifyResult.confidence },
			lastBet: { status: 'pending', phase: verifyResult.phase || 'G0', createdOnTimestamp: verifyResult.createdOnTimestamp }
		});
			
			console.log('%câœ… SINAL SALVO COM SUCESSO NO STORAGE!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
			console.log('%c   â¤ Agora aguardando prÃ³ximo giro para verificar WIN/LOSS...', 'color: #00FF88;');
			
			// âœ… ENVIAR SINAIS PARA AMBOS OS CANAIS (INDEPENDENTES)
			const sendResults = {
				extensao: false,
				telegram: false
			};
			
			// 1. Enviar para extensÃ£o (UI)
			try {
				sendResults.extensao = await emitAnalysisToContent(verifyResult, 'standard');
			} catch (e) {
				console.error('âŒ Erro crÃ­tico ao enviar para extensÃ£o:', e);
			}
			
			// 2. Enviar para Telegram (INDEPENDENTE)
			try {
			if (history && history.length > 0) {
					sendResults.telegram = await sendTelegramEntrySignal(verifyResult.color, history[0], verifyResult.confidence, verifyResult);
				}
			} catch (e) {
				console.error('âŒ Erro crÃ­tico ao enviar para Telegram:', e);
			}
			
			// 3. Log de resultado consolidado
			console.log('â•‘  ğŸ“Š RESULTADO DO ENVIO DE SINAIS                          â•‘');
			console.log('â•‘  ğŸ’¾ Sistema usado: PADRÃƒO SALVO (BANCO)                   â•‘');
			console.log(`â•‘  ğŸ“± ExtensÃ£o: ${sendResults.extensao ? 'âœ… ENVIADO' : 'âŒ FALHOU'.padEnd(11)}                        â•‘`);
			console.log(`â•‘  ğŸ“² Telegram: ${sendResults.telegram ? 'âœ… ENVIADO' : 'âŒ FALHOU'.padEnd(11)}                        â•‘`);
			
			// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
			displaySystemFooter();
			
			// âœ… RETURN apÃ³s enviar sinal para evitar fallback (que causaria mensagem duplicada)
			return;
		}
		
		// âœ… MODO AVANÃ‡ADO: Se ativado e nÃ£o achou padrÃ£o salvo, usar anÃ¡lise avanÃ§ada
		if (analyzerConfig.aiMode && !verifyResult) {
			logSection('AnÃ¡lise avanÃ§ada (modo Diamante)');
			logInfo('HistÃ³rico disponÃ­vel', `${history.length} giros`);
			logInfo('AÃ§Ã£o', 'Executando analyzeWithPatternSystem');
			
		const aiResult = await analyzeWithPatternSystem(history);
		
		logInfo('Resultado IA', aiResult ? 'Retornou com dados' : 'Sem sinal');
		console.log('   Resultado:', aiResult ? 'ENCONTROU SINAL' : 'NÃƒO ENCONTROU');
		
		if (aiResult) {
			// âš¡âš¡âš¡ CRÃTICO: VERIFICAR SE O MODO AINDA ESTÃ ATIVO âš¡âš¡âš¡
			// A anÃ¡lise pode ter demorado e o usuÃ¡rio pode ter desativado o modo durante a execuÃ§Ã£o
			const currentConfig = await chrome.storage.local.get(['analyzerConfig']);
			if (currentConfig && currentConfig.analyzerConfig) {
				const currentAiMode = currentConfig.analyzerConfig.aiMode;
				
				if (!currentAiMode) {
					console.log('%câ•‘  ğŸš« MODO DIAMANTE FOI DESATIVADO DURANTE A ANÃLISE!      â•‘', 'color: #FF0000; font-weight: bold; font-size: 14px;');
					console.log('%câ•‘  âš ï¸ AnÃ¡lise foi concluÃ­da mas modo jÃ¡ mudou              â•‘', 'color: #FFAA00;');
					console.log('%câ•‘  ğŸš« CANCELANDO envio de sinal                            â•‘', 'color: #FF0000; font-weight: bold;');
					console.log('%câ•‘  âœ… Sistema agora estÃ¡ em Modo PadrÃ£o                    â•‘', 'color: #00FF88;');
					console.log('%câŒ SINAL CANCELADO! Modo foi alterado pelo usuÃ¡rio.', 'color: #FF0000; font-weight: bold; font-size: 16px;');
					
					// âœ… Atualizar config global para refletir mudanÃ§a
					analyzerConfig.aiMode = false;
					
					return; // âŒ CANCELAR - nÃ£o enviar sinal de modo diferente
				}
				
				console.log('%câœ… Modo Diamante ainda ativo - continuando com envio do sinal...', 'color: #00FF88; font-weight: bold;');
			}
			
			// âš ï¸ VERIFICAR SE Ã‰ A PRIMEIRA ANÃLISE APÃ“S ATIVAR MODO AVANÃ‡ADO
			if (aiModeJustActivated) {
					console.log('%câ•‘  â³ MODO AVANÃ‡ADO RECÃ‰M-ATIVADO                           â•‘', 'color: #FFAA00; font-weight: bold; font-size: 14px;');
					console.log('%câ•‘  ğŸ¯ Sistema analisou e encontrou padrÃ£o!                  â•‘', 'color: #FFAA00; font-weight: bold;');
					console.log('%câ•‘  ğŸ¯ Cor prevista: ' + aiResult.color.toUpperCase() + '                                     â•‘', 'color: #FFAA00;');
					console.log('%câ•‘  ğŸ“Š ConfianÃ§a: ' + aiResult.confidence + '%                                   â•‘', 'color: #FFAA00;');
					console.log('%câ•‘  â³ AGUARDANDO 1 GIRO antes de enviar sinal...            â•‘', 'color: #FFAA00; font-weight: bold;');
					console.log('%câ•‘  ğŸš« Sinal NÃƒO serÃ¡ enviado neste momento                  â•‘', 'color: #FFAA00; font-weight: bold;');
					console.log('%câ•‘  âœ… PrÃ³ximo giro: sinal serÃ¡ enviado normalmente          â•‘', 'color: #FFAA00; font-weight: bold;');
					
				// Desabilitar flag para permitir prÃ³ximo sinal
				aiModeJustActivated = false;
				console.log('%câœ… Flag aiModeJustActivated = false (prÃ³ximos sinais serÃ£o enviados)', 'color: #00FF88; font-weight: bold;');
				
				// âœ… SALVAR o giro atual como "Ãºltimo sinal" para respeitar intervalo mÃ­nimo configurado
                const latestSpin = history[0] || null;
				await chrome.storage.local.set({
					lastSignalSpinNumber: latestSpin ? latestSpin.number : null,
					lastSignalSpinId: latestSpin ? latestSpin.id || null : null,
					lastSignalSpinTimestamp: latestSpin ? latestSpin.timestamp || null : null,
					lastSignalTimestamp: Date.now()
				});
				console.log('%cğŸ“ Giro atual salvo como "Ãºltimo sinal" para respeitar intervalo mÃ­nimo de ' + analyzerConfig.minIntervalSpins + ' giros', 'color: #FFD700; font-weight: bold;');
				
				// Enviar status para UI informando que estÃ¡ aguardando
				sendAnalysisStatus('â³ Aguardando prÃ³ximo giro para enviar sinal...');
				
				// RETURN - nÃ£o enviar sinal
				return;
				}
				
				// âš ï¸ VERIFICAR SE HÃ MARTINGALE ATIVO
				let aiColor = aiResult.color;
				let aiPhase = 'G0';
				
				if (martingaleState.active) {
					const { consecutiveGales } = getMartingaleSettings();
					console.log('â•‘  ğŸ”„ MARTINGALE ATIVO DETECTADO! (MODO IA)                â•‘');
					console.log(`â•‘  Cor da IA: ${aiColor}                                         â•‘`);
					console.log(`â•‘  Cor da entrada original: ${martingaleState.entryColor}                    â•‘`);
					console.log(`â•‘  EstÃ¡gio atual: ${martingaleState.stage}                              â•‘`);
					aiPhase = martingaleState.stage;
					
					// âœ… SÃ³ forÃ§a a cor se este estÃ¡gio for consecutivo
					if (martingaleState.entryColor && isMartingaleStageConsecutive(martingaleState.stage, consecutiveGales)) {
						console.log('â•‘  âœ… COR FORÃ‡ADA (estÃ¡gio consecutivo)                     â•‘');
					aiColor = martingaleState.entryColor;
					} else {
						console.log('â•‘  âœ… COR LIVRE (prÃ³ximo sinal)                             â•‘');
					}
				}
				
				// ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: SEMPRE usar dados REAIS do histÃ³rico
				// NUNCA confiar no que a IA retorna, pois ela frequentemente inventa dados
				console.log('%cğŸ”¥ FORÃ‡ANDO uso de dados REAIS para descriÃ§Ã£o/exibiÃ§Ã£o', 'color: #FF6600; font-weight: bold;');
				
				// âœ… Definir tamanho do histÃ³rico usado
				const aiHistorySizeUsed = Math.min(Math.max(analyzerConfig.aiHistorySize || 50, 20), history.length);
				
				const last10SpinsForDescription = history.slice(0, 10).map(spin => ({
					color: spin.color,
					number: spin.number,
					timestamp: spin.timestamp
				}));
				console.log('%câœ… ExtraÃ­do do histÃ³rico REAL:', 'color: #00FF88;', last10SpinsForDescription.slice(0, 10));
				
				const aiDescriptionData = {
					type: 'AI_ANALYSIS',
					color: aiColor,
					confidence: aiResult.confidence,
					last10Spins: last10SpinsForDescription,
					last5Spins: last10SpinsForDescription ? last10SpinsForDescription.slice(0, 10) : [], // âœ… Mostrando Ãºltimos 10 giros
					reasoning: aiResult.reasoning || aiResult.patternDescription || 'AnÃ¡lise baseada nos Ãºltimos ' + aiHistorySizeUsed + ' giros do histÃ³rico.',
					historySize: aiHistorySizeUsed
				};
				
				console.log('%cğŸ“¦ DADOS ESTRUTURADOS DA IA (para renderizaÃ§Ã£o):', 'color: #00FFFF; font-weight: bold;');
				console.log('%c   ğŸ¨ Tipo:', 'color: #00FFFF;', aiDescriptionData.type);
				console.log('%c   ğŸ¯ Cor:', 'color: #00FFFF;', aiDescriptionData.color);
				console.log('%c   ğŸ“Š ConfianÃ§a:', 'color: #00FFFF;', aiDescriptionData.confidence + '%');
				console.log('%c   ğŸ² Ãšltimos 10 giros:', 'color: #00FFFF;', aiDescriptionData.last10Spins);
				console.log('%c   ğŸ’­ RaciocÃ­nio (200 chars):', 'color: #00FFFF;', (aiDescriptionData.reasoning || '').substring(0, 200) + '...');
				
				// Serializar para JSON para armazenamento
				const aiDescription = JSON.stringify(aiDescriptionData);
				
				// Criar objeto de anÃ¡lise no formato esperado (com padrÃ£o para futura comparaÃ§Ã£o)
				const analysis = {
					color: aiColor,
					confidence: aiResult.confidence,
					patternDescription: aiDescription,
					last10Spins: last10SpinsForDescription, // âœ… INCLUIR DIRETAMENTE para facilitar acesso
					last5Spins: last10SpinsForDescription ? last10SpinsForDescription.slice(0, 10) : [], // âœ… Mostrando Ãºltimos 10 giros
					patternType: 'ai-analysis',
					phase: aiPhase,
					predictedFor: 'next',
					createdOnTimestamp: history[0].timestamp,
					aiPattern: null // âœ… Novo fluxo nÃ£o usa currentPattern
				};
				if (analysis.phase && analysis.phase !== 'G0' && analysis.phase !== 'ENTRADA') {
					analysis.confidence = calculateGaleConfidenceValue(analysis.confidence, analysis);
				}
				
				console.log('%câ•‘  ğŸ’¾ SALVANDO ANÃLISE IA EM CHROME.STORAGE.LOCAL          â•‘', 'color: #00FF00; font-weight: bold;');
				console.log('%cğŸ“Š Dados da anÃ¡lise IA:', 'color: #00FF88; font-weight: bold;');
				console.log('%c   ğŸ¯ Cor: ' + analysis.color.toUpperCase(), 'color: #00FF88;');
				console.log('%c   ğŸ“Š ConfianÃ§a: ' + analysis.confidence + '%', 'color: #00FF88;');
				console.log('%c   ğŸ² Fase: ' + analysis.phase, 'color: #00FF88;');
				console.log(`%c   ğŸ“ NÃºmero do giro: #${history[0].number}`, 'color: #00FF88;');
				
				// Salvar anÃ¡lise E nÃºmero do giro do Ãºltimo sinal
				await chrome.storage.local.set({
					analysis: analysis,
					pattern: { description: analysis.patternDescription, confidence: analysis.confidence },
					lastBet: { status: 'pending', phase: aiPhase, createdOnTimestamp: analysis.createdOnTimestamp },
					lastSignalSpinNumber: history[0].number, // âœ… CRÃTICO: Salvar nÃºmero do giro para validaÃ§Ã£o de intervalo
					lastSignalSpinId: history[0].id || null,
					lastSignalSpinTimestamp: history[0].timestamp || null,
					lastSignalTimestamp: Date.now() // âœ… Timestamp para debug
				});
				
				console.log('%câœ… AnÃ¡lise IA salva em chrome.storage.local!', 'color: #00FF00; font-weight: bold; font-size: 13px;');
				console.log(`%cğŸ“ NÃºmero do giro registrado: #${history[0].number}`, 'color: #00D4FF; font-weight: bold;');
				console.log(`%câ° Timestamp registrado: ${new Date().toLocaleTimeString()}`, 'color: #00D4FF; font-weight: bold;');
				console.log('%câ•‘  ğŸ“‹ DESCRIÃ‡ÃƒO DO PADRÃƒO (ENVIADA PARA O USUÃRIO):        â•‘', 'color: #00FF00; font-weight: bold;');
				console.log('%c' + aiDescription, 'color: #00FF88;');
				
				// âœ… ENVIAR SINAIS PARA AMBOS OS CANAIS (INDEPENDENTES)
				const sendResults = {
					extensao: false,
					telegram: false
				};
				
				// 1. Enviar para extensÃ£o (UI)
				try {
					sendResults.extensao = await emitAnalysisToContent(analysis, 'diamond');
				} catch (e) {
					console.error('âŒ Erro crÃ­tico ao enviar para extensÃ£o:', e);
				}
				
				// 2. Enviar para Telegram (INDEPENDENTE)
				try {
					if (history && history.length > 0) {
						sendResults.telegram = await sendTelegramEntrySignal(analysis.color, history[0], analysis.confidence, analysis);
					}
				} catch (e) {
					console.error('âŒ Erro crÃ­tico ao enviar para Telegram:', e);
				}
				
				// 3. Log de resultado consolidado
				console.log('%câ•‘  âœ… SINAL ENVIADO COM SUCESSO!                           â•‘', 'color: #00FF00; font-weight: bold; font-size: 14px; background: #003300; padding: 2px;');
			
			// ğŸ§  Status dinÃ¢mico da memÃ³ria
			const statusMemoria = memoriaAtiva.inicializada ? 
				`âš¡ CACHE RAM ATIVO (${memoriaAtiva.totalAtualizacoes} updates)` : 
				'ğŸ”„ INICIALIZANDO...';
			
			console.log(`%câ•‘  ğŸ¤– Sistema: ANÃLISE IA | ${statusMemoria}              â•‘`, 'color: #00FF00; font-weight: bold; background: #003300; padding: 2px;');
			console.log('%câ•‘  ğŸ“± ExtensÃ£o: ' + (sendResults.extensao ? 'âœ… ENVIADO' : 'âŒ FALHOU') + '                                    â•‘', 'color: #00FF88; background: #003300; padding: 2px;');
				console.log('%câ•‘  ğŸ“² Telegram: ' + (sendResults.telegram ? 'âœ… ENVIADO' : 'âŒ FALHOU') + '                                    â•‘', 'color: #00FF88; background: #003300; padding: 2px;');
				
				// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
				displaySystemFooter();
				
				// âœ… RETURN apÃ³s enviar sinal IA
				return;
			} else {
				// âš ï¸ CRÃTICO: Se IA nÃ£o encontrou resultado, PARAR AQUI (nÃ£o executar anÃ¡lise padrÃ£o)
				console.log('%câ•‘  âš ï¸ MODO DIAMANTE: Nenhum nÃ­vel liberou sinal neste giro  â•‘', 'color: #FFAA00; font-weight: bold;');
				console.log('%câ•‘  PossÃ­veis motivos:                                       â•‘', 'color: #FFAA00; font-weight: bold;');
				console.log('%câ•‘    â€¢ Barreira final (N9) bloqueou a entrada               â•‘', 'color: #FFAA00;');
				console.log('%câ•‘    â€¢ Falta de consenso entre os nÃ­veis                    â•‘', 'color: #FFAA00;');
				console.log('%câ•‘    â€¢ Todos os nÃ­veis reportaram NULO                      â•‘', 'color: #FFAA00;');
				console.log('%câ•‘  â³ Aguardando prÃ³ximo giro para nova tentativa...        â•‘', 'color: #FFAA00; font-weight: bold;');
				console.log('%câ•‘  ğŸš« AnÃ¡lise padrÃ£o BLOQUEADA (modo Diamante permanece)    â•‘', 'color: #FFAA00; font-weight: bold;');
				sendAnalysisStatus('â³ IA aguardando novo giro...');
				
				// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
				displaySystemFooter();
				
				return; // âœ… PARAR AQUI - NÃƒO executar anÃ¡lise padrÃ£o quando modo IA estÃ¡ ativo
			}
		}

		// 2) Descoberta: 173+ anÃ¡lises e persistÃªncia (sem repetir o que jÃ¡ temos)
		// âš ï¸ SÃ“ EXECUTA SE MODO IA NÃƒO ESTIVER ATIVO
		const timeLeftAfterVerify = budgetMs - (Date.now() - startTs);
		if (!analyzerConfig.aiMode && timeLeftAfterVerify > 100) {
			sendAnalysisStatus('ğŸ§  Descobrindo novos padrÃµes...');
			await discoverAndPersistPatterns(history, startTs, budgetMs);
		}

		// 3) Se verificaÃ§Ã£o nÃ£o deu sinal E modo IA nÃ£o ativo, usar anÃ¡lise existente como fallback
		const timeLeftForFallback = budgetMs - (Date.now() - startTs);
		if (!verifyResult && !analyzerConfig.aiMode && timeLeftForFallback > 200) {
			console.log('â•‘  ğŸ“Š EXECUTANDO: ANÃLISE PADRÃƒO (DESCOBERTA)              â•‘');
			console.log('â•‘  âœ… PadrÃµes salvos: NÃ£o encontrado                       â•‘');
			console.log('â•‘  ğŸ”„ Buscando padrÃ£o atual em 173+ anÃ¡lises...            â•‘');
			
			sendAnalysisStatus('ğŸ¤– Buscando padrÃ£o atual...');
			const analysis = await performPatternAnalysis(history);
			if (analysis) {
				// âš ï¸ CRÃTICO: VERIFICAR SE HÃ MARTINGALE ATIVO
				if (martingaleState.active && martingaleState.entryColor) {
					console.log('â•‘  ğŸ”„ MARTINGALE ATIVO DETECTADO! (DESCOBERTA)             â•‘');
					console.log(`â•‘  Cor do novo padrÃ£o: ${analysis.color}                           â•‘`);
					console.log(`â•‘  Cor da entrada original: ${martingaleState.entryColor}                    â•‘`);
					console.log(`â•‘  EstÃ¡gio atual: ${martingaleState.stage}                              â•‘`);
					console.log('â•‘  âœ… SOBRESCREVENDO COR PARA MANTER ENTRADA ORIGINAL      â•‘');
					
					// âœ… SOBRESCREVER A COR PARA USAR A COR DA ENTRADA ORIGINAL
					analysis.color = martingaleState.entryColor;
					analysis.phase = martingaleState.stage;
					analysis.confidence = calculateGaleConfidenceValue(analysis.confidence, analysis);
				}
				
				console.log('â•‘  ğŸ’¾ SALVANDO ANÃLISE EM CHROME.STORAGE.LOCAL (DESCOBERTA)â•‘');
				console.log('ğŸ“Š Dados da anÃ¡lise:');
				console.log('   Cor:', analysis.color);
				console.log('   ConfianÃ§a:', analysis.confidence);
				console.log('   Fase:', analysis.phase || 'G0');
				console.log('   CreatedOn:', analysis.createdOnTimestamp);
				console.log('   PredictedFor:', analysis.predictedFor);
				
				await chrome.storage.local.set({
					analysis: analysis,
					pattern: { description: analysis.patternDescription, confidence: analysis.confidence },
					lastBet: { status: 'pending', phase: analysis.phase || 'G0', createdOnTimestamp: analysis.createdOnTimestamp }
				});
				
				console.log('âœ… AnÃ¡lise salva em chrome.storage.local!');
				
				// âœ… ENVIAR SINAIS PARA AMBOS OS CANAIS (INDEPENDENTES)
				const sendResults = {
					extensao: false,
					telegram: false
				};
				
				// 1. Enviar para extensÃ£o (UI)
				try {
					sendResults.extensao = await emitAnalysisToContent(analysis, 'diamond');
				} catch (e) {
					console.error('âŒ Erro crÃ­tico ao enviar para extensÃ£o:', e);
				}
				
				// 2. Enviar para Telegram (INDEPENDENTE)
				try {
				if (history && history.length > 0) {
						sendResults.telegram = await sendTelegramEntrySignal(analysis.color, history[0], analysis.confidence, analysis);
					}
				} catch (e) {
					console.error('âŒ Erro crÃ­tico ao enviar para Telegram:', e);
				}
				
				// 3. Log de resultado consolidado
				console.log('â•‘  ğŸ“Š RESULTADO DO ENVIO DE SINAIS                          â•‘');
				console.log('â•‘  ğŸ“Š Sistema usado: ANÃLISE PADRÃƒO (DESCOBERTA)            â•‘');
				console.log(`â•‘  ğŸ“± ExtensÃ£o: ${sendResults.extensao ? 'âœ… ENVIADO' : 'âŒ FALHOU'.padEnd(11)}                        â•‘`);
				console.log(`â•‘  ğŸ“² Telegram: ${sendResults.telegram ? 'âœ… ENVIADO' : 'âŒ FALHOU'.padEnd(11)}                        â•‘`);
				
				// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
				displaySystemFooter();
			} else {
				console.log('%câ•‘  âš ï¸ NENHUM SINAL ENCONTRADO NESTE GIRO                   â•‘', 'color: #FFAA00; font-weight: bold;');
				console.log('%câ•‘  ğŸ“Š Modo ativo:', 'color: #FFAA00;', analyzerConfig.aiMode ? 'DIAMANTE' : 'PADRÃƒO');
				console.log('%câ•‘  ğŸ“Š Verificou banco de padrÃµes?', 'color: #FFAA00;', verifyResult ? 'SIM (nÃ£o encontrou)' : 'NÃƒO');
				console.log('%câ•‘  ğŸ“Š Executou anÃ¡lise avanÃ§ada?', 'color: #FFAA00;', analyzerConfig.aiMode ? 'SIM' : 'NÃƒO');
				console.log('%câ•‘  âœ… Aguardando prÃ³ximo giro...                           â•‘', 'color: #00FF88;');
				
				await chrome.storage.local.set({ analysis: null, pattern: null });
				sendMessageToContent('CLEAR_ANALYSIS');
				sendAnalysisStatus('â³ Aguardando novo giro...');
				
				// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
				displaySystemFooter();
			
			// âœ… LOG RESUMIDO DO CICLO
			logAnalysisCycle({
				serverStatus: 'ativo',
				patternsFound: [],
				searchingNewSpin: true,
				rejectedPatterns: [],
				telegramSent: null,
				displayedPatternsCount: 0,
				spinsAvailable: { server: history.length, app: cachedHistory.length }
			});
			}
		} else {
			console.log('%câŒ [DEBUG] NÃƒO ENTROU NO if (analyzerConfig.aiMode && !verifyResult)!', 'color: #FF0000; font-weight: bold;');
			console.log('   Motivo: analyzerConfig.aiMode =', analyzerConfig.aiMode, ' | verifyResult =', verifyResult ? 'ENCONTROU' : 'null/false');
		}
	} catch (e) {
		console.error('');
		console.error('%câŒ ERRO NO CONTROLADOR DE ANÃLISE!', 'color: #FF0000; font-weight: bold; font-size: 16px;');
		console.error('Detalhes do erro:', e);
		console.error('Stack:', e.stack);
		console.error('');
	}
}

// FunÃ§Ã£o helper para exibir estatÃ­sticas do banco de padrÃµes
function logPatternDBStats(db, action = 'load') {
	const total = db.patterns_found ? db.patterns_found.length : 0;
	const limit = 5000;
	const percentage = total > 0 ? ((total / limit) * 100).toFixed(1) : 0;
	
	// Agrupar por tipo
	const byType = {};
	const byConfidence = { high: 0, medium: 0, low: 0 };
	
	if (db.patterns_found) {
		db.patterns_found.forEach(p => {
			const type = p.type || 'desconhecido';
			byType[type] = (byType[type] || 0) + 1;
			
			const conf = p.confidence || 0;
			if (conf >= 80) byConfidence.high++;
			else if (conf >= 60) byConfidence.medium++;
			else byConfidence.low++;
		});
	}
	
	const emoji = action === 'load' ? 'ğŸ“‚' : action === 'save' ? 'ğŸ’¾' : 'ğŸ”';
	const actionText = action === 'load' ? 'CARREGADO' : action === 'save' ? 'SALVO' : 'DESCOBERTA';
	
	console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ${emoji} BANCO DE PADRÃ•ES ${actionText}                              
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“Š TOTAL DE PADRÃ•ES: ${total.toString().padEnd(4)} / ${limit} (${percentage}%)          
â•‘  âš¡ Capacidade: ${'â–ˆ'.repeat(Math.floor(percentage / 5))}${'â–‘'.repeat(20 - Math.floor(percentage / 5))}
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ¯ POR CONFIANÃ‡A:                                        
â•‘     â”œâ”€ ğŸŸ¢ Alta (â‰¥80%):   ${byConfidence.high.toString().padEnd(4)} padrÃµes
â•‘     â”œâ”€ ğŸŸ¡ MÃ©dia (60-79%): ${byConfidence.medium.toString().padEnd(4)} padrÃµes
â•‘     â””â”€ ğŸ”´ Baixa (<60%):   ${byConfidence.low.toString().padEnd(4)} padrÃµes
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“ POR TIPO:                                             
${Object.entries(byType).slice(0, 10).map(([type, count]) => 
`â•‘     â€¢ ${type.padEnd(20)}: ${count.toString().padEnd(4)} padrÃµes`).join('\n')}
${Object.keys(byType).length > 10 ? `â•‘     â€¢ ... e mais ${Object.keys(byType).length - 10} tipos` : ''}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	`.trim());
}

// Carrega o banco de padrÃµes salvos
async function loadPatternDB(silent = false) {
	const res = await chrome.storage.local.get(['patternDB']);
	const db = res.patternDB && Array.isArray(res.patternDB.patterns_found)
		? res.patternDB
		: { patterns_found: [], version: 1 };
	
	// ğŸ”¥ LIMPEZA CRÃTICA: Remover padrÃµes com trigger invÃ¡lida do banco
	if (db.patterns_found && db.patterns_found.length > 0) {
		const beforeCount = db.patterns_found.length;
		db.patterns_found = db.patterns_found.filter(pat => {
			// Se nÃ£o tem padrÃ£o ou trigger, manter (serÃ¡ validado depois)
			if (!Array.isArray(pat.pattern) || pat.pattern.length === 0 || !pat.triggerColor) {
				return true;
			}
			
			// Validar trigger
			const firstColorNorm = normalizeColorName(getInitialPatternColor(pat.pattern));
			const triggerNorm = normalizeColorName(pat.triggerColor);
			const validation = validateDisparoColor(firstColorNorm, triggerNorm);
			
			if (!validation.valid) {
				console.log(`ğŸ—‘ï¸ Removendo padrÃ£o invÃ¡lido do banco:`, {
					pattern: pat.pattern.join('-'),
					firstColor: firstColorNorm,
					trigger: triggerNorm,
					reason: validation.reason
				});
				return false; // âŒ Remover do banco
			}
			
			return true; // âœ… Manter no banco
		});
		
		const removedCount = beforeCount - db.patterns_found.length;
		if (removedCount > 0) {
			console.log(`ğŸ§¹ Limpeza do banco: ${removedCount} padrÃ£o(Ãµes) invÃ¡lido(s) removido(s)`);
			// Salvar banco limpo
			await savePatternDB(db);
		}
	}
	
	// âœ… Log visual das estatÃ­sticas (DESABILITAR durante busca ativa para performance)
	if (!silent && !initialSearchActive) {
		logPatternDBStats(db, 'load');
	}
	
	return db;
}

// Salva o banco de padrÃµes (APENAS LOCALMENTE)
async function savePatternDB(db) {
	// Salvar APENAS localmente (nÃ£o envia para servidor)
	await chrome.storage.local.set({ patternDB: db });
	
	// Log visual das estatÃ­sticas
	logPatternDBStats(db, 'save');
	
	// Notificar content script para atualizar UI
	sendMessageToContent('PATTERN_BANK_UPDATE', { total: db.patterns_found ? db.patterns_found.length : 0 });
}

// Limpa APENAS padrÃµes (usado ao abrir extensÃ£o - preserva anÃ¡lise pendente)
async function clearAllPatterns() {
	console.log('â•‘  ğŸ—‘ï¸ LIMPANDO BANCO DE PADRÃ•ES                            â•‘');
	
	// 1. Limpar banco de padrÃµes
	console.log('ğŸ—‘ï¸ Limpando banco de padrÃµes...');
	const emptyDB = { patterns_found: [], version: 1 };
	await chrome.storage.local.set({ patternDB: emptyDB });
	
	// 2. âœ… NÃƒO LIMPAR anÃ¡lise pendente (ela deve persistir se estiver aguardando resultado)
	// A anÃ¡lise sÃ³ deve ser limpa quando:
	// - O resultado for confirmado (WIN/LOSS)
	// - O usuÃ¡rio clicar explicitamente em "Resetar PadrÃµes"
	console.log('â•‘  âœ… ANÃLISE PENDENTE PRESERVADA                          â•‘');
	console.log('â•‘  (Aguardando resultado - nÃ£o serÃ¡ limpa)                 â•‘');
	
	// 3. âœ… NÃƒO LIMPAR histÃ³rico de entradas (deve persistir apÃ³s reload)
	// Se o usuÃ¡rio quiser limpar entradas, deve usar o botÃ£o "Limpar HistÃ³rico" na interface
	console.log('â•‘  âœ… HISTÃ“RICO DE ENTRADAS PRESERVADO                    â•‘');
	console.log('â•‘  (NÃ£o serÃ¡ limpo - persiste apÃ³s recarregar pÃ¡gina)     â•‘');
	console.log('â•‘  Para limpar: use botÃ£o "Limpar HistÃ³rico" na UI        â•‘');
	
	// 4. âœ… NÃƒO RESETAR calibrador de porcentagens (ele Ã© sincronizado automaticamente com entriesHistory)
	// O calibrador Ã© persistente e serÃ¡ reconstruÃ­do pela sincronizaÃ§Ã£o em loadObserverDataAtStartup()
	console.log('â•‘  âœ… CALIBRADOR DE PORCENTAGENS PRESERVADO                â•‘');
	console.log('â•‘  (Sincronizado automaticamente com entriesHistory)       â•‘');
	
	// 5. âœ… NÃƒO enviar mensagens aqui - deixar para o fluxo de busca controlar
	// O `startPatternSearch` enviarÃ¡ as mensagens apropriadas
	
	console.log('â•‘  âœ… RESET PARCIAL - PADRÃ•ES ZERADOS                      â•‘');
	console.log('â•‘  ğŸ“Š PadrÃµes: Limpos (serÃ£o recalculados)                  â•‘');
	console.log('â•‘  ğŸ¯ AnÃ¡lise Pendente: Preservada                          â•‘');
	console.log('â•‘  ğŸ“ˆ Entradas: Preservadas                                 â•‘');
	console.log('â•‘  Calibrador: Preservado (sincronizado)                    â•‘');
	console.log('â•‘  ğŸ’¾ Cache: SerÃ¡ recarregado do servidor                   â•‘');
}

// Limpa TUDO: padrÃµes E anÃ¡lise pendente (usado quando o usuÃ¡rio clica em "Resetar PadrÃµes")
async function clearAllPatternsAndAnalysis() {
	console.log('â•‘  ğŸ—‘ï¸ RESET COMPLETO - LIMPANDO TUDO                       â•‘');
	
	// 1. Limpar banco de padrÃµes
	console.log('ğŸ—‘ï¸ Limpando banco de padrÃµes...');
	const emptyDB = { patterns_found: [], version: 1 };
	await chrome.storage.local.set({ patternDB: emptyDB });
	
	// 2. âœ… LIMPAR anÃ¡lise e padrÃ£o atual (incluindo anÃ¡lise pendente)
	console.log('ğŸ—‘ï¸ Limpando anÃ¡lise pendente e padrÃ£o atual...');
	await chrome.storage.local.set({ 
		analysis: null, 
		pattern: null,
		lastBet: null
	});
	
	// 3. Enviar atualizaÃ§Ãµes para UI
	sendMessageToContent('PATTERN_BANK_UPDATE', { total: 0 });
	sendMessageToContent('CLEAR_ANALYSIS');
	sendAnalysisStatus('ğŸ”„ Reset completo - Aguardando nova anÃ¡lise...');
	await setPatternDiscoveryCutoffFlag(Date.now());
	
	console.log('â•‘  âœ… RESET COMPLETO - TUDO ZERADO                         â•‘');
	console.log('â•‘  ğŸ“Š PadrÃµes: Limpos                                       â•‘');
	console.log('â•‘  ğŸ¯ AnÃ¡lise Pendente: Limpa                               â•‘');
	console.log('â•‘  ğŸ“ˆ Entradas: Preservadas                                 â•‘');
	console.log('â•‘  Calibrador: Preservado                                   â•‘');
}

// Busca INICIAL de padrÃµes por 30 segundos ao abrir a extensÃ£o
let initialSearchActive = false;
let initialSearchInterval = null;

async function startInitialPatternSearch(history) {
	if (!history || history.length < 50) {
		console.log('âš ï¸ HistÃ³rico insuficiente para busca inicial (<50 giros). Aguardando...');
		return;
	}
	
	if (initialSearchActive) {
		console.log('âš ï¸ Busca inicial jÃ¡ estÃ¡ em andamento.');
		return;
	}
	
	initialSearchActive = true;
	const startTime = Date.now();
	const duration = 30 * 1000; // 30 segundos (30s)
	const updateInterval = 1000; // âœ… ATUALIZAR A CADA 1 SEGUNDO (cronÃ´metro fluido)
	
	console.log('%cğŸ” Busca de padrÃµes iniciada | 30s | ' + history.length + ' giros', 'color: #00D4FF; font-weight: bold; background: #002244; padding: 4px 8px; border-radius: 4px;');
	
	// âœ… NOTIFICAR IMEDIATAMENTE COM 0 PADRÃ•ES (antes da primeira iteraÃ§Ã£o)
	sendMessageToContent('INITIAL_SEARCH_START', { 
		duration: duration,
		startTime: startTime
	});
	
	// âœ… Loop de CRONÃ”METRO (atualiza a cada 1s) + BUSCA de padrÃµes (a cada 5s)
	let iteration = 0;
	let lastSearchTime = Date.now();
	const searchInterval = 5000; // Buscar padrÃµes a cada 5 segundos
	
	initialSearchInterval = setInterval(async () => {
		iteration++;
		const elapsed = Date.now() - startTime;
		const remaining = duration - elapsed;
		const minutes = Math.floor(remaining / 60000);
		const seconds = Math.floor((remaining % 60000) / 1000);
		
		if (remaining <= 0 || elapsed >= duration) {
			// Tempo esgotado - finalizar busca
			clearInterval(initialSearchInterval);
			initialSearchActive = false;
			
			const db = await loadPatternDB(); // âœ… Aqui pode logar (busca finalizada)
			const total = db.patterns_found ? db.patterns_found.length : 0;
			
		console.log('%câœ… Busca concluÃ­da | ' + total + '/5000 padrÃµes | ğŸ¯ Pronto!', 'color: #00FF88; font-weight: bold; background: #003322; padding: 4px 8px; border-radius: 4px;');
			
			sendMessageToContent('INITIAL_SEARCH_COMPLETE', { 
				total: total,
				duration: elapsed
			});
			return;
		}
		
		// âœ… ATUALIZAR CRONÃ”METRO NA UI (a cada 1s)
		const db = await loadPatternDB(true); // silent = true (sem logs gigantes)
		const total = db.patterns_found ? db.patterns_found.length : 0;
		
		// âœ… LOG A CADA 10 SEGUNDOS (reduzido para menos poluiÃ§Ã£o)
		if (iteration % 10 === 0) {
			console.log(`%câ±ï¸ Busca: ${minutes}m ${seconds}s | ${total}/5000 padrÃµes`, 'color: #00D4FF; font-weight: bold;');
		}
		
		sendMessageToContent('INITIAL_SEARCH_PROGRESS', { 
			total: total,
			remaining: remaining,
			iteration: iteration
		});
		
		// âœ… BUSCAR PADRÃ•ES apenas a cada 5 segundos (para nÃ£o sobrecarregar)
		const timeSinceLastSearch = Date.now() - lastSearchTime;
		if (timeSinceLastSearch >= searchInterval) {
			lastSearchTime = Date.now();
			
			try {
				const iterationStartTs = Date.now();
				const iterationBudget = Math.min(8000, remaining); // AtÃ© 8s por iteraÃ§Ã£o
				
				await discoverAndPersistPatterns(history, iterationStartTs, iterationBudget);
				
				const dbAfterSearch = await loadPatternDB(true); // silent = true
				const totalAfterSearch = dbAfterSearch.patterns_found ? dbAfterSearch.patterns_found.length : 0;
				
			// Log removido: jÃ¡ temos o cronÃ´metro periÃ³dico
				
				// Se atingiu o limite, parar
				if (totalAfterSearch >= 5000) {
					clearInterval(initialSearchInterval);
					initialSearchActive = false;
					
				console.log('%câœ… Limite atingido | 5000 padrÃµes | ğŸ¯ Pronto!', 'color: #00FF88; font-weight: bold; background: #003322; padding: 4px 8px; border-radius: 4px;');
					
					sendMessageToContent('INITIAL_SEARCH_COMPLETE', { 
						total: totalAfterSearch,
						duration: elapsed
					});
				}
			} catch (error) {
				console.error('âŒ Erro na busca inicial:', error);
			}
		}
	}, updateInterval);
}

// Para a busca inicial (se necessÃ¡rio)
function stopInitialPatternSearch() {
	if (initialSearchInterval) {
		clearInterval(initialSearchInterval);
		initialSearchActive = false;
		console.log('%câ¸ï¸ Busca interrompida', 'color: #FF9900; font-weight: bold;');
	}
}

// Gera assinatura Ãºnica para evitar duplicidade de padrÃ£o (RIGOROSA)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GERAR CHAVE ÃšNICA PARA PADRÃƒO - REFATORADO 100% (Anti-duplicaÃ§Ã£o)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function patternKeyOf(p) {
	// âœ… VALIDAÃ‡ÃƒO DE ENTRADA
	if (!p || typeof p !== 'object') {
		console.warn('âš ï¸ PadrÃ£o invÃ¡lido para geraÃ§Ã£o de chave:', p);
		return 'invalid-pattern';
	}
	
	// âœ… NORMALIZAR PADRÃƒO (string â†’ array para consistÃªncia)
	let normalizedPattern;
	if (Array.isArray(p.pattern)) {
		normalizedPattern = p.pattern;
	} else if (typeof p.pattern === 'string') {
		// âœ… Converter string para array de 1 elemento
		normalizedPattern = [p.pattern];
	} else {
		console.warn('âš ï¸ Formato de padrÃ£o desconhecido:', p.pattern);
		normalizedPattern = [];
	}
	
	// âœ… GERAR STRING DO PADRÃƒO
	const core = normalizedPattern.join('-');
	
	// âœ… EXTRAIR TIPO
	const type = p.type || p.patternType || 'generic';
	
	// âœ… EXTRAIR PRÃ“XIMA COR ESPERADA
	const expect = p.expected_next || p.suggestedColor || '';
	
	// âœ… CALCULAR TAMANHO REAL DO PADRÃƒO
	const size = normalizedPattern.length;
	
	// âœ… ASSINATURA ÃšNICA: tipo + tamanho + sequÃªncia + prÃ³xima cor
	// âš ï¸ NÃƒO incluir triggerColor (pode variar entre ocorrÃªncias)
	const uniqueKey = `${type}|s:${size}|p:${core}|e:${expect}`;
	
	return uniqueKey;
}

// Verifica se padrÃ£o jÃ¡ existe no banco (por assinatura)
function isDuplicatePattern(newPattern, existingPatterns) {
	const newKey = patternKeyOf(newPattern);
	return existingPatterns.some(p => patternKeyOf(p) === newKey);
}

// VerificaÃ§Ã£o: compara head do histÃ³rico com padrÃµes salvos e retorna melhor sinal
// âœ… Aceita db opcional para simulaÃ§Ãµes/otimizaÃ§Ãµes (evita loadPatternDB a cada giro)
async function verifyWithSavedPatterns(history, dbOverride = null) {
	if (!history || history.length < 3) return null;
	const db = dbOverride || await loadPatternDB();
	if (!db.patterns_found || db.patterns_found.length === 0) return null;

	const headColors = history.map(s => s.color);
	const maxTrackedStage = MAX_GALE_STAGE_TRACKED;
	let best = null;
	for (const pat of db.patterns_found) {
		const galeStageTotals = Array(maxTrackedStage + 1).fill(0);
		const galeStageWins = Array(maxTrackedStage + 1).fill(0);
		const galeStageLosses = Array(maxTrackedStage + 1).fill(0);
		const galeCoverageAvailable = Array(maxTrackedStage + 1).fill(0);
		const galeSuccessCumulative = Array(maxTrackedStage + 1).fill(0);
		if (!Array.isArray(pat.pattern) || pat.pattern.length === 0) continue;
		const need = pat.pattern.length;
		if (need < 3) continue; // ignorar padrÃµes muito curtos
		if (headColors.length < need) continue;
		const currentSeq = headColors.slice(0, need);
		const isMatch = currentSeq.every((c, i) => c === pat.pattern[i]);
		if (!isMatch) continue;
		let suggested = pat.expected_next || pat.suggestedColor; // âœ… Mudado para 'let' para permitir reatribuiÃ§Ã£o
		if (!suggested) continue;

	// Obter cor de disparo atual (serÃ¡ usada depois para referÃªncia)
		const currentTrigger = headColors[need]; // cor imediatamente anterior ao padrÃ£o no histÃ³rico
	
	const currentTriggerNormalized = normalizeColorName(currentTrigger);
	const firstPatternNormalized = normalizeColorName(getInitialPatternColor(pat.pattern));

	if (!firstPatternNormalized) {
		console.warn('âš ï¸ PadrÃ£o salvo com cor inicial invÃ¡lida (nÃ£o conseguiu normalizar):', pat.pattern);
		continue;
	}

	if (!currentTriggerNormalized) {
		console.log('âŒ PadrÃ£o salvo rejeitado: sem cor de disparo atual disponÃ­vel', {
			pattern: pat.pattern,
			firstPatternColor: getInitialPatternColor(pat.pattern)
		});
		continue;
	}

	const validation = validateDisparoColor(firstPatternNormalized, currentTriggerNormalized);
	if (!validation.valid) {
		console.log('âŒ PadrÃ£o salvo rejeitado: cor de disparo atual invÃ¡lida', {
				pattern: pat.pattern,
				currentTrigger: currentTrigger,
			currentTriggerNormalized,
			firstPatternColor: getInitialPatternColor(pat.pattern),
			firstPatternNormalized,
			motivo: validation.reason || 'Cor de disparo igual ou invÃ¡lida'
		});
		continue;
	}
		// NÃƒO exigir que a trigger seja igual Ã  salva; triggers podem variar por ocorrÃªncia

		// Reconstruir ocorrÃªncias com nÃºmeros e horÃ¡rios a partir do histÃ³rico
	// âœ… APLICAR PROFUNDIDADE DE ANÃLISE CONFIGURADA PELO USUÃRIO
	const configuredDepth = analyzerConfig.historyDepth || 2000;
	const searchDepth = Math.min(configuredDepth, history.length);
	const minIntervalSpins = analyzerConfig.minIntervalSpins || 0;
	
		const occNumbers = [];
		const occTimestamps = [];
		const trigNumbers = [];
		const trigTimestamps = [];
	const occurrenceDetails = [];
		let occCount = 0;
		let lastAcceptedIndexForDetails = null;
	for (let i = need; i < searchDepth; i++) {
			const seq = history.slice(i, i + need);
			if (seq.length < need) break;
			const seqColors = seq.map(s => s.color);
			const match = seqColors.every((c, idx) => c === pat.pattern[idx]);
			if (match) {
			// â±ï¸ INTERVALO ENTRE PADRÃ•ES (ocorrÃªncias detalhadas do MESMO padrÃ£o)
			if (minIntervalSpins > 0 && lastAcceptedIndexForDetails !== null) {
				const diff = i - lastAcceptedIndexForDetails;
				if (diff < minIntervalSpins) {
					continue; // ocorrÃªncia muito prÃ³xima da Ãºltima deste padrÃ£o
				}
			}
			
			const trigSpin = history[i + need];
			const trigColorRaw = trigSpin ? trigSpin.color : null;
			
			const trigNormalized = normalizeColorName(trigColorRaw);
			let triggerValid = true;
			if (!trigNormalized) {
				triggerValid = !analyzerConfig.requireTrigger;
			} else {
				triggerValid = validateDisparoColor(firstPatternNormalized, trigNormalized).valid;
			}
			if (!triggerValid) continue;

			const resultColor = history[i - 1] ? history[i - 1].color : null;
			const occurrenceRecord = createOccurrenceRecord(pat.pattern, trigColorRaw, resultColor, seq, trigSpin, occCount + 1);
			occurrenceRecord.gale_results = evaluateGaleStagesForOccurrence(history, i, suggested, maxTrackedStage);

			if (occurrenceRecord.flag_invalid_disparo) {
				continue;
			}

				occCount++;
				occNumbers.push(seq.map(s => s.number));
				occTimestamps.push(seq.map(s => s.timestamp));
				trigNumbers.push(trigSpin ? trigSpin.number : null);
				trigTimestamps.push(trigSpin ? trigSpin.timestamp : null);
			occurrenceDetails.push(occurrenceRecord);
			lastAcceptedIndexForDetails = i;
			}
		}

	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// NOVA LÃ“GICA DE VALIDAÃ‡ÃƒO: HÃ­brida (Antiga + Nova)
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	const minOccurrences = Math.max(analyzerConfig.minOccurrences || 1, 1);
	
	// Contar todas as ocorrÃªncias do padrÃ£o no histÃ³rico
	const colorResults = { red: 0, black: 0, white: 0 };
	let totalOccurrences = 0;
	let lastAcceptedIndexForStats = null;
	
		for (let i = need; i < history.length; i++) {
			const seq = history.slice(i, i + need);
			if (seq.length < need) break;
			const seqColors = seq.map(s => s.color);
			const match = seqColors.every((c, idx) => c === pat.pattern[idx]);
			if (!match) continue;
		
		// â±ï¸ INTERVALO ENTRE PADRÃ•ES (contagem estatÃ­stica do MESMO padrÃ£o)
		if (minIntervalSpins > 0 && lastAcceptedIndexForStats !== null) {
			const diff = i - lastAcceptedIndexForStats;
			if (diff < minIntervalSpins) {
				continue;
			}
		}
		
		const trigEntry = history[i + need] ? history[i + need].color : null;
		const trigNormalized = normalizeColorName(trigEntry);
		if (!trigNormalized) {
			if (analyzerConfig.requireTrigger) continue;
		} else {
			if (!validateDisparoColor(firstPatternNormalized, trigNormalized).valid) continue;
		}
		
		totalOccurrences++;
		lastAcceptedIndexForStats = i;
		const resultColor = history[i - 1] ? history[i - 1].color : null;
		if (resultColor) {
			colorResults[resultColor]++;
		}
		const stageAvailable = Math.min(maxTrackedStage, i - 1);
		for (let stage = 0; stage <= stageAvailable; stage++) {
			galeCoverageAvailable[stage]++;
		}
		const galeResults = evaluateGaleStagesForOccurrence(history, i, suggested, maxTrackedStage);
		let successStageValue = null;
		galeResults.forEach(result => {
			galeStageTotals[result.stage]++;
			if (result.win) {
				galeStageWins[result.stage]++;
				if (successStageValue === null) {
					successStageValue = result.stage;
				}
			} else {
				galeStageLosses[result.stage]++;
			}
		});
		if (successStageValue !== null) {
			for (let stage = successStageValue; stage < galeSuccessCumulative.length; stage++) {
				galeSuccessCumulative[stage]++;
			}
		}
	}
	
	// âœ… VALIDAR QUANTIDADE MÃNIMA DE OCORRÃŠNCIAS
	if (totalOccurrences < minOccurrences) {
		console.log('âŒ PadrÃ£o salvo rejeitado: ocorrÃªncias insuficientes:', {
				pattern: pat.pattern,
				suggested,
			totalOccurrences,
			minOccurrences
		});
		continue;
	}
	
	// âœ… VALIDAR QUANTIDADE MÃXIMA DE OCORRÃŠNCIAS (0 = sem limite)
	// âš ï¸ MODO IA: Ignora validaÃ§Ã£o de mÃ¡ximo de ocorrÃªncias (configuraÃ§Ã£o exclusiva do modo padrÃ£o)
	if (!analyzerConfig.aiMode) {
		const maxOccurrences = analyzerConfig.maxOccurrences || 0;
		if (maxOccurrences > 0 && totalOccurrences > maxOccurrences) {
			console.log('âŒ PadrÃ£o salvo rejeitado: excede ocorrÃªncias mÃ¡ximas:', {
				pattern: pat.pattern,
				suggested,
				totalOccurrences,
				maxOccurrences,
				limite: `mÃ¡x ${maxOccurrences}`
			});
			continue;
		}
	}
	
	// âœ… VALIDAR TAMANHO MÃNIMO E MÃXIMO DO PADRÃƒO
	// âš ï¸ MODO IA: Ignora validaÃ§Ãµes de tamanho (configuraÃ§Ãµes exclusivas do modo padrÃ£o)
	if (!analyzerConfig.aiMode) {
		const patternSize = pat.pattern.length;
		const minPatternSize = analyzerConfig.minPatternSize || 2;
		if (patternSize < minPatternSize) {
			console.log('âŒ PadrÃ£o salvo rejeitado: tamanho abaixo do mÃ­nimo:', {
				pattern: pat.pattern,
				patternSize,
				minPatternSize,
				limite: `mÃ­n ${minPatternSize} giros`
			});
			continue;
		}
		
		// âœ… VALIDAR TAMANHO MÃXIMO DO PADRÃƒO (0 = sem limite)
		const maxPatternSize = analyzerConfig.maxPatternSize || 0;
		if (maxPatternSize > 0 && patternSize > maxPatternSize) {
			console.log('âŒ PadrÃ£o salvo rejeitado: tamanho acima do mÃ¡ximo:', {
				pattern: pat.pattern,
				patternSize,
				maxPatternSize,
				limite: `mÃ¡x ${maxPatternSize} giros`
			});
			continue;
		}
	}
	
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// DECISÃƒO: Qual lÃ³gica usar?
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	let isValid = false;
	
	if (totalOccurrences === minOccurrences) {
		// âœ… LÃ“GICA ANTIGA: Exige 100% WIN
		console.log(`ğŸ“Š PadrÃ£o ${pat.pattern.join('-')}: ${totalOccurrences} ocorrÃªncias (= mÃ­nimo)`);
		console.log('   Aplicando LÃ“GICA ANTIGA (100% WIN)');
		
		const winsInSuggested = colorResults[suggested] || 0;
		isValid = (winsInSuggested === minOccurrences);
		
		if (!isValid) {
			console.log('   âŒ Rejeitado: NÃ£o tem 100% WIN na cor sugerida');
			console.log(`      ${suggested}: ${winsInSuggested}/${minOccurrences} WINS`);
		} else {
			console.log('   âœ… Aprovado: 100% WIN na cor sugerida');
		}
		
	} else {
		// âœ… LÃ“GICA NOVA: Cor que aparece mais
		const redCount = colorResults.red || 0;
		const blackCount = colorResults.black || 0;
		const whiteCount = colorResults.white || 0;
		
		// Ignorar branco se < 5%
		const whitePct = (whiteCount / totalOccurrences) * 100;
		const shouldIgnoreWhite = whitePct < 5;
		
		// Determinar cor vencedora (SEM VIÃ‰S - IMPARCIAL)
		let winningColor = null;
		let winningCount = 0;
		
		// âœ… CORREÃ‡ÃƒO: Usar >= para evitar viÃ©s em empates
		// Ordem: BLACK â†’ RED â†’ WHITE
		
		if (blackCount > winningCount) {
			winningColor = 'black';
			winningCount = blackCount;
		}
		
		if (redCount >= winningCount && redCount > 0) {
			winningColor = 'red';
			winningCount = redCount;
		}
		
		if (!shouldIgnoreWhite && whiteCount >= winningCount && whiteCount > 0) {
			winningColor = 'white';
			winningCount = whiteCount;
		}
		
		if (!winningColor) {
			continue; // Sem cor vencedora, ignorar silenciosamente
		}
		
		// Calcular WINS e LOSS
		const totalWins = winningCount;
		const totalLoss = totalOccurrences - winningCount;
		const balance = totalWins - totalLoss;
		
		// âœ… FILTRAR PADRÃ•ES FRACOS SILENCIOSAMENTE
		if (totalWins < minOccurrences) {
			continue; // NÃ£o atende mÃ­nimo de WINS
		}
		
		if (balance <= 0) {
			continue; // Saldo nÃ£o positivo
		}
		
		// Verificar se cor vencedora Ã© a sugerida
		if (winningColor !== suggested) {
			console.log(`   âš ï¸ Cor vencedora (${winningColor}) difere da sugerida (${suggested})`);
			console.log('   Atualizando sugerida para cor vencedora');
			suggested = winningColor; // Atualizar para usar cor vencedora
		}
		
		isValid = true;
		console.log('   âœ… Aprovado pela NOVA LÃ“GICA');
	}
	
	// Se nÃ£o passou na validaÃ§Ã£o, pular este padrÃ£o
	if (!isValid) {
		continue;
		}

		const patternName = identifyPatternType(pat.pattern, null);
		// Calcular assertividade inteligente baseada no histÃ³rico e contexto recente
		const assertCalc = computeAssertivenessForColorPattern(pat.pattern, suggested, history);
		const patternDesc = {
			colorAnalysis: {
				pattern: pat.pattern,
				occurrences: occCount || pat.occurrences || 1,
				allOccurrenceNumbers: occNumbers,
				allOccurrenceTimestamps: occTimestamps,
				patternType: patternName,
			triggerColor: currentTrigger || null, // SEMPRE usar trigger ATUAL, nÃ£o o salvo
				allTriggerNumbers: trigNumbers,
                allTriggerTimestamps: trigTimestamps,
                occurrenceDetails: occurrenceDetails, // Detalhes por ocorrÃªncia (append-only)
                summary: (function(){
                    // Recomputar wins/losses exatamente com as mesmas regras de ocorrÃªncia (inclui trigger)
                    let w = 0, l = 0, occ = 0;
                    for (let i = need; i < history.length; i++) {
                        const seq = history.slice(i, i + need);
                        if (seq.length < need) break;
                        const seqColors = seq.map(s => s.color);
                        const match = seqColors.every((c,ix) => c === pat.pattern[ix]);
                        if (!match) continue;
						
						// SÃ³ validar trigger se requireTrigger estiver ativo
						if (analyzerConfig.requireTrigger) {
						const trig = history[i + need] ? history[i + need].color : null;
						if (!trig || !isValidTrigger(trig, pat.pattern)) continue;
						}
						// triggers podem variar; nÃ£o exigir igualdade Ã  trigger salva
                        occ++;
                        const out = history[i-1] ? history[i-1].color : null;
                        if (out === suggested) w++; else l++;
                    }
                    const winPct = (w + l) > 0 ? (w/(w+l))*100 : 0;
                    // Calcular rigor baseado na configuraÃ§Ã£o atual
                    const sampleMin = Math.max(analyzerConfig.minOccurrences || 1, 1);
                    let othersWins = 0, othersLosses = 0;
                    let counted = 0;
                    for (let i = need; i < history.length && counted < occ; i++) {
                        const seq = history.slice(i, i + need);
                        if (seq.length < need) break;
                        const seqColors = seq.map(s => s.color);
                        const match = seqColors.every((c,ix) => c === pat.pattern[ix]);
                        if (!match) continue;
                        
                        // SÃ³ validar trigger se requireTrigger estiver ativo
                        if (analyzerConfig.requireTrigger) {
                        const trig = history[i + need] ? history[i + need].color : null;
                        if (!trig || !isValidTrigger(trig, pat.pattern)) continue;
                            // NÃƒO filtrar por cor de disparo especÃ­fica - triggers podem variar entre ocorrÃªncias
                        }
                        counted++;
                        const out = history[i-1] ? history[i-1].color : null;
                        if (counted <= sampleMin) {
                            // amostra mÃ­nima (deveria ser 100% win pela seleÃ§Ã£o); nÃ£o entra no rigor
                            continue;
                        }
                        if (out === suggested) othersWins++; else othersLosses++;
                    }
                    const othersCount = Math.max((occ - sampleMin), 0);
                    const rigorWinPct = othersCount > 0 ? (othersWins / othersCount) * 100 : 100;
                    // CORREÃ‡ÃƒO: Retornar wins/losses TOTAIS, nÃ£o apenas "others"
                    const stageSummaries = galeStageTotals.map((total, stage) => {
                        const wins = galeStageWins[stage];
                        const losses = galeStageLosses[stage];
                        return {
                            stage: stage === 0 ? 'G0' : `G${stage}`,
                            wins,
                            losses,
                            total,
                            winPct: total > 0 ? (wins / total) * 100 : null
                        };
                    });
                    const coverageSummaries = galeCoverageAvailable.map((attempts, stage) => {
                        const wins = galeSuccessCumulative[stage];
                        return {
                            stage: stage === 0 ? 'G0' : `G${stage}`,
                            wins,
                            attempts,
                            coveragePct: attempts > 0 ? (wins / attempts) * 100 : null
                        };
                    });
                    return {
                        occurrences: occ,
                        wins: w,  // Total de wins (inclui rigor + demais)
                        losses: l,  // Total de losses (inclui rigor + demais)
                        winPct: winPct,  // Porcentagem total
                        lossPct: Math.max(0, 100 - winPct),
                        othersCount,
                        othersWins,  // Wins apenas das "demais" (excluindo rigor)
                        othersLosses,  // Losses apenas das "demais" (excluindo rigor)
                        rigorWinPct,  // Porcentagem apenas das "demais"
                        sampleMin,
                        sampleMinWins100: true,
                        patternLength: Array.isArray(pat.pattern) ? pat.pattern.length : null,
                        galeStats: {
                            maxStageTracked: MAX_GALE_STAGE_TRACKED,
                            stages: stageSummaries,
                            coverage: coverageSummaries
                        }
                    };
                })()
			},
			patternType: patternName,
			expected_next: suggested,
			id: pat.id,
			found_at: pat.found_at,
			assertiveness: assertCalc && assertCalc.explain ? assertCalc.explain : undefined
		};
		
		// âœ… VALIDAÃ‡ÃƒO CRÃTICA: Verificar WIN% das ocorrÃªncias "Demais"
		const summary = patternDesc.colorAnalysis.summary;
		if (summary && summary.rigorWinPct !== undefined) {
			const threshold = analyzerConfig.winPercentOthers || 0;
			if (threshold > 0 && summary.rigorWinPct < threshold) {
				// âŒ REJEITAR: WIN% das "Demais" estÃ¡ abaixo do threshold configurado
				logRejectedPattern(
					`${pat.pattern.join('-')} (salvo)`,
					`WIN% Demais = ${summary.rigorWinPct.toFixed(1)}% < ${threshold}% (config)`
				);
				console.log(`   ğŸ“Š Detalhes: ${summary.othersWins}W/${summary.othersLosses}L em ${summary.othersCount} ocorrÃªncias`);
				console.log(`   ğŸ¯ ConfiguraÃ§Ã£o exige: mÃ­nimo ${threshold}% de WIN nas demais ocorrÃªncias`);
				continue;
			}
		}

		// ğŸ”¥ VALIDAÃ‡ÃƒO CRÃTICA FINAL: Cor de disparo ATUAL deve ser vÃ¡lida
		// Verificar se a cor de disparo ATUAL (antes do padrÃ£o head) Ã© diferente da primeira cor do padrÃ£o
		const finalTriggerNormalized = normalizeColorName(currentTrigger);
		const firstFinalNormalized = normalizeColorName(getInitialPatternColor(pat.pattern));

		if (!firstFinalNormalized) {
			console.warn('âš ï¸ PadrÃ£o salvo rejeitado no sinal final: cor inicial invÃ¡lida', pat.pattern);
			continue;
		}

		if (!finalTriggerNormalized) {
			console.log(`âŒ PadrÃ£o salvo rejeitado no sinal final: sem cor de disparo atual`);
			continue; // Sempre exigir trigger vÃ¡lida na hora de enviar sinal
		}
		
		const finalValidation = validateDisparoColor(firstFinalNormalized, finalTriggerNormalized);
		
		if (!finalValidation.valid) {
			console.log(`âŒ PadrÃ£o salvo rejeitado no sinal final: cor de disparo atual INVÃLIDA`, {
				pattern: pat.pattern.join('-'),
				currentTrigger: currentTrigger,
				triggerNormalized: finalTriggerNormalized,
				firstPatternColor: getInitialPatternColor(pat.pattern),
				firstNormalized: firstFinalNormalized,
				motivo: finalValidation.reason || 'Cor de disparo IGUAL ou invÃ¡lida - corromperia o padrÃ£o!'
			});
			continue; // âŒ Cor de disparo INVÃLIDA - NÃƒO ENVIAR ENTRADA
		}
		
		console.log(`âœ… ValidaÃ§Ã£o final de trigger: APROVADA`, {
			currentTrigger: finalTriggerNormalized,
			firstPatternColor: firstFinalNormalized,
			isOpposite: finalTriggerNormalized === 'white' || (finalTriggerNormalized === 'red' && firstFinalNormalized === 'black') || (finalTriggerNormalized === 'black' && firstFinalNormalized === 'red')
		});

		// Se assertCalc existe, jÃ¡ vem calibrado; senÃ£o, calibrar a confidence salva
		const rawPatternConfidence = typeof pat.confidence === 'number' ? pat.confidence : 70;
		const patternConfidence = assertCalc ? assertCalc.finalConfidence : applyCalibratedConfidence(rawPatternConfidence);
		
		// âœ… FILTRO DE RISCO DE SEQUÃŠNCIA: EVITAR PADRÃ•ES SALVOS COM ALTO RISCO DE 3 LOSS CONSECUTIVOS
		// Usamos preferencialmente o winPct real calculado em summary; se nÃ£o existir, usamos a confidence do padrÃ£o.
		let estimatedWinProb = null;
		if (summary && typeof summary.winPct === 'number') {
			estimatedWinProb = summary.winPct / 100;
		} else {
			estimatedWinProb = (typeof patternConfidence === 'number' ? patternConfidence : rawPatternConfidence) / 100;
		}
		// Proteger contra extremos 0% e 100%
		estimatedWinProb = Math.min(Math.max(estimatedWinProb, 0.01), 0.99);
		const probThreeLossSaved = Math.pow(1 - estimatedWinProb, 3);
		const maxThreeLossProbSaved = 0.02; // 2% de tolerÃ¢ncia (mesmo limite do modo padrÃ£o multidimensional)
		
		if (probThreeLossSaved > maxThreeLossProbSaved) {
			console.log('âŒ PadrÃ£o salvo rejeitado pelo filtro de risco de sequÃªncia (P(3 LOSS) acima do limite)', {
				pattern: pat.pattern,
				suggested,
				estimatedWinProb: (estimatedWinProb * 100).toFixed(2) + '%',
				probThreeLoss: (probThreeLossSaved * 100).toFixed(2) + '%',
				maxAllowed: (maxThreeLossProbSaved * 100).toFixed(2) + '%'
			});
			continue;
		}

		const candidate = {
			color: suggested,
			suggestion: 'PadrÃ£o salvo',
			confidence: patternConfidence,
			patternDescription: JSON.stringify(patternDesc),
			createdOnTimestamp: history[0] ? history[0].timestamp : new Date().toISOString(),
			predictedFor: 'next',
			phase: 'G0'
		};
		if (!best || candidate.confidence > best.confidence) best = candidate;
	}
	return best;
}

// Descoberta: executa 50+ anÃ¡lises em atÃ© 5s, evita repetir padrÃµes jÃ¡ salvos
async function discoverAndPersistPatterns(history, startTs, budgetMs) {
	if (patternDiscoveryCutoff) {
		history = filterHistoryByResetCutoff(history);
	}
	if (!history || history.length < 50) return; // respeita regra mÃ­nima existente
	const db = await loadPatternDB();
	const existingKeys = new Set(db.patterns_found.map(patternKeyOf));

	const colors = history.map(s => s.color);
	const tasks = [];
	// Planejar 173+ anÃ¡lises diversificadas (cores, nÃºmeros, temporais e brancos)
    for (let size = 3; size <= 15; size++) { // padrÃµes de 3 a 15 giros
		for (let offset = 0; offset < 10; offset++) { // 10 offsets para maior cobertura
			tasks.push({ kind: 'color-window', size, offset });
		}
	}
    for (let len = 3; len <= 8; len++) { // correlaÃ§Ãµes numÃ©ricas atÃ© 8 giros
		for (let offset = 0; offset < 5; offset++) { // 5 offsets
			tasks.push({ kind: 'number-correlation-lite', len, offset });
		}
	}
	// Adicionar anÃ¡lises temporais e de brancos
	tasks.push({ kind: 'white-intervals' });
	tasks.push({ kind: 'night-white' });
	tasks.push({ kind: 'time-repetition' });
	tasks.push({ kind: 'temporal-reversal' });
	tasks.push({ kind: 'white-break' });
	tasks.push({ kind: 'white-after-dominance' });
	tasks.push({ kind: 'complete-cycle' });
	tasks.push({ kind: 'post-white-peak' });
	tasks.push({ kind: 'post-white-recovery' });
	tasks.push({ kind: 'total-correction' });
	tasks.push({ kind: 'microcycle' });
	tasks.push({ kind: 'night-stability' });
	tasks.push({ kind: 'day-oscillation' });

	let discovered = [];
	let duplicatesCount = 0; // âœ… CONTADOR DE DUPLICATAS
	let rejectedByInvalidTriggerCount = 0; // âœ… CONTADOR DE PADRÃ•ES REJEITADOS POR TRIGGER INVÃLIDA
	
	for (let idx = 0; idx < tasks.length; idx++) {
		// OrÃ§amento de tempo
		if ((Date.now() - startTs) > budgetMs) break;
		const t = tasks[idx];
		let results = [];
		if (t.kind === 'color-window') {
			results = discoverColorPatternsFast(colors, t.size, t.offset);
		} else if (t.kind === 'number-correlation-lite') {
			results = discoverNumberCorrelationsFast(history.map(s => s.number), colors, t.len, t.offset);
		} else if (t.kind === 'white-intervals') {
			const pattern = analyzeWhiteIntervals(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'night-white') {
			const pattern = analyzeNightWhitePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'time-repetition') {
			const pattern = analyzeTimeRepetitionPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'temporal-reversal') {
			const pattern = analyzeTemporalReversalPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'white-break') {
			const pattern = analyzeWhiteBreakPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'white-after-dominance') {
			const pattern = analyzeWhiteAfterDominancePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'complete-cycle') {
			const pattern = analyzeCompleteCyclePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'post-white-peak') {
			const pattern = analyzePostWhitePeakPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'post-white-recovery') {
			const pattern = analyzePostWhiteRecoveryPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'total-correction') {
			const pattern = analyzeTotalCorrectionPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'microcycle') {
			const pattern = analyzeMicrocyclePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'night-stability') {
			const pattern = analyzeNightStabilityPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'day-oscillation') {
			const pattern = analyzeDayOscillationPattern(history);
			if (pattern) results = [pattern];
		}
		for (const r of results) {
			// âœ… NORMALIZAR FORMATO DE PADRÃ•ES (CRÃTICO PARA ANTI-DUPLICAÃ‡ÃƒO!)
			
			// 1. Normalizar prÃ³xima cor esperada
			if (r.suggestedColor && !r.expected_next) {
				r.expected_next = r.suggestedColor;
			}
			
			// 2. âœ… NORMALIZAR PADRÃƒO (string â†’ array) ANTES de gerar chave
			if (typeof r.pattern === 'string' && !Array.isArray(r.pattern)) {
				// âœ… Converter string para array diretamente
				r.pattern = [r.pattern];
			} else if (!Array.isArray(r.pattern) && Array.isArray(r.patternArr)) {
				// âœ… Usar patternArr se pattern nÃ£o for array
				r.pattern = r.patternArr;
			} else if (!Array.isArray(r.pattern)) {
				// âœ… Fallback para array vazio
				console.warn('âš ï¸ PadrÃ£o sem formato vÃ¡lido, convertendo para array:', r);
				r.pattern = r.pattern ? [String(r.pattern)] : [];
			}
			
			// 3. Normalizar tipo
			if (!r.type && r.patternType) {
				r.type = r.patternType;
			}
			
			// âœ… GERAR CHAVE ÃšNICA (agora com padrÃ£o normalizado)
			const key = patternKeyOf(r);
			
			// âœ… VERIFICAR DUPLICATA
			if (existingKeys.has(key)) {
				duplicatesCount++; // âœ… INCREMENTAR CONTADOR
				continue; // âœ… Pular duplicata
			}
			
			// âœ… ADICIONAR CHAVE AO SET
			existingKeys.add(key);
			
			// âœ… ADICIONAR AO ARRAY DE DESCOBERTOS
			discovered.push(r);
		}
	}

	// Log resumido: apenas se encontrou novos padrÃµes
	if (discovered.length === 0) {
		// Silencioso: nÃ£o precisa logar quando nÃ£o encontra nada novo
		return;
	}

	// Log compacto de novos padrÃµes
	const timeElapsed = ((Date.now() - startTs) / 1000).toFixed(2);
	console.log(`%cğŸ¯ +${discovered.length} padrÃ£o(Ãµes) | â±ï¸ ${timeElapsed}s`, 'color: #00FF88; font-weight: bold; background: #003322; padding: 4px 8px; border-radius: 4px;');

	// âœ… UPSERT NO DB - REFATORADO COM ANTI-DUPLICAÃ‡ÃƒO
	const nowIso = new Date().toISOString();
	let idCounter = 0; // âœ… Contador para garantir IDs Ãºnicos
	
	for (const p of discovered) {
		// âœ… GERAR ID ÃšNICO (timestamp + contador + random)
		if (!p.id) {
			const timestamp = Date.now();
			const counter = idCounter++;
			const random = Math.floor(Math.random() * 10000);
			p.id = `${timestamp}-${counter}-${random}`;
		}
		
		// âœ… NORMALIZAR DATA DE DESCOBERTA
		p.found_at = p.found_at || nowIso;
		
		// âœ… NORMALIZAR NOME DA PRÃ“XIMA COR ESPERADA
		if (!p.expected_next && p.suggestedColor) {
			p.expected_next = p.suggestedColor;
		}
		
		// âœ… NORMALIZAR CONFIANÃ‡A
		if (typeof p.confidence !== 'number') {
			p.confidence = 70;
		}
		
		// âœ… NORMALIZAR PADRÃƒO (CRÃTICO PARA ANTI-DUPLICAÃ‡ÃƒO!)
		if (!Array.isArray(p.pattern)) {
			if (Array.isArray(p.patternArr)) {
				p.pattern = p.patternArr;
			} else if (typeof p.pattern === 'string') {
				// âœ… Converter string para array de 1 elemento
				p.pattern = [p.pattern];
			} else {
				// âœ… Fallback para array vazio
				p.pattern = [];
				console.warn('âš ï¸ PadrÃ£o sem formato vÃ¡lido:', p);
			}
		}
		
		// âœ… INICIALIZAR CONTADORES DE DESEMPENHO
		if (typeof p.total_wins !== 'number') p.total_wins = 0;
		if (typeof p.total_losses !== 'number') p.total_losses = 0;
		
		// ğŸ”¥ VALIDAÃ‡ÃƒO CRÃTICA FINAL: Validar trigger antes de salvar no banco
		if (Array.isArray(p.pattern) && p.pattern.length > 0 && p.triggerColor) {
			const firstColorNormalized = normalizeColorName(getInitialPatternColor(p.pattern));
			const triggerNormalized = normalizeColorName(p.triggerColor);
			const triggerValidation = validateDisparoColor(firstColorNormalized, triggerNormalized);
			
			if (!triggerValidation.valid) {
				rejectedByInvalidTriggerCount++; // Incrementar contador
				// Log removido: nÃ£o Ã© necessÃ¡rio logar padrÃµes rejeitados individualmente
				continue; // âŒ NÃƒO SALVAR este padrÃ£o no banco
			}
		}
		
		// âœ… ADICIONAR AO BANCO (JÃ VALIDADO COMO NÃƒO DUPLICADO E TRIGGER VÃLIDA)
		db.patterns_found.unshift({
			id: p.id,
			pattern: p.pattern, // âœ… Sempre array apÃ³s normalizaÃ§Ã£o
			expected_next: p.expected_next,
			confidence: p.confidence,
			found_at: p.found_at,
			type: p.type || p.patternType || 'discovery',
			occurrences: p.occurrences || 0,
			triggerColor: p.triggerColor || null,
			total_wins: p.total_wins,
			total_losses: p.total_losses
		});
	}
	// Limitar para nÃ£o crescer indefinidamente
	db.patterns_found = db.patterns_found.slice(0, 5000);
	await savePatternDB(db);
	
	// Log removido: resumo jÃ¡ foi mostrado acima (compacto)
}

// Varredura rÃ¡pida por padrÃµes de cores (sem exigir match atual, apenas descoberta)
function discoverColorPatternsFast(colors, size, strideOffset) {
	const out = [];
	if (!Array.isArray(colors) || colors.length < size + 1) return out;
	if (size < 3) return out; // garantir pelo menos 3 giros no padrÃ£o
	
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// ğŸ”¥ NOVA LÃ“GICA: Agrupar por PADRÃƒO + TRIGGER (nÃ£o sÃ³ padrÃ£o)
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// Isso garante que TODAS as ocorrÃªncias tenham a MESMA cor de disparo!
	
	const outcomesMap = new Map(); // Chave: "padrÃ£o|trigger"
	
	for (let i = size; i < colors.length - 1; i++) {
		if (((i - size) % 5) !== strideOffset) continue; // espaÃ§ar varredura
		const seq = colors.slice(i, i + size);
		const nextColor = colors[i - 1];
		const triggerColor = colors[i + size]; // cor imediatamente antes do padrÃ£o
		
		if (!triggerColor) continue;
		if (!isValidTrigger(triggerColor, seq)) continue; // respeitar regra de disparo
		
		const normalizedTrigger = normalizeColorName(triggerColor);
		if (!normalizedTrigger) continue;
		
		// âœ… CHAVE ÃšNICA: padrÃ£o + trigger (ex: "red-black-red|black")
		// Isso separa ocorrÃªncias com triggers diferentes em grupos distintos!
		const key = `${seq.join('-')}|${normalizedTrigger}`;
		
		let bag = outcomesMap.get(key);
		if (!bag) { 
			bag = { 
				seq, 
				trigger: normalizedTrigger, // âœ… Trigger ÃšNICA deste grupo
				outcomes: [], 
				count: 0 
			}; 
			outcomesMap.set(key, bag); 
		}
		
		bag.outcomes.push(nextColor);
		bag.count++;
	}
	
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// âœ… PROCESSAR CADA GRUPO (padrÃ£o + trigger especÃ­fica)
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	for (const bag of outcomesMap.values()) {
		if (bag.count < 2) continue; // MÃ­nimo 2 ocorrÃªncias com a MESMA trigger
		
		const cnt = {};
		for (const c of bag.outcomes) cnt[c] = (cnt[c] || 0) + 1;
		
		const keys = Object.keys(cnt);
		if (keys.length === 0) continue;
		
		const winner = keys.reduce((a, b) => cnt[a] >= cnt[b] ? a : b);
		const acc = (cnt[winner] / bag.outcomes.length) * 100;
		
		if (acc >= 68) { // um pouco abaixo de 75 para descobrir mais padrÃµes
			const signif = cnt[winner] / (bag.outcomes.length / 3);
			if (signif >= 1.6) {
			// âœ… VALIDAÃ‡ÃƒO FINAL: Garantir que trigger Ã© vÃ¡lida para o padrÃ£o
			const firstPatternColorNormalized = normalizeColorName(bag.seq[0]);
			const triggerValidation = validateDisparoColor(firstPatternColorNormalized, bag.trigger);
			
			if (!triggerValidation.valid) {
				// Log removido: nÃ£o Ã© necessÃ¡rio mostrar padrÃµes rejeitados individualmente
				continue;
			}
			
			// âœ… PADRÃƒO VÃLIDO: Todas as ocorrÃªncias tÃªm a MESMA trigger!
			// Log removido: resumo serÃ¡ mostrado no final
				
				out.push({
					type: 'color-discovery',
					pattern: bag.seq,
					triggerColor: bag.trigger,
					expected_next: winner,
					confidence: acc,
					occurrences: bag.count
				});
			}
		}
	}
	
	return out;
}

// Descoberta leve de correlaÃ§Ã£o numÃ©rica
function discoverNumberCorrelationsFast(numbers, colors, len, strideOffset) {
	const out = [];
	if (!Array.isArray(numbers) || numbers.length < len + 1) return out;
	if (len < 3) return out; // nÃ£o considerar padrÃµes com menos de 3 nÃºmeros
	const map = new Map();
	for (let i = len; i < numbers.length - 1; i++) {
		if (((i - len) % 3) !== strideOffset) continue;
		const seq = [];
		for (let k = 0; k < len; k++) seq.push(numbers[i + (len - 1 - k)]);
		const key = seq.join('â†’');
		const outcome = colors[i - 1];
		let bag = map.get(key);
		if (!bag) { bag = { seq, outcomes: [], count: 0 }; map.set(key, bag); }
		bag.outcomes.push(outcome);
		bag.count++;
	}
	for (const bag of map.values()) {
		if (bag.count < 3) continue;
		const cnt = {};
		for (const c of bag.outcomes) cnt[c] = (cnt[c] || 0) + 1;
		// âœ… CORREÃ‡ÃƒO: Usar primeira chave disponÃ­vel em vez de 'red' como padrÃ£o
		const keys = Object.keys(cnt);
		if (keys.length === 0) continue;
		const winner = keys.reduce((a, b) => cnt[a] >= cnt[b] ? a : b);
		const acc = (cnt[winner] / bag.outcomes.length) * 100;
		const signif = cnt[winner] / (bag.outcomes.length / 3);
		if (acc >= 70 && signif >= 1.8) {
			out.push({
				type: 'number-corr-discovery',
				pattern: bag.seq.map(n => (typeof n === 'number' ? String(n) : n)).join('â†’'),
				patternArr: colorsForNumberSeq(bag.seq),
				expected_next: winner,
				confidence: acc,
				occurrences: bag.count
			});
		}
	}
	return out;
}

function colorsForNumberSeq(seq) {
	return seq.map(n => getColorFromNumber(n));
}

// AI Pattern Analysis System - MULTIDIMENSIONAL
async function performPatternAnalysis(history) {
    // âœ… VALIDAÃ‡ÃƒO INICIAL DO HISTÃ“RICO
    console.log('ğŸ” Iniciando anÃ¡lise multidimensional de IA com', history ? history.length : 'N/A', 'giros', '| Rigor:', rigorLogString());

    if (!history || !Array.isArray(history) || history.length === 0) {
        console.log('âš ï¸ HistÃ³rico invÃ¡lido ou vazio recebido em performPatternAnalysis');
        return null;
    }

    // âœ… APLICAR PROFUNDIDADE DE ANÃLISE CONFIGURADA (historyDepth) PARA O MODO PADRÃƒO
    // ğŸ”¹ IMPORTANTE: performPatternAnalysis sÃ³ Ã© chamado quando aiMode = false (Modo PadrÃ£o)
    const configuredDepth = analyzerConfig && typeof analyzerConfig.historyDepth === 'number'
        ? analyzerConfig.historyDepth
        : 2000;
    const effectiveDepth = Math.min(Math.max(50, configuredDepth), history.length);
    const limitedHistory = history.slice(0, effectiveDepth);

    console.log(`ğŸ“Š HistÃ³rico total disponÃ­vel: ${history.length} giros`);
    console.log(`âš™ï¸ Profundidade configurada (historyDepth): ${configuredDepth} giros`);
    console.log(`âœ… performPatternAnalysis vai usar apenas os Ãºltimos: ${effectiveDepth} giros (respeitando historyDepth)`);
    
    // âœ… BLOQUEAR ANÃLISES DURANTE A BUSCA DE PADRÃ•ES (30s)
    if (initialSearchActive) {
        console.log('%cğŸš« ANÃLISE BLOQUEADA - Busca de padrÃµes em andamento (30s)', 'color: #FFA500; font-weight: bold;');
        return null; // NÃ£o enviar sinais durante a busca
    }
    
    // Verificar se hÃ¡ dados suficientes para anÃ¡lise
    if (limitedHistory.length < 50) {
        console.log('âš ï¸ Dados insuficientes para anÃ¡lise multidimensional:', limitedHistory.length, '/ 50 giros necessÃ¡rios');
        sendAnalysisStatus(`Coletando dados... ${limitedHistory.length}/50 giros`);
        return null;
    }
    
    // Enviar status inicial com quantidade de giros (APÃ“S aplicar historyDepth)
    sendAnalysisStatus(`ğŸ” Iniciando anÃ¡lise multidimensional de IA com ${limitedHistory.length} giros (limite historyDepth)`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ANÃLISE PADRÃƒO (CONTINUA NORMALMENTE SE NÃƒO HOUVER PADRÃƒO CUSTOMIZADO)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // 1. ANÃLISE DE PADRÃ•ES DE COR COM COR DE DISPARO (baseada nos exemplos)
    const colorAnalysis = analyzeColorPatternsWithTrigger(limitedHistory);
    if (colorAnalysis) {
        console.log(`ğŸ“Š PadrÃ£o de cores: ${colorAnalysis.pattern.join('-')} â†’ ${colorAnalysis.suggestedColor} (${colorAnalysis.confidence.toFixed(1)}%, ${colorAnalysis.occurrences}x)`);
    }
    
    // Enviar status para anÃ¡lise numÃ©rica
    sendAnalysisStatus('ğŸ§® Verificando padrÃµes numÃ©ricos...');
    
    // 2. ANÃLISE DE PADRÃ•ES NUMÃ‰RICOS
    const numberAnalysis = analyzeNumberPatterns(limitedHistory);
    if (numberAnalysis) {
        console.log(`ğŸ”¢ PadrÃ£o numÃ©rico: ${numberAnalysis.pattern} â†’ ${numberAnalysis.suggestedNumber} (${numberAnalysis.confidence.toFixed(1)}%)`);
    }
    
    // Enviar status para anÃ¡lise temporal
    sendAnalysisStatus('â° Analisando tendÃªncias temporais...');
    
    // 3. ANÃLISE TEMPORAL E MISTA AVANÃ‡ADA (baseada nos exemplos 21-33)
    const timeAnalysis = analyzeTemporalAndMixedPatterns(limitedHistory);
    if (timeAnalysis) {
        console.log(`â° PadrÃ£o temporal/misto: ${timeAnalysis.pattern} â†’ ${timeAnalysis.suggestedColor} (${timeAnalysis.confidence.toFixed(1)}%)`);
    }
    
    // Enviar status para anÃ¡lise de correlaÃ§Ãµes
    sendAnalysisStatus('ğŸ”— Calculando correlaÃ§Ãµes...');
    
    // 4. ANÃLISE DE CORRELAÃ‡Ã•ES
    const correlationAnalysis = analyzeCorrelations(limitedHistory);
    if (correlationAnalysis) {
        console.log(`ğŸ”— CorrelaÃ§Ã£o: ${correlationAnalysis.pattern} â†’ ${correlationAnalysis.suggestedColor} (${correlationAnalysis.confidence.toFixed(1)}%)`);
    }
    
    // Enviar status para anÃ¡lise de frequÃªncia
    sendAnalysisStatus('ğŸ“Š Avaliando frequÃªncias...');
    
    // 5. ANÃLISE DE FREQUÃŠNCIA MULTIDIMENSIONAL
    const frequencyAnalysis = analyzeMultidimensionalFrequency(limitedHistory);
    if (frequencyAnalysis) {
        console.log(`ğŸ“ˆ FrequÃªncia multidimensional: ${frequencyAnalysis.pattern} â†’ ${frequencyAnalysis.suggestedColor} (${frequencyAnalysis.confidence.toFixed(1)}%)`);
    }
    
    // Enviar status para combinaÃ§Ã£o final
    sendAnalysisStatus('ğŸ¯ Combinando anÃ¡lises...');
    
    // 6. COMBINAR TODAS AS ANÃLISES MULTIDIMENSIONAIS
    const finalAnalysis = await combineMultidimensionalAnalyses(
        colorAnalysis, 
        numberAnalysis, 
        timeAnalysis, 
        correlationAnalysis, 
        frequencyAnalysis
    );
    
    if (finalAnalysis) {
        console.log(`âœ… ANÃLISE MULTIDIMENSIONAL APROVADA: ${finalAnalysis.color} (${finalAnalysis.confidence.toFixed(1)}%)`, '| Rigor:', rigorLogString());
        console.log(`ğŸ“Š ContribuiÃ§Ãµes: Cor=${finalAnalysis.contributions.color}%, NÃºm=${finalAnalysis.contributions.number}%, Tempo=${finalAnalysis.contributions.time}%, Corr=${finalAnalysis.contributions.correlation}%, Freq=${finalAnalysis.contributions.frequency}%`);
        // Enviar status de conclusÃ£o
        sendAnalysisStatus('âœ… PadrÃ£o encontrado!');
    } else {
        console.log('âŒ AnÃ¡lise multidimensional rejeitada - critÃ©rios nÃ£o atendidos');
        // Enviar status de aguardando novo giro apÃ³s anÃ¡lise completa
        sendAnalysisStatus('â³ Aguardando novo giro...');
    }
    
    return finalAnalysis;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANÃLISE DE PADRÃ•ES DE CORES - CORREÃ‡ÃƒO CRÃTICA
// IDENTIFICA SEQUÃŠNCIAS COMPLETAS DE CORES (DO INÃCIO AO FIM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ğŸ”§ FUNÃ‡ÃƒO AUXILIAR: Identificar sequÃªncia completa de cores mais recente
function identifyCompleteColorSequence(colors, maxLength = 20) {
    if (!colors || colors.length < 2) return null;
    
    // Agrupar cores consecutivas iguais em blocos
    const blocks = [];
    let currentColor = colors[0];
    let currentCount = 1;
    
    for (let i = 1; i < Math.min(colors.length, maxLength); i++) {
        if (colors[i] === currentColor) {
            currentCount++;
        } else {
            blocks.push({ color: currentColor, count: currentCount });
            currentColor = colors[i];
            currentCount = 1;
        }
    }
    blocks.push({ color: currentColor, count: currentCount });
    
    // Converter blocos em sequÃªncia completa
    const sequence = [];
    for (const block of blocks) {
        for (let i = 0; i < block.count; i++) {
            sequence.push(block.color);
        }
    }
    
    return {
        sequence: sequence,
        blocks: blocks,
        length: sequence.length
    };
}

function analyzeColorPatternsWithTrigger(history) {
    // âœ… VALIDAÃ‡ÃƒO INICIAL
    if (!history || !Array.isArray(history) || history.length < 50) {
        console.log('âš ï¸ HistÃ³rico insuficiente para anÃ¡lise de cores:', history?.length || 0, '/ 50 giros necessÃ¡rios');
        return null;
    }
    
    // âœ… APLICAR PROFUNDIDADE DE ANÃLISE CONFIGURADA PELO USUÃRIO (historyDepth)
    const configuredDepth = analyzerConfig.historyDepth || 2000;
    const effectiveDepth = Math.min(configuredDepth, history.length);
    const limitedHistory = history.slice(0, effectiveDepth);
    
    console.log(`ğŸ” Iniciando anÃ¡lise de padrÃµes de cores`);
    console.log(`ğŸ“Š HistÃ³rico total disponÃ­vel: ${history.length} giros`);
    console.log(`âš™ï¸ Profundidade configurada pelo usuÃ¡rio: ${configuredDepth} giros`);
    console.log(`âœ… Analisando apenas os Ãºltimos: ${effectiveDepth} giros (respeitando historyDepth)`);
    console.log('ğŸš¨ CORREÃ‡ÃƒO ATIVADA: Identificando SEQUÃŠNCIAS COMPLETAS de cores');
    
    // âœ… EXTRAÃ‡ÃƒO DE CORES (usando histÃ³rico limitado)
    const colors = limitedHistory.map(s => {
        if (!s || !s.color) {
            console.warn('âš ï¸ Giro invÃ¡lido detectado:', s);
            return 'red'; // Fallback seguro
        }
        return s.color;
    });
    
    // âœ… CONFIGURAÃ‡ÃƒO DO USUÃRIO
    const minOccurrences = parseInt(analyzerConfig.minOccurrences) || 5;
    
    console.log(`ğŸ“Š Config: minOccurrences=${minOccurrences}`);
    
    // ğŸ” PASSO 1: IDENTIFICAR SEQUÃŠNCIA COMPLETA MAIS RECENTE
    const currentPattern = identifyCompleteColorSequence(colors, 20);
    
    if (!currentPattern || currentPattern.length < 2) {
        console.log('âŒ NÃ£o foi possÃ­vel identificar sequÃªncia completa nos giros recentes');
        return null;
    }
    
    console.log('ğŸ“ SEQUÃŠNCIA COMPLETA IDENTIFICADA:');
    console.log(`   Giros: ${currentPattern.sequence.join('-')}`);
    console.log(`   Blocos: ${currentPattern.blocks.map(b => `${b.count}x${b.color.toUpperCase()}`).join(' + ')}`);
    console.log(`   Tamanho total: ${currentPattern.length} giros`);
    
    // ğŸ” PASSO 2: BUSCAR ESSA SEQUÃŠNCIA COMPLETA NO HISTÃ“RICO (LIMITADO)
    const patternToFind = currentPattern.sequence;
    const patternLength = patternToFind.length;
    
    const occurrences = [];
    const minIntervalSpins = analyzerConfig.minIntervalSpins || 0;
    
    // Guardar Ãºltimo Ã­ndice aceito para o MESMO padrÃ£o (intervalo entre ocorrÃªncias)
    let lastAcceptedIndex = null;
    
    // Varrer histÃ³rico LIMITADO procurando a SEQUÃŠNCIA COMPLETA
    // âœ… CORREÃ‡ÃƒO: Usar limitedHistory.length em vez de history.length
    for (let i = patternLength; i < limitedHistory.length - 1; i++) {
        const historicalSequence = colors.slice(i, i + patternLength);
        
        // Verificar se a sequÃªncia completa Ã© igual
        const isMatch = historicalSequence.every((c, idx) => c === patternToFind[idx]);
        
        if (isMatch) {
            // â±ï¸ INTERVALO ENTRE PADRÃ•ES (somente MESMO padrÃ£o)
            if (minIntervalSpins > 0 && lastAcceptedIndex !== null) {
                const diff = i - lastAcceptedIndex;
                if (diff < minIntervalSpins) {
                    continue; // muito prÃ³ximo da Ãºltima ocorrÃªncia do MESMO padrÃ£o
                }
            }
            
            const triggerColor = colors[i + patternLength]; // Cor antes da sequÃªncia
            const resultColor = colors[i - 1]; // Cor que saiu APÃ“S a sequÃªncia completa
            
            // âœ… VALIDAR TRIGGER (se configurado)
            if (analyzerConfig.requireTrigger && triggerColor) {
                if (!isValidTrigger(triggerColor, patternToFind)) {
                    continue; // Trigger invÃ¡lida, pular
                }
            }
            
            occurrences.push({
                index: i,
                trigger: triggerColor,
                result: resultColor,
                number: limitedHistory[i - 1]?.number,
                timestamp: limitedHistory[i - 1]?.timestamp
            });
            
            // Atualizar Ãºltimo Ã­ndice aceito para este padrÃ£o
            lastAcceptedIndex = i;
        }
    }
    
    console.log(`\nğŸ” Buscando sequÃªncia completa no histÃ³rico...`);
    console.log(`   SequÃªncia procurada: ${patternToFind.join('-')}`);
    console.log(`   Tamanho: ${patternLength} giros (COMPLETOS)`);
    console.log(`   OcorrÃªncias encontradas: ${occurrences.length}`);
    
    // âœ… VALIDAR: OcorrÃªncias suficientes?
    if (occurrences.length < minOccurrences) {
        console.log(`âŒ OcorrÃªncias insuficientes: ${occurrences.length} < ${minOccurrences} (mÃ­nimo)`);
        return null;
    }
    
    // ğŸ” PASSO 3: ANALISAR RESULTADOS APÃ“S A SEQUÃŠNCIA COMPLETA
    const colorResults = {
        red: [],
        black: [],
        white: []
    };
    
    occurrences.forEach(occ => {
        if (occ.result) {
            colorResults[occ.result].push(occ);
        }
    });
    
    const redCount = colorResults.red.length;
    const blackCount = colorResults.black.length;
    const whiteCount = colorResults.white.length;
    const totalOccurrences = occurrences.length;
    
    console.log(`\nğŸ“Š RESULTADOS APÃ“S A SEQUÃŠNCIA COMPLETA:`);
    console.log(`   VERMELHO: ${redCount} vezes (${((redCount/totalOccurrences)*100).toFixed(1)}%)`);
    console.log(`   PRETO: ${blackCount} vezes (${((blackCount/totalOccurrences)*100).toFixed(1)}%)`);
    console.log(`   BRANCO: ${whiteCount} vezes (${((whiteCount/totalOccurrences)*100).toFixed(1)}%)`);
    
    // âœ… Ignorar branco se < 5%
    const whitePct = (whiteCount / totalOccurrences) * 100;
    const shouldIgnoreWhite = whitePct < 5;
    
    // ğŸ” PASSO 4: DETERMINAR COR VENCEDORA (SEM VIÃ‰S - IMPARCIAL)
    let winningColor = null;
    let winningCount = 0;
    
    // âœ… CORREÃ‡ÃƒO: Usar >= para garantir que em caso de empate, a ÃšLTIMA cor verificada ganha
    // Ordem: BLACK â†’ RED â†’ WHITE (para nÃ£o favorecer nenhuma cor especÃ­fica)
    
    if (blackCount > winningCount) {
        winningColor = 'black';
        winningCount = blackCount;
    }
    
    if (redCount >= winningCount && redCount > 0) {
        winningColor = 'red';
        winningCount = redCount;
    }
    
    if (!shouldIgnoreWhite && whiteCount >= winningCount && whiteCount > 0) {
        winningColor = 'white';
        winningCount = whiteCount;
    }
    
    if (!winningColor) {
        console.log('âŒ Nenhuma cor vencedora identificada');
        return null;
    }
    
    // âœ… CALCULAR WINS E LOSS DA COR VENCEDORA
    const totalWins = winningCount;
    const totalLoss = totalOccurrences - winningCount;
    const balance = totalWins - totalLoss;
    
    console.log(`\nğŸ¯ COR VENCEDORA: ${winningColor.toUpperCase()}`);
    console.log(`   WINS: ${totalWins}`);
    console.log(`   LOSS: ${totalLoss}`);
    console.log(`   Saldo: ${balance > 0 ? '+' : ''}${balance}`);
    
    // âœ… RECONSTRUIR NÃšMEROS E TIMESTAMPS DE CADA OCORRÃŠNCIA
    // Isso alimenta a UI para desenhar cada ocorrÃªncia completa (igual ao histÃ³rico de giros)
    const allOccurrenceNumbers = [];
    const allOccurrenceTimestamps = [];
    const allTriggerNumbers = [];
    const allTriggerTimestamps = [];
    const allTriggerColors = [];

    occurrences.forEach(occ => {
        const seqStart = occ.index;
        const seqSpins = limitedHistory.slice(seqStart, seqStart + patternLength);
        const triggerSpin = limitedHistory[seqStart + patternLength];

        allOccurrenceNumbers.push(seqSpins.map(s => s?.number ?? null));
        allOccurrenceTimestamps.push(seqSpins.map(s => s?.timestamp ?? null));
        allTriggerNumbers.push(triggerSpin ? triggerSpin.number : null);
        allTriggerTimestamps.push(triggerSpin ? triggerSpin.timestamp : null);
        allTriggerColors.push(triggerSpin ? triggerSpin.color : null);
    });
    
    // âœ… FILTRAR PADRÃ•ES FRACOS
    if (totalWins < minOccurrences) {
        console.log(`âŒ WINS insuficientes: ${totalWins} < ${minOccurrences} (mÃ­nimo)`);
        return null;
    }
    
    if (balance <= 0) {
        console.log(`âŒ Saldo nÃ£o positivo: ${balance}`);
        return null;
    }
    
    // âœ… CALCULAR CONFIANÃ‡A
    const confidence = (totalWins / totalOccurrences) * 100;
    
    console.log(`   ConfianÃ§a: ${confidence.toFixed(1)}%`);
    
    // ğŸ” PASSO 5: VERIFICAR SE PADRÃƒO ATUAL CORRESPONDE
    const currentSequence = colors.slice(0, patternLength);
    const isCurrentMatch = currentSequence.every((c, idx) => c === patternToFind[idx]);
    
    if (!isCurrentMatch) {
        console.log('âŒ SequÃªncia atual nÃ£o corresponde ao padrÃ£o encontrado');
        return null;
    }
    
    // âœ… VALIDAR TRIGGER ATUAL (se configurado)
    const currentTriggerColor = colors[patternLength];
    if (analyzerConfig.requireTrigger) {
        if (!isValidTrigger(currentTriggerColor, patternToFind)) {
            console.log('âŒ Cor de disparo atual invÃ¡lida');
            return null;
        }
    }
    
    // âœ… CONSTRUIR RESULTADO FINAL (incluindo detalhes das ocorrÃªncias para a UI)
    const bestPattern = {
        pattern: patternToFind,
        blocks: currentPattern.blocks, // ğŸ†• InformaÃ§Ã£o dos blocos (ex: 7xPRETO + 7xVERMELHO)
        suggestedColor: winningColor,
        confidence: confidence,
        occurrences: totalOccurrences,
        wins: totalWins,
        loss: totalLoss,
        balance: balance,
        triggerColor: currentTriggerColor,
        colorResults: colorResults,
        type: 'color-pattern',
        patternType: identifyPatternType(patternToFind, currentTriggerColor),
        isCurrentMatch: true,
        currentTriggerValid: true,
        createdOnTimestamp: limitedHistory[0]?.timestamp || null,
        // Arrays usados pela UI para desenhar as ocorrÃªncias
        allOccurrenceNumbers,
        allOccurrenceTimestamps,
        allTriggerNumbers,
        allTriggerTimestamps,
        allTriggerColors,
        summary: {
            occurrences: totalOccurrences,
            wins: totalWins,
            losses: totalLoss,
            winPct: confidence,
            lossPct: Math.max(0, 100 - confidence),
            patternLength: patternLength
        }
    };
    
    console.log(`âœ… PADRÃƒO COMPLETO VALIDADO!`);
    console.log(`   SequÃªncia: ${bestPattern.blocks.map(b => `${b.count}x${b.color.toUpperCase()}`).join(' + ')}`);
    console.log(`   SugestÃ£o: ${bestPattern.suggestedColor.toUpperCase()}`);
    console.log(`   WINS: ${bestPattern.wins} | LOSS: ${bestPattern.loss} | Saldo: +${bestPattern.balance}`);
    console.log(`   ConfianÃ§a: ${bestPattern.confidence.toFixed(1)}%`);
    
    return bestPattern;
}



// Verificar se a Cor de Disparo Ã© vÃ¡lida para o padrÃ£o
function normalizeColorName(color) {
	if (!color) return null;
	const c = color.toString().trim().toLowerCase();
	switch (c) {
		case 'red':
		case 'r':
		case 'vermelho':
		case 'v':
			return 'red';
		case 'black':
		case 'b':
		case 'preto':
		case 'p':
			return 'black';
		case 'white':
		case 'w':
		case 'branco':
		case 'branca':
		case '0':
			return 'white';
		default:
			return null;
	}
}

function getInitialPatternColor(patternArray) {
	if (!Array.isArray(patternArray) || patternArray.length === 0) {
		return null;
	}
	// Os padrÃµes sÃ£o armazenados do mais recente para o mais antigo.
	// A primeira cor imediatamente apÃ³s a cor de disparo Ã© o Ãºltimo elemento.
	return patternArray[patternArray.length - 1];
}

function isValidTrigger(triggerColor, patternSequence) {
    if (!patternSequence || patternSequence.length === 0) return false;
    
	const firstPatternColor = normalizeColorName(getInitialPatternColor(patternSequence));
    const trigger = normalizeColorName(triggerColor);
    
    if (!firstPatternColor || !trigger) return false;
    
    return validateDisparoColor(firstPatternColor, trigger).valid;
}

// Validar se cor de disparo Ã© OPOSTA Ã  cor inicial (regra estrita)
function validateDisparoColor(corInicial, corDisparo) {
    const initial = normalizeColorName(corInicial);
    const trigger = normalizeColorName(corDisparo);
    
    const mapping = {
        'red': ['black', 'white'],
        'black': ['red', 'white'],
        'white': ['red', 'black']
    };
    
    if (!initial || !trigger) {
        return { valid: false, reason: 'missing_color' };
    }
    
    if (initial === trigger) {
        return { valid: false, reason: 'same_as_initial' };
    }
    
    if (!mapping[initial] || !mapping[initial].includes(trigger)) {
        return { valid: false, reason: 'invalid_opposite' };
    }
    
    return { valid: true };
}

// Criar objeto de ocorrÃªncia individual (append-only)
const MAX_GALE_STAGE_TRACKED = 3;

function evaluateGaleStagesForOccurrence(history, startIndex, suggestedColor, maxStage = MAX_GALE_STAGE_TRACKED) {
	const normalizedTarget = normalizeColorName(suggestedColor);
	if (!normalizedTarget || !history) return [];
	const stages = [];
	for (let stage = 0; stage <= maxStage; stage++) {
		const resultIndex = startIndex - 1 - stage;
		if (resultIndex < 0) break;
		const spin = history[resultIndex];
		if (!spin || !spin.color) break;
		const normalizedColor = normalizeColorName(spin.color);
		if (!normalizedColor) break;
		const isWin = normalizedColor === normalizedTarget;
		stages.push({
			stage,
			stageLabel: stage === 0 ? 'G0' : `G${stage}`,
			color: normalizedColor,
			win: isWin,
			number: spin.number ?? null,
			timestamp: spin.timestamp || spin.created_at || null
		});
		if (isWin) break;
	}
	return stages;
}

function createOccurrenceRecord(patternSequence, triggerColor, resultColor, sequenceSpins, triggerSpin, index) {
	const corInicial = normalizeColorName(getInitialPatternColor(patternSequence));
    const triggerNormalized = normalizeColorName(triggerColor);
    const resultNormalized = normalizeColorName(resultColor);
	const validation = validateDisparoColor(corInicial, triggerNormalized);

	const spinsArray = Array.isArray(sequenceSpins) ? sequenceSpins : [];
	const sequenceNumbers = spinsArray.map(spin => spin.number ?? null);
	const sequenceColors = spinsArray.map(spin => normalizeColorName(spin.color));
	const sequenceTimestamps = spinsArray.map(spin => spin.timestamp || spin.created_at || null);

	const triggerNumber = triggerSpin ? triggerSpin.number ?? null : null;
	const triggerTimestamp = triggerSpin ? (triggerSpin.timestamp || triggerSpin.created_at || null) : null;

	const occurrenceTimestamp = sequenceTimestamps[0] || triggerTimestamp || new Date().toISOString();
    
    return {
        occurrence_id: triggerSpin ? (triggerSpin.created_at || triggerSpin.timestamp || `${Date.now()}_${index}`) : `${Date.now()}_${index}`,
        index: index,
        cor_inicial: corInicial,
        cor_disparo: triggerNormalized,
        resultado: resultNormalized,
        timestamp: occurrenceTimestamp,
		sequence_numbers: sequenceNumbers,
		sequence_colors: sequenceColors,
		sequence_timestamps: sequenceTimestamps,
		trigger_number: triggerNumber,
		trigger_timestamp: triggerTimestamp,
        giro_numbers: triggerNumber != null ? [triggerNumber] : [],
        flag_invalid_disparo: !validation.valid,
        invalid_reason: validation.valid ? null : validation.reason,
        raw_trigger_color: !validation.valid ? triggerColor : null
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IDENTIFICAR TIPO DE PADRÃƒO - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function identifyPatternType(pattern, triggerColor) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern) || pattern.length === 0) {
        console.warn('âš ï¸ PadrÃ£o invÃ¡lido para identificaÃ§Ã£o:', pattern);
        return 'PadrÃ£o Desconhecido';
    }
    
    const patternStr = pattern.join('-');
    const patternLength = pattern.length;
    
    // âœ… PADRÃƒO 1-2: REPETIÃ‡ÃƒO (todos da mesma cor)
    const isAllSameColor = pattern.every(color => color === pattern[0]);
    if (isAllSameColor) {
        if (pattern[0] === 'red') return 'RepetiÃ§Ã£o Vermelha';
        if (pattern[0] === 'black') return 'RepetiÃ§Ã£o Preta';
        if (pattern[0] === 'white') return 'RepetiÃ§Ã£o Branca';
    }
    
    // âœ… PADRÃƒO 3-5: ALTERNÃ‚NCIA (cores alternadas)
    if (isAlternatingPattern(pattern)) {
        if (patternLength === 4) return 'AlternÃ¢ncia Curta (4 giros)';
        if (patternLength === 5) return 'AlternÃ¢ncia Longa (5 giros)';
        if (patternLength > 5) return `AlternÃ¢ncia Extendida (${patternLength} giros)`;
        return 'AlternÃ¢ncia Quebrada';
    }
    
    // âœ… PADRÃƒO 6: DUPLA ALTERNÃ‚NCIA (pares alternados)
    if (isDoubleAlternatingPattern(pattern)) {
        return 'Dupla AlternÃ¢ncia';
    }
    
    // âœ… PADRÃƒO 7: INVERSÃƒO RÃPIDA (2 iguais + mudanÃ§a)
    if (patternLength >= 4) {
        const hasQuickInversion = pattern[0] === pattern[1] && pattern[1] !== pattern[2];
        if (hasQuickInversion) {
        return 'InversÃ£o RÃ¡pida';
        }
    }
    
    // âœ… PADRÃƒO 8-9: DOMINÃ‚NCIA (5+ cores da mesma)
    if (patternLength >= 5 && isAllSameColor) {
        const dominantColor = pattern[0];
        if (dominantColor === 'red') return `DominÃ¢ncia Vermelha (${patternLength} giros)`;
        if (dominantColor === 'black') return `DominÃ¢ncia Preta (${patternLength} giros)`;
        if (dominantColor === 'white') return `DominÃ¢ncia Branca (${patternLength} giros)`;
    }
    
    // âœ… PADRÃƒO 10: CORREÃ‡ÃƒO DE COR (metade de uma cor, metade de outra)
    if (isCorrectionPattern(pattern)) {
        return 'CorreÃ§Ã£o de Cor';
    }
    
    // âœ… PADRÃ•ES COM BRANCO
    const hasWhite = pattern.includes('white');
    if (hasWhite) {
        return identifyWhitePattern(pattern);
    }
    
    // âœ… PADRÃƒO GENÃ‰RICO
    return `PadrÃ£o Personalizado (${patternLength} giros)`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERIFICAR PADRÃƒO DE ALTERNÃ‚NCIA - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function isAlternatingPattern(pattern) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern)) {
        return false;
    }
    
    // âœ… MÃNIMO 4 CORES NECESSÃRIO
    if (pattern.length < 4) {
        return false;
    }
    
    // âœ… VERIFICAR SE CADA COR Ã‰ DIFERENTE DA ANTERIOR
    for (let i = 1; i < pattern.length; i++) {
        // Se encontrar duas cores iguais consecutivas, nÃ£o Ã© alternÃ¢ncia
        if (pattern[i] === pattern[i - 1]) {
            return false;
    }
    }
    
    // âœ… TODAS AS CORES ALTERNADAS
    return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERIFICAR DUPLA ALTERNÃ‚NCIA - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function isDoubleAlternatingPattern(pattern) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern)) {
        return false;
    }
    
    // âœ… MÃNIMO 4 CORES NECESSÃRIO (2 pares)
    if (pattern.length < 4) {
        return false;
    }
    
    // âœ… VERIFICAR SE CADA PAR Ã‰ IDÃŠNTICO
    // PadrÃ£o: AA BB AA BB (cada par de cores iguais, pares alternados)
    for (let i = 0; i < pattern.length - 1; i += 2) {
        // Verificar se hÃ¡ Ã­ndice suficiente
        if (i + 1 >= pattern.length) {
            break;
        }
        
        // Par atual deve ter cores iguais
        if (pattern[i] !== pattern[i + 1]) {
            return false;
        }
    }
    
    // âœ… TODOS OS PARES SÃƒO VÃLIDOS
    return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERIFICAR PADRÃƒO DE CORREÃ‡ÃƒO - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function isCorrectionPattern(pattern) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern)) {
        return false;
    }
    
    // âœ… MÃNIMO 5 CORES NECESSÃRIO
    if (pattern.length < 5) {
        return false;
    }
    
    // âœ… DIVIDIR EM DUAS METADES
    const midPoint = Math.floor(pattern.length / 2);
    const firstHalf = pattern.slice(0, midPoint);
    const secondHalf = pattern.slice(midPoint);
    
    // âœ… VALIDAR METADES
    if (firstHalf.length === 0 || secondHalf.length === 0) {
        return false;
    }
    
    // âœ… PRIMEIRA METADE: TODAS DA MESMA COR
    const firstHalfSameColor = firstHalf.every(color => color === firstHalf[0]);
    
    // âœ… SEGUNDA METADE: TODAS DA MESMA COR
    const secondHalfSameColor = secondHalf.every(color => color === secondHalf[0]);
    
    // âœ… AS DUAS METADES DEVEM TER CORES DIFERENTES
    const differentColors = firstHalf[0] !== secondHalf[0];
    
    return firstHalfSameColor && secondHalfSameColor && differentColors;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IDENTIFICAR PADRÃ•ES COM BRANCO - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function identifyWhitePattern(pattern) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern)) {
        console.warn('âš ï¸ PadrÃ£o invÃ¡lido para identificaÃ§Ã£o de branco:', pattern);
        return 'PadrÃ£o Desconhecido';
    }
    
    // âœ… CONTAR QUANTOS BRANCOS
    const whiteCount = pattern.filter(color => color === 'white').length;
    
    // âœ… IDENTIFICAR TIPO BASEADO NA QUANTIDADE
    if (whiteCount === 0) {
        return 'Sem Branco';
    } else if (whiteCount === 1) {
        // Verificar posiÃ§Ã£o do branco
        const whiteIndex = pattern.indexOf('white');
        if (whiteIndex === 0) {
            return 'Branco Inicial';
        } else if (whiteIndex === pattern.length - 1) {
            return 'Branco Final';
        } else {
            return 'Branco Isolado (meio)';
        }
    } else if (whiteCount === 2) {
        // Verificar se sÃ£o consecutivos
        const firstWhiteIndex = pattern.indexOf('white');
        const lastWhiteIndex = pattern.lastIndexOf('white');
        
        if (lastWhiteIndex - firstWhiteIndex === 1) {
            return 'Duplo Branco Consecutivo';
        } else {
            return 'Duplo Branco EspaÃ§ado';
        }
    } else if (whiteCount === 3) {
        return 'Triplo Branco';
    } else if (whiteCount >= pattern.length / 2) {
        return `DominÃ¢ncia Branca (${whiteCount}/${pattern.length})`;
    } else {
        return `PadrÃ£o Misto com Branco (${whiteCount}x)`;
    }
}

// Analisar sequÃªncias recorrentes no histÃ³rico (funÃ§Ã£o antiga mantida para compatibilidade)
function analyzeRecurrentSequences(history) {
    const currentCreatedOn = history[0] ? history[0].timestamp : null;

    // Procura padrÃµes exatos de tamanhos 5 a 8 (mais confiÃ¡veis)
    const bestCandidates = [];
    for (let win = 5; win <= 8; win++) {
        if (history.length < win + 2) continue; // Precisa de pelo menos win + 2 para analisar o prÃ³ximo
        
        // CORRIGIDO: Verificar se o padrÃ£o atual estÃ¡ QUASE COMPLETO (faltando 1 giro)
        const currentSequence = history.slice(0, win).map(s => s.color); // PadrÃ£o completo atual
        const sequences = {};

        for (let i = win; i < history.length - 1; i++) {
            // Buscar padrÃµes que estÃ£o QUASE COMPLETOS (faltando 1 giro)
            const windowSlice = history.slice(i, i + win); // PadrÃ£o completo
            const pastSequence = windowSlice.map(s => s.color);
            const isExactMatch = pastSequence.every((c, idx) => c === currentSequence[idx]);
            if (!isExactMatch) continue;

            // Analisar o giro que COMPLETOU o padrÃ£o (o giro seguinte)
            const completingColor = history[i - 1].color; // O giro que completou o padrÃ£o
            const sequenceKey = pastSequence.join('-');
            if (!sequences[sequenceKey]) {
                sequences[sequenceKey] = {
                    pattern: pastSequence,
                    outcomes: [],
                    count: 0,
                    occurrenceTimes: [],
                    lastOccurrenceTimestamps: [],
                    lastOccurrenceNumbers: []
                };
            }
            sequences[sequenceKey].outcomes.push(completingColor);
            sequences[sequenceKey].count++;
            const occurrenceEndTimestamp = history[i - 1] && history[i - 1].timestamp ? history[i - 1].timestamp : (history[i] && history[i].timestamp);
            if (occurrenceEndTimestamp) sequences[sequenceKey].occurrenceTimes.push(occurrenceEndTimestamp);
            sequences[sequenceKey].lastOccurrenceTimestamps = windowSlice.map(s => s.timestamp);
            sequences[sequenceKey].lastOccurrenceNumbers = windowSlice.map(s => s.number);
        }

        const analyzed = Object.values(sequences).map(seq => {
            const colorCounts = {};
            seq.outcomes.forEach(color => { colorCounts[color] = (colorCounts[color] || 0) + 1; });
            // âœ… CORREÃ‡ÃƒO: Usar primeira chave disponÃ­vel em vez de 'red' como padrÃ£o
            const keys = Object.keys(colorCounts);
            if (keys.length === 0) return null;
            const mostFrequentColor = keys.reduce((a, b) => colorCounts[a] >= colorCounts[b] ? a : b);
            const accuracy = (colorCounts[mostFrequentColor] / seq.outcomes.length) * 100;
            
            // ValidaÃ§Ã£o estatÃ­stica: verificar se nÃ£o Ã© distribuiÃ§Ã£o aleatÃ³ria
            const totalOutcomes = seq.outcomes.length;
            const expectedRandom = totalOutcomes / 3; // Esperado se fosse aleatÃ³rio (3 cores)
            const actualCount = colorCounts[mostFrequentColor];
            const statisticalSignificance = actualCount / expectedRandom;
            
            // SÃ³ aceitar se for estatisticamente significativo (pelo menos 2.0x o esperado para 80%+ acertividade)
            if (statisticalSignificance < 2.0) {
                return null;
            }
            
            return {
                type: 'sequence',
                pattern: seq.pattern,
                window: win,
                suggestedColor: mostFrequentColor, // Cor que mais frequentemente COMPLETOU o padrÃ£o
                accuracy: accuracy,
                occurrences: seq.count,
                occurrenceTimes: seq.occurrenceTimes.sort((a,b) => new Date(b) - new Date(a)),
                lastOccurrenceTimestamps: Array.isArray(seq.lastOccurrenceTimestamps) ? seq.lastOccurrenceTimestamps : [],
                lastOccurrenceNumbers: Array.isArray(seq.lastOccurrenceNumbers) ? seq.lastOccurrenceNumbers : [],
                confidence: accuracy,
                statisticalSignificance: statisticalSignificance,
                createdOnTimestamp: currentCreatedOn
            };
        }).filter(analysis => analysis !== null);

        if (analyzed.length > 0) {
            analyzed.sort((a, b) => (b.confidence - a.confidence) || (b.occurrences - a.occurrences));
            bestCandidates.push(analyzed[0]);
        }
    }

    if (bestCandidates.length === 0) return null;
    bestCandidates.sort((a, b) => (b.confidence - a.confidence) || (b.occurrences - a.occurrences) || (b.window - a.window));
    return bestCandidates[0];
}

// ANÃLISE DE PADRÃ•ES NUMÃ‰RICOS E CORRELATIVOS (baseada nos exemplos 34-50)
function analyzeNumberPatterns(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    const numbers = history.map(s => s.number);
    const colors = history.map(s => s.color);
    const bestPatterns = [];
    
    // 0. NOVO: PadrÃµes nÃºmero+cor â†’ prÃ³xima cor (ex.: 1 vermelho + 14 preto â†’ preto)
    const numberColorPair = analyzeNumberColorPairs(history);
    if (numberColorPair) bestPatterns.push(numberColorPair);
    
    // 1. PADRÃƒO NUMÃ‰RICO 1-4: CorrelaÃ§Ãµes Simples e Estendidas
    const correlationPatterns = analyzeNumberCorrelations(numbers, colors);
    if (correlationPatterns) bestPatterns.push(correlationPatterns);
    
    // 2. PADRÃƒO NUMÃ‰RICO 5-7: SequÃªncias Especiais
    const sequencePatterns = analyzeSpecialSequences(numbers, colors);
    if (sequencePatterns) bestPatterns.push(sequencePatterns);
    
    // 3. (DESATIVADO) PadrÃµes MatemÃ¡ticos por soma â€“ removido para evitar falso positivo de soma
    // const mathPatterns = analyzeMathematicalPatterns(numbers, colors);
    // if (mathPatterns) bestPatterns.push(mathPatterns);
    
    // 4. PADRÃƒO NUMÃ‰RICO 13-17: PadrÃµes AvanÃ§ados
    const advancedPatterns = analyzeAdvancedPatterns(numbers, colors);
    if (advancedPatterns) bestPatterns.push(advancedPatterns);
    
    if (bestPatterns.length === 0) return null;
    
    // Selecionar melhor padrÃ£o dentre os candidatos
    const bestPattern = bestPatterns.sort((a, b) => (b.confidence - a.confidence) || (b.occurrences - a.occurrences))[0];
    
    // VerificaÃ§Ã£o por tipo
    if (bestPattern.type === 'number-color-pair') {
        // Checar se o head atual bate com o par nÃºmero+cor
        if (history.length < 2) return null;
        const headPair = [history[1], history[0]]; // mais antigo â†’ mais recente
        const p = bestPattern.pair; // [{number,color},{number,color}]
        const isMatch = p && p.length === 2 &&
                        headPair[0].number === p[0].number && headPair[0].color === p[0].color &&
                        headPair[1].number === p[1].number && headPair[1].color === p[1].color;
        if (!isMatch) {
            console.log('âŒ Par nÃºmero+cor nÃ£o corresponde ao head atual:', { pair: p, head: [{n: headPair[0].number, c: headPair[0].color},{n: headPair[1].number, c: headPair[1].color}] });
            return null;
        }
        console.log('âœ… Par nÃºmero+cor confirma o padrÃ£o encontrado:', { pair: p, suggested: bestPattern.suggestedColor, conf: bestPattern.confidence.toFixed(1)+'%' });
        return bestPattern;
    }
    
    // Demais padrÃµes numÃ©ricos: manter verificaÃ§Ã£o por nÃºmeros puros
    const patternNumbers = bestPattern.pattern.split('â†’').map(n => parseInt(n));
    const currentNumbers = numbers.slice(0, patternNumbers.length);
    const isCurrentPatternMatch = currentNumbers.every((num, index) => num === patternNumbers[index]);
    if (!isCurrentPatternMatch) {
        console.log('âŒ PadrÃ£o numÃ©rico encontrado nÃ£o corresponde ao padrÃ£o atual:', {
            foundPattern: patternNumbers,
            currentNumbers: currentNumbers,
            isMatch: isCurrentPatternMatch
        });
        return null;
    }
    console.log('âœ… PadrÃ£o numÃ©rico atual confirma o padrÃ£o encontrado:', { foundPattern: patternNumbers, currentNumbers: currentNumbers, isMatch: isCurrentPatternMatch });
    return bestPattern;
}

// Analisar correlaÃ§Ãµes numÃ©ricas (PadrÃµes 1-4)
function analyzeNumberCorrelations(numbers, colors) {
    const correlations = {};
    
    // Buscar sequÃªncias de 2-3 nÃºmeros e suas correlaÃ§Ãµes
    for (let i = 2; i < numbers.length - 1; i++) {
        // PadrÃ£o 1: CorrelaÃ§Ã£o Simples (5â†’11)
        const seq2 = [numbers[i+1], numbers[i]];
        const seq2Key = seq2.join('â†’');
        const resultColor = colors[i-1];
        
        if (!correlations[seq2Key]) {
            correlations[seq2Key] = {
                pattern: seq2,
                outcomes: [],
                count: 0,
                occurrenceTimes: [],
                lastOccurrenceNumbers: []
            };
        }
        
        correlations[seq2Key].outcomes.push(resultColor);
        correlations[seq2Key].count++;
        correlations[seq2Key].occurrenceTimes.push(new Date().toISOString());
        correlations[seq2Key].lastOccurrenceNumbers = seq2;
        
        // PadrÃ£o 2: CorrelaÃ§Ã£o Estendida (10â†’1â†’6)
        if (i >= 2) {
            const seq3 = [numbers[i+2], numbers[i+1], numbers[i]];
            const seq3Key = seq3.join('â†’');
            
            if (!correlations[seq3Key]) {
                correlations[seq3Key] = {
                    pattern: seq3,
                    outcomes: [],
                    count: 0,
                    occurrenceTimes: [],
                    lastOccurrenceNumbers: []
                };
            }
            
            correlations[seq3Key].outcomes.push(resultColor);
            correlations[seq3Key].count++;
            correlations[seq3Key].occurrenceTimes.push(new Date().toISOString());
            correlations[seq3Key].lastOccurrenceNumbers = seq3;
        }
    }
    
    // Analisar correlaÃ§Ãµes encontradas
    const validPatterns = [];
    Object.values(correlations).forEach(pattern => {
        if (pattern.count < 3) return; // MÃ­nimo 3 ocorrÃªncias
        
        const colorCounts = {};
        pattern.outcomes.forEach(color => {
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        });
        
        const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
            colorCounts[a] > colorCounts[b] ? a : b, 'red');
        
        const accuracy = (colorCounts[mostFrequentColor] / pattern.outcomes.length) * 100;
        const statisticalSignificance = colorCounts[mostFrequentColor] / (pattern.outcomes.length / 3);
        
        // âœ… Calcular WINS e LOSSES
        const wins = colorCounts[mostFrequentColor] || 0;
        const losses = pattern.outcomes.length - wins;
        
        if (accuracy >= 75 && statisticalSignificance >= 2.0) {
            validPatterns.push({
                type: 'number-correlation',
                pattern: pattern.pattern.join('â†’'),
                suggestedColor: mostFrequentColor,
                confidence: accuracy,
                occurrences: pattern.count,
                wins: wins,  // âœ… ADICIONADO
                losses: losses,  // âœ… ADICIONADO
                occurrenceTimes: pattern.occurrenceTimes,
                lastOccurrenceNumbers: pattern.lastOccurrenceNumbers,
                statisticalSignificance: statisticalSignificance,
                patternType: pattern.pattern.length === 2 ? 'CorrelaÃ§Ã£o Simples' : 'CorrelaÃ§Ã£o Estendida'
            });
        }
    });
    
    return validPatterns.length > 0 ? validPatterns[0] : null;
}

// NOVO: analisar pares de nÃºmero+cor consecutivos que levam a prÃ³xima cor
function analyzeNumberColorPairs(history) {
    if (!history || history.length < 3) return null;
    const pairMap = new Map();
    // Percorre janelas de 3 giros: [i+2, i+1] determinam o par, outcome Ã© i (giro seguinte)
    for (let i = 1; i < history.length - 1; i++) {
        const a = history[i+1]; // mais antigo no par
        const b = history[i];   // mais recente no par
        const outcome = history[i-1]; // prÃ³xima cor apÃ³s o par
        if (!a || !b || !outcome) continue;
        const key = `${a.number}-${a.color}|${b.number}-${b.color}`;
        let rec = pairMap.get(key);
        if (!rec) {
            rec = { pair: [{ number: a.number, color: a.color }, { number: b.number, color: b.color }], outcomes: [], count: 0 };
            pairMap.set(key, rec);
        }
        rec.outcomes.push(outcome.color);
        rec.count++;
    }
    // Avaliar pares
    const candidates = [];
    pairMap.forEach(rec => {
        if (rec.count < 3) return; // mÃ­nimo 3 ocorrÃªncias do par
        const counts = {};
        rec.outcomes.forEach(c => counts[c] = (counts[c] || 0) + 1);
        // âœ… CORREÃ‡ÃƒO: Usar primeira chave disponÃ­vel em vez de 'red' como padrÃ£o
        const keys = Object.keys(counts);
        if (keys.length === 0) return;
        const winner = keys.reduce((a, b) => counts[a] >= counts[b] ? a : b);
        const acc = (counts[winner] / rec.outcomes.length) * 100;
        const signif = counts[winner] / (rec.outcomes.length / 3);
        if (acc >= 70 && signif >= 1.8) {
            candidates.push({
                type: 'number-color-pair',
                pair: rec.pair,
                suggestedColor: winner,
                confidence: acc,
                occurrences: rec.count,
                statisticalSignificance: signif,
                pattern: `${rec.pair[0].number}-${rec.pair[0].color} + ${rec.pair[1].number}-${rec.pair[1].color}`
            });
        }
    });
    if (candidates.length === 0) return null;
    candidates.sort((a,b)=> (b.confidence - a.confidence) || (b.occurrences - a.occurrences));
    return candidates[0];
}

// Analisar sequÃªncias especiais (PadrÃµes 5-7)
function analyzeSpecialSequences(numbers, colors) {
    const specialPatterns = [];
    
    for (let i = 2; i < numbers.length - 1; i++) {
        const currentNumbers = [numbers[i+2], numbers[i+1], numbers[i]];
        const resultColor = colors[i-1];
        
        // PadrÃ£o 5: Pares Crescentes (2â†’4â†’6)
        if (isAscendingEvenSequence(currentNumbers)) {
            specialPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'Pares Crescentes'
            });
        }
        
        // PadrÃ£o 6: Ãmpares Decrescentes (13â†’11â†’9)
        if (isDescendingOddSequence(currentNumbers)) {
            specialPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'Ãmpares Decrescentes'
            });
        }
        
        // PadrÃ£o 7: Retorno ao MÃºltiplo de 5 (5â†’10â†’0)
        if (isMultipleOfFiveSequence(currentNumbers)) {
            specialPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'MÃºltiplos de 5'
            });
        }
    }
    
    // Analisar padrÃµes especiais encontrados
    const analyzedPatterns = {};
    specialPatterns.forEach(pattern => {
        const key = `${pattern.type}-${pattern.pattern}`;
        if (!analyzedPatterns[key]) {
            analyzedPatterns[key] = {
                pattern: pattern.pattern,
                type: pattern.type,
                outcomes: [],
                count: 0
            };
        }
        analyzedPatterns[key].outcomes.push(pattern.outcome);
        analyzedPatterns[key].count++;
    });
    
    // Retornar o melhor padrÃ£o especial
    const validSpecialPatterns = [];
    Object.values(analyzedPatterns).forEach(pattern => {
        if (pattern.count < 3) return;
        
        const colorCounts = {};
        pattern.outcomes.forEach(color => {
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        });
        
        const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
            colorCounts[a] > colorCounts[b] ? a : b, 'red');
        
        const accuracy = (colorCounts[mostFrequentColor] / pattern.outcomes.length) * 100;
        const statisticalSignificance = colorCounts[mostFrequentColor] / (pattern.outcomes.length / 3);
        
        if (accuracy >= 75 && statisticalSignificance >= 2.0) {
            validSpecialPatterns.push({
                type: 'number-sequence',
                pattern: pattern.pattern,
                suggestedColor: mostFrequentColor,
                confidence: accuracy,
                occurrences: pattern.count,
                statisticalSignificance: statisticalSignificance,
                patternType: pattern.type
            });
        }
    });
    
    return validSpecialPatterns.length > 0 ? validSpecialPatterns[0] : null;
}

// Analisar padrÃµes matemÃ¡ticos (PadrÃµes 8-12)
function analyzeMathematicalPatterns(numbers, colors) {
    const mathPatterns = [];
    
    for (let i = 1; i < numbers.length - 1; i++) {
        const num1 = numbers[i+1];
        const num2 = numbers[i];
        const resultColor = colors[i-1];
        
        // PadrÃ£o 8: DuplicaÃ§Ã£o Reversa
        if (num1 === num2) {
            mathPatterns.push({
                pattern: `${num1}â†’${num2}`,
                outcome: resultColor,
                type: 'DuplicaÃ§Ã£o Reversa'
            });
        }
        
        // PadrÃ£o 9: SequÃªncia de extremos (1â†’14 ou 14â†’1)
        if ((num1 === 1 && num2 === 14) || (num1 === 14 && num2 === 1)) {
            mathPatterns.push({
                pattern: `${num1}â†’${num2}`,
                outcome: resultColor,
                type: 'Extremos Consecutivos'
            });
        }
        
        // PadrÃ£o 10: Soma mÃºltipla de 5
        if ((num1 + num2) % 5 === 0) {
            mathPatterns.push({
                pattern: `${num1}+${num2}=${num1+num2}`,
                outcome: resultColor,
                type: 'Soma MÃºltipla de 5'
            });
        }
        
        // PadrÃ£o 11: AlternÃ¢ncia Ãmpar/Par
        if ((num1 % 2 !== num2 % 2) && getColorFromNumber(num1) === getColorFromNumber(num2)) {
            mathPatterns.push({
                pattern: `${num1}â†’${num2}`,
                outcome: resultColor,
                type: 'AlternÃ¢ncia Ãmpar/Par'
            });
        }
        
        // PadrÃ£o 12: InversÃ£o de Extremidade
        if ((num1 >= 12 && num2 <= 3) || (num1 <= 3 && num2 >= 12)) {
            mathPatterns.push({
                pattern: `${num1}â†’${num2}`,
                outcome: resultColor,
                type: 'InversÃ£o de Extremidade'
            });
        }
    }
    
    // Analisar padrÃµes matemÃ¡ticos encontrados
    const analyzedMathPatterns = {};
    mathPatterns.forEach(pattern => {
        const key = `${pattern.type}-${pattern.pattern}`;
        if (!analyzedMathPatterns[key]) {
            analyzedMathPatterns[key] = {
                pattern: pattern.pattern,
                type: pattern.type,
                outcomes: [],
                count: 0
            };
        }
        analyzedMathPatterns[key].outcomes.push(pattern.outcome);
        analyzedMathPatterns[key].count++;
    });
    
    // Retornar o melhor padrÃ£o matemÃ¡tico
    const validMathPatterns = [];
    Object.values(analyzedMathPatterns).forEach(pattern => {
        if (pattern.count < 3) return;
        
        const colorCounts = {};
        pattern.outcomes.forEach(color => {
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        });
        
        const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
            colorCounts[a] > colorCounts[b] ? a : b, 'red');
        
        const accuracy = (colorCounts[mostFrequentColor] / pattern.outcomes.length) * 100;
        const statisticalSignificance = colorCounts[mostFrequentColor] / (pattern.outcomes.length / 3);
        
        if (accuracy >= 75 && statisticalSignificance >= 2.0) {
            validMathPatterns.push({
                type: 'number-math',
                pattern: pattern.pattern,
                suggestedColor: mostFrequentColor,
                confidence: accuracy,
                occurrences: pattern.count,
                statisticalSignificance: statisticalSignificance,
                patternType: pattern.type
            });
        }
    });
    
    return validMathPatterns.length > 0 ? validMathPatterns[0] : null;
}

// Analisar padrÃµes avanÃ§ados (PadrÃµes 13-17)
function analyzeAdvancedPatterns(numbers, colors) {
    const advancedPatterns = [];
    
    for (let i = 2; i < numbers.length - 1; i++) {
        const currentNumbers = [numbers[i+2], numbers[i+1], numbers[i]];
        const resultColor = colors[i-1];
        
        // PadrÃ£o 13: RepetiÃ§Ã£o de Bloco
        if (isSameColorBlock(currentNumbers)) {
            advancedPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'RepetiÃ§Ã£o de Bloco'
            });
        }
        
        // PadrÃ£o 14: Branco em Intervalo Fixo (simulado)
        if (currentNumbers.includes(0)) {
            advancedPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'Branco em Intervalo'
            });
        }
        
        // PadrÃ£o 15: RepetiÃ§Ã£o por HorÃ¡rio (simulado)
        const hour = new Date().getHours();
        if (hour >= 22 || hour <= 2) { // HorÃ¡rio noturno
            advancedPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'PadrÃ£o Noturno'
            });
        }
        
        // PadrÃ£o 16: Tripla CorrelaÃ§Ã£o Inversa
        if (isTripleSameColor(currentNumbers)) {
            advancedPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'Tripla CorrelaÃ§Ã£o Inversa'
            });
        }
        
        // PadrÃ£o 17: Espelhamento de Intervalo
        if (i >= 10) {
            const mirrorNumbers = [numbers[i+12], numbers[i+11], numbers[i+10]];
            if (isMirrorSequence(currentNumbers, mirrorNumbers)) {
                advancedPatterns.push({
                    pattern: currentNumbers.join('â†’'),
                    outcome: resultColor,
                    type: 'Espelhamento de Intervalo'
                });
            }
        }
    }
    
    // Analisar padrÃµes avanÃ§ados encontrados
    const analyzedAdvancedPatterns = {};
    advancedPatterns.forEach(pattern => {
        const key = `${pattern.type}-${pattern.pattern}`;
        if (!analyzedAdvancedPatterns[key]) {
            analyzedAdvancedPatterns[key] = {
                pattern: pattern.pattern,
                type: pattern.type,
                outcomes: [],
                count: 0
            };
        }
        analyzedAdvancedPatterns[key].outcomes.push(pattern.outcome);
        analyzedAdvancedPatterns[key].count++;
    });
    
    // Retornar o melhor padrÃ£o avanÃ§ado
    const validAdvancedPatterns = [];
    Object.values(analyzedAdvancedPatterns).forEach(pattern => {
        if (pattern.count < 3) return;
        
        const colorCounts = {};
        pattern.outcomes.forEach(color => {
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        });
        
        const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
            colorCounts[a] > colorCounts[b] ? a : b, 'red');
        
        const accuracy = (colorCounts[mostFrequentColor] / pattern.outcomes.length) * 100;
        const statisticalSignificance = colorCounts[mostFrequentColor] / (pattern.outcomes.length / 3);
        
        if (accuracy >= 75 && statisticalSignificance >= 2.0) {
            validAdvancedPatterns.push({
                type: 'number-advanced',
                pattern: pattern.pattern,
                suggestedColor: mostFrequentColor,
                confidence: accuracy,
                occurrences: pattern.count,
                statisticalSignificance: statisticalSignificance,
                patternType: pattern.type
            });
        }
    });
    
    return validAdvancedPatterns.length > 0 ? validAdvancedPatterns[0] : null;
}

// FunÃ§Ãµes auxiliares para anÃ¡lise numÃ©rica
function isAscendingEvenSequence(numbers) {
    return numbers.every(num => num % 2 === 0) && 
           numbers[0] < numbers[1] && numbers[1] < numbers[2];
}

function isDescendingOddSequence(numbers) {
    return numbers.every(num => num % 2 === 1) && 
           numbers[0] > numbers[1] && numbers[1] > numbers[2];
}

function isMultipleOfFiveSequence(numbers) {
    return numbers.every(num => num % 5 === 0);
}

function isSameColorBlock(numbers) {
    // âœ… VALIDAR se todos os nÃºmeros sÃ£o vÃ¡lidos
    if (!numbers || numbers.some(num => num === undefined || num === null)) {
        return false;
    }
    const colors = numbers.map(num => getColorFromNumber(num));
    return colors.every(color => color === colors[0] && color !== 'unknown');
}

function isTripleSameColor(numbers) {
    // âœ… VALIDAR se todos os nÃºmeros sÃ£o vÃ¡lidos
    if (!numbers || numbers.some(num => num === undefined || num === null)) {
        return false;
    }
    const colors = numbers.map(num => getColorFromNumber(num));
    return colors.every(color => color === colors[0] && color !== 'unknown');
}

function isMirrorSequence(seq1, seq2) {
    if (seq1.length !== seq2.length) return false;
    for (let i = 0; i < seq1.length; i++) {
        if (seq1[i] !== seq2[seq2.length - 1 - i]) return false;
    }
    return true;
}

// ANÃLISE DE PADRÃ•ES NUMÃ‰RICOS MULTIDIMENSIONAL (funÃ§Ã£o antiga mantida para compatibilidade)
function analyzeNumberPatternsOld(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const numbers = history.map(s => s.number);
    const colors = history.map(s => s.color);
    
    // 1. ANÃLISE DE SEQUÃŠNCIAS NUMÃ‰RICAS
    const sequencePattern = analyzeNumberSequences(numbers);
    
    // 2. ANÃLISE DE PARIDADE
    const parityPattern = analyzeParityPatterns(numbers, colors);
    
    // 3. ANÃLISE DE FAIXAS NUMÃ‰RICAS
    const rangePattern = analyzeNumberRanges(numbers, colors);
    
    // 4. ANÃLISE DE DÃGITOS
    const digitPattern = analyzeDigitPatterns(numbers, colors);
    
    // 5. ANÃLISE DE PROGRESSÃ•ES MATEMÃTICAS
    const mathPattern = analyzeMathProgressions(numbers, colors);
    
    // Combinar todas as anÃ¡lises numÃ©ricas
    const patterns = [sequencePattern, parityPattern, rangePattern, digitPattern, mathPattern].filter(p => p !== null);
    
    if (patterns.length === 0) return null;
    
    // Encontrar o padrÃ£o com maior confianÃ§a
    const bestPattern = patterns.sort((a, b) => b.confidence - a.confidence)[0];
    
    return {
        type: 'number',
        pattern: bestPattern.pattern,
        suggestedNumber: bestPattern.suggestedNumber,
        suggestedColor: bestPattern.suggestedColor,
        confidence: bestPattern.confidence,
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.statisticalSignificance,
        subPatterns: patterns.map(p => ({ type: p.type, confidence: p.confidence }))
    };
}

// Analisar sequÃªncias numÃ©ricas (1-2-3-4-5, 10-20-30-40-50)
function analyzeNumberSequences(numbers) {
    const sequences = {};
    
    // Procurar sequÃªncias de 2-5 nÃºmeros
    for (let len = 2; len <= 5; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            const key = sequence.join('-');
            
            if (!sequences[key]) {
                sequences[key] = {
                    pattern: sequence,
                    occurrences: 0,
                    nextNumbers: [],
                    nextColors: []
                };
            }
            
            sequences[key].occurrences++;
            
            // Se nÃ£o Ã© a Ãºltima sequÃªncia, pegar o prÃ³ximo nÃºmero
            if (i > 0) {
                sequences[key].nextNumbers.push(numbers[i - 1]);
                // Assumir cor baseada no nÃºmero (serÃ¡ refinado depois)
                sequences[key].nextColors.push(getColorFromNumber(numbers[i - 1]));
            }
        }
    }
    
    // Encontrar sequÃªncias mais frequentes
    const frequentSequences = Object.values(sequences).filter(s => s.occurrences >= 2);
    if (frequentSequences.length === 0) return null;
    
    const bestSequence = frequentSequences.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³xima cor mais provÃ¡vel
    const colorCounts = {};
    bestSequence.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestSequence.nextColors.length) * 100;
    
    return {
        type: 'sequence',
        pattern: `SequÃªncia: ${bestSequence.pattern.join('-')}`,
        suggestedNumber: bestSequence.pattern[bestSequence.pattern.length - 1] + 1, // PrÃ³ximo na sequÃªncia
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 85),
        occurrences: bestSequence.occurrences,
        statisticalSignificance: bestSequence.occurrences / 2 // Normalizar
    };
}

// Analisar padrÃµes de paridade (pares/Ã­mpares)
function analyzeParityPatterns(numbers, colors) {
    const parityPatterns = {};
    
    // Procurar padrÃµes de paridade de 2-5 giros
    for (let len = 2; len <= 5; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            const parity = sequence.map(n => n % 2 === 0 ? 'par' : 'Ã­mpar');
            const key = parity.join('-');
            
            if (!parityPatterns[key]) {
                parityPatterns[key] = {
                    pattern: parity,
                    occurrences: 0,
                    nextParity: [],
                    nextColors: []
                };
            }
            
            parityPatterns[key].occurrences++;
            
            if (i > 0) {
                parityPatterns[key].nextParity.push(numbers[i - 1] % 2 === 0 ? 'par' : 'Ã­mpar');
                parityPatterns[key].nextColors.push(colors[i - 1]);
            }
        }
    }
    
    const frequentPatterns = Object.values(parityPatterns).filter(p => p.occurrences >= 2);
    if (frequentPatterns.length === 0) return null;
    
    const bestPattern = frequentPatterns.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³xima paridade e cor
    const colorCounts = {};
    bestPattern.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestPattern.nextColors.length) * 100;
    
    return {
        type: 'parity',
        pattern: `Paridade: ${bestPattern.pattern.join('-')}`,
        suggestedNumber: bestPattern.pattern[bestPattern.pattern.length - 1] === 'par' ? 'Ã­mpar' : 'par',
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 80),
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.occurrences / 2
    };
}

// Analisar faixas numÃ©ricas (1-7, 8-14, 0)
function analyzeNumberRanges(numbers, colors) {
    const rangePatterns = {};
    
    // Procurar padrÃµes de faixas de 2-5 giros
    for (let len = 2; len <= 5; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            const ranges = sequence.map(n => {
                if (n === 0) return 'branco';
                if (n >= 1 && n <= 7) return 'vermelho';
                if (n >= 8 && n <= 14) return 'preto';
                return 'outro';
            });
            const key = ranges.join('-');
            
            if (!rangePatterns[key]) {
                rangePatterns[key] = {
                    pattern: ranges,
                    occurrences: 0,
                    nextRanges: [],
                    nextColors: []
                };
            }
            
            rangePatterns[key].occurrences++;
            
            if (i > 0) {
                const nextNum = numbers[i - 1];
                const nextRange = nextNum === 0 ? 'branco' : 
                                 (nextNum >= 1 && nextNum <= 7) ? 'vermelho' : 
                                 (nextNum >= 8 && nextNum <= 14) ? 'preto' : 'outro';
                rangePatterns[key].nextRanges.push(nextRange);
                rangePatterns[key].nextColors.push(colors[i - 1]);
            }
        }
    }
    
    const frequentPatterns = Object.values(rangePatterns).filter(p => p.occurrences >= 2);
    if (frequentPatterns.length === 0) return null;
    
    const bestPattern = frequentPatterns.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³xima faixa e cor
    const colorCounts = {};
    bestPattern.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestPattern.nextColors.length) * 100;
    
    return {
        type: 'range',
        pattern: `Faixa: ${bestPattern.pattern.join('-')}`,
        suggestedNumber: bestPattern.pattern[bestPattern.pattern.length - 1] === 'vermelho' ? 'preto' : 
                        bestPattern.pattern[bestPattern.pattern.length - 1] === 'preto' ? 'vermelho' : 'branco',
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 75),
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.occurrences / 2
    };
}

// Analisar padrÃµes de dÃ­gitos (terminaÃ§Ãµes)
function analyzeDigitPatterns(numbers, colors) {
    const digitPatterns = {};
    
    // Procurar padrÃµes de dÃ­gitos finais de 2-5 giros
    for (let len = 2; len <= 5; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            const digits = sequence.map(n => n % 10); // Ãšltimo dÃ­gito
            const key = digits.join('-');
            
            if (!digitPatterns[key]) {
                digitPatterns[key] = {
                    pattern: digits,
                    occurrences: 0,
                    nextDigits: [],
                    nextColors: []
                };
            }
            
            digitPatterns[key].occurrences++;
            
            if (i > 0) {
                digitPatterns[key].nextDigits.push(numbers[i - 1] % 10);
                digitPatterns[key].nextColors.push(colors[i - 1]);
            }
        }
    }
    
    const frequentPatterns = Object.values(digitPatterns).filter(p => p.occurrences >= 2);
    if (frequentPatterns.length === 0) return null;
    
    const bestPattern = frequentPatterns.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³ximo dÃ­gito e cor
    const colorCounts = {};
    bestPattern.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestPattern.nextColors.length) * 100;
    
    return {
        type: 'digit',
        pattern: `DÃ­gitos: ${bestPattern.pattern.join('-')}`,
        suggestedNumber: bestPattern.pattern[bestPattern.pattern.length - 1],
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 70),
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.occurrences / 2
    };
}

// Analisar progressÃµes matemÃ¡ticas (Fibonacci, aritmÃ©ticas)
function analyzeMathProgressions(numbers, colors) {
    const progressions = {};
    
    // Procurar progressÃµes aritmÃ©ticas de 2-4 nÃºmeros
    for (let len = 2; len <= 4; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            
            // Verificar se Ã© progressÃ£o aritmÃ©tica
            const diffs = [];
            for (let j = 1; j < sequence.length; j++) {
                diffs.push(sequence[j] - sequence[j - 1]);
            }
            
            if (diffs.every(d => d === diffs[0])) {
                const key = `PA-${diffs[0]}-${sequence.join('-')}`;
                
                if (!progressions[key]) {
                    progressions[key] = {
                        pattern: sequence,
                        difference: diffs[0],
                        occurrences: 0,
                        nextNumbers: [],
                        nextColors: []
                    };
                }
                
                progressions[key].occurrences++;
                
                if (i > 0) {
                    progressions[key].nextNumbers.push(numbers[i - 1]);
                    progressions[key].nextColors.push(colors[i - 1]);
                }
            }
        }
    }
    
    const frequentProgressions = Object.values(progressions).filter(p => p.occurrences >= 2);
    if (frequentProgressions.length === 0) return null;
    
    const bestProgression = frequentProgressions.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³ximo nÃºmero na progressÃ£o e cor
    const colorCounts = {};
    bestProgression.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestProgression.nextColors.length) * 100;
    
    return {
        type: 'progression',
        pattern: `PA(${bestProgression.difference}): ${bestProgression.pattern.join('-')}`,
        suggestedNumber: bestProgression.pattern[bestProgression.pattern.length - 1] + bestProgression.difference,
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 80),
        occurrences: bestProgression.occurrences,
        statisticalSignificance: bestProgression.occurrences / 2
    };
}

// ANÃLISE DE PADRÃ•ES TEMPORAIS E MISTOS (baseada nos exemplos 21-33)
function analyzeTemporalAndMixedPatterns(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    const colors = history.map(s => s.color);
    const timestamps = history.map(s => s.timestamp);
    const bestPatterns = [];
    
    // 1. PADRÃ•ES DE TEMPO E HORÃRIO (21-25)
    const timePatterns = analyzeTimePatterns(history, colors, timestamps);
    if (timePatterns) bestPatterns.push(timePatterns);
    
    // 2. PADRÃ•ES MISTOS COR + TEMPO (26-33)
    const mixedPatterns = analyzeMixedPatterns(history, colors, timestamps);
    if (mixedPatterns) bestPatterns.push(mixedPatterns);
    
    if (bestPatterns.length === 0) return null;
    
    // CRÃTICO: Verificar se o padrÃ£o atual realmente corresponde ao padrÃ£o encontrado
    const bestPattern = bestPatterns.sort((a, b) => (b.confidence - a.confidence) || (b.occurrences - a.occurrences))[0];
    
    // Para padrÃµes temporais, verificar se o contexto atual Ã© vÃ¡lido
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    const recentSpins = colors.slice(0, 10); // Ãšltimos 10 giros
    
    // Verificar se o padrÃ£o temporal Ã© aplicÃ¡vel ao momento atual
    if (bestPattern.type === 'time-pattern') {
        // Verificar se estamos no horÃ¡rio correto para o padrÃ£o
        if (bestPattern.pattern.includes('Noturno') && (currentHour < 22 || currentHour > 2)) {
            console.log('âŒ PadrÃ£o temporal nÃ£o aplicÃ¡vel ao horÃ¡rio atual:', {
                pattern: bestPattern.pattern,
                currentHour: currentHour
            });
            return null;
        }
        
        if (bestPattern.pattern.includes('Diurno') && (currentHour >= 22 || currentHour <= 2)) {
            console.log('âŒ PadrÃ£o temporal nÃ£o aplicÃ¡vel ao horÃ¡rio atual:', {
                pattern: bestPattern.pattern,
                currentHour: currentHour
            });
            return null;
        }
    }
    
    console.log('âœ… PadrÃ£o temporal/misto atual confirma o padrÃ£o encontrado:', {
        foundPattern: bestPattern.pattern,
        currentHour: currentHour,
        recentSpins: recentSpins.slice(0, 10)
    });
    
    return bestPattern;
}

// Analisar padrÃµes de tempo e horÃ¡rio (21-25)
function analyzeTimePatterns(history, colors, timestamps) {
    const timePatterns = [];
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    
    // PadrÃ£o 21: Branco Intervalado (a cada 70-100 giros)
    const whiteIntervals = analyzeWhiteIntervals(history);
    if (whiteIntervals) timePatterns.push(whiteIntervals);
    
    // PadrÃ£o 22: Pico Noturno de Brancos (22h-02h)
    if (currentHour >= 22 || currentHour <= 2) {
        const nightWhitePattern = analyzeNightWhitePattern(history);
        if (nightWhitePattern) timePatterns.push(nightWhitePattern);
    }
    
    // PadrÃ£o 23: Estabilidade Noturna (sequÃªncias longas Ã  noite)
    if (currentHour >= 22 || currentHour <= 2) {
        const nightStabilityPattern = analyzeNightStabilityPattern(history);
        if (nightStabilityPattern) timePatterns.push(nightStabilityPattern);
    }
    
    // PadrÃ£o 24: OscilaÃ§Ã£o Diurna (alternÃ¢ncias curtas durante o dia)
    if (currentHour >= 6 && currentHour <= 18) {
        const dayOscillationPattern = analyzeDayOscillationPattern(history);
        if (dayOscillationPattern) timePatterns.push(dayOscillationPattern);
    }
    
    // PadrÃ£o 25: PÃ³s-Pico de Branco
    const postWhitePeakPattern = analyzePostWhitePeakPattern(history);
    if (postWhitePeakPattern) timePatterns.push(postWhitePeakPattern);
    
    return timePatterns.length > 0 ? timePatterns[0] : null;
}

// Analisar padrÃµes mistos cor + tempo (26-33)
function analyzeMixedPatterns(history, colors, timestamps) {
    const mixedPatterns = [];
    
    // PadrÃ£o 26: RecuperaÃ§Ã£o PÃ³s-Branco
    const recoveryPattern = analyzePostWhiteRecoveryPattern(history);
    if (recoveryPattern) mixedPatterns.push(recoveryPattern);
    
    // PadrÃ£o 27: Branco na Quebra de AlternÃ¢ncia
    const whiteBreakPattern = analyzeWhiteBreakPattern(history);
    if (whiteBreakPattern) mixedPatterns.push(whiteBreakPattern);
    
    // PadrÃ£o 28: Branco ApÃ³s DominÃ¢ncia Longa
    const whiteAfterDominancePattern = analyzeWhiteAfterDominancePattern(history);
    if (whiteAfterDominancePattern) mixedPatterns.push(whiteAfterDominancePattern);
    
    // PadrÃ£o 29: CorreÃ§Ã£o Total
    const totalCorrectionPattern = analyzeTotalCorrectionPattern(history);
    if (totalCorrectionPattern) mixedPatterns.push(totalCorrectionPattern);
    
    // PadrÃ£o 30: Ciclo Completo
    const completeCyclePattern = analyzeCompleteCyclePattern(history);
    if (completeCyclePattern) mixedPatterns.push(completeCyclePattern);
    
    // PadrÃ£o 31: RepetiÃ§Ã£o em Mesmo HorÃ¡rio
    const timeRepetitionPattern = analyzeTimeRepetitionPattern(history);
    if (timeRepetitionPattern) mixedPatterns.push(timeRepetitionPattern);
    
    // PadrÃ£o 32: ReversÃ£o Temporal
    const temporalReversalPattern = analyzeTemporalReversalPattern(history);
    if (temporalReversalPattern) mixedPatterns.push(temporalReversalPattern);
    
    // PadrÃ£o 33: Microciclos Repetidos
    const microcyclePattern = analyzeMicrocyclePattern(history);
    if (microcyclePattern) mixedPatterns.push(microcyclePattern);
    
    return mixedPatterns.length > 0 ? mixedPatterns[0] : null;
}

// FunÃ§Ãµes especÃ­ficas para cada padrÃ£o temporal
function analyzeWhiteIntervals(history) {
    const whitePositions = [];
    history.forEach((spin, index) => {
        if (spin.color === 'white') {
            whitePositions.push(index);
        }
    });
    
    if (whitePositions.length < 3) return null;
    
    // Calcular intervalos entre brancos
    const intervals = [];
    for (let i = 1; i < whitePositions.length; i++) {
        intervals.push(whitePositions[i] - whitePositions[i-1]);
    }
    
    // Verificar se hÃ¡ padrÃ£o de intervalo (70-100 giros)
    const validIntervals = intervals.filter(interval => interval >= 70 && interval <= 100);
    
    if (validIntervals.length >= 3) {
        const lastWhiteIndex = whitePositions[whitePositions.length - 1];
        const spinsSinceLastWhite = history.length - lastWhiteIndex;
        
        if (spinsSinceLastWhite >= 70) {
            return {
                type: 'time-pattern',
                pattern: 'Branco Intervalado',
                suggestedColor: 'white',
                confidence: 80,
                occurrences: validIntervals.length,
                statisticalSignificance: 2.5,
                patternType: 'Branco Intervalado'
            };
        }
    }
    
    return null;
}

function analyzeNightWhitePattern(history) {
    const recentSpins = history.slice(0, 60);
    const whiteCount = recentSpins.filter(spin => spin.color === 'white').length;
    
    if (whiteCount === 0 && recentSpins.length >= 60) {
        return {
            type: 'time-pattern',
            pattern: 'Pico Noturno de Brancos',
            suggestedColor: 'white',
            confidence: 75,
            occurrences: 1,
            statisticalSignificance: 2.0,
            patternType: 'Pico Noturno de Brancos'
        };
    }
    
    return null;
}

function analyzeNightStabilityPattern(history) {
    // Procurar sequÃªncias longas (8+ da mesma cor)
    for (let i = 0; i < history.length - 8; i++) {
        const sequence = history.slice(i, i + 8);
        const colors = sequence.map(s => s.color);
        
        if (colors.every(color => color === colors[0])) {
            return {
                type: 'time-pattern',
                pattern: 'Estabilidade Noturna',
                suggestedColor: colors[0] === 'red' ? 'black' : 'red',
                confidence: 78,
                occurrences: 1,
                statisticalSignificance: 2.2,
                patternType: 'Estabilidade Noturna'
            };
        }
    }
    
    return null;
}

function analyzeDayOscillationPattern(history) {
    // Procurar alternÃ¢ncias curtas durante o dia
    const recentSpins = history.slice(0, 6);
    const colors = recentSpins.map(s => s.color);
    
    if (isAlternatingPattern(colors.slice(0, 4))) {
        return {
            type: 'time-pattern',
            pattern: 'OscilaÃ§Ã£o Diurna',
            suggestedColor: colors[0] === 'red' ? 'black' : 'red',
            confidence: 76,
            occurrences: 1,
            statisticalSignificance: 2.1,
            patternType: 'OscilaÃ§Ã£o Diurna'
        };
    }
    
    return null;
}

function analyzePostWhitePeakPattern(history) {
    // Procurar muitos brancos em sequÃªncia curta
    const recentSpins = history.slice(0, 10);
    const whiteCount = recentSpins.filter(spin => spin.color === 'white').length;
    
    if (whiteCount >= 3) {
        return {
            type: 'time-pattern',
            pattern: 'PÃ³s-Pico de Branco',
            suggestedColor: 'red', // Apostar 2x (vermelho ou preto)
            confidence: 77,
            occurrences: 1,
            statisticalSignificance: 2.3,
            patternType: 'PÃ³s-Pico de Branco'
        };
    }
    
    return null;
}

// FunÃ§Ãµes especÃ­ficas para padrÃµes mistos
function analyzePostWhiteRecoveryPattern(history) {
    const recentSpins = history.slice(0, 10);
    const colors = recentSpins.map(s => s.color);
    
    // PadrÃ£o: Branco, Vermelho, Vermelho, Preto, Preto
    if (colors[0] === 'white' && colors[1] === 'red' && colors[2] === 'red' && 
        colors[3] === 'black' && colors[4] === 'black') {
        return {
            type: 'mixed-pattern',
            pattern: 'RecuperaÃ§Ã£o PÃ³s-Branco',
            suggestedColor: 'red',
            confidence: 80,
            occurrences: 1,
            statisticalSignificance: 2.4,
            patternType: 'RecuperaÃ§Ã£o PÃ³s-Branco'
        };
    }
    
    return null;
}

function analyzeWhiteBreakPattern(history) {
    const recentSpins = history.slice(0, 10);
    const colors = recentSpins.map(s => s.color);
    
    // PadrÃ£o: Vermelho, Preto, Vermelho, Preto, Branco
    if (colors[0] === 'red' && colors[1] === 'black' && colors[2] === 'red' && 
        colors[3] === 'black' && colors[4] === 'white') {
        return {
            type: 'mixed-pattern',
            pattern: 'Branco na Quebra de AlternÃ¢ncia',
            suggestedColor: 'black',
            confidence: 79,
            occurrences: 1,
            statisticalSignificance: 2.2,
            patternType: 'Branco na Quebra de AlternÃ¢ncia'
        };
    }
    
    return null;
}

function analyzeWhiteAfterDominancePattern(history) {
    // Procurar 8+ repetiÃ§Ãµes da mesma cor seguida de branco
    for (let i = 0; i < history.length - 9; i++) {
        const sequence = history.slice(i, i + 9);
        const colors = sequence.map(s => s.color);
        
        if (colors.slice(0, 8).every(color => color === colors[0]) && colors[8] === 'white') {
            return {
                type: 'mixed-pattern',
                pattern: 'Branco ApÃ³s DominÃ¢ncia Longa',
                suggestedColor: 'white',
                confidence: 82,
                occurrences: 1,
                statisticalSignificance: 2.6,
                patternType: 'Branco ApÃ³s DominÃ¢ncia Longa'
            };
        }
    }
    
    return null;
}

function analyzeTotalCorrectionPattern(history) {
    const recentSpins = history.slice(0, 6);
    const colors = recentSpins.map(s => s.color);
    
    // PadrÃ£o: Vermelho, Vermelho, Vermelho, Branco, Preto, Preto
    if (colors[0] === 'red' && colors[1] === 'red' && colors[2] === 'red' && 
        colors[3] === 'white' && colors[4] === 'black' && colors[5] === 'black') {
        return {
            type: 'mixed-pattern',
            pattern: 'CorreÃ§Ã£o Total',
            suggestedColor: 'black',
            confidence: 81,
            occurrences: 1,
            statisticalSignificance: 2.5,
            patternType: 'CorreÃ§Ã£o Total'
        };
    }
    
    return null;
}

function analyzeCompleteCyclePattern(history) {
    // Procurar ciclo completo em 50-70 giros
    const cycleWindow = Math.min(70, history.length);
    const cycleSpins = history.slice(0, cycleWindow);
    
    // Verificar se hÃ¡ alternÃ¢ncia â†’ branco â†’ repetiÃ§Ã£o â†’ equilÃ­brio
    const hasAlternation = checkForAlternation(cycleSpins.slice(0, 20));
    const hasWhite = cycleSpins.some(spin => spin.color === 'white');
    const hasRepetition = checkForRepetition(cycleSpins.slice(20, 40));
    
    if (hasAlternation && hasWhite && hasRepetition) {
        const mostRepeatedColor = getMostRepeatedColorAfterWhite(cycleSpins);
        return {
            type: 'mixed-pattern',
            pattern: 'Ciclo Completo',
            suggestedColor: mostRepeatedColor,
            confidence: 78,
            occurrences: 1,
            statisticalSignificance: 2.3,
            patternType: 'Ciclo Completo'
        };
    }
    
    return null;
}

function analyzeTimeRepetitionPattern(history) {
    const currentHour = new Date().getHours();
    const currentMinute = new Date().getMinutes();
    
    // Simular busca por sequÃªncia igual no mesmo horÃ¡rio de dias diferentes
    // (implementaÃ§Ã£o simplificada)
    const recentSpins = history.slice(0, 10);
    const colors = recentSpins.map(s => s.color);
    
    if (currentMinute % 15 === 0) { // A cada 15 minutos
        return {
            type: 'mixed-pattern',
            pattern: 'RepetiÃ§Ã£o em Mesmo HorÃ¡rio',
            suggestedColor: colors[colors.length - 1],
            confidence: 77,
            occurrences: 1,
            statisticalSignificance: 2.1,
            patternType: 'RepetiÃ§Ã£o em Mesmo HorÃ¡rio'
        };
    }
    
    return null;
}

function analyzeTemporalReversalPattern(history) {
    // Procurar 1h de dominÃ¢ncia de uma cor (simulado com 60 giros)
    const recentSpins = history.slice(0, 60);
    const colors = recentSpins.map(s => s.color);
    
    const redCount = colors.filter(c => c === 'red').length;
    const blackCount = colors.filter(c => c === 'black').length;
    
    if (redCount >= 40 || blackCount >= 40) {
        const dominantColor = redCount > blackCount ? 'red' : 'black';
        return {
            type: 'mixed-pattern',
            pattern: 'ReversÃ£o Temporal',
            suggestedColor: dominantColor === 'red' ? 'black' : 'red',
            confidence: 79,
            occurrences: 1,
            statisticalSignificance: 2.4,
            patternType: 'ReversÃ£o Temporal'
        };
    }
    
    return null;
}

function analyzeMicrocyclePattern(history) {
    // Procurar padrÃµes curtos de 5-10 giros se repetindo
    for (let cycleSize = 5; cycleSize <= 10; cycleSize++) {
        if (history.length < cycleSize * 2) continue;
        
        const recentCycle = history.slice(0, cycleSize);
        const previousCycle = history.slice(cycleSize, cycleSize * 2);
        
        const recentColors = recentCycle.map(s => s.color);
        const previousColors = previousCycle.map(s => s.color);
        
        if (JSON.stringify(recentColors) === JSON.stringify(previousColors)) {
            return {
                type: 'mixed-pattern',
                pattern: 'Microciclos Repetidos',
                suggestedColor: recentColors[recentColors.length - 1],
                confidence: 80,
                occurrences: 1,
                statisticalSignificance: 2.5,
                patternType: 'Microciclos Repetidos'
            };
        }
    }
    
    return null;
}

// FunÃ§Ãµes auxiliares para anÃ¡lise temporal
function checkForAlternation(spins) {
    const colors = spins.map(s => s.color);
    for (let i = 1; i < colors.length; i++) {
        if (colors[i] === colors[i-1]) return false;
    }
    return colors.length >= 4;
}

function checkForRepetition(spins) {
    const colors = spins.map(s => s.color);
    return colors.every(color => color === colors[0]) && colors.length >= 3;
}

function getMostRepeatedColorAfterWhite(spins) {
    const whiteIndex = spins.findIndex(s => s.color === 'white');
    if (whiteIndex === -1) return 'red';
    
    const afterWhite = spins.slice(0, whiteIndex);
    const colorCounts = {};
    afterWhite.forEach(spin => {
        colorCounts[spin.color] = (colorCounts[spin.color] || 0) + 1;
    });
    
    return Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red');
}

// ANÃLISE TEMPORAL AVANÃ‡ADA MULTIDIMENSIONAL (funÃ§Ã£o antiga mantida para compatibilidade)
function analyzeTemporalPatternsAdvancedOld(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o temporal
    const recentSpins = history; // Todo o histÃ³rico
    
    // 1. ANÃLISE POR MINUTOS (quartos de hora)
    const minutePattern = analyzeMinutePatterns(recentSpins);
    
    // 2. ANÃLISE POR HORAS (perÃ­odos do dia)
    const hourPattern = analyzeHourPatterns(recentSpins);
    
    // 3. ANÃLISE POR DIA DA SEMANA
    const dayPattern = analyzeDayPatterns(recentSpins);
    
    // 4. ANÃLISE POR PERÃODOS (manhÃ£, tarde, noite, madrugada)
    const periodPattern = analyzePeriodPatterns(recentSpins);
    
    // 5. ANÃLISE DE CICLOS TEMPORAIS
    const cyclePattern = analyzeTemporalCycles(recentSpins);
    
    // Combinar todas as anÃ¡lises temporais
    const patterns = [minutePattern, hourPattern, dayPattern, periodPattern, cyclePattern].filter(p => p !== null);
    
    if (patterns.length === 0) return null;
    
    // Encontrar o padrÃ£o temporal com maior confianÃ§a
    const bestPattern = patterns.sort((a, b) => b.confidence - a.confidence)[0];
    
    return {
        type: 'temporal',
        pattern: bestPattern.pattern,
        suggestedColor: bestPattern.suggestedColor,
        confidence: bestPattern.confidence,
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.statisticalSignificance,
        subPatterns: patterns.map(p => ({ type: p.type, confidence: p.confidence }))
    };
}

// Analisar padrÃµes por minutos (00, 15, 30, 45)
function analyzeMinutePatterns(spins) {
    const minutePatterns = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const minute = spinTime.getMinutes();
        const quarter = Math.floor(minute / 15) * 15; // 0, 15, 30, 45
        const key = `${quarter}-${spin.color}`;
        
        if (!minutePatterns[key]) {
            minutePatterns[key] = {
                quarter: quarter,
                color: spin.color,
                count: 0,
                totalInQuarter: 0
            };
        }
        
        minutePatterns[key].count++;
    });
    
    // Calcular total por quarto
    const quarterTotals = {};
    Object.values(minutePatterns).forEach(p => {
        if (!quarterTotals[p.quarter]) quarterTotals[p.quarter] = 0;
        quarterTotals[p.quarter] += p.count;
    });
    
    // Encontrar padrÃµes mais frequentes
    const currentTime = new Date();
    const currentQuarter = Math.floor(currentTime.getMinutes() / 15) * 15;
    
    const currentQuarterPatterns = Object.values(minutePatterns).filter(p => p.quarter === currentQuarter);
    if (currentQuarterPatterns.length === 0) return null;
    
    const bestPattern = currentQuarterPatterns.sort((a, b) => b.count - a.count)[0];
    const totalInCurrentQuarter = quarterTotals[currentQuarter] || 1;
    const confidence = (bestPattern.count / totalInCurrentQuarter) * 100;
    
    if (confidence < 60) return null;
    
    return {
        type: 'minute',
        pattern: `Minuto ${currentQuarter}: ${bestPattern.color} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestPattern.color,
        confidence: Math.min(confidence, 85),
        occurrences: bestPattern.count,
        statisticalSignificance: bestPattern.count / 2
    };
}

// Analisar padrÃµes por horas (perÃ­odos do dia)
function analyzeHourPatterns(spins) {
    const hourPatterns = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const period = hour < 6 ? 'madrugada' : 
                      hour < 12 ? 'manhÃ£' : 
                      hour < 18 ? 'tarde' : 'noite';
        const key = `${period}-${spin.color}`;
        
        if (!hourPatterns[key]) {
            hourPatterns[key] = {
                period: period,
                color: spin.color,
                count: 0,
                totalInPeriod: 0
            };
        }
        
        hourPatterns[key].count++;
    });
    
    // Calcular total por perÃ­odo
    const periodTotals = {};
    Object.values(hourPatterns).forEach(p => {
        if (!periodTotals[p.period]) periodTotals[p.period] = 0;
        periodTotals[p.period] += p.count;
    });
    
    // Encontrar padrÃ£o do perÃ­odo atual
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    const currentPeriod = currentHour < 6 ? 'madrugada' : 
                         currentHour < 12 ? 'manhÃ£' : 
                         currentHour < 18 ? 'tarde' : 'noite';
    
    const currentPeriodPatterns = Object.values(hourPatterns).filter(p => p.period === currentPeriod);
    if (currentPeriodPatterns.length === 0) return null;
    
    const bestPattern = currentPeriodPatterns.sort((a, b) => b.count - a.count)[0];
    const totalInCurrentPeriod = periodTotals[currentPeriod] || 1;
    const confidence = (bestPattern.count / totalInCurrentPeriod) * 100;
    
    if (confidence < 60) return null;
    
    return {
        type: 'hour',
        pattern: `${currentPeriod}: ${bestPattern.color} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestPattern.color,
        confidence: Math.min(confidence, 80),
        occurrences: bestPattern.count,
        statisticalSignificance: bestPattern.count / 2
    };
}

// Analisar padrÃµes por dia da semana
function analyzeDayPatterns(spins) {
    const dayPatterns = {};
    const dayNames = ['domingo', 'segunda', 'terÃ§a', 'quarta', 'quinta', 'sexta', 'sÃ¡bado'];
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const dayOfWeek = spinTime.getDay();
        const dayName = dayNames[dayOfWeek];
        const key = `${dayName}-${spin.color}`;
        
        if (!dayPatterns[key]) {
            dayPatterns[key] = {
                day: dayName,
                color: spin.color,
                count: 0,
                totalInDay: 0
            };
        }
        
        dayPatterns[key].count++;
    });
    
    // Calcular total por dia
    const dayTotals = {};
    Object.values(dayPatterns).forEach(p => {
        if (!dayTotals[p.day]) dayTotals[p.day] = 0;
        dayTotals[p.day] += p.count;
    });
    
    // Encontrar padrÃ£o do dia atual
    const currentTime = new Date();
    const currentDay = dayNames[currentTime.getDay()];
    
    const currentDayPatterns = Object.values(dayPatterns).filter(p => p.day === currentDay);
    if (currentDayPatterns.length === 0) return null;
    
    const bestPattern = currentDayPatterns.sort((a, b) => b.count - a.count)[0];
    const totalInCurrentDay = dayTotals[currentDay] || 1;
    const confidence = (bestPattern.count / totalInCurrentDay) * 100;
    
    if (confidence < 60) return null;
    
    return {
        type: 'day',
        pattern: `${currentDay}: ${bestPattern.color} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestPattern.color,
        confidence: Math.min(confidence, 75),
        occurrences: bestPattern.count,
        statisticalSignificance: bestPattern.count / 2
    };
}

// Analisar padrÃµes por perÃ­odos (manhÃ£, tarde, noite, madrugada)
function analyzePeriodPatterns(spins) {
    const periodPatterns = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const period = hour < 6 ? 'madrugada' : 
                      hour < 12 ? 'manhÃ£' : 
                      hour < 18 ? 'tarde' : 'noite';
        const key = `${period}-${spin.color}`;
        
        if (!periodPatterns[key]) {
            periodPatterns[key] = {
                period: period,
                color: spin.color,
                count: 0,
                totalInPeriod: 0
            };
        }
        
        periodPatterns[key].count++;
    });
    
    // Calcular total por perÃ­odo
    const periodTotals = {};
    Object.values(periodPatterns).forEach(p => {
        if (!periodTotals[p.period]) periodTotals[p.period] = 0;
        periodTotals[p.period] += p.count;
    });
    
    // Encontrar padrÃ£o do perÃ­odo atual
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    const currentPeriod = currentHour < 6 ? 'madrugada' : 
                         currentHour < 12 ? 'manhÃ£' : 
                         currentHour < 18 ? 'tarde' : 'noite';
    
    const currentPeriodPatterns = Object.values(periodPatterns).filter(p => p.period === currentPeriod);
    if (currentPeriodPatterns.length === 0) return null;
    
    const bestPattern = currentPeriodPatterns.sort((a, b) => b.count - a.count)[0];
    const totalInCurrentPeriod = periodTotals[currentPeriod] || 1;
    const confidence = (bestPattern.count / totalInCurrentPeriod) * 100;
    
    if (confidence < 60) return null;
    
    return {
        type: 'period',
        pattern: `${currentPeriod}: ${bestPattern.color} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestPattern.color,
        confidence: Math.min(confidence, 80),
        occurrences: bestPattern.count,
        statisticalSignificance: bestPattern.count / 2
    };
}

// Analisar ciclos temporais (padrÃµes que se repetem em horÃ¡rios especÃ­ficos)
function analyzeTemporalCycles(spins) {
    const cyclePatterns = {};
    
    // Procurar ciclos de 1-4 horas
    for (let cycleHours = 1; cycleHours <= 4; cycleHours++) {
        spins.forEach(spin => {
            const spinTime = new Date(spin.timestamp);
            const hour = spinTime.getHours();
            const cyclePosition = hour % cycleHours;
            const key = `ciclo-${cycleHours}h-${cyclePosition}-${spin.color}`;
            
            if (!cyclePatterns[key]) {
                cyclePatterns[key] = {
                    cycleHours: cycleHours,
                    position: cyclePosition,
                    color: spin.color,
                    count: 0,
                    totalInPosition: 0
                };
            }
            
            cyclePatterns[key].count++;
        });
    }
    
    // Calcular total por posiÃ§Ã£o do ciclo
    const positionTotals = {};
    Object.values(cyclePatterns).forEach(p => {
        const key = `${p.cycleHours}h-${p.position}`;
        if (!positionTotals[key]) positionTotals[key] = 0;
        positionTotals[key] += p.count;
    });
    
    // Encontrar ciclo mais forte
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    
    let bestCycle = null;
    let bestConfidence = 0;
    
    for (let cycleHours = 1; cycleHours <= 4; cycleHours++) {
        const cyclePosition = currentHour % cycleHours;
        const key = `ciclo-${cycleHours}h-${cyclePosition}`;
        const totalInPosition = positionTotals[key] || 1;
        
        const cyclePatternsInPosition = Object.values(cyclePatterns).filter(p => 
            p.cycleHours === cycleHours && p.position === cyclePosition
        );
        
        if (cyclePatternsInPosition.length > 0) {
            const bestPattern = cyclePatternsInPosition.sort((a, b) => b.count - a.count)[0];
            const confidence = (bestPattern.count / totalInPosition) * 100;
            
            if (confidence > bestConfidence && confidence >= 60) {
                bestConfidence = confidence;
                bestCycle = bestPattern;
            }
        }
    }
    
    if (!bestCycle) return null;
    
    return {
        type: 'cycle',
        pattern: `Ciclo ${bestCycle.cycleHours}h posiÃ§Ã£o ${bestCycle.position}: ${bestCycle.color} (${bestConfidence.toFixed(1)}%)`,
        suggestedColor: bestCycle.color,
        confidence: Math.min(bestConfidence, 85),
        occurrences: bestCycle.count,
        statisticalSignificance: bestCycle.count / 2
    };
}

// ANÃLISE DE CORRELAÃ‡Ã•ES MULTIDIMENSIONAIS
function analyzeCorrelations(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o de correlaÃ§Ãµes
    const recentSpins = history; // Todo o histÃ³rico
    
    // 1. CORRELAÃ‡ÃƒO COR + NÃšMERO
    const colorNumberCorrelation = analyzeColorNumberCorrelation(recentSpins);
    
    // 2. CORRELAÃ‡ÃƒO COR + TEMPO
    const colorTimeCorrelation = analyzeColorTimeCorrelation(recentSpins);
    
    // 3. CORRELAÃ‡ÃƒO NÃšMERO + TEMPO
    const numberTimeCorrelation = analyzeNumberTimeCorrelation(recentSpins);
    
    // 4. CORRELAÃ‡ÃƒO COMPOSTA (COR + NÃšMERO + TEMPO)
    const compositeCorrelation = analyzeCompositeCorrelation(recentSpins);
    
    // Combinar todas as correlaÃ§Ãµes
    const correlations = [colorNumberCorrelation, colorTimeCorrelation, numberTimeCorrelation, compositeCorrelation].filter(c => c !== null);
    
    if (correlations.length === 0) return null;
    
    // Encontrar a correlaÃ§Ã£o com maior confianÃ§a
    const bestCorrelation = correlations.sort((a, b) => b.confidence - a.confidence)[0];
    
    // CRÃTICO: Verificar se a correlaÃ§Ã£o atual realmente corresponde ao padrÃ£o encontrado
    const colors = history.map(s => s.color);
    const numbers = history.map(s => s.number);
    
    // Para correlaÃ§Ãµes de cor-nÃºmero, verificar se o padrÃ£o atual corresponde
    if (bestCorrelation.type === 'color-number') {
        const patternParts = bestCorrelation.pattern.split('-');
        if (patternParts.length >= 2) {
            const expectedColor = patternParts[0];
            const expectedNumber = parseInt(patternParts[1]);
            
            // Verificar se o Ãºltimo giro corresponde Ã  correlaÃ§Ã£o
            if (colors[0] !== expectedColor || numbers[0] !== expectedNumber) {
                console.log('âŒ CorrelaÃ§Ã£o cor-nÃºmero nÃ£o corresponde ao padrÃ£o atual:', {
                    foundPattern: bestCorrelation.pattern,
                    currentColor: colors[0],
                    currentNumber: numbers[0],
                    expectedColor: expectedColor,
                    expectedNumber: expectedNumber
                });
                return null;
            }
        }
    }
    
    console.log('âœ… CorrelaÃ§Ã£o atual confirma o padrÃ£o encontrado:', {
        foundPattern: bestCorrelation.pattern,
        currentColor: colors[0],
        currentNumber: numbers[0]
    });
    
    return {
        type: 'correlation',
        pattern: bestCorrelation.pattern,
        suggestedColor: bestCorrelation.suggestedColor,
        confidence: bestCorrelation.confidence,
        occurrences: bestCorrelation.occurrences,
        statisticalSignificance: bestCorrelation.statisticalSignificance,
        subCorrelations: correlations.map(c => ({ type: c.type, confidence: c.confidence }))
    };
}

// CorrelaÃ§Ã£o Cor + NÃºmero
function analyzeColorNumberCorrelation(spins) {
    const correlations = {};
    
    spins.forEach(spin => {
        const key = `${spin.color}-${spin.number}`;
        if (!correlations[key]) {
            correlations[key] = {
                color: spin.color,
                number: spin.number,
                count: 0,
                nextColors: []
            };
        }
        correlations[key].count++;
    });
    
    // Encontrar correlaÃ§Ãµes mais frequentes
    const frequentCorrelations = Object.values(correlations).filter(c => c.count >= 2);
    if (frequentCorrelations.length === 0) return null;
    
    const bestCorrelation = frequentCorrelations.sort((a, b) => b.count - a.count)[0];
    
    // Calcular prÃ³xima cor baseada na correlaÃ§Ã£o
    const colorCounts = {};
    frequentCorrelations.forEach(c => {
        colorCounts[c.color] = (colorCounts[c.color] || 0) + c.count;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / frequentCorrelations.length) * 100;
    
    return {
        type: 'color-number',
        pattern: `Cor-NÃºmero: ${bestCorrelation.color}-${bestCorrelation.number} (${confidence.toFixed(1)}%)`,
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 80),
        occurrences: bestCorrelation.count,
        statisticalSignificance: bestCorrelation.count / 2
    };
}

// CorrelaÃ§Ã£o Cor + Tempo
function analyzeColorTimeCorrelation(spins) {
    const correlations = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const minute = Math.floor(spinTime.getMinutes() / 15) * 15; // Quartos de hora
        const key = `${spin.color}-${hour}h${minute}m`;
        
        if (!correlations[key]) {
            correlations[key] = {
                color: spin.color,
                time: `${hour}h${minute}m`,
                count: 0
            };
        }
        correlations[key].count++;
    });
    
    // Encontrar correlaÃ§Ãµes mais frequentes
    const frequentCorrelations = Object.values(correlations).filter(c => c.count >= 2);
    if (frequentCorrelations.length === 0) return null;
    
    const bestCorrelation = frequentCorrelations.sort((a, b) => b.count - a.count)[0];
    
    const confidence = (bestCorrelation.count / frequentCorrelations.length) * 100;
    
    return {
        type: 'color-time',
        pattern: `Cor-Tempo: ${bestCorrelation.color}-${bestCorrelation.time} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestCorrelation.color,
        confidence: Math.min(confidence, 75),
        occurrences: bestCorrelation.count,
        statisticalSignificance: bestCorrelation.count / 2
    };
}

// CorrelaÃ§Ã£o NÃºmero + Tempo
function analyzeNumberTimeCorrelation(spins) {
    const correlations = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const numberRange = spin.number === 0 ? 'branco' : 
                           (spin.number >= 1 && spin.number <= 7) ? 'vermelho' : 'preto';
        const key = `${numberRange}-${hour}h`;
        
        if (!correlations[key]) {
            correlations[key] = {
                numberRange: numberRange,
                hour: hour,
                count: 0
            };
        }
        correlations[key].count++;
    });
    
    // Encontrar correlaÃ§Ãµes mais frequentes
    const frequentCorrelations = Object.values(correlations).filter(c => c.count >= 2);
    if (frequentCorrelations.length === 0) return null;
    
    const bestCorrelation = frequentCorrelations.sort((a, b) => b.count - a.count)[0];
    
    const confidence = (bestCorrelation.count / frequentCorrelations.length) * 100;
    
    return {
        type: 'number-time',
        pattern: `NÃºmero-Tempo: ${bestCorrelation.numberRange}-${bestCorrelation.hour}h (${confidence.toFixed(1)}%)`,
        suggestedColor: bestCorrelation.numberRange === 'vermelho' ? 'red' : 
                       bestCorrelation.numberRange === 'preto' ? 'black' : 'white',
        confidence: Math.min(confidence, 70),
        occurrences: bestCorrelation.count,
        statisticalSignificance: bestCorrelation.count / 2
    };
}

// CorrelaÃ§Ã£o Composta (Cor + NÃºmero + Tempo)
function analyzeCompositeCorrelation(spins) {
    const correlations = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const minute = Math.floor(spinTime.getMinutes() / 15) * 15;
        const key = `${spin.color}-${spin.number}-${hour}h${minute}m`;
        
        if (!correlations[key]) {
            correlations[key] = {
                color: spin.color,
                number: spin.number,
                time: `${hour}h${minute}m`,
                count: 0
            };
        }
        correlations[key].count++;
    });
    
    // Encontrar correlaÃ§Ãµes mais frequentes
    const frequentCorrelations = Object.values(correlations).filter(c => c.count >= 2);
    if (frequentCorrelations.length === 0) return null;
    
    const bestCorrelation = frequentCorrelations.sort((a, b) => b.count - a.count)[0];
    
    const confidence = (bestCorrelation.count / frequentCorrelations.length) * 100;
    
    return {
        type: 'composite',
        pattern: `Composto: ${bestCorrelation.color}-${bestCorrelation.number}-${bestCorrelation.time} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestCorrelation.color,
        confidence: Math.min(confidence, 85),
        occurrences: bestCorrelation.count,
        statisticalSignificance: bestCorrelation.count / 2
    };
}

// ANÃLISE DE FREQUÃŠNCIA MULTIDIMENSIONAL
function analyzeMultidimensionalFrequency(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o de frequÃªncia
    const recentSpins = history; // Todo o histÃ³rico
    
    // 1. FREQUÃŠNCIA POR FAIXA NUMÃ‰RICA
    const rangeFrequency = analyzeRangeFrequency(recentSpins);
    
    // 2. FREQUÃŠNCIA POR PERÃODO DO DIA
    const periodFrequency = analyzePeriodFrequency(recentSpins);
    
    // 3. FREQUÃŠNCIA POR DIA DA SEMANA
    const dayFrequency = analyzeDayFrequency(recentSpins);
    
    // 4. FREQUÃŠNCIA POR MINUTO
    const minuteFrequency = analyzeMinuteFrequency(recentSpins);
    
    // Combinar todas as frequÃªncias
    const frequencies = [rangeFrequency, periodFrequency, dayFrequency, minuteFrequency].filter(f => f !== null);
    
    if (frequencies.length === 0) return null;
    
    // Encontrar a frequÃªncia com maior confianÃ§a
    const bestFrequency = frequencies.sort((a, b) => b.confidence - a.confidence)[0];
    
    return {
        type: 'frequency',
        pattern: bestFrequency.pattern,
        suggestedColor: bestFrequency.suggestedColor,
        confidence: bestFrequency.confidence,
        occurrences: bestFrequency.occurrences,
        statisticalSignificance: bestFrequency.statisticalSignificance,
        subFrequencies: frequencies.map(f => ({ type: f.type, confidence: f.confidence }))
    };
}

// FrequÃªncia por faixa numÃ©rica
function analyzeRangeFrequency(spins) {
    const rangeCounts = { red: 0, black: 0, white: 0 };
    
    spins.forEach(spin => {
        if (spin.number === 0) rangeCounts.white++;
        else if (spin.number >= 1 && spin.number <= 7) rangeCounts.red++;
        else if (spin.number >= 8 && spin.number <= 14) rangeCounts.black++;
    });
    
    const total = spins.length;
    const redPercent = (rangeCounts.red / total) * 100;
    const blackPercent = (rangeCounts.black / total) * 100;
    const whitePercent = (rangeCounts.white / total) * 100;
    
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o, retornar null se nÃ£o houver padrÃ£o claro
    let suggestedColor = null;
    let confidence = 0;
    
    if (redPercent > 60) {
        suggestedColor = 'black';
        confidence = Math.min(redPercent - 50, 80);
    } else if (blackPercent > 60) {
        suggestedColor = 'red';
        confidence = Math.min(blackPercent - 50, 80);
    } else if (whitePercent > 25) {
        // âœ… CORREÃ‡ÃƒO: Usar a cor MENOS frequente em vez de sempre 'red'
        suggestedColor = redPercent < blackPercent ? 'red' : 'black';
        confidence = Math.min(whitePercent * 2, 70);
    } else {
        return null;
    }
    
    if (!suggestedColor) return null;
    
    return {
        type: 'range-frequency',
        pattern: `Faixa: R${redPercent.toFixed(1)}% B${blackPercent.toFixed(1)}% W${whitePercent.toFixed(1)}%`,
        suggestedColor: suggestedColor,
        confidence: confidence,
        occurrences: Math.max(rangeCounts.red, rangeCounts.black, rangeCounts.white),
        statisticalSignificance: confidence / 50
    };
}

// FrequÃªncia por perÃ­odo do dia
function analyzePeriodFrequency(spins) {
    const periodCounts = { madrugada: 0, manhÃ£: 0, tarde: 0, noite: 0 };
    const periodColors = { madrugada: {}, manhÃ£: {}, tarde: {}, noite: {} };
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const period = hour < 6 ? 'madrugada' : 
                      hour < 12 ? 'manhÃ£' : 
                      hour < 18 ? 'tarde' : 'noite';
        
        periodCounts[period]++;
        if (!periodColors[period][spin.color]) periodColors[period][spin.color] = 0;
        periodColors[period][spin.color]++;
    });
    
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    const currentPeriod = currentHour < 6 ? 'madrugada' : 
                         currentHour < 12 ? 'manhÃ£' : 
                         currentHour < 18 ? 'tarde' : 'noite';
    
    const currentPeriodCount = periodCounts[currentPeriod];
    if (currentPeriodCount < 3) return null;
    
    const currentPeriodColors = periodColors[currentPeriod];
    const totalColors = Object.values(currentPeriodColors).reduce((a, b) => a + b, 0);
    
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
    let suggestedColor = null;
    let confidence = 0;
    
    Object.entries(currentPeriodColors).forEach(([color, count]) => {
        const percent = (count / totalColors) * 100;
        if (percent > 60) {
            // âœ… CORREÃ‡ÃƒO: Sugerir cor oposta sem viÃ©s
            if (color === 'red') suggestedColor = 'black';
            else if (color === 'black') suggestedColor = 'red';
            else suggestedColor = 'black'; // Se white estÃ¡ dominante, apostar em black
            confidence = Math.min(percent - 50, 75);
        }
    });
    
    if (confidence < 60 || !suggestedColor) return null;
    
    return {
        type: 'period-frequency',
        pattern: `${currentPeriod}: ${suggestedColor} (${confidence.toFixed(1)}%)`,
        suggestedColor: suggestedColor,
        confidence: confidence,
        occurrences: currentPeriodCount,
        statisticalSignificance: confidence / 50
    };
}

// FrequÃªncia por dia da semana
function analyzeDayFrequency(spins) {
    const dayNames = ['domingo', 'segunda', 'terÃ§a', 'quarta', 'quinta', 'sexta', 'sÃ¡bado'];
    const dayCounts = {};
    const dayColors = {};
    
    dayNames.forEach(day => {
        dayCounts[day] = 0;
        dayColors[day] = {};
    });
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const dayOfWeek = spinTime.getDay();
        const dayName = dayNames[dayOfWeek];
        
        dayCounts[dayName]++;
        if (!dayColors[dayName][spin.color]) dayColors[dayName][spin.color] = 0;
        dayColors[dayName][spin.color]++;
    });
    
    const currentTime = new Date();
    const currentDay = dayNames[currentTime.getDay()];
    
    const currentDayCount = dayCounts[currentDay];
    if (currentDayCount < 3) return null;
    
    const currentDayColors = dayColors[currentDay];
    const totalColors = Object.values(currentDayColors).reduce((a, b) => a + b, 0);
    
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
    let suggestedColor = null;
    let confidence = 0;
    
    Object.entries(currentDayColors).forEach(([color, count]) => {
        const percent = (count / totalColors) * 100;
        if (percent > 60) {
            // âœ… CORREÃ‡ÃƒO: Sugerir cor oposta sem viÃ©s
            if (color === 'red') suggestedColor = 'black';
            else if (color === 'black') suggestedColor = 'red';
            else suggestedColor = 'black'; // Se white estÃ¡ dominante, apostar em black
            confidence = Math.min(percent - 50, 70);
        }
    });
    
    if (confidence < 60 || !suggestedColor) return null;
    
    return {
        type: 'day-frequency',
        pattern: `${currentDay}: ${suggestedColor} (${confidence.toFixed(1)}%)`,
        suggestedColor: suggestedColor,
        confidence: confidence,
        occurrences: currentDayCount,
        statisticalSignificance: confidence / 50
    };
}

// FrequÃªncia por minuto
function analyzeMinuteFrequency(spins) {
    const minuteCounts = {};
    const minuteColors = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const minute = Math.floor(spinTime.getMinutes() / 15) * 15; // Quartos de hora
        const key = `${minute}`;
        
        if (!minuteCounts[key]) {
            minuteCounts[key] = 0;
            minuteColors[key] = {};
        }
        
        minuteCounts[key]++;
        if (!minuteColors[key][spin.color]) minuteColors[key][spin.color] = 0;
        minuteColors[key][spin.color]++;
    });
    
    const currentTime = new Date();
    const currentMinute = Math.floor(currentTime.getMinutes() / 15) * 15;
    const currentMinuteKey = `${currentMinute}`;
    
    const currentMinuteCount = minuteCounts[currentMinuteKey];
    if (currentMinuteCount < 2) return null;
    
    const currentMinuteColors = minuteColors[currentMinuteKey];
    const totalColors = Object.values(currentMinuteColors).reduce((a, b) => a + b, 0);
    
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
    let suggestedColor = null;
    let confidence = 0;
    
    Object.entries(currentMinuteColors).forEach(([color, count]) => {
        const percent = (count / totalColors) * 100;
        if (percent > 60) {
            // âœ… CORREÃ‡ÃƒO: Sugerir cor oposta sem viÃ©s
            if (color === 'red') suggestedColor = 'black';
            else if (color === 'black') suggestedColor = 'red';
            else suggestedColor = 'black'; // Se white estÃ¡ dominante, apostar em black
            confidence = Math.min(percent - 50, 80);
        }
    });
    
    if (confidence < 60 || !suggestedColor) return null;
    
    return {
        type: 'minute-frequency',
        pattern: `Minuto ${currentMinute}: ${suggestedColor} (${confidence.toFixed(1)}%)`,
        suggestedColor: suggestedColor,
        confidence: confidence,
        occurrences: currentMinuteCount,
        statisticalSignificance: confidence / 50
    };
}

// FUNÃ‡ÃƒO PARA COMPARAR SE DOIS PADRÃ•ES SÃƒO IGUAIS
function comparePatterns(lastPattern, currentPattern) {
    try {
        // Comparar tipo de anÃ¡lise principal
        const lastMainType = lastPattern.colorAnalysis ? 'color' : 
                           lastPattern.numberAnalysis ? 'number' : 
                           lastPattern.timeAnalysis ? 'time' : 
                           lastPattern.correlationAnalysis ? 'correlation' : 'frequency';
        
        const currentMainType = currentPattern.colorAnalysis ? 'color' : 
                              currentPattern.numberAnalysis ? 'number' : 
                              currentPattern.timeAnalysis ? 'time' : 
                              currentPattern.correlationAnalysis ? 'correlation' : 'frequency';
        
        // Se tipos diferentes, nÃ£o sÃ£o o mesmo padrÃ£o
        if (lastMainType !== currentMainType) {
            return false;
        }
        
        // Comparar sequÃªncias especÃ­ficas baseadas no tipo
        if (lastMainType === 'color') {
            const lastSequence = lastPattern.colorAnalysis?.pattern || [];
            const currentSequence = currentPattern.colorAnalysis?.pattern || [];
            
            // Comparar sequÃªncias de cores
            if (lastSequence.length !== currentSequence.length) {
                return false;
            }
            
            return lastSequence.every((color, index) => color === currentSequence[index]);
        }
        
        if (lastMainType === 'number') {
            const lastSequence = lastPattern.numberAnalysis?.pattern || '';
            const currentSequence = currentPattern.numberAnalysis?.pattern || '';
            
            return lastSequence === currentSequence;
        }
        
        if (lastMainType === 'time') {
            const lastPatternType = lastPattern.timeAnalysis?.pattern || '';
            const currentPatternType = currentPattern.timeAnalysis?.pattern || '';
            
            return lastPatternType === currentPatternType;
        }
        
        if (lastMainType === 'correlation') {
            const lastCorrelation = lastPattern.correlationAnalysis?.pattern || '';
            const currentCorrelation = currentPattern.correlationAnalysis?.pattern || '';
            
            return lastCorrelation === currentCorrelation;
        }
        
        // Para frequency, comparar por tipo de zona
        if (lastMainType === 'frequency') {
            const lastZone = lastPattern.frequencyAnalysis?.zone || '';
            const currentZone = currentPattern.frequencyAnalysis?.zone || '';
            
            return lastZone === currentZone;
        }
        
        return false;
    } catch (e) {
        console.log('âš ï¸ Erro ao comparar padrÃµes:', e);
        return false; // Em caso de erro, considerar como padrÃ£o diferente
    }
}

// COMBINAR TODAS AS ANÃLISES MULTIDIMENSIONAIS COM REGRAS DE RIGOR
async function combineMultidimensionalAnalyses(colorAnalysis, numberAnalysis, timeAnalysis, correlationAnalysis, frequencyAnalysis) {
    const analyses = [colorAnalysis, numberAnalysis, timeAnalysis, correlationAnalysis, frequencyAnalysis].filter(a => a !== null);
    
    if (analyses.length === 0) return null;
    
    // NOVA LÃ“GICA: Verificar se mÃºltiplos padrÃµes recomendam a mesma cor
    const colorRecommendations = {};
    analyses.forEach(analysis => {
        const color = analysis.suggestedColor;
        if (!colorRecommendations[color]) {
            colorRecommendations[color] = {
                color: color,
                analyses: [],
                totalConfidence: 0,
                count: 0
            };
        }
        colorRecommendations[color].analyses.push(analysis);
        colorRecommendations[color].totalConfidence += analysis.confidence;
        colorRecommendations[color].count++;
    });
    
    // Calcular confianÃ§a ajustada baseada no consenso
    Object.keys(colorRecommendations).forEach(color => {
        const rec = colorRecommendations[color];
        const avgConfidence = rec.totalConfidence / rec.count;
        
        // Se mÃºltiplos padrÃµes recomendam a mesma cor, AUMENTAR confianÃ§a
        if (rec.count > 1) {
            const consensusBonus = (rec.count - 1) * 5; // +5% por padrÃ£o adicional
            rec.adjustedConfidence = Math.min(avgConfidence + consensusBonus, 95);
            console.log(`ğŸ¯ Consenso detectado: ${rec.count} padrÃµes recomendam ${color} - ConfianÃ§a ajustada: ${rec.adjustedConfidence.toFixed(1)}%`);
        } else {
            // Se apenas um padrÃ£o, manter confianÃ§a original
            rec.adjustedConfidence = avgConfidence;
        }
    });
    
    // Escolher a cor com maior confianÃ§a ajustada
    const bestRecommendation = Object.values(colorRecommendations).sort((a, b) => 
        b.adjustedConfidence - a.adjustedConfidence
    )[0];
    
	// NOVAS REGRAS DE RIGOR: Sistema de escalonamento 50% â†’ 60%
    const minOccurrences = 2; // MÃ­nimo 2 ocorrÃªncias obrigatÃ³rio
    const minStatisticalSignificance = 2.0;
    
    // Verificar nÃ­vel de rigor atual e histÃ³rico de losses
    const storage = await chrome.storage.local.get(['lastBet', 'rigorLevel']);
    const lastBet = storage.lastBet;
	const currentRigorLevel = storage.rigorLevel || 50; // Default 50%
    
    const hasRecentLoss = lastBet && 
                         lastBet.status === 'loss' && 
                         lastBet.resolvedAtTimestamp;
    
	// Determinar nÃ­vel mÃ­nimo: 60% apÃ³s loss, senÃ£o usa o nÃ­vel atual
	const minConfidence = hasRecentLoss ? 60 : currentRigorLevel;
    
    console.log(`ğŸ¯ NÃ­vel de rigor: ${minConfidence}% (${hasRecentLoss ? 'ApÃ³s loss' : 'Normal'})`);
    console.log(`ğŸ¯ Melhor recomendaÃ§Ã£o: ${bestRecommendation.color} com ${bestRecommendation.adjustedConfidence.toFixed(1)}% (${bestRecommendation.count} padrÃ£o${bestRecommendation.count > 1 ? 's' : ''})`);
    
    // Verificar se atende aos critÃ©rios
    const bestAnalysis = bestRecommendation.analyses.sort((a, b) => b.confidence - a.confidence)[0];
    
    // âœ… ESTIMAR RISCO DE 3 LOSS CONSECUTIVOS COM BASE NA CONFIANÃ‡A DO PADRÃƒO
    // Usamos a confianÃ§a do melhor padrÃ£o como aproximaÃ§Ã£o da probabilidade de acerto (p_hat).
    // Probabilidade aproximada de 3 LOSS seguidos: (1 - p_hat)^3.
    const estimatedWinProb = Math.min(
        Math.max((bestAnalysis.confidence || bestRecommendation.adjustedConfidence || 0) / 100, 0.01),
        0.99
    );
    const probThreeLoss = Math.pow(1 - estimatedWinProb, 3);
    const maxThreeLossProb = 0.02; // 2% de tolerÃ¢ncia para 3 LOSS seguidos
    const streakRiskOk = probThreeLoss <= maxThreeLossProb;
    
    const meetsCriteria = bestRecommendation.adjustedConfidence >= minConfidence && 
                         bestAnalysis.occurrences >= minOccurrences && 
                         bestAnalysis.statisticalSignificance >= minStatisticalSignificance &&
                         streakRiskOk;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VALIDAÃ‡ÃƒO DE RIGOR POR TIPO DE ANÃLISE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let rigorOk = true;
    let rigorMessage = '';
    
    // Identificar qual tipo de anÃ¡lise foi escolhida como melhor
    const bestType = bestAnalysis.type;
    
    console.log(`\nğŸ¯ Tipo de anÃ¡lise selecionada: ${bestType}`);
    
    // âœ… APLICAR VALIDAÃ‡ÃƒO ESPECÃFICA BASEADA NO TIPO
    if (bestType === 'color-pattern' && colorAnalysis) {
        // âœ… PADRÃ•ES DE COR: Aplicar regras configurÃ¡veis do usuÃ¡rio
        console.log('ğŸ“Š Aplicando regras de RIGOR para PADRÃ•ES DE COR (configurÃ¡veis)...');
        
        const needsRigor = (analyzerConfig && (analyzerConfig.minOccurrences > 1 || (analyzerConfig.winPercentOthers || 0) > 0 || (analyzerConfig.maxOccurrences || 0) > 0 || (analyzerConfig.minPatternSize || 0) > 2));
        
    if (needsRigor) {
            const sampleMin = analyzerConfig.minOccurrences || 1;
            const sampleOk = colorAnalysis.sampleMinWins100 === true || sampleMin === 1;
            const rigorPct = typeof colorAnalysis.rigorWinPct === 'number' ? colorAnalysis.rigorWinPct : 
                             (typeof colorAnalysis.winPct === 'number' ? colorAnalysis.winPct : 0);
            const threshold = analyzerConfig.winPercentOthers || 0;
            
            // âœ… NOVA VALIDAÃ‡ÃƒO: OcorrÃªncias MÃXIMAS (0 = sem limite)
            const totalOccurrences = colorAnalysis.occurrences || 0;
            const maxOccurrences = analyzerConfig.maxOccurrences || 0;
            const maxOccurrencesOk = maxOccurrences === 0 || totalOccurrences <= maxOccurrences;
            
            // âœ… VALIDAÃ‡ÃƒO DE TAMANHO DO PADRÃƒO (minPatternSize e maxPatternSize)
            const patternSize = colorAnalysis.pattern ? colorAnalysis.pattern.length : 0;
            const minPatternSize = analyzerConfig.minPatternSize || 2;
            const maxPatternSize = analyzerConfig.maxPatternSize || 0; // 0 = sem limite
            const patternSizeOk = (patternSize >= minPatternSize) && (maxPatternSize === 0 || patternSize <= maxPatternSize);
            
            rigorOk = sampleOk && (rigorPct >= threshold) && maxOccurrencesOk && patternSizeOk;
            
            // âœ… LOG DETALHADO DO FILTRO DE RIGOR
            console.log('â•‘  ğŸ” VALIDAÃ‡ÃƒO DE RIGOR (Filtros de qualidade)            â•‘');
            console.log(`â•‘  ğŸ“ Tamanho do PadrÃ£o: ${patternSize} giros`);
            console.log(`â•‘  ğŸ¯ Limite MÃ­nimo: ${minPatternSize} giros`);
            console.log(`â•‘  ğŸ¯ Limite MÃ¡ximo: ${maxPatternSize === 0 ? 'SEM LIMITE' : maxPatternSize + ' giros'}`);
            console.log(`â•‘  ${patternSizeOk ? 'âœ…' : 'âŒ'} ValidaÃ§Ã£o Tamanho: ${patternSizeOk ? 'APROVADO' : 'REJEITADO'} ${maxPatternSize > 0 ? `(${minPatternSize} <= ${patternSize} <= ${maxPatternSize})` : `(${patternSize} >= ${minPatternSize})`}`);
            console.log(`â•‘  ğŸ“Š Total de OcorrÃªncias: ${totalOccurrences}`);
            console.log(`â•‘  ğŸ¯ Limite MÃ¡ximo OcorrÃªncias: ${maxOccurrences === 0 ? 'SEM LIMITE' : maxOccurrences}`);
            console.log(`â•‘  ${maxOccurrencesOk ? 'âœ…' : 'âŒ'} ValidaÃ§Ã£o MÃ¡ximo OcorrÃªncias: ${maxOccurrencesOk ? 'APROVADO' : 'REJEITADO'} ${maxOccurrences > 0 ? `(${totalOccurrences} <= ${maxOccurrences})` : ''}`);
            console.log(`â•‘  ğŸ“Š Demais OcorrÃªncias: ${colorAnalysis.othersCount || 0} (excluindo amostra mÃ­nima)`);
            console.log(`â•‘  âœ… Demais WINs: ${colorAnalysis.othersWins || 0}`);
            console.log(`â•‘  âŒ Demais LOSSes: ${colorAnalysis.othersLosses || 0}`);
            console.log(`â•‘  ğŸ“ˆ Rigor WIN%: ${rigorPct.toFixed(1)}%`);
            console.log(`â•‘  ğŸ¯ Threshold WIN% (configurado): ${threshold}%`);
            console.log(`â•‘  ${(rigorPct >= threshold) ? 'âœ…' : 'âŒ'} ValidaÃ§Ã£o WIN%: ${(rigorPct >= threshold) ? 'APROVADO' : 'REJEITADO'} (rigorPct >= threshold)`);
            console.log(`â•‘  ${rigorOk ? 'âœ… RESULTADO FINAL: APROVADO' : 'âŒ RESULTADO FINAL: REJEITADO'}                              â•‘`);
        }
        
    } else if (bestType === 'number-correlation' && numberAnalysis) {
        // âœ… ANÃLISE NÃšMERO + COR: 3 ocorrÃªncias, 100% WIN (0 LOSS)
        console.log('ğŸ”¢ Aplicando regras de RIGOR para NÃšMERO + COR (3 occ, 100% WIN)...');
        const validation = validateNumberAnalysis(numberAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else if (bestType === 'time-pattern' && timeAnalysis) {
        // âœ… ANÃLISE TEMPORAL: 6 ocorrÃªncias, 100% WIN (0 LOSS)
        console.log('â° Aplicando regras de RIGOR para ANÃLISE TEMPORAL (6 occ, 100% WIN)...');
        const validation = validateTemporalAnalysis(timeAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else if (bestType === 'correlation' && correlationAnalysis) {
        // âœ… ANÃLISE DE CICLO: 6 ocorrÃªncias, 100% WIN (0 LOSS)
        console.log('ğŸ”„ Aplicando regras de RIGOR para ANÃLISE DE CICLO (6 occ, 100% WIN)...');
        const validation = validateCorrelationAnalysis(correlationAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else if (bestType === 'frequency' && frequencyAnalysis) {
        // âœ… ANÃLISE DE TENDÃŠNCIA: 5 ocorrÃªncias, 100% WIN (0 LOSS)
        console.log('ğŸ“Š Aplicando regras de RIGOR para TENDÃŠNCIA/FREQUÃŠNCIA (5 occ, 100% WIN)...');
        const validation = validateFrequencyAnalysis(frequencyAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else if (bestType === 'mixed-pattern' && timeAnalysis) {
        // âœ… PADRÃƒO TEMPORAL/MISTO: Usar mesma validaÃ§Ã£o temporal (6 occ, 100% WIN)
        console.log('ğŸ”€ Aplicando regras de RIGOR para PADRÃƒO MISTO (6 occ, 100% WIN)...');
        const validation = validateTemporalAnalysis(timeAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else {
        // âœ… TIPO DESCONHECIDO OU SEM ANÃLISE: Rejeitar
        console.log(`âš ï¸ Tipo de anÃ¡lise desconhecido ou sem dados: ${bestType}`);
        rigorOk = false;
        rigorMessage = `Tipo de anÃ¡lise nÃ£o suportado: ${bestType}`;
    }

    if (!meetsCriteria || !rigorOk) {
        if (!rigorOk && rigorMessage) {
            console.log(`âŒ AnÃ¡lise rejeitada por validaÃ§Ã£o especÃ­fica: ${rigorMessage}`);
        }
        if (!rigorOk) {
            console.log('âŒ AnÃ¡lise rejeitada por rigor do usuÃ¡rio:', {
                hasColorAnalysis: !!colorAnalysis,
                patternSize: colorAnalysis && colorAnalysis.pattern ? colorAnalysis.pattern.length : undefined,
                minPatternSize: analyzerConfig.minPatternSize,
                maxPatternSize: analyzerConfig.maxPatternSize || 'sem limite',
                totalOccurrences: colorAnalysis ? colorAnalysis.occurrences : undefined,
                maxOccurrences: analyzerConfig.maxOccurrences || 'sem limite',
                sampleMin: analyzerConfig.minOccurrences,
                sampleMinWins100: colorAnalysis ? colorAnalysis.sampleMinWins100 : undefined,
                rigorWinPct: colorAnalysis ? (colorAnalysis.rigorWinPct ?? colorAnalysis.winPct) : undefined,
                threshold: analyzerConfig.winPercentOthers
            });
        }
        // âœ… LOG SEGURO: verificar se propriedades existem antes de usar .toFixed()
        const confStr = bestRecommendation?.adjustedConfidence != null ? bestRecommendation.adjustedConfidence.toFixed(1) : 'N/A';
        const occStr = bestAnalysis?.occurrences != null ? bestAnalysis.occurrences : 'N/A';
        const sigStr = bestAnalysis?.statisticalSignificance != null ? bestAnalysis.statisticalSignificance.toFixed(2) : 'N/A';
        const streakStr = probThreeLoss != null ? (probThreeLoss * 100).toFixed(2) + '%' : 'N/A';
        console.log(`âŒ AnÃ¡lise rejeitada: conf=${confStr}%/${minConfidence}%, occ=${occStr}/${minOccurrences}, sig=${sigStr}, P(3 LOSS)=${streakStr} (mÃ¡x ${(
            maxThreeLossProb * 100
        ).toFixed(2)}%)`);
        return null;
    }
    
    // âœ… LOG SEGURO para aprovaÃ§Ã£o tambÃ©m
    const confStrOk = bestRecommendation?.adjustedConfidence != null ? bestRecommendation.adjustedConfidence.toFixed(1) : 'N/A';
    const occStrOk = bestAnalysis?.occurrences != null ? bestAnalysis.occurrences : 'N/A';
    const sigStrOk = bestAnalysis?.statisticalSignificance != null ? bestAnalysis.statisticalSignificance.toFixed(2) : 'N/A';
    console.log(`âœ… ANÃLISE MULTIDIMENSIONAL APROVADA: conf=${confStrOk}%, occ=${occStrOk}, sig=${sigStrOk}`);
    
    // Aplicar calibraÃ§Ã£o do observador inteligente na confianÃ§a final
    const rawConfidence = bestRecommendation.adjustedConfidence;
    const calibratedConfidence = applyCalibratedConfidence(rawConfidence);
    
    // Calcular contribuiÃ§Ãµes baseadas no consenso
    const contributions = {};
    bestRecommendation.analyses.forEach(analysis => {
        const weight = analysis.type === 'color-pattern' ? 0.30 : 
                      analysis.type === 'number-correlation' ? 0.25 :
                      analysis.type === 'time-pattern' ? 0.20 :
                      analysis.type === 'mixed-pattern' ? 0.20 :
                      analysis.type === 'correlation' ? 0.15 : 0.10;
        contributions[analysis.type] = analysis.confidence * weight;
    });
    
    // âœ… CRIAR TIMESTAMPS CORRETOS (nÃºmeros, nÃ£o strings!)
    const now = Date.now();
    const nextSpinTimestamp = now + 30000; // 30 segundos para prÃ³ximo giro
    
    return {
        suggestion: 'Entrada na prÃ³xima rodada (anÃ¡lise multidimensional confirmada)',
        color: bestRecommendation.color,
        confidence: calibratedConfidence,
        patternDescription: JSON.stringify({
            	expected_next: bestRecommendation.color,
            colorAnalysis: colorAnalysis ? { 
                pattern: colorAnalysis.pattern, 
                confidence: colorAnalysis.confidence,
                occurrences: colorAnalysis.occurrences,
                allOccurrenceTimestamps: colorAnalysis.allOccurrenceTimestamps || [],
                allOccurrenceNumbers: colorAnalysis.allOccurrenceNumbers || [],
                occurrenceTimes: colorAnalysis.occurrenceTimes || [],
                triggerColor: colorAnalysis.triggerColor || null,
                allTriggerColors: colorAnalysis.allTriggerColors || [],
                allTriggerNumbers: colorAnalysis.allTriggerNumbers || [],
                allTriggerTimestamps: colorAnalysis.allTriggerTimestamps || [],
                occurrenceDetails: colorAnalysis.occurrenceDetails || [],
                assertiveness: colorAnalysis.assertivenessExplain ? colorAnalysis.assertivenessExplain : {
                    occurrences: colorAnalysis.occurrences,
                    wins: colorAnalysis.wins,
                    losses: colorAnalysis.losses,
                    winPct: colorAnalysis.winPct,
                    lossPct: colorAnalysis.lossPct,
                    othersCount: colorAnalysis.othersCount,
                    othersWins: colorAnalysis.othersWins,
                    othersLosses: colorAnalysis.othersLosses,
                    rigorWinPct: colorAnalysis.rigorWinPct,
                    sampleMin: colorAnalysis.sampleMin,
                    sampleMinWins100: colorAnalysis.sampleMinWins100
                }
            } : null,
            numberAnalysis: numberAnalysis ? { pattern: numberAnalysis.pattern, confidence: numberAnalysis.confidence } : null,
            timeAnalysis: timeAnalysis ? { pattern: timeAnalysis.pattern, confidence: timeAnalysis.confidence } : null,
            correlationAnalysis: correlationAnalysis ? { pattern: correlationAnalysis.pattern, confidence: correlationAnalysis.confidence } : null,
            frequencyAnalysis: frequencyAnalysis ? { pattern: frequencyAnalysis.pattern, confidence: frequencyAnalysis.confidence } : null,
            contributions: contributions,
            finalConfidence: calibratedConfidence,
            rawConfidence: rawConfidence,
            rigorLevel: minConfidence,
            hasRecentLoss: hasRecentLoss,
            consensusCount: bestRecommendation.count,
            consensusBonus: bestRecommendation.count > 1 ? (bestRecommendation.count - 1) * 5 : 0
        }),
        // âœ… TIMESTAMPS NUMÃ‰RICOS para validaÃ§Ã£o WIN/LOSS funcionar!
        createdOnTimestamp: now,
        predictedFor: nextSpinTimestamp,
        phase: 'G0',
        contributions: contributions,
        rigorLevel: minConfidence,
        hasRecentLoss: hasRecentLoss,
        consensusCount: bestRecommendation.count,
        consensusBonus: bestRecommendation.count > 1 ? (bestRecommendation.count - 1) * 5 : 0
    };
}



// Calcular similaridade entre sequÃªncias
function calculateSequenceSimilarity(seq1, seq2) {
    if (seq1.length !== seq2.length) return 0;
    
    let matches = 0;
    for (let i = 0; i < seq1.length; i++) {
        if (seq1[i] === seq2[i]) matches++;
    }
    
    return matches / seq1.length;
}

// Analisar padrÃµes temporais
function analyzeTemporalPatterns(history) {
    const now = new Date();
    const currentHour = now.getHours();
    
    // Analisar giros do mesmo horÃ¡rio nos Ãºltimos dias
    const recentHistory = history.filter(spin => {
        const spinTime = new Date(spin.timestamp);
        const timeDiff = now - spinTime;
        return timeDiff < 7 * 24 * 60 * 60 * 1000; // Ãšltimos 7 dias
    });
    
    const hourlyPatterns = {};
    recentHistory.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        
        if (!hourlyPatterns[hour]) {
            hourlyPatterns[hour] = { red: 0, black: 0, white: 0, total: 0 };
        }
        
        hourlyPatterns[hour][spin.color]++;
        hourlyPatterns[hour].total++;
    });
    
    // Encontrar padrÃ£o no horÃ¡rio atual
    const currentHourPattern = hourlyPatterns[currentHour];
    if (currentHourPattern && currentHourPattern.total >= 5) {
        const redPercent = (currentHourPattern.red / currentHourPattern.total) * 100;
        const blackPercent = (currentHourPattern.black / currentHourPattern.total) * 100;
        const whitePercent = (currentHourPattern.white / currentHourPattern.total) * 100;
        
        // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
        let suggestedColor = null;
        let confidence = 0;
        
        if (redPercent > 60) {
            suggestedColor = 'red';
            confidence = Math.min(redPercent, 80);
        } else if (blackPercent > 60) {
            suggestedColor = 'black';
            confidence = Math.min(blackPercent, 80);
        } else if (whitePercent > 30) {
            suggestedColor = 'white';
            confidence = Math.min(whitePercent * 2, 70);
        }
        
        if (!suggestedColor || confidence === 0) return null;
        
        return {
            type: 'temporal',
            suggestedColor: suggestedColor,
            confidence: confidence,
            pattern: `PadrÃ£o horÃ¡rio ${currentHour}h: ${redPercent.toFixed(1)}%V ${blackPercent.toFixed(1)}%P ${whitePercent.toFixed(1)}%B`
        };
    }
    
    return null;
}

// Analisar frequÃªncia de cores
function analyzeColorFrequency(history) {
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const recentSpins = history; // Todo o histÃ³rico
    const colorCounts = { red: 0, black: 0, white: 0 };
    
    recentSpins.forEach(spin => {
        colorCounts[spin.color]++;
    });
    
    const total = recentSpins.length;
    const redPercent = (colorCounts.red / total) * 100;
    const blackPercent = (colorCounts.black / total) * 100;
    const whitePercent = (colorCounts.white / total) * 100;
    
    // Se uma cor estÃ¡ muito frequente, sugerir a oposta
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
    let suggestedColor = null;
    let confidence = 0;
    let pattern = '';
    
    if (redPercent > 70) {
        suggestedColor = 'black';
        confidence = Math.min(redPercent - 50, 60);
        pattern = `Vermelho dominante (${redPercent.toFixed(1)}%) - Sugerindo preto`;
    } else if (blackPercent > 70) {
        suggestedColor = 'red';
        confidence = Math.min(blackPercent - 50, 60);
        pattern = `Preto dominante (${blackPercent.toFixed(1)}%) - Sugerindo vermelho`;
    } else if (whitePercent > 25) {
        // âœ… CORREÃ‡ÃƒO: Sugerir a cor MENOS frequente entre red e black
        suggestedColor = redPercent < blackPercent ? 'red' : 'black';
        confidence = Math.min(whitePercent * 2, 60);
        const colorText = suggestedColor === 'red' ? 'vermelho' : 'preto';
        pattern = `Branco frequente (${whitePercent.toFixed(1)}%) - Sugerindo ${colorText}`;
    } else {
        // PadrÃ£o equilibrado, usar anÃ¡lise de sequÃªncias
        return null;
    }
    
    if (!suggestedColor) return null;
    
    return {
        type: 'frequency',
        suggestedColor: suggestedColor,
        confidence: confidence,
        pattern: pattern
    };
}

// Combinar todas as anÃ¡lises
function combineAnalyses(sequenceAnalysis, zoneAnalysis, trendAnalysis) {
    const analysis = sequenceAnalysis || null;
    if (!analysis) {
        return null;
    }

    // Base confidence from sequence (sem limitaÃ§Ã£o artificial)
    let confidence = analysis.confidence || 0;
    const occurrences = analysis.occurrences || 0;
    const statisticalSignificance = analysis.statisticalSignificance || 1;

    // Ajustes por zona e tendÃªncia (mais conservador)
    if (zoneAnalysis) {
        if (zoneAnalysis.zoneColor === analysis.suggestedColor) {
            confidence = Math.min(confidence + (zoneAnalysis.confidence * 0.3), 95); // Apenas 30% do boost
        } else {
            confidence = Math.max(confidence - (zoneAnalysis.confidence * 0.2), 0); // Penalidade menor
        }
    }
    if (trendAnalysis) {
        if (trendAnalysis.trendColor === analysis.suggestedColor) {
            confidence = Math.min(confidence + (trendAnalysis.confidence * 0.3), 95); // Apenas 30% do boost
        } else {
            confidence = Math.max(confidence - (trendAnalysis.confidence * 0.2), 0); // Penalidade menor
        }
    }

    // CRITÃ‰RIOS ULTRA RIGOROSOS PARA 80%+ ACERTIVIDADE
    const allowEntry = confidence >= 80 && occurrences >= 5 && statisticalSignificance >= 2.0;
    if (!allowEntry) {
        console.log(`PadrÃ£o rejeitado: conf=${confidence.toFixed(1)}%, occ=${occurrences}, sig=${statisticalSignificance.toFixed(2)}`);
        return null;
    }

    const description = JSON.stringify({ 
        pattern: analysis.pattern, 
        occurrences: analysis.occurrences, 
        times: analysis.occurrenceTimes || [], 
        lastSequenceTimes: analysis.lastOccurrenceTimestamps || [],
        lastSequenceNumbers: analysis.lastOccurrenceNumbers || [],
        zone: zoneAnalysis ? { color: zoneAnalysis.zoneColor, dominance: zoneAnalysis.dominance } : null,
        trend: trendAnalysis ? { color: trendAnalysis.trendColor, aligned: trendAnalysis.alignment } : null,
        statisticalSignificance: statisticalSignificance
    });

    console.log(`âœ… PADRÃƒO APROVADO: conf=${confidence.toFixed(1)}%, occ=${occurrences}, sig=${statisticalSignificance.toFixed(2)}`);

    return {
        suggestion: 'Entrada na prÃ³xima rodada (padrÃ£o confirmado)',
        color: analysis.suggestedColor,
        confidence: confidence,
        patternDescription: description,
        createdOnTimestamp: analysis.createdOnTimestamp || null,
        predictedFor: 'next',
        phase: 'G0'
    };
}

// Analyze color streaks
function analyzeColorStreaks(spins) {
    const colors = spins.map(s => s.color);
    const lastColor = colors[0];
    const streakLength = getStreakLength(colors, lastColor);
    
    // If streak is 3 or more, suggest opposite color
    if (streakLength >= 3) {
        const oppositeColor = lastColor === 'red' ? 'black' : lastColor === 'black' ? 'red' : 'red';
        const confidence = Math.min(streakLength * 15, 70); // Max 70% confidence
        
        return {
            confidence,
            suggestion: `SequÃªncia de ${streakLength} ${lastColor}s detectada`,
            color: oppositeColor,
            probability: confidence,
            description: `PadrÃ£o de sequÃªncia: ${streakLength} ${lastColor}s consecutivos`,
            weight: 1.2
        };
    }
    
    return null;
}

// Analyze number distribution
function analyzeNumberDistribution(spins) {
    const numbers = spins.map(s => s.number);
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const recentNumbers = numbers; // Todo o histÃ³rico
    
    // Count frequency of each number
    const frequency = {};
    recentNumbers.forEach(num => {
        frequency[num] = (frequency[num] || 0) + 1;
    });
    
    // Find least frequent numbers
    const minFreq = Math.min(...Object.values(frequency));
    const leastFrequent = Object.keys(frequency).filter(num => frequency[num] === minFreq);
    
    if (leastFrequent.length > 0 && minFreq === 0) {
        const suggestedNumber = parseInt(leastFrequent[0]);
        const color = getColorFromNumber(suggestedNumber);
        
        return {
            confidence: 45,
            suggestion: `NÃºmero ${suggestedNumber} nÃ£o apareceu recentemente`,
            color,
            probability: 45,
            description: `DistribuiÃ§Ã£o: nÃºmero ${suggestedNumber} ausente nas Ãºltimas 20 rodadas`,
            weight: 0.8
        };
    }
    
    return null;
}

// Analyze alternating patterns
function analyzeAlternatingPatterns(spins) {
    const colors = spins.map(s => s.color);
    
    // Check for alternating pattern in last 6 spins
    if (colors.length >= 6) {
        const last6 = colors.slice(0, 6);
        let alternating = true;
        
        for (let i = 1; i < last6.length; i++) {
            if (last6[i] === last6[i-1]) {
                alternating = false;
                break;
            }
        }
        
        if (alternating) {
            const nextColor = last6[0] === 'red' ? 'black' : last6[0] === 'black' ? 'red' : 'red';
            
            return {
                confidence: 55,
                suggestion: 'PadrÃ£o alternado detectado',
                color: nextColor,
                probability: 55,
                description: 'PadrÃ£o alternado nas Ãºltimas 6 rodadas',
                weight: 1.0
            };
        }
    }
    
    return null;
}

// Analyze hot/cold numbers
function analyzeHotColdNumbers(spins) {
    const numbers = spins.map(s => s.number);
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const recentNumbers = numbers; // Todo o histÃ³rico
    
    // Count frequency
    const frequency = {};
    recentNumbers.forEach(num => {
        frequency[num] = (frequency[num] || 0) + 1;
    });
    
    // Find hot numbers (appeared most frequently)
    const maxFreq = Math.max(...Object.values(frequency));
    const hotNumbers = Object.keys(frequency).filter(num => frequency[num] === maxFreq);
    
    if (hotNumbers.length > 0 && maxFreq >= 3) {
        const suggestedNumber = parseInt(hotNumbers[0]);
        const color = getColorFromNumber(suggestedNumber);
        
        return {
            confidence: 40,
            suggestion: `NÃºmero quente: ${suggestedNumber}`,
            color,
            probability: 40,
            description: `NÃºmero ${suggestedNumber} apareceu ${maxFreq} vezes nas Ãºltimas 30 rodadas`,
            weight: 0.6
        };
    }
    
    return null;
}

// Reconhecimento de Zonas: detecta cor dominante em janelas recentes
function analyzeZones(history) {
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const windowSize = history.length; // Todo o histÃ³rico
    if (windowSize < 50) return null; // MÃ­nimo de 50 giros
    const recent = history; // Todo o histÃ³rico
    const colorCounts = { red: 0, black: 0, white: 0 };
    recent.forEach(s => { colorCounts[s.color] = (colorCounts[s.color] || 0) + 1; });
    const total = recent.length;
    const ratios = {
        red: colorCounts.red / total,
        black: colorCounts.black / total,
        white: colorCounts.white / total
    };
    let zoneColor = 'red';
    if (ratios.black >= ratios.red && ratios.black >= ratios.white) zoneColor = 'black';
    else if (ratios.white >= ratios.red && ratios.white >= ratios.black) zoneColor = 'white';
    const dominance = Math.max(ratios.red, ratios.black, ratios.white) * 100; // 0-100
    if (dominance < 55) return null; // Sem zona dominante
    return {
        type: 'zone',
        zoneColor,
        dominance,
        confidence: Math.min(dominance - 50, 15) // atÃ© +15
    };
}

// Reconhecimento de TendÃªncia: compara janelas curta e mÃ©dia
function analyzeTrend(history) {
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const shortN = Math.min(50, history.length); // Janela curta: 50 giros
    const midN = history.length; // Janela mÃ©dia: todo o histÃ³rico
    if (shortN < 50) return null; // MÃ­nimo de 50 giros
    const short = history.slice(0, shortN);
    const mid = history; // Todo o histÃ³rico
    function dominantColor(spins) {
        const c = { red: 0, black: 0, white: 0 };
        spins.forEach(s => { c[s.color] = (c[s.color] || 0) + 1; });
        const total = spins.length;
        const r = c.red / total, b = c.black / total, w = c.white / total;
        let color = 'red', dom = r;
        if (b >= dom) { color = 'black'; dom = b; }
        if (w >= dom) { color = 'white'; dom = w; }
        return { color, share: dom*100 };
    }
    const s = dominantColor(short);
    const m = dominantColor(mid);
    if (s.share < 55 && m.share < 55) return null; // tendÃªncia fraca
    const aligned = s.color === m.color;
    return {
        type: 'trend',
        trendColor: aligned ? s.color : s.color,
        alignment: aligned,
        confidence: aligned ? Math.min((s.share - 50) + (m.share - 50), 20) : Math.min(s.share - 50, 10) // atÃ© +20
    };
}

// Helper functions
function getStreakLength(colors, color) {
    let streak = 0;
    for (let i = 0; i < colors.length; i++) {
        if (colors[i] === color) {
            streak++;
        } else {
            break;
        }
    }
    return streak;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GET COLOR FROM NUMBER (GLOBAL) - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getColorFromNumber(number) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA (silenciosa - undefined Ã© comum em anÃ¡lises)
    if (typeof number !== 'number' || isNaN(number) || number === undefined || number === null) {
        return 'unknown';
    }
    
    // âœ… NORMALIZAR NÃšMERO (caso seja float)
    const normalizedNumber = Math.floor(number);
    
    // âœ… VALIDAR RANGE (0-14)
    if (normalizedNumber < 0 || normalizedNumber > 14) {
        return 'unknown';
    }
    
    // âœ… DETERMINAR COR
    if (normalizedNumber === 0) {
        return 'white';
    } else if (normalizedNumber >= 1 && normalizedNumber <= 7) {
        return 'red';
    } else if (normalizedNumber >= 8 && normalizedNumber <= 14) {
    return 'black';
    }
    
    // âœ… FALLBACK (nunca deve chegar aqui)
    return 'unknown';
}

// ========= NOVO: CÃ¡lculo inteligente de assertividade =========
// (Constantes movidas para o inÃ­cio do arquivo para evitar TDZ errors)

// Calcula assertividade para padrÃµes de cor (pattern: [colors], expectedNext: 'red'|'black'|'white')
function computeAssertivenessForColorPattern(patternColors, expectedNext, history) {
	try {
		if (!Array.isArray(patternColors) || patternColors.length < 3 || !history || history.length < 50) {
			return null;
		}

		// 1) Desempenho histÃ³rico do padrÃ£o (wins/losses)
		let totalWins = 0, totalLosses = 0, totalOcc = 0;
		const colors = history.map(s => s.color);
		const need = patternColors.length;
		for (let i = need; i < colors.length; i++) {
			const seq = colors.slice(i, i + need);
			if (seq.length < need) break;
			const match = seq.every((c, idx) => c === patternColors[idx]);
			if (!match) continue;
			totalOcc++;
			const outcome = colors[i - 1];
			if (outcome === expectedNext) totalWins++; else totalLosses++;
		}
		if (totalOcc === 0) return null;
		let base = (totalWins / totalOcc) * 100;
		if (totalLosses === 0 && totalWins >= 3) base = Math.min(100, 95 + Math.min(totalWins, 5));

		// 2) TendÃªncia recente (Ãºltimos 25 giros)
		const recent = history.slice(0, Math.min(RECENT_WINDOW, history.length));
		const rc = { red: 0, black: 0, white: 0 };
		recent.forEach(s => { rc[s.color] = (rc[s.color] || 0) + 1; });
		const totalRecent = recent.length || 1;
		const recentPct = {
			red: (rc.red / totalRecent) * 100,
			black: (rc.black / totalRecent) * 100,
			white: (rc.white / totalRecent) * 100
		};
		let trendAdj = 0;
		// DominÃ¢ncia oposta >70% â†’ -15%
		const opposite = expectedNext === 'red' ? 'black' : expectedNext === 'black' ? 'red' : (recentPct.red >= recentPct.black ? 'red' : 'black');
		if (recentPct[opposite] > 70) trendAdj -= PENALTY_OPPOSITE_DOMINANCE;
		// RepetiÃ§Ã£o longa atual >5 â†’ -10%
		const streakLen = getStreakLength(colors, colors[0]);
		if (streakLen > 5) trendAdj -= PENALTY_LONG_STREAK;
		// TendÃªncia a favor >60% â†’ +10%
		if (recentPct[expectedNext] > 60) trendAdj += BONUS_FAVORABLE_TREND;

		// 3) Estabilidade do padrÃ£o (variÃ¢ncia do desempenho por janelas)
		// AproximaÃ§Ã£o: medir taxa de acerto por blocos de 10 ocorrÃªncias
		let stabilityAdj = 0;
		if (totalOcc >= 6) {
			const blockSize = 10;
			const accRates = [];
			let acc = 0, cnt = 0;
			// Revarrer somando wins/losses sequencialmente
			for (let i = need; i < colors.length; i++) {
				const seq = colors.slice(i, i + need);
				if (seq.length < need) break;
				if (!seq.every((c, idx) => c === patternColors[idx])) continue;
				cnt++;
				const outcome = colors[i - 1];
				if (outcome === expectedNext) acc++;
				if (cnt === blockSize) {
					accRates.push(acc / cnt);
					acc = 0; cnt = 0;
				}
			}
			if (cnt > 0) accRates.push(acc / cnt);
			if (accRates.length >= 2) {
				const mean = accRates.reduce((a,b)=>a+b,0) / accRates.length;
				const variance = accRates.reduce((s,v)=> s + Math.pow(v - mean, 2), 0) / accRates.length;
				const std = Math.sqrt(variance);
				// Baixa variÃ¢ncia â†’ estÃ¡vel
				if (std <= 0.1) stabilityAdj += BONUS_STABILITY;
				else if (std >= 0.25) stabilityAdj -= PENALTY_INSTABILITY;
			}
		}

		// 4) Final
	let rawConfidence = Math.max(0, Math.min(100, base + trendAdj + stabilityAdj));
	
	// 5) Aplicar calibraÃ§Ã£o do observador inteligente
	let finalConfidence = applyCalibratedConfidence(rawConfidence);
	
	// LOG DETALHADO para debug (padrÃµes com 100% win)
	if (totalLosses === 0 && totalWins >= 3) {
		console.log('ğŸ” PADRÃƒO 100% WIN - CÃLCULO DETALHADO:', {
			pattern: patternColors.join('-'),
			expected_next: expectedNext,
			total_wins: totalWins,
			total_losses: totalLosses,
			'BASE (antes ajustes)': base.toFixed(2) + '%',
			'--- ÃšLTIMOS 25 GIROS ---': '',
			red_pct: recentPct.red.toFixed(1) + '%',
			black_pct: recentPct.black.toFixed(1) + '%',
			white_pct: recentPct.white.toFixed(1) + '%',
			'--- AJUSTES ---': '',
			cor_oposta: opposite,
			dominancia_oposta: recentPct[opposite].toFixed(1) + '%',
			penalidade_dominancia: recentPct[opposite] > 70 ? '-15%' : '0%',
			repeticao_atual: streakLen,
			penalidade_repeticao: streakLen > 5 ? '-10%' : '0%',
			bonus_tendencia: recentPct[expectedNext] > 60 ? '+10%' : '0%',
			'AJUSTE TENDÃŠNCIA TOTAL': trendAdj + '%',
			'AJUSTE ESTABILIDADE': stabilityAdj + '%',
			'--- RESULTADO FINAL ---': '',
			calculo: `${base} + ${trendAdj} + ${stabilityAdj} = ${base + trendAdj + stabilityAdj}`,
			'CONFIANÃ‡A RAW': rawConfidence.toFixed(2) + '%',
			'FATOR CALIBRAÃ‡ÃƒO': (observerData.calibrationFactor * 100).toFixed(1) + '%',
			'CONFIANÃ‡A CALIBRADA': finalConfidence + '%'
		});
	}
	
		return {
			finalConfidence,
			explain: {
				pattern: patternColors,
				expected_next: expectedNext,
				total_wins: totalWins,
				total_losses: totalLosses,
				recent_window: RECENT_WINDOW,
				tendencia_ultimos_25: recentPct,
				repeticao_atual: streakLen,
				base: parseFloat(base.toFixed(2)),
				ajuste_tendencia: trendAdj,
				ajuste_estabilidade: stabilityAdj,
				assertividade_final: parseFloat(finalConfidence.toFixed(2))
			}
		};
	} catch (e) {
		console.warn('Falha no computeAssertivenessForColorPattern:', e);
		return null;
	}
}

// FunÃ§Ã£o auxiliar para enviar mensagens com tratamento de erro
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENVIAR MENSAGEM PARA CONTENT SCRIPT - REFATORADO 100% (Async com verificaÃ§Ã£o)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function sendMessageToContent(type, data = null) {
    return new Promise((resolve) => {
        chrome.tabs.query({}, function(tabs) {
            const blazeTabs = tabs.filter(tab => {
                if (!tab.url) return false;
                return tab.url.includes('blaze.bet.br') || 
                       tab.url.includes('blaze.com') || 
                       tab.url.includes('blaze1.space') ||
                       tab.url.includes('blaze-1.com');
            });
            
            if (!blazeTabs || blazeTabs.length === 0) {
                resolve(false);
                return;
            }
            
            const message = { type };
            if (data) {
                message.data = data;
            }

            let successCount = 0;
            let processedCount = 0;

            const finalize = () => {
                if (processedCount === blazeTabs.length) {
                    resolve(successCount > 0);
                }
            };

            blazeTabs.forEach(tab => {
                chrome.tabs.sendMessage(tab.id, message)
                .then(() => {
                        successCount += 1;
                        processedCount += 1;
                        finalize();
                })
                .catch(error => {
                        processedCount += 1;
                        if (error?.message && (
                            error.message.includes('Could not establish connection') ||
                            error.message.includes('Receiving end does not exist')
                        )) {
                            finalize();
                } else {
                            if (error) {
                                console.error(`âŒ Erro ao enviar ${type} para a aba ${tab.id}:`, error);
                            }
                            finalize();
                        }
                    });
            });
        });
    });
}

function attachLatestSpinsSnapshot(analysis) {
    if (!analysis || !Array.isArray(cachedHistory)) {
        return analysis;
    }
    try {
        const payload = { ...analysis };
        const last10 = cachedHistory.slice(0, 10).map(spin => ({
            color: spin.color,
            number: spin.number,
            timestamp: spin.timestamp
        }));

        payload.last10Spins = last10;
        payload.last5Spins = last10;

        if (!payload.phase && martingaleState && martingaleState.active) {
            payload.phase = martingaleState.stage || 'G0';
        }

        if (typeof payload.patternDescription === 'string') {
            try {
                const parsed = JSON.parse(payload.patternDescription);
                if (parsed && typeof parsed === 'object') {
                    parsed.last5Spins = last10;
                    payload.patternDescription = JSON.stringify(parsed);
                }
            } catch (_) {
                // ignorar: patternDescription nÃ£o Ã© JSON
            }
        } else if (payload.patternDescription && typeof payload.patternDescription === 'object') {
            payload.patternDescription = {
                ...payload.patternDescription,
                last5Spins: last10
            };
        }

        return payload;
    } catch (error) {
        console.warn('âš ï¸ NÃ£o foi possÃ­vel anexar Ãºltimos giros ao payload da anÃ¡lise:', error);
        return analysis;
    }
}

function emitAnalysisToContent(analysis, mode) {
    const payload = analysis ? { ...attachLatestSpinsSnapshot(analysis) } : {};
    if (mode) {
        payload.analysisMode = mode;
    }
    return sendMessageToContent('NEW_ANALYSIS', payload);
}

// FunÃ§Ã£o para enviar status de anÃ¡lise para o content script
function sendAnalysisStatus(status) {
    sendMessageToContent('ANALYSIS_STATUS', { status: status });
}

// Helper local para obter um snapshot simples da memÃ³ria ativa
function getMemoriaAtivaStatus() {
    try {
        const totalGiros = Array.isArray(memoriaAtiva.giros) ? memoriaAtiva.giros.length : 0;
        return {
            inicializada: !!memoriaAtiva.inicializada,
            totalAtualizacoes: memoriaAtiva.totalAtualizacoes || 0,
            tempoUltimaAtualizacao: memoriaAtiva.tempoUltimaAtualizacao || 0,
            totalGiros
        };
    } catch (e) {
        return {
            inicializada: false,
            totalAtualizacoes: 0,
            tempoUltimaAtualizacao: 0,
            totalGiros: 0
        };
    }
}

// FunÃ§Ã£o para restaurar o status "IA ativada" apÃ³s anÃ¡lise
async function restoreIAStatus() {
    lastDiamondLevelTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    lastDiamondLevelTimeouts = [];
    try {
        const status = getMemoriaAtivaStatus();
        const updates = status.totalAtualizacoes || 0;
        const baseText = updates > 0
            ? `MemÃ³ria ativada â€¢ ${updates} anÃ¡lises`
            : 'IA ativada';
        sendAnalysisStatus(baseText);
        console.log('%câœ… Status restaurado:', 'color: #00FF88; font-weight: bold;', baseText);
    } catch (error) {
        console.error('âŒ Erro ao restaurar status:', error);
    }
}

// ============================================
// TELEGRAM INTEGRATION
// ============================================

// FunÃ§Ã£o para enviar mensagem ao Telegram
async function sendTelegramMessage(text) {
    if (!analyzerConfig.telegramChatId || analyzerConfig.telegramChatId.trim() === '') {
        console.log('âš ï¸ Telegram Chat ID nÃ£o configurado. Mensagem nÃ£o enviada.');
        console.log('ğŸ’¡ Configure seu Chat ID na caixa de configuraÃ§Ãµes da extensÃ£o.');
        return false;
    }

    console.log('ğŸ“¤ Tentando enviar mensagem ao Telegram...');
    console.log('ğŸ“± Chat ID:', analyzerConfig.telegramChatId);
    console.log('ğŸ“ Mensagem:', text);

    try {
        const response = await fetch(TELEGRAM_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                chat_id: analyzerConfig.telegramChatId,
                text: text,
                parse_mode: 'HTML'
            })
        });

        const result = await response.json();
        
        if (result.ok) {
            console.log('âœ… Mensagem enviada ao Telegram com sucesso!');
            console.log('ğŸ“¬ Resposta:', result);
            return true;
        } else {
            console.error('âŒ Erro ao enviar mensagem ao Telegram:', result);
            if (result.description) {
                console.error('ğŸ“‹ DescriÃ§Ã£o do erro:', result.description);
                if (result.description.includes('chat not found')) {
                    console.error('ğŸ’¡ SOLUÃ‡ÃƒO: VocÃª precisa iniciar uma conversa com o bot primeiro!');
                    console.error('ğŸ’¡ Acesse: https://t.me/Blaze_doubleIA_Bot e clique em "Start"');
                }
            }
            return false;
        }
    } catch (error) {
        console.error('âŒ Erro de conexÃ£o com Telegram:', error);
        console.error('ğŸ“‹ Detalhes:', error.message);
        return false;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENVIAR SINAL DE ENTRADA AO TELEGRAM - REFATORADO 100% (Com verificaÃ§Ã£o de retorno)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function sendTelegramEntrySignal(color, lastSpin, confidence, analysisData = null) {
    console.log('ğŸ¯ Enviando SINAL DE ENTRADA ao Telegram...');
    
    // âœ… VERIFICAR SE HÃ ABA DA BLAZE ABERTA (SEGURANÃ‡A EXTRA)
    const hasBlaze = await hasBlazeTabOpen();
    if (!hasBlaze) {
        console.log('â•‘  â›” ENVIO BLOQUEADO: NENHUMA ABA DA BLAZE ABERTA         â•‘');
        console.log('â•‘  ğŸ’¡ Sinais sÃ³ sÃ£o enviados quando a Blaze estÃ¡ aberta    â•‘');
        return false;
    }
    
    // âœ… VALIDAÃ‡ÃƒO DE PARÃ‚METROS
    if (!color || !lastSpin) {
        console.error('âŒ ParÃ¢metros invÃ¡lidos para envio ao Telegram:', { color, lastSpin });
        return false;
    }
    
    const colorEmoji = color === 'red' ? 'ğŸ”´' : color === 'black' ? 'âš«' : 'âšª';
    const colorText = color === 'red' ? 'VERMELHO' : color === 'black' ? 'PRETO' : 'BRANCO';
    
    // Extrair informaÃ§Ãµes de assertividade do patternDescription se disponÃ­vel
    let assertivenessInfo = '';
    let isAIAnalysis = false;
    if (analysisData && analysisData.patternDescription) {
        try {
            // Tentar fazer parse como JSON primeiro
            const patternDesc = JSON.parse(analysisData.patternDescription);
            
            // Verificar se Ã© anÃ¡lise IA (novo formato estruturado)
            if (patternDesc.type === 'AI_ANALYSIS') {
                isAIAnalysis = true;
                console.log('%cğŸ¤– AnÃ¡lise IA detectada (formato estruturado)', 'color: #00FF88;');
                assertivenessInfo = ''; // Nenhuma info extra
            } else if (patternDesc.type === 'AI_ANALYSIS_OLD' || (typeof patternDesc === 'string' && patternDesc.includes('ğŸ¤–'))) {
                // Formato antigo de IA (texto)
                isAIAnalysis = true;
                console.log('%cğŸ¤– AnÃ¡lise IA detectada (formato antigo)', 'color: #00FF88;');
                assertivenessInfo = '';
            } else {
                // Para anÃ¡lise padrÃ£o, patternDescription Ã© JSON
            let assert = null;
            
            // Buscar informaÃ§Ãµes de assertividade em diferentes locais
            if (patternDesc) {
                // Prioridade 1: colorAnalysis.summary (padrÃµes salvos)
                if (patternDesc.colorAnalysis && patternDesc.colorAnalysis.summary) {
                    assert = patternDesc.colorAnalysis.summary;
                }
                // Prioridade 2: colorAnalysis.assertiveness (anÃ¡lise nova)
                else if (patternDesc.colorAnalysis && patternDesc.colorAnalysis.assertiveness) {
                    assert = patternDesc.colorAnalysis.assertiveness;
                }
                // Prioridade 3: assertiveness direto (padrÃµes salvos legacy)
                else if (patternDesc.assertiveness) {
                    assert = patternDesc.assertiveness;
                }
            }
            
            if (assert) {
                // InformaÃ§Ãµes sobre as demais ocorrÃªncias (excluindo a amostra mÃ­nima)
                if (assert.othersCount !== undefined && assert.othersCount > 0) {
                    // âœ… CORREÃ‡ÃƒO: Usar othersCount diretamente, nÃ£o somar othersWins + othersLosses
                    const othersTotal = assert.othersCount;
                    const othersPct = othersTotal > 0 ? ((assert.othersWins / othersTotal) * 100).toFixed(1) : '0.0';
                    assertivenessInfo += `\nğŸ“Š <b>Demais OcorrÃªncias:</b> ${assert.othersWins}W / ${assert.othersLosses}L (${othersPct}%)`;
                }
                
                // InformaÃ§Ãµes totais
                if (assert.occurrences !== undefined) {
                    assertivenessInfo += `\nğŸ“ˆ <b>Total de OcorrÃªncias:</b> ${assert.occurrences}`;
                }
                
                if (assert.wins !== undefined && assert.losses !== undefined) {
                    const totalPct = assert.winPct ? assert.winPct.toFixed(1) : '0.0';
                    assertivenessInfo += `\nğŸ’¯ <b>WIN Total:</b> ${assert.wins}W / ${assert.losses}L (${totalPct}%)`;
                }
            }
            }
        } catch (e) {
            console.error('Erro ao extrair informaÃ§Ãµes de assertividade:', e);
            // Continuar sem as informaÃ§Ãµes de assertividade
        }
    }
    
    // âœ… Calcular placar baseado em CICLOS COMPLETOS
    const { entriesHistory = [] } = await chrome.storage.local.get('entriesHistory');
    const { totalWins, totalLosses } = calculateCycleScore(entriesHistory);
    
    // isAIAnalysis jÃ¡ foi definido anteriormente ao fazer parse do patternDescription
    const systemTag = isAIAnalysis ? 'ğŸ¤– AnÃ¡lise AvanÃ§ada (IA)' : 'ğŸ“Š Sistema PadrÃ£o';
    
    const message = `
ğŸ¯ <b>ATENÃ‡ÃƒO ENTRAR AGORA</b>
${colorEmoji} <b>${colorText}</b>
ğŸ“Š ConfianÃ§a: ${confidence}%
${isAIAnalysis ? 'ğŸ¤– <b>AnÃ¡lise: InteligÃªncia Artificial</b>' : ''}
ğŸ² Ãšltimo: ${lastSpin.color === 'red' ? 'ğŸ”´' : lastSpin.color === 'black' ? 'âš«' : 'âšª'} ${lastSpin.color === 'red' ? 'Vermelho' : lastSpin.color === 'black' ? 'Preto' : 'Branco'} (${lastSpin.number})
ğŸ“ˆ Placar: WIN: ${totalWins} | LOSS: ${totalLosses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();

    // âœ… ENVIAR E VERIFICAR RETORNO
    const result = await sendTelegramMessage(message);
    
    if (result) {
        console.log('âœ… Sinal de entrada enviado ao Telegram com sucesso!');
        return true;
    } else {
        console.error('âŒ FALHA ao enviar sinal de entrada ao Telegram!');
        console.error('ğŸ’¡ Verifique: 1) Chat ID configurado | 2) Bot iniciado | 3) ConexÃ£o com internet');
        return false;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• FUNÃ‡ÃƒO: Calcular placar filtrado por modo de anÃ¡lise
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calculateFilteredScore(entriesHistory, analysisMode) {
    // Filtrar entradas pelo modo de anÃ¡lise
    const filteredEntries = entriesHistory.filter(e => {
        // âœ… Entradas antigas sem analysisMode â†’ tratar como MODO PADRÃƒO
        const entryMode = e.analysisMode || 'standard';
        
        // Incluir apenas se for do modo especificado
        return entryMode === analysisMode;
    });
    
    // Filtrar apenas ciclos completos (WIN ou RET)
    const completeCycles = filteredEntries.filter(e => {
        if (e.result === 'WIN') return true;
        if (e.result === 'LOSS' && e.finalResult === 'RET') return true;
        return false;
    });
    
    const wins = completeCycles.filter(e => e.result === 'WIN').length;
    const losses = completeCycles.filter(e => e.result === 'LOSS').length;
    
    console.log(`ğŸ“Š Placar filtrado (modo ${analysisMode}):`, { wins, losses, total: wins + losses });
    
    return { wins, losses };
}

// FunÃ§Ã£o para enviar confirmaÃ§Ã£o de WIN ao Telegram
async function sendTelegramWinConfirmation(wins, losses) {
    console.log('ğŸ’° Enviando confirmaÃ§Ã£o de WIN ao Telegram...');
    console.log('ğŸ“Š Placar: WIN', wins, '/ LOSS', losses);
    
    const total = wins + losses;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
    
    const message = `
ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°
ğŸ”´ <b>Vermelho</b>
ğŸ“Š ConfianÃ§a: 75.2%
ğŸ“ˆ Placar: WIN: ${wins} | LOSS: ${losses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();

    console.log('ğŸ“¤ Enviando mensagem de WIN...');
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio WIN:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// FunÃ§Ã£o para enviar confirmaÃ§Ã£o de LOSS ao Telegram
async function sendTelegramLossConfirmation(wins, losses) {
    console.log('âŒ Enviando confirmaÃ§Ã£o de LOSS ao Telegram...');
    console.log('ğŸ“Š Placar: WIN', wins, '/ LOSS', losses);
    
    const total = wins + losses;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
    
    const message = `
âŒâŒâŒâŒâŒâŒâŒ <b>LOSS</b> âŒâŒâŒâŒâŒâŒâŒ
âš« <b>Preto</b>
ğŸ“Š ConfianÃ§a: 91.2%
ğŸ“ˆ Placar: WIN: ${wins} | LOSS: ${losses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();

    console.log('ğŸ“¤ Enviando mensagem de LOSS...');
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio LOSS:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNÃ‡Ã•ES DE ENVIO DE SINAIS - SISTEMA DE MARTINGALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Enviar sinal de LOSS (ENTRADA, G1 ou G2)
async function sendTelegramMartingaleLoss(stage, resultSpin) {
    console.log(`âŒ Enviando confirmaÃ§Ã£o de LOSS ${stage} ao Telegram...`);
    
    // âœ… Determinar prÃ³ximo Gale baseado no estÃ¡gio atual
    let nextGale = '';
    if (stage === 'ENTRADA') {
        nextGale = 'ğŸ”„ PrÃ³ximo: <b>G1</b>';
    } else if (stage === 'G1') {
        nextGale = 'ğŸ”„ PrÃ³ximo: <b>G2</b>';
    } else if (stage === 'G2') {
        nextGale = 'ğŸ”„ PrÃ³ximo: <b>G3</b>';
    } else if (stage.startsWith('G')) {
        const currentNum = parseInt(stage.substring(1)) || 0;
        nextGale = `ğŸ”„ PrÃ³ximo: <b>G${currentNum + 1}</b>`;
    }
    
    // âœ… Simplificar nome do estÃ¡gio (remover "ENTRADA" se for entrada)
    const stageName = stage === 'ENTRADA' ? '' : ` ${stage}`;
    
    const message = `
âŒ <b>LOSS${stageName}</b>
ğŸ“Š ConfianÃ§a: 91.2%
ğŸ² Ãšltimo: ${resultSpin.color === 'red' ? 'ğŸ”´' : resultSpin.color === 'black' ? 'âš«' : 'âšª'} ${resultSpin.color === 'red' ? 'Vermelho' : resultSpin.color === 'black' ? 'Preto' : 'Branco'} (${resultSpin.number})
${nextGale}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio LOSS:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• FUNÃ‡ÃƒO GENÃ‰RICA: Enviar sinal de qualquer Gale (G1, G2, G3... G200)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function sendTelegramMartingaleGale(galeNumber, color, percentage) {
    console.log(`ğŸ”„ Enviando sinal de G${galeNumber} ao Telegram...`);
    
    const colorEmoji = color === 'red' ? 'ğŸ”´' : color === 'black' ? 'âš«' : 'âšª';
    const colorText = color === 'red' ? 'VERMELHO' : color === 'black' ? 'PRETO' : 'BRANCO';
    
    // Determinar texto de alerta baseado no nÃºmero do Gale
    let warningText = '';
    const { maxGales } = getMartingaleSettings();
    const configuredMaxGales = maxGales || 2;
    if (galeNumber === configuredMaxGales) {
        warningText = '\nâš ï¸ <b>ÃšLTIMA TENTATIVA!</b> âš ï¸';
    } else if (galeNumber >= 3) {
        warningText = `\nâš ï¸ Gale ${galeNumber} de ${configuredMaxGales}`;
    }
    
    const message = `
ğŸ”„ <b>GALE ${galeNumber}</b>
${colorEmoji} <b>${colorText}</b>
ğŸ“Š ConfianÃ§a: ${galeNumber === 1 ? '82.1' : '88.5'}%
ğŸ² Ãšltimo: âš« Preto (5)
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log(`ğŸ“¬ Resultado do envio G${galeNumber}:`, result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// Enviar sinal de G1 (Martingale 1)
async function sendTelegramMartingaleG1(color, hotColorPercentage) {
    console.log('ğŸ”„ Enviando sinal de G1 ao Telegram...');
    
    const colorEmoji = color === 'red' ? 'ğŸ”´' : color === 'black' ? 'âš«' : 'âšª';
    const colorText = color === 'red' ? 'VERMELHO' : color === 'black' ? 'PRETO' : 'BRANCO';
    
    // âœ… Nova lÃ³gica: mesma cor da entrada (nÃ£o mostra porcentagem de histÃ³rico)
    const message = `
ğŸ”„ <b>GALE 1</b>
${colorEmoji} <b>${colorText}</b>
ğŸ“Š ConfianÃ§a: 82.1%
ğŸ² Ãšltimo: âš« Preto (5)
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio G1:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// Enviar sinal de G2 (Martingale 2)
async function sendTelegramMartingaleG2(color, hotColorPercentage) {
    console.log('ğŸ”„ Enviando sinal de G2 ao Telegram...');
    
    const colorEmoji = color === 'red' ? 'ğŸ”´' : color === 'black' ? 'âš«' : 'âšª';
    const colorText = color === 'red' ? 'VERMELHO' : color === 'black' ? 'PRETO' : 'BRANCO';
    
    // âœ… Nova lÃ³gica: mesma cor da entrada (nÃ£o mostra porcentagem de histÃ³rico)
    const message = `
ğŸ”„ <b>GALE 2</b>
${colorEmoji} <b>${colorText}</b>
ğŸ“Š ConfianÃ§a: 88.5%
ğŸ² Ãšltimo: âš« Preto (5)
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio G2:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// Enviar sinal de WIN no Martingale
async function sendTelegramMartingaleWin(stage, resultSpin, wins, losses, analysisMode = 'standard') {
    console.log(`âœ… Enviando confirmaÃ§Ã£o de WIN ${stage} ao Telegram...`);
    console.log(`   Modo de anÃ¡lise: ${analysisMode}`);
    
    const total = wins + losses;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
    const spinEmoji = resultSpin.color === 'red' ? 'ğŸ”´' : resultSpin.color === 'black' ? 'âš«' : 'âšª';
    const spinColor = resultSpin.color === 'red' ? 'VERMELHO' : resultSpin.color === 'black' ? 'PRETO' : 'BRANCO';
    
    // âœ… Identificador do modo
    const modeIcon = analysisMode === 'diamond' ? 'ğŸ’' : 'âš™ï¸';
    const modeName = analysisMode === 'diamond' ? 'Modo Diamante' : 'Modo PadrÃ£o';
    
    let stageMessage = '';
    if (stage === 'ENTRADA') {
        stageMessage = 'ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°';
    } else if (stage === 'G1') {
        stageMessage = 'ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN G1</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°';
    } else if (stage === 'G2') {
        stageMessage = 'ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN G2</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°';
    } else if (stage.startsWith('G')) {
        const galeNum = stage.substring(1);
        stageMessage = `ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN G${galeNum}</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°`;
    }
    
    const message = `
${stageMessage}
${spinEmoji} <b>${spinColor}</b>
${modeIcon} <b>${modeName}</b>
ğŸ“Š ConfianÃ§a: 88.5%
ğŸ“ˆ Placar (${modeName}): WIN: ${wins} | LOSS: ${losses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio WIN:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// Enviar sinal de RET (Loss Final)
async function sendTelegramMartingaleRET(wins, losses, analysisMode = 'standard') {
    console.log('â›” Enviando sinal de RET ao Telegram...');
    console.log(`   Modo de anÃ¡lise: ${analysisMode}`);
    
    const total = wins + losses;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
    
    // âœ… Identificador do modo
    const modeIcon = analysisMode === 'diamond' ? 'ğŸ’' : 'âš™ï¸';
    const modeName = analysisMode === 'diamond' ? 'Modo Diamante' : 'Modo PadrÃ£o';
    
    const message = `
âŒâŒâŒâŒâŒâŒâŒ <b>LOSS NÃƒO PAGOU</b> âŒâŒâŒâŒâŒâŒâŒ
ğŸ”´ <b>Vermelho</b>
${modeIcon} <b>${modeName}</b>
ğŸ“Š ConfianÃ§a: 91.2%
ğŸ“ˆ Placar (${modeName}): WIN: ${wins} | LOSS: ${losses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio RET:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// Monitorar abas e controlar extensÃ£o automaticamente
chrome.tabs.onRemoved.addListener(async (tabId, removeInfo) => {
    // Verificar se ainda hÃ¡ abas da Blaze abertas
    const hasBlaze = await hasBlazeTabOpen();
    if (!hasBlaze && isRunning) {
        console.log('â•‘  âš ï¸ NENHUMA ABA DA BLAZE ABERTA - PARANDO EXTENSÃƒO       â•‘');
        stopDataCollection();
    }
});

chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
    if (changeInfo.status === 'complete') {
        // âœ… Verificar mÃºltiplos domÃ­nios da Blaze
        const blazeDomains = [
            'blaze.com',
            'blaze1.space',
            'blaze-1.com',
            'blaze-bet.com',
            'blaze.bet.br'
        ];
        
        const isBlaze = tab.url && blazeDomains.some(domain => tab.url.includes(domain));
        
        if (isBlaze) {
            if (!isRunning) {
                console.log('â•‘  âœ… ABA DA BLAZE DETECTADA - INICIANDO EXTENSÃƒO          â•‘');
                console.log(`â•‘  URL: ${tab.url.substring(0, 50)}...`);
                startDataCollection();
            }
        }
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’ SIMULAÃ‡ÃƒO NO PASSADO (BACKTEST) - MODO DIAMANTE (SEM SPOILER)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const DIAMOND_SIMULATION_BATCH = 25;
const DIAMOND_OPTIMIZATION_TRIALS_DEFAULT = 100;
const DIAMOND_OPTIMIZATION_PROGRESS_EVERY = 1; // enviar progresso a cada tentativa (100 no total)
const DIAMOND_OPTIMIZATION_MIN_PCT_DEFAULT = 95; // âœ… sÃ³ "recomendar" config >= 95%
const diamondOptimizationJobs = new Map(); // jobId -> { cancelled: boolean }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ SIMULAÃ‡ÃƒO NO PASSADO (BACKTEST) - MODO PADRÃƒO / ANÃLISE PREMIUM (SEM SPOILER)
//  - Reusa o banco de padrÃµes (verifyWithSavedPatterns)
//  - NÃ£o olha futuro: cria sinal no giro i para avaliar no giro i+1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const STANDARD_SIMULATION_BATCH = 25;
const STANDARD_OPTIMIZATION_TRIALS_DEFAULT = 100;
const STANDARD_OPTIMIZATION_PROGRESS_EVERY = 1;
const STANDARD_OPTIMIZATION_MIN_PCT_DEFAULT = 95;

const standardSimulationJobs = new Map(); // jobId -> { cancelled: boolean }
const standardOptimizationJobs = new Map(); // jobId -> { cancelled: boolean }

function makeStandardSimulationJobId() {
    return `std-sim-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function makeStandardOptimizationJobId() {
    return `std-opt-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

async function withTempAnalyzerConfig(tempConfig, fn) {
    const prev = deepClonePlain(analyzerConfig);
    try {
        const merged = { ...prev, ...(tempConfig && typeof tempConfig === 'object' ? deepClonePlain(tempConfig) : {}) };
        merged.aiMode = false; // forÃ§ar modo padrÃ£o durante simulaÃ§Ã£o/otimizaÃ§Ã£o premium
        analyzerConfig = merged;
        return await fn();
    } finally {
        analyzerConfig = prev;
    }
}

function normalizeStandardConfigForSimulation(cfg) {
    const c = cfg && typeof cfg === 'object' ? deepClonePlain(cfg) : {};
    c.aiMode = false;
    ensureMartingaleProfiles(c);
    return c;
}

async function maybeGenerateStandardAnalysisSimulation(history, simState, patternDB) {
    const config = simState.config || {};
    const { consecutiveGales } = getMartingaleSettings('standard', config);

    // se anÃ¡lise pendente, nÃ£o gerar outra
    if (simState.analysis && simState.analysis.createdOnTimestamp && simState.analysis.predictedFor === 'next') {
        const latestTs = history[0]?.timestamp;
        if (latestTs && simState.analysis.createdOnTimestamp !== latestTs) {
            return;
        }
    }

    // se estamos em gale consecutivo, nÃ£o buscar novo padrÃ£o (mantÃ©m ciclo)
    if (simState.martingaleState.active && isMartingaleStageConsecutive(simState.martingaleState.stage, consecutiveGales)) return;

    const verifyResult = await verifyWithSavedPatterns(history, patternDB);
    if (!verifyResult) return;

    let analysis = { ...verifyResult };
    analysis.predictedFor = 'next';
    analysis.createdOnTimestamp = history[0]?.timestamp;
    if (!analysis.phase) analysis.phase = 'G0';

    if (simState.martingaleState && simState.martingaleState.active) {
        analysis.phase = simState.martingaleState.stage;
        if (simState.martingaleState.entryColor && isMartingaleStageConsecutive(simState.martingaleState.stage, consecutiveGales)) {
            analysis.color = simState.martingaleState.entryColor;
        }
        analysis.confidence = calculateGaleConfidenceValue(analysis.confidence, analysis, simState.martingaleState);
    }

    simState.analysis = analysis;
    simState.lastSignalSpinNumber = history[0]?.number ?? null;
    simState.lastSignalSpinId = history[0]?.id ?? null;
    simState.lastSignalSpinTimestamp = history[0]?.timestamp ?? null;

    const signal = {
        timestamp: history[0]?.timestamp ? new Date(history[0].timestamp).getTime() : Date.now(),
        patternType: analysis.patternType || 'premium',
        patternName: analysis.patternDescription || 'SimulaÃ§Ã£o Premium',
        colorRecommended: analysis.color,
        verified: false,
        colorThatCame: null,
        hit: null
    };
    if (simState.signalsHistory && Array.isArray(simState.signalsHistory.signals)) {
        simState.signalsHistory.signals.push(signal);
        if (simState.signalsHistory.signals.length > 200) {
            simState.signalsHistory.signals = simState.signalsHistory.signals.slice(-200);
        }
    }
    simState.totalSignals++;
}

async function runStandardPastSimulation({ config, senderTabId, jobId, historyLimit }) {
    const job = standardSimulationJobs.get(jobId);
    const requestedLimit = Number(historyLimit);
    const safeDefault = 1440;
    const availableHistory = Array.isArray(cachedHistory) ? cachedHistory.length : 0;
    const limit = (Number.isFinite(requestedLimit) && requestedLimit > 0)
        ? Math.min(requestedLimit, 10000, availableHistory || requestedLimit)
        : Math.min(safeDefault, availableHistory || safeDefault);

    const stableWindow = getStableChronologicalHistoryWindow({ limit, sourceHistory: Array.isArray(cachedHistory) ? cachedHistory : [] });
    const chronological = stableWindow.chronological;
    const totalSpins = chronological.length;
    const fromTimestamp = chronological[0]?.timestamp || null;
    const toTimestamp = chronological[totalSpins - 1]?.timestamp || null;

    const simConfig = normalizeStandardConfigForSimulation(config);
    const simState = createDiamondSimulationState(simConfig);
    const simHistory = [];

    const patternDB = await loadPatternDB();

    return await withTempAnalyzerConfig(simConfig, async () => {
        for (let i = 0; i < totalSpins; i++) {
            if (job && job.cancelled) {
                if (senderTabId != null) {
                    try { chrome.tabs.sendMessage(senderTabId, { type: 'STANDARD_SIMULATION_CANCELLED', data: { jobId } }); } catch (_) {}
                }
                return {
                    cancelled: true,
                    fromTimestamp,
                    toTimestamp,
                    totalSpins,
                    requestedLimit,
                    usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
                    availableHistory: stableWindow.meta.availableHistory,
                    uniqueHistory: stableWindow.meta.uniqueCount,
                    droppedDuplicates: stableWindow.meta.droppedDuplicates,
                    droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
                    simState
                };
            }

            const spin = chronological[i];
            simHistory.unshift(spin);
            if (simHistory.length > limit) simHistory.pop();

            // 1) avaliar anÃ¡lise pendente no giro atual
            evaluatePendingAnalysisSimulation(spin, simState, 'standard');

            // 2) gerar sinal para o prÃ³ximo giro (sem ver o futuro)
            if (i < totalSpins - 1) {
                await maybeGenerateStandardAnalysisSimulation(simHistory, simState, patternDB);
            }

            if (i % STANDARD_SIMULATION_BATCH === 0 || i === totalSpins - 1) {
                try {
                    try {
                        chrome.runtime.sendMessage({
                            type: 'STANDARD_SIMULATION_PROGRESS',
                            data: { jobId, processed: i + 1, total: totalSpins }
                        });
                    } catch (_) {}
                } catch (_) {}
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        return {
            cancelled: false,
            fromTimestamp,
            toTimestamp,
            totalSpins,
            requestedLimit,
            usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
            availableHistory: stableWindow.meta.availableHistory,
            uniqueHistory: stableWindow.meta.uniqueCount,
            droppedDuplicates: stableWindow.meta.droppedDuplicates,
            droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
            simState
        };
    });
}

function buildStandardOptimizationCandidateConfig(baseConfig, rng) {
    const cfg = normalizeStandardConfigForSimulation(baseConfig);
    // variar em torno do valor atual (faixas seguras)
    const baseDepth = clampInt(cfg.historyDepth ?? 500, 100, 2000);
    const baseMinOcc = clampInt(cfg.minOccurrences ?? 2, 1, 20);
    const baseMaxOcc = clampInt(cfg.maxOccurrences ?? 0, 0, 60);
    const baseInterval = clampInt(cfg.minIntervalSpins ?? 0, 0, 30);
    const baseMinSize = clampInt(cfg.minPatternSize ?? 3, 2, 20);
    const baseMaxSize = clampInt(cfg.maxPatternSize ?? 0, 0, 30);
    const baseWinPct = clampInt(cfg.winPercentOthers ?? 100, 0, 100);
    const baseReqTrig = cfg.requireTrigger !== undefined ? !!cfg.requireTrigger : true;

    const depth = clampInt(randomInt(rng, Math.max(100, Math.floor(baseDepth * 0.6)), Math.min(2000, Math.ceil(baseDepth * 1.4))), 100, 2000);
    const minOcc = clampInt(randomInt(rng, Math.max(1, baseMinOcc - 2), Math.min(20, baseMinOcc + 4)), 1, 20);
    const maxOccChoices = [0, clampInt(randomInt(rng, minOcc, Math.min(60, Math.max(minOcc, baseMaxOcc || 20))), minOcc, 60)];
    const maxOcc = maxOccChoices[Math.floor(rng() * maxOccChoices.length)];
    const interval = clampInt(randomInt(rng, Math.max(0, baseInterval - 3), Math.min(30, baseInterval + 6)), 0, 30);
    const minSize = clampInt(randomInt(rng, Math.max(2, baseMinSize - 1), Math.min(20, baseMinSize + 4)), 2, 20);
    const maxSizeChoices = [0, clampInt(randomInt(rng, minSize, Math.min(30, Math.max(minSize, baseMaxSize || 12))), minSize, 30)];
    const maxSize = maxSizeChoices[Math.floor(rng() * maxSizeChoices.length)];
    const winPct = clampInt(randomInt(rng, Math.max(0, baseWinPct - 25), Math.min(100, baseWinPct + 10)), 0, 100);
    const reqTrig = rng() < 0.25 ? !baseReqTrig : baseReqTrig;

    cfg.historyDepth = depth;
    cfg.minOccurrences = minOcc;
    cfg.maxOccurrences = maxOcc;
    cfg.minIntervalSpins = interval;
    cfg.minPatternSize = minSize;
    cfg.maxPatternSize = maxSize;
    cfg.winPercentOthers = winPct;
    cfg.requireTrigger = reqTrig;

    return cfg;
}

async function runStandardPastOptimization({ config, senderTabId, jobId, historyLimit, trials }) {
    const job = standardOptimizationJobs.get(jobId);
    const requestedLimit = Number(historyLimit);
    const safeDefault = 1440;
    const availableHistory = Array.isArray(cachedHistory) ? cachedHistory.length : 0;
    const limit = (Number.isFinite(requestedLimit) && requestedLimit > 0)
        ? Math.min(requestedLimit, 10000, availableHistory || requestedLimit)
        : Math.min(safeDefault, availableHistory || safeDefault);

    const stableWindow = getStableChronologicalHistoryWindow({ limit, sourceHistory: Array.isArray(cachedHistory) ? cachedHistory : [] });
    const chronological = stableWindow.chronological;
    const totalSpins = chronological.length;
    const fromTimestamp = chronological[0]?.timestamp || null;
    const toTimestamp = chronological[totalSpins - 1]?.timestamp || null;

    const totalTrials = clampInt(trials || STANDARD_OPTIMIZATION_TRIALS_DEFAULT, 1, 1000);
    const minPct = STANDARD_OPTIMIZATION_MIN_PCT_DEFAULT;
    const baseConfig = normalizeStandardConfigForSimulation(config);

    // Seed determinÃ­stico: mesma config + mesma janela => mesmos 100 testes
    const seedPayload = JSON.stringify({
        usedHistoryLimit: limit,
        fromTimestamp,
        toTimestamp,
        standard: {
            historyDepth: baseConfig.historyDepth,
            minOccurrences: baseConfig.minOccurrences,
            maxOccurrences: baseConfig.maxOccurrences,
            minIntervalSpins: baseConfig.minIntervalSpins,
            minPatternSize: baseConfig.minPatternSize,
            maxPatternSize: baseConfig.maxPatternSize,
            winPercentOthers: baseConfig.winPercentOthers,
            requireTrigger: baseConfig.requireTrigger
        }
    });
    const seed = hashStringToSeed(seedPayload);
    const rng = makeMulberry32(seed);

    const patternDB = await loadPatternDB();

    let bestOverall = null;
    let bestEligible = null;
    const seen = new Set();

    const simulateCandidate = async (candidateCfg) => {
        const simState = createDiamondSimulationState(candidateCfg);
        const simHistory = [];
        for (let i = 0; i < totalSpins; i++) {
            const spin = chronological[i];
            simHistory.unshift(spin);
            if (simHistory.length > limit) simHistory.pop();
            evaluatePendingAnalysisSimulation(spin, simState, 'standard');
            if (i < totalSpins - 1) {
                await maybeGenerateStandardAnalysisSimulation(simHistory, simState, patternDB);
            }
        }
        const entries = simState.entriesHistory || [];
        const filtered = filterFinalEntries(entries);
        const wins = filtered.filter(e => e.result === 'WIN').length;
        const totalCycles = filtered.length;
        const losses = totalCycles - wins;
        const pct = totalCycles ? (wins / totalCycles) * 100 : 0;
        const score = scoreOptimizationCandidate(pct, totalCycles);
        return { pct: Number(pct.toFixed(1)), wins, losses, totalCycles, totalSignals: simState.totalSignals || 0, score, entries, config: candidateCfg };
    };

    for (let t = 0; t < totalTrials; t++) {
        if (job && job.cancelled) {
            if (senderTabId != null) {
                try { chrome.tabs.sendMessage(senderTabId, { type: 'STANDARD_OPTIMIZATION_CANCELLED', data: { jobId } }); } catch (_) {}
            }
            return {
                cancelled: true,
                jobId,
                totalTrials,
                fromTimestamp,
                toTimestamp,
                totalSpins,
                requestedLimit,
                usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
                availableHistory: stableWindow.meta.availableHistory,
                uniqueHistory: stableWindow.meta.uniqueCount,
                droppedDuplicates: stableWindow.meta.droppedDuplicates,
                droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
                bestEligible: null,
                bestOverall: null
            };
        }

        let candidateCfg = null;
        let sig = '';
        for (let tries = 0; tries < 30; tries++) {
            candidateCfg = buildStandardOptimizationCandidateConfig(baseConfig, rng);
            sig = `D${candidateCfg.historyDepth}|minOcc${candidateCfg.minOccurrences}|maxOcc${candidateCfg.maxOccurrences}|int${candidateCfg.minIntervalSpins}|minS${candidateCfg.minPatternSize}|maxS${candidateCfg.maxPatternSize}|win${candidateCfg.winPercentOthers}|trig${candidateCfg.requireTrigger ? 1 : 0}`;
            if (!seen.has(sig)) break;
        }
        if (!candidateCfg) continue;
        seen.add(sig);

        const result = await withTempAnalyzerConfig(candidateCfg, async () => simulateCandidate(candidateCfg));

        if (!bestOverall || result.score > bestOverall.score) {
            bestOverall = result;
        }
        if (result.pct >= minPct && (!bestEligible || result.score > bestEligible.score)) {
            bestEligible = result;
        }

        if ((t % STANDARD_OPTIMIZATION_PROGRESS_EVERY) === 0 || t === totalTrials - 1) {
            try {
                chrome.runtime.sendMessage({
                    type: 'STANDARD_OPTIMIZATION_PROGRESS',
                    data: {
                        jobId,
                        trial: t + 1,
                        totalTrials,
                        minPct,
                        recommendedFound: !!bestEligible,
                        best: (bestEligible || bestOverall) ? {
                            pct: (bestEligible || bestOverall).pct,
                            totalCycles: (bestEligible || bestOverall).totalCycles
                        } : null
                    }
                });
            } catch (_) {}
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    return {
        cancelled: false,
        jobId,
        totalTrials,
        minPct,
        fromTimestamp,
        toTimestamp,
        totalSpins,
        requestedLimit,
        usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
        availableHistory: stableWindow.meta.availableHistory,
        uniqueHistory: stableWindow.meta.uniqueCount,
        droppedDuplicates: stableWindow.meta.droppedDuplicates,
        droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
        bestEligible,
        bestOverall
    };
}

function makeDiamondOptimizationJobId() {
    return `diamond-opt-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function deepClonePlain(obj) {
    try {
        return obj ? JSON.parse(JSON.stringify(obj)) : {};
    } catch (_) {
        return obj ? { ...obj } : {};
    }
}

function makeMulberry32(seed) {
    let a = (Number(seed) || 0) >>> 0;
    return function rng() {
        a |= 0;
        a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
}

function hashStringToSeed(str) {
    const s = String(str || '');
    let h = 2166136261 >>> 0;
    for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
    }
    return h >>> 0;
}

function parseSpinTimestamp(spin) {
    if (!spin) return NaN;
    const raw = spin.timestamp ?? spin.created_at ?? spin.createdAt ?? spin.time ?? null;
    if (raw == null) return NaN;
    if (typeof raw === 'number') return raw;
    const n = Number(raw);
    if (Number.isFinite(n)) return n;
    const t = Date.parse(String(raw));
    return Number.isFinite(t) ? t : NaN;
}

function getSpinDedupKey(spin) {
    if (!spin) return null;
    if (spin.id != null) return `id:${String(spin.id)}`;
    const ts = parseSpinTimestamp(spin);
    const num = spin.number != null ? String(spin.number) : '';
    const col = spin.color != null ? String(spin.color) : '';
    if (Number.isFinite(ts)) return `ts:${ts}|n:${num}|c:${col}`;
    return null;
}

function getStableChronologicalHistoryWindow({ limit, sourceHistory }) {
    const raw = Array.isArray(sourceHistory) ? sourceHistory : [];
    const availableHistory = raw.length;
    const take = Math.max(0, Math.min(Number(limit) || 0, availableHistory));

    // Snapshot em memÃ³ria + dedup + filtro timestamp
    const seen = new Set();
    const unique = [];
    let droppedDuplicates = 0;
    let droppedInvalidTs = 0;

    // raw costuma vir most-recent-first; mas pode ter duplicados / fora de ordem
    for (let i = 0; i < raw.length; i++) {
        const spin = raw[i];
        if (!spin || !spin.color) continue;
        const ts = parseSpinTimestamp(spin);
        if (!Number.isFinite(ts)) {
            droppedInvalidTs++;
            continue;
        }
        const key = getSpinDedupKey(spin);
        if (key && seen.has(key)) {
            droppedDuplicates++;
            continue;
        }
        if (key) seen.add(key);
        unique.push({
            ...spin,
            timestamp: spin.timestamp ?? ts // garantir campo timestamp utilizÃ¡vel
        });
    }

    unique.sort((a, b) => parseSpinTimestamp(a) - parseSpinTimestamp(b)); // antigo -> recente
    const windowChron = take > 0 ? unique.slice(Math.max(0, unique.length - take)) : [];

    return {
        chronological: windowChron,
        meta: {
            availableHistory,
            uniqueCount: unique.length,
            droppedDuplicates,
            droppedInvalidTs,
            usedHistoryLimit: take
        }
    };
}

function clampInt(n, min, max) {
    const v = Math.floor(Number(n));
    if (!Number.isFinite(v)) return min;
    return Math.max(min, Math.min(max, v));
}

function randomInt(rng, min, max) {
    const a = Math.ceil(min);
    const b = Math.floor(max);
    if (b <= a) return a;
    return a + Math.floor(rng() * (b - a + 1));
}

function scoreOptimizationCandidate(pct, totalCycles) {
    const p = Number(pct) || 0;
    const n = Math.max(0, Number(totalCycles) || 0);
    // Combina assertividade com "cobertura" (evita 100% com 1 ciclo vencer 90% com 100 ciclos)
    return p * Math.log10(n + 1);
}

function buildDiamondOptimizationCandidateConfig(baseConfig, levelId, rng) {
    const cfg = deepClonePlain(baseConfig || {});
    cfg.aiMode = true;
    ensureMartingaleProfiles(cfg);
    cfg.diamondLevelEnabled = buildDiamondSingleLevelEnabledMap(levelId, cfg.diamondLevelEnabled || {});

    const windows = cfg.diamondLevelWindows && typeof cfg.diamondLevelWindows === 'object'
        ? { ...cfg.diamondLevelWindows }
        : {};

    // âœ… IMPORTANTE: nunca variar campos de OUTROS nÃ­veis.
    // O otimizador por nÃ­vel deve mexer SOMENTE nos parÃ¢metros daquele nÃ­vel.
    const upper = String(levelId || '').toUpperCase();
    if (upper === 'N1') {
        const baseW = Number(windows.n1WindowSize ?? SAFE_ZONE_DEFAULTS.windowSize) || SAFE_ZONE_DEFAULTS.windowSize;
        const baseA = Number(windows.n1PrimaryRequirement ?? SAFE_ZONE_DEFAULTS.primaryRequirement) || SAFE_ZONE_DEFAULTS.primaryRequirement;
        const baseB = Number(windows.n1SecondaryRequirement ?? SAFE_ZONE_DEFAULTS.secondaryRequirement) || SAFE_ZONE_DEFAULTS.secondaryRequirement;
        const baseMaxE = Number(windows.n1MaxEntries ?? SAFE_ZONE_DEFAULTS.maxEntries) || SAFE_ZONE_DEFAULTS.maxEntries;

        // variar em torno do valor atual (Â±50%), respeitando limites
        const w = randomInt(rng, Math.max(5, Math.floor(baseW * 0.5)), Math.min(200, Math.ceil(baseW * 1.5)));
        const aMax = Math.max(1, w - 1);
        const a = randomInt(rng, Math.max(1, Math.floor(baseA * 0.5)), Math.min(aMax, Math.ceil(baseA * 1.5)));
        const bMax = Math.max(1, a - 1);
        const b = randomInt(rng, 1, Math.min(bMax, Math.max(1, Math.ceil(baseB * 1.5))));
        const maxE = randomInt(rng, Math.max(1, Math.floor(baseMaxE * 0.5)), Math.min(20, Math.ceil(baseMaxE * 1.5)));

        windows.n1WindowSize = clampInt(w, 5, 200);
        windows.n1PrimaryRequirement = clampInt(a, 1, windows.n1WindowSize - 1);
        windows.n1SecondaryRequirement = clampInt(b, 1, windows.n1PrimaryRequirement - 1);
        windows.n1MaxEntries = clampInt(maxE, 1, 20);
    } else if (upper === 'N2') {
        // N2 - Ritmo AutÃ´nomo (W Ãºnico)
        const baseW = clampInt(windows.n2Recent ?? 10, 6, 200);
        const w = clampInt(
            randomInt(rng, Math.max(6, Math.floor(baseW * 0.5)), Math.min(200, Math.ceil(baseW * 1.6))),
            6,
            200
        );
        windows.n2Recent = w;
        windows.n2Previous = w; // legado: espelha W por compatibilidade
    } else if (upper === 'N3') {
        // N3 - AlternÃ¢ncia
        const baseHist = clampInt(windows.n3Alternance ?? 60, 4, 400);
        const baseThreshPct = clampInt(windows.n3ThresholdPct ?? 75, 50, 95);
        const baseMinOcc = clampInt(windows.n3MinOccurrences ?? 1, 1, 50);
        const baseAllowBackoff = windows.n3AllowBackoff !== undefined ? !!windows.n3AllowBackoff : false;
        const baseIgnoreWhite = windows.n3IgnoreWhite !== undefined ? !!windows.n3IgnoreWhite : false;

        const hist = clampInt(
            randomInt(rng, Math.max(4, Math.floor(baseHist * 0.5)), Math.min(400, Math.ceil(baseHist * 1.5))),
            4,
            400
        );
        const threshPct = clampInt(
            randomInt(rng, Math.max(50, baseThreshPct - 18), Math.min(95, baseThreshPct + 12)),
            50,
            95
        );
        const minOcc = clampInt(
            randomInt(rng, 1, Math.min(50, Math.max(1, baseMinOcc + 4))),
            1,
            50
        );
        const allowBackoff = rng() < 0.35 ? !baseAllowBackoff : baseAllowBackoff;
        // Branco quebra alternÃ¢ncia; esse toggle Ã© compatibilidade/UX â€” manter, mas variar pouco
        const ignoreWhite = rng() < 0.15 ? !baseIgnoreWhite : baseIgnoreWhite;

        windows.n3Alternance = hist;
        windows.n3ThresholdPct = threshPct;
        windows.n3MinOccurrences = minOcc;
        windows.n3AllowBackoff = allowBackoff;
        windows.n3IgnoreWhite = ignoreWhite;
    } else if (upper === 'N4') {
        // N4 - PersistÃªncia (ciclo/janela)
        const baseW = clampInt(windows.n4Persistence ?? 20, 10, 120);
        const w = clampInt(
            randomInt(rng, Math.max(10, Math.floor(baseW * 0.5)), Math.min(120, Math.ceil(baseW * 1.6))),
            10,
            120
        );
        windows.n4Persistence = w;
    } else {
        // Outros nÃ­veis: nÃ£o alterar nada por enquanto (evita bagunÃ§ar configuraÃ§Ãµes do usuÃ¡rio).
    }

    cfg.diamondLevelWindows = windows;
    return cfg;
}

async function runDiamondPastOptimization({ config, levelId, senderTabId, jobId, historyLimit, trials }) {
    const job = diamondOptimizationJobs.get(jobId);
    const requestedLimit = Number(historyLimit);
    const safeDefault = 1440;
    const availableHistory = Array.isArray(cachedHistory) ? cachedHistory.length : 0;
    const limit = (Number.isFinite(requestedLimit) && requestedLimit > 0)
        ? Math.min(requestedLimit, 10000, availableHistory || requestedLimit)
        : Math.min(safeDefault, availableHistory || safeDefault);

    const stableWindow = getStableChronologicalHistoryWindow({ limit, sourceHistory: Array.isArray(cachedHistory) ? cachedHistory : [] });
    const chronological = stableWindow.chronological;
    const totalSpins = chronological.length;
    const fromTimestamp = chronological[0]?.timestamp || null;
    const toTimestamp = chronological[totalSpins - 1]?.timestamp || null;

    const totalTrials = clampInt(trials || DIAMOND_OPTIMIZATION_TRIALS_DEFAULT, 1, 1000);
    const minPct = DIAMOND_OPTIMIZATION_MIN_PCT_DEFAULT;
    const baseConfig = (config && typeof config === 'object') ? deepClonePlain(config) : {};
    baseConfig.aiMode = true;
    ensureMartingaleProfiles(baseConfig);

    // âœ… Seed determinÃ­stico: mesma config + mesma janela => mesmos 100 testes (sem "aleatoriedade do nada")
    const seedPayload = JSON.stringify({
        levelId: String(levelId || '').toUpperCase(),
        usedHistoryLimit: limit,
        fromTimestamp,
        toTimestamp,
        windows: baseConfig.diamondLevelWindows || {},
        enabled: baseConfig.diamondLevelEnabled || {}
    });
    const seed = hashStringToSeed(seedPayload);
    const rng = makeMulberry32(seed);

    let bestOverall = null; // melhor "geral" (para referÃªncia)
    let bestEligible = null; // melhor >= minPct (para recomendaÃ§Ã£o)
    const seen = new Set();

    for (let t = 0; t < totalTrials; t++) {
        if (job && job.cancelled) {
            if (senderTabId != null) {
                try { chrome.tabs.sendMessage(senderTabId, { type: 'DIAMOND_OPTIMIZATION_CANCELLED', data: { jobId } }); } catch (_) {}
            }
            return {
                cancelled: true,
                jobId,
                totalTrials,
                fromTimestamp,
                toTimestamp,
                totalSpins,
                requestedLimit,
                usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
                availableHistory: stableWindow.meta.availableHistory,
                uniqueHistory: stableWindow.meta.uniqueCount,
                droppedDuplicates: stableWindow.meta.droppedDuplicates,
                droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
                bestEligible: null,
                bestOverall: null
            };
        }

        // gerar config candidata (garantir "diferentes" pelo menos por assinatura)
        let candidateCfg = null;
        let sig = '';
        for (let tries = 0; tries < 30; tries++) {
            candidateCfg = buildDiamondOptimizationCandidateConfig(baseConfig, levelId, rng);
            const dw = candidateCfg.diamondLevelWindows || {};
            if (String(levelId || '').toUpperCase() === 'N1') {
                sig = `W${dw.n1WindowSize}|A${dw.n1PrimaryRequirement}|B${dw.n1SecondaryRequirement}|E${dw.n1MaxEntries}`;
            } else {
                sig = JSON.stringify(dw);
            }
            if (!seen.has(sig)) break;
            candidateCfg = null;
        }
        if (!candidateCfg) {
            // fallback: aceitar mesmo se repetiu
            candidateCfg = buildDiamondOptimizationCandidateConfig(baseConfig, levelId, rng);
        } else {
            seen.add(sig);
        }

        // rodar simulaÃ§Ã£o walk-forward (sem vazamento)
        const simState = createDiamondSimulationState(candidateCfg);
        const simHistory = [];
        for (let i = 0; i < totalSpins; i++) {
            const spin = chronological[i];
            simHistory.unshift(spin);
            if (simHistory.length > limit) simHistory.pop();

            evaluatePendingAnalysisSimulation(spin, simState, 'diamond');
            if (i < totalSpins - 1) {
                maybeGenerateDiamondAnalysisSimulation(simHistory, simState);
            }
        }

        const entries = simState.entriesHistory || [];
        const filtered = filterFinalEntries(entries);
        const wins = filtered.filter(e => e && e.result === 'WIN').length;
        const totalCycles = filtered.length;
        const losses = totalCycles - wins;
        const pct = totalCycles ? ((wins / totalCycles) * 100) : 0;
        const score = scoreOptimizationCandidate(pct, totalCycles);
        const totalSignals = simState.totalSignals || 0;

        const candidate = {
            score,
            pct: Number(pct.toFixed(2)),
            wins,
            losses,
            totalCycles,
            totalSignals,
            config: candidateCfg,
            entries,
            meta: { totalSpins, fromTimestamp, toTimestamp }
        };

        const isBetterOverall = !bestOverall
            || candidate.score > bestOverall.score
            || (candidate.score === bestOverall.score && candidate.pct > bestOverall.pct)
            || (candidate.score === bestOverall.score && candidate.pct === bestOverall.pct && candidate.totalCycles > bestOverall.totalCycles);

        if (isBetterOverall) bestOverall = candidate;

        const isEligible = candidate.totalCycles > 0 && candidate.pct >= minPct;
        if (isEligible) {
            const isBetterEligible = !bestEligible
                || candidate.score > bestEligible.score
                || (candidate.score === bestEligible.score && candidate.pct > bestEligible.pct)
                || (candidate.score === bestEligible.score && candidate.pct === bestEligible.pct && candidate.totalCycles > bestEligible.totalCycles);
            if (isBetterEligible) bestEligible = candidate;
        }

        if (t % DIAMOND_OPTIMIZATION_PROGRESS_EVERY === 0 || t === totalTrials - 1) {
            try {
                const pick = bestEligible || bestOverall;
                const dw = (pick && pick.config && pick.config.diamondLevelWindows) ? pick.config.diamondLevelWindows : {};
                const upper = String(levelId || '').toUpperCase();
                const summary = upper === 'N1'
                    ? `W ${dw.n1WindowSize} | minA ${dw.n1PrimaryRequirement} | minB ${dw.n1SecondaryRequirement} | maxE ${dw.n1MaxEntries}`
                    : upper === 'N2'
                    ? `W ${dw.n2Recent}`
                    : upper === 'N3'
                    ? `Hist ${dw.n3Alternance} | Rigor ${dw.n3ThresholdPct}% | minOcc ${dw.n3MinOccurrences}`
                    : upper === 'N4'
                    ? `${dw.n4Persistence} giros`
                    : 'â€”';

                // âœ… Enviar via runtime (nÃ£o depende de tabId). Quem nÃ£o for o job atual ignora pelo jobId.
                try {
                    chrome.runtime.sendMessage({
                        type: 'DIAMOND_OPTIMIZATION_PROGRESS',
                        data: {
                            jobId,
                            levelId: upper,
                            trial: t + 1,
                            totalTrials,
                            minPct,
                            recommendedFound: !!bestEligible,
                            best: pick ? {
                                pct: pick.pct,
                                totalCycles: pick.totalCycles,
                                totalSignals: pick.totalSignals,
                                score: Number(pick.score.toFixed(2)),
                                summary
                            } : null
                        }
                    });
                } catch (_) {}
            } catch (_) {}
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    return {
        cancelled: false,
        jobId,
        totalTrials,
        fromTimestamp,
        toTimestamp,
        totalSpins,
        requestedLimit,
        usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
        availableHistory: stableWindow.meta.availableHistory,
        uniqueHistory: stableWindow.meta.uniqueCount,
        droppedDuplicates: stableWindow.meta.droppedDuplicates,
        droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
        minPct,
        bestEligible,
        bestOverall
    };
}
const diamondSimulationJobs = new Map();

function makeDiamondSimulationJobId() {
    return `diamond-sim-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function getDiamondWindowFromConfig(config, key, fallback) {
    const windows = config && config.diamondLevelWindows ? config.diamondLevelWindows : {};
    const rawValue = windows ? Number(windows[key]) : NaN;
    if (Number.isFinite(rawValue) && rawValue > 0) {
        return rawValue;
    }
    const legacyKeyMap = {
        n6RetracementWindow: 'n8RetracementWindow',
        n7DecisionWindow: 'n10DecisionWindow',
        n7HistoryWindow: 'n10HistoryWindow',
        n8Barrier: 'n6Barrier',
        n0History: 'n0TotalHistory',
        n0Window: 'n0WindowSize'
    };
    const legacyKey = legacyKeyMap[key];
    if (legacyKey && Number.isFinite(Number(windows[legacyKey])) && Number(windows[legacyKey]) > 0) {
        return Number(windows[legacyKey]);
    }
    if (key === 'n5MinuteBias' && Number.isFinite(Number(config && config.minuteSpinWindow))) {
        const legacy = Number(config.minuteSpinWindow);
        if (legacy > 0) return legacy;
    }
    return fallback;
}

function getDiamondBooleanFromConfig(config, key, fallback = false) {
    const windows = config && config.diamondLevelWindows ? config.diamondLevelWindows : {};
    if (!windows || !Object.prototype.hasOwnProperty.call(windows, key)) {
        return fallback;
    }
    const raw = windows[key];
    if (typeof raw === 'boolean') return raw;
    if (typeof raw === 'string') {
        const lowered = raw.trim().toLowerCase();
        if (lowered === 'true') return true;
        if (lowered === 'false') return false;
        const numeric = Number(raw);
        if (!Number.isNaN(numeric)) return numeric > 0;
        return fallback;
    }
    if (typeof raw === 'number') {
        if (!Number.isNaN(raw)) return raw > 0;
    }
    return fallback;
}

function getSafeZoneSettingsFromConfig(config) {
    const windows = config?.diamondLevelWindows || {};
    let windowSize = Number(windows.n1WindowSize) || SAFE_ZONE_DEFAULTS.windowSize;
    let minPrimary = Number(windows.n1PrimaryRequirement) || SAFE_ZONE_DEFAULTS.primaryRequirement;
    let minSecondary = Number(windows.n1SecondaryRequirement) || SAFE_ZONE_DEFAULTS.secondaryRequirement;
    let maxEntries = Number(windows.n1MaxEntries) || SAFE_ZONE_DEFAULTS.maxEntries;

    windowSize = Math.max(5, Math.min(200, windowSize));
    minPrimary = Math.max(1, Math.min(windowSize - 1, minPrimary));
    minSecondary = Math.max(1, Math.min(minPrimary - 1, minSecondary));
    maxEntries = Math.max(1, Math.min(20, Math.floor(maxEntries)));

    return { windowSize, minPrimary, minSecondary, maxEntries };
}

function getN0SettingsFromConfig(config) {
    const windows = config && config.diamondLevelWindows ? config.diamondLevelWindows : {};
    const historySizeRaw = Number(windows.n0History);
    const windowSizeRaw = Number(windows.n0Window);
    const historySize = Number.isFinite(historySizeRaw) && historySizeRaw > 0 ? Math.floor(historySizeRaw) : N0_DEFAULTS.historySize;
    const windowSize = Number.isFinite(windowSizeRaw) && windowSizeRaw > 0 ? Math.floor(windowSizeRaw) : N0_DEFAULTS.windowSize;
    return {
        historySize: Math.max(200, Math.min(5000, historySize)),
        windowSize: Math.max(25, Math.min(250, windowSize)),
        allowBlockAll: config && config.n0AllowBlockAll !== false
    };
}

function analyzeMomentumFromConfig(history, config) {
    // âœ… NOVO N2: janela base Ãºnica W (usuÃ¡rio) + ajuste automÃ¡tico
    const baseW = Math.max(6, Math.min(200, getDiamondWindowFromConfig(config, 'n2Recent', 10)));
    return analyzeMomentumWithSizes(history, baseW, 0);
}

function buildDiamondSingleLevelEnabledMap(levelId, baseEnabledMap = null) {
    const allKeys = Object.keys(DEFAULT_ANALYZER_CONFIG.diamondLevelEnabled || {});
    const enabled = {};
    allKeys.forEach(k => { enabled[k] = false; });
    const key = getDiamondLevelKeyFromId(levelId);
    if (key) enabled[key] = true;

    // âœ… Garantir que a Barreira N9 continue respeitada quando o usuÃ¡rio estiver
    // simulando "apenas um nÃ­vel" (N9 Ã© validador/veto, nÃ£o Ã© voto).
    // Se o usuÃ¡rio manteve N9 ativo na configuraÃ§Ã£o base, preservamos n9 aqui.
    if (baseEnabledMap && typeof baseEnabledMap === 'object') {
        if (baseEnabledMap.n9 === true) {
            enabled.n9 = true;
        }
    }
    return enabled;
}

function computeIntervalBlockForSimulation(history, config, simState) {
    const minIntervalSpins = (config?.minSignalIntervalSpins ?? config?.minIntervalSpins) || 0;
    if (!config?.aiMode || minIntervalSpins <= 0) {
        return { blocked: false, message: '' };
    }

    // âœ… Intervalo apÃ³s entrada (Diamante): contar a partir do FIM DO CICLO (WIN/RET) na simulaÃ§Ã£o.
    const lastCycleResolvedSpinId = simState?.lastCycleResolvedSpinId || null;
    const lastCycleResolvedSpinTimestamp = simState?.lastCycleResolvedSpinTimestamp || null;
    // fallback legado:
    const lastSignalSpinId = simState?.lastSignalSpinId || null;
    const lastSignalSpinTimestamp = simState?.lastSignalSpinTimestamp || null;

    const refId = lastCycleResolvedSpinId || lastSignalSpinId;
    const refTs = lastCycleResolvedSpinTimestamp || lastSignalSpinTimestamp;

    let spinsSince = null;
    if (Array.isArray(history) && history.length > 0) {
        if (refId) {
            const idx = history.findIndex(spin => spin && spin.id === refId);
            spinsSince = idx >= 0 ? idx : history.length;
        } else if (refTs) {
            const referenceTime = new Date(refTs).getTime();
            if (!Number.isNaN(referenceTime)) {
                for (let i = 0; i < history.length; i++) {
                    const spinTime = history[i]?.timestamp ? new Date(history[i].timestamp).getTime() : NaN;
                    if (!Number.isNaN(spinTime) && spinTime <= referenceTime) {
                        spinsSince = i;
                        break;
                    }
                }
                if (spinsSince === null) spinsSince = history.length;
            }
        }
    }

    if (spinsSince === null) {
        return { blocked: false, message: '' };
    }
    if (spinsSince >= minIntervalSpins) {
        return { blocked: false, message: '' };
    }
    const remaining = minIntervalSpins - spinsSince;
    return {
        blocked: true,
        message: `â³ Aguardando ${remaining} giro(s)... ${spinsSince}/${minIntervalSpins}`
    };
}

function createDiamondSimulationState(config) {
    return {
        config,
        analysis: null,
        entriesHistory: [],
        lastSignalSpinId: null,
        lastSignalSpinNumber: null,
        lastSignalSpinTimestamp: null,
        lastCycleResolvedSpinId: null,
        lastCycleResolvedSpinTimestamp: null,
        signalsHistory: { signals: [] },
        safeZoneEntryState: { signature: null, entriesUsed: 0 },
        alternanceEntryControl: {
            active: false,
            patternSignature: null,
            entryColor: null,
            entryCount: 0,
            lastResult: null,
            lastEntryTimestamp: null,
            blockedUntil: null,
            totalWins: 0,
            totalLosses: 0
        },
        martingaleState: {
            active: false,
            stage: 'ENTRADA',
            patternKey: null,
            entryColor: null,
            entryColorResult: null,
            entryTimestamp: null,
            analysisData: null,
            lossCount: 0,
            lossColors: [],
            patternsWithoutHistory: 0
        },
        totalSignals: 0
    };
}

function updateAlternanceControlAfterSignal(simState, hit) {
    const ctrl = simState.alternanceEntryControl;
    if (!ctrl || !ctrl.active) return;
    ctrl.lastResult = hit ? 'win' : 'loss';
    if (hit) {
        ctrl.totalWins++;
        if (ctrl.entryCount >= 2) {
            ctrl.active = false;
            ctrl.patternSignature = null;
            ctrl.entryColor = null;
            ctrl.entryCount = 0;
            ctrl.lastResult = null;
            ctrl.lastEntryTimestamp = null;
        }
    } else {
        ctrl.totalLosses++;
        if (ctrl.entryCount <= 1 || ctrl.entryCount >= 2) {
            ctrl.active = false;
            ctrl.patternSignature = null;
            ctrl.entryColor = null;
            ctrl.entryCount = 0;
            ctrl.lastResult = null;
            ctrl.lastEntryTimestamp = null;
        }
    }
}

function markLastSignalResolved(simState, newSpin, hit) {
    const signals = simState?.signalsHistory?.signals;
    if (!Array.isArray(signals) || signals.length === 0) return;
    const lastSignal = signals[signals.length - 1];
    if (!lastSignal || lastSignal.verified) return;
    lastSignal.colorThatCame = newSpin?.color || null;
    lastSignal.hit = !!hit;
    lastSignal.verified = true;
    updateAlternanceControlAfterSignal(simState, !!hit);
}

function evaluatePendingAnalysisSimulation(latestSpin, simState, modeKey = 'diamond') {
    const config = simState.config || {};
    const currentAnalysis = simState.analysis;
    if (!currentAnalysis || !currentAnalysis.createdOnTimestamp || currentAnalysis.predictedFor !== 'next') {
        return;
    }
    if (currentAnalysis.createdOnTimestamp === latestSpin.timestamp) {
        return;
    }

    const expectedColor = String(currentAnalysis.color || '').toLowerCase().trim();
    const actualColor = String(latestSpin.color || '').toLowerCase().trim();
    const whiteProtectionWin = !!config.whiteProtectionAsWin
        && actualColor === 'white'
        && (expectedColor === 'red' || expectedColor === 'black');
    const hit = whiteProtectionWin || (expectedColor === actualColor);

    // Atualizar signalsHistory (N7) + alternance control
    markLastSignalResolved(simState, latestSpin, hit);

    const martingale = simState.martingaleState;
    const { maxGales, consecutiveGales } = getMartingaleSettings(modeKey, config);

    if (hit) {
        let martingaleStage = 'ENTRADA';
        if (currentAnalysis.phase === 'G1') martingaleStage = 'G1';
        else if (currentAnalysis.phase === 'G2') martingaleStage = 'G2';
        else if (martingale.active) martingaleStage = martingale.stage;

        const winEntry = {
            timestamp: latestSpin.timestamp,
            number: latestSpin.number,
            color: latestSpin.color,
            phase: currentAnalysis.phase || 'G0',
            result: 'WIN',
            confidence: currentAnalysis.confidence,
            patternData: {
                patternDescription: currentAnalysis.patternDescription,
                confidence: currentAnalysis.confidence,
                color: currentAnalysis.color,
                createdOnTimestamp: currentAnalysis.createdOnTimestamp
            },
            martingaleStage,
            wonAt: martingaleStage,
            finalResult: 'WIN',
            analysisMode: modeKey,
            simulation: true
        };
        simState.entriesHistory.unshift(winEntry);
        // âœ… Marcar fim do ciclo (para intervalo apÃ³s entrada)
        simState.lastCycleResolvedSpinId = latestSpin?.id ?? null;
        simState.lastCycleResolvedSpinTimestamp = latestSpin?.timestamp ?? null;

        // Reset ciclo
        if (martingale.active) {
            simState.martingaleState = {
                ...simState.martingaleState,
                active: false,
                stage: 'ENTRADA',
                patternKey: null,
                entryColor: null,
                entryColorResult: null,
                entryTimestamp: null,
                analysisData: null,
                lossCount: 0,
                lossColors: []
            };
        }
        simState.analysis = null;
        return;
    }

    // LOSS
    const currentStage = martingale.active ? martingale.stage : 'ENTRADA';
    let currentGaleNumber = 0;
    if (currentStage === 'ENTRADA') currentGaleNumber = 0;
    else if (currentStage.startsWith('G')) currentGaleNumber = parseInt(currentStage.substring(1)) || 0;
    const nextGaleNumber = currentGaleNumber + 1;
    const canTryNextGale = nextGaleNumber <= maxGales;

    if (currentStage === 'ENTRADA') {
        if (!canTryNextGale) {
            const lossEntry = {
                timestamp: latestSpin.timestamp,
                number: latestSpin.number,
                color: latestSpin.color,
                phase: 'G0',
                result: 'LOSS',
                confidence: currentAnalysis.confidence,
                patternData: {
                    patternDescription: currentAnalysis.patternDescription,
                    confidence: currentAnalysis.confidence,
                    color: currentAnalysis.color,
                    createdOnTimestamp: currentAnalysis.createdOnTimestamp
                },
                martingaleStage: 'ENTRADA',
                finalResult: 'RET',
                analysisMode: modeKey,
                simulation: true
            };
            simState.entriesHistory.unshift(lossEntry);
            // âœ… Marcar fim do ciclo (RET)
            simState.lastCycleResolvedSpinId = latestSpin?.id ?? null;
            simState.lastCycleResolvedSpinTimestamp = latestSpin?.timestamp ?? null;
            simState.martingaleState = {
                ...simState.martingaleState,
                active: false,
                stage: 'ENTRADA',
                patternKey: null,
                entryColor: null,
                entryColorResult: null,
                entryTimestamp: null,
                analysisData: null,
                lossCount: 0,
                lossColors: []
            };
            simState.analysis = null;
            return;
        }

        // Registrar LOSS da entrada e ativar ciclo
        const entradaLossEntry = {
            timestamp: latestSpin.timestamp,
            number: latestSpin.number,
            color: latestSpin.color,
            phase: 'G0',
            result: 'LOSS',
            confidence: currentAnalysis.confidence,
            patternData: {
                patternDescription: currentAnalysis.patternDescription,
                confidence: currentAnalysis.confidence,
                color: currentAnalysis.color,
                createdOnTimestamp: currentAnalysis.createdOnTimestamp
            },
            martingaleStage: 'ENTRADA',
            finalResult: null,
            continuingToG1: true,
            analysisMode: modeKey,
            simulation: true
        };
        simState.entriesHistory.unshift(entradaLossEntry);

        const patternKey = martingale.active ? martingale.patternKey : createPatternKey(currentAnalysis);
        simState.martingaleState = {
            ...simState.martingaleState,
            active: true,
            stage: 'G1',
            patternKey,
            entryColor: currentAnalysis.color,
            entryColorResult: latestSpin.color,
            entryTimestamp: currentAnalysis.createdOnTimestamp,
            analysisData: currentAnalysis,
            lossCount: 1,
            lossColors: [latestSpin.color]
        };

        // âœ… SÃ³ auto-gera o prÃ³ximo gale se ele estiver dentro do "consecutivo atÃ©"
        if (nextGaleNumber <= consecutiveGales) {
            const g1Analysis = {
                ...currentAnalysis,
                color: currentAnalysis.color,
                phase: 'G1',
                predictedFor: 'next',
                createdOnTimestamp: latestSpin.timestamp
            };
            g1Analysis.confidence = calculateGaleConfidenceValue(g1Analysis.confidence, g1Analysis, simState.martingaleState);
            simState.analysis = g1Analysis;
        } else {
            simState.analysis = null;
        }
        return;
    }

    // LOSS em um GALE
    if (currentStage.startsWith('G')) {
        if (!canTryNextGale) {
            const retEntry = {
                timestamp: latestSpin.timestamp,
                number: latestSpin.number,
                color: latestSpin.color,
                phase: currentStage,
                result: 'LOSS',
                confidence: currentAnalysis.confidence,
                patternData: {
                    patternDescription: currentAnalysis.patternDescription,
                    confidence: currentAnalysis.confidence,
                    color: currentAnalysis.color,
                    createdOnTimestamp: currentAnalysis.createdOnTimestamp
                },
                martingaleStage: currentStage,
                finalResult: 'RET',
                    analysisMode: modeKey,
                simulation: true
            };
            simState.entriesHistory.unshift(retEntry);
            // âœ… Marcar fim do ciclo (RET)
            simState.lastCycleResolvedSpinId = latestSpin?.id ?? null;
            simState.lastCycleResolvedSpinTimestamp = latestSpin?.timestamp ?? null;
            simState.martingaleState = {
                ...simState.martingaleState,
                active: false,
                stage: 'ENTRADA',
                patternKey: null,
                entryColor: null,
                entryColorResult: null,
                entryTimestamp: null,
                analysisData: null,
                lossCount: 0,
                lossColors: []
            };
            simState.analysis = null;
            return;
        }

        const nextStage = `G${nextGaleNumber}`;
        const lossEntry = {
            timestamp: latestSpin.timestamp,
            number: latestSpin.number,
            color: latestSpin.color,
            phase: currentStage,
            result: 'LOSS',
            confidence: currentAnalysis.confidence,
            patternData: {
                patternDescription: currentAnalysis.patternDescription,
                confidence: currentAnalysis.confidence,
                color: currentAnalysis.color,
                createdOnTimestamp: currentAnalysis.createdOnTimestamp
            },
            martingaleStage: currentStage,
            finalResult: null,
            [`continuingTo${nextStage}`]: true,
            analysisMode: modeKey,
            simulation: true
        };
        simState.entriesHistory.unshift(lossEntry);

        simState.martingaleState = {
            ...simState.martingaleState,
            active: true,
            stage: nextStage,
            lossCount: nextGaleNumber,
            lossColors: [...(simState.martingaleState.lossColors || []), latestSpin.color]
        };

        if (nextGaleNumber <= consecutiveGales) {
            const nextAnalysis = {
                ...currentAnalysis,
                color: simState.martingaleState.entryColor || currentAnalysis.color,
                phase: nextStage,
                predictedFor: 'next',
                createdOnTimestamp: latestSpin.timestamp
            };
            nextAnalysis.confidence = calculateGaleConfidenceValue(nextAnalysis.confidence, nextAnalysis, simState.martingaleState);
            simState.analysis = nextAnalysis;
        } else {
            simState.analysis = null;
        }
    }
}

function analyzeDiamondLevelsSimulation(history, config, simState) {
    const totalDiamondLevels = DIAMOND_LEVEL_IDS.length;
    const diamondLevelEnabledMap = {};
    DIAMOND_LEVEL_IDS.forEach(id => {
        diamondLevelEnabledMap[id] = isDiamondLevelEnabled(id, config);
    });
    const isLevelEnabledLocal = (id) => !!diamondLevelEnabledMap[id];
    const activeDiamondLevels = DIAMOND_LEVEL_IDS.filter(id => diamondLevelEnabledMap[id]);

    if (activeDiamondLevels.length === 0) {
        return null;
    }

    const { blocked: intervalBlocked } = computeIntervalBlockForSimulation(history, config, simState);

    const configuredSize = Math.min(Math.max(config.aiHistorySize || 60, 60), 2000);
    const historySize = Math.min(configuredSize, history.length);

    const lastSpinTimestamp = history[0]?.timestamp || Date.now();
    const lastSpinPosition = history[0]?.timestamp ? identifySpinPosition(lastSpinTimestamp) : 1;
    const nextSpinPosition = lastSpinPosition === 1 ? 2 : 1;
    const lastSpinDate = new Date(lastSpinTimestamp);
    const nextSpinDate = new Date(lastSpinDate);
    if (lastSpinPosition === 2) {
        nextSpinDate.setMinutes(nextSpinDate.getMinutes() + 1);
    }
    const targetMinute = nextSpinDate.getMinutes();

    const clamp01Local = (value) => Math.max(0, Math.min(1, typeof value === 'number' ? value : 0));
    const directionValue = (color) => color === 'red' ? 1 : color === 'black' ? -1 : 0;

    // Pesos e meta (igual ao modo real)
    const levelWeights = {
        whiteDetector: 0,
        patterns: 0.19,
        momentum: 0.15,
        alternance: 0.13,
        persistence: 0.11,
        minuteSpin: 0.095,
        retracement: 0.085,
        globalContinuity: 0.11,
        barrier: 0.05,
        bayesianCalibration: 0.08,
        walkForward: 0.12
    };

    const levelReports = [];

    // N0
    const n0Enabled = isLevelEnabledLocal('N0');
    const n0Settings = getN0SettingsFromConfig(config);
    const n0Options = {
        historySize: n0Settings.historySize,
        windowSize: n0Settings.windowSize,
        analysesToRun: N0_DEFAULTS.analysesToRun,
        minWindowsRequired: N0_DEFAULTS.minWindowsRequired,
        precisionMin: N0_DEFAULTS.precisionMin,
        confidenceGrid: N0_DEFAULTS.confidenceGrid,
        holdoutEnabled: N0_DEFAULTS.holdoutEnabled,
        holdoutTolerance: N0_DEFAULTS.holdoutTolerance,
        seed: N0_DEFAULTS.seed
    };

    let n0Result = null;
    let n0EffectiveAction = 'no_block';
    let n0ForceWhite = false;
    let n0SoftBlockActive = false;
    let n0WhiteStrength = 0;
    let n0ActionSuppressed = false;

    if (n0Enabled) {
        try {
            n0Result = runN0Detector(history, n0Options);
            if (n0Result && n0Result.enabled) {
                const actionRequested = n0Result.blocking_action || 'no_block';
                const blockAllAllowed = n0Settings.allowBlockAll;
                n0WhiteStrength = clamp01Local(n0Result.white_confidence || 0);
                n0EffectiveAction = actionRequested;
                if (actionRequested === 'block_all' && !blockAllAllowed) {
                    n0EffectiveAction = 'no_block';
                    n0ActionSuppressed = true;
                }
                n0ForceWhite = n0EffectiveAction === 'block_all' && n0Result.pred_live === 'W';
                n0SoftBlockActive = n0EffectiveAction === 'soft_block' && n0Result.pred_live === 'W';
            }
        } catch (_) {
            n0Result = { enabled: false, reason: 'Erro interno' };
        }
    }

    levelReports.push({
        id: 'N0',
        name: 'Detector de Branco',
        color: n0Result && n0Result.pred_live === 'W' ? 'white' : null,
        weight: n0Enabled ? levelWeights.whiteDetector : 0,
        strength: n0WhiteStrength,
        score: 0,
        details: !n0Enabled ? 'DESATIVADO' : (n0ForceWhite ? 'BLOCK ALL' : n0SoftBlockActive ? 'SOFT BLOCK' : 'NULO'),
        disabled: !n0Enabled
    });

    const n0WeightModifier = (n0Enabled && n0SoftBlockActive) ? N0_DEFAULTS.softBlockFactor : 1;
    const weightFor = (baseWeight) => baseWeight * n0WeightModifier;

    // N1 - Zona Segura
    let safeZoneVote = null;
    let safeZoneMeta = null;
    let patternDescription = 'AnÃ¡lise NÃ­vel Diamante - SimulaÃ§Ã£o';

    const n1Enabled = isLevelEnabledLocal('N1');
    if (n1Enabled) {
        const safeZoneSettings = getSafeZoneSettingsFromConfig(config);
        safeZoneMeta = analyzeSafeZone(history, safeZoneSettings);
        safeZoneMeta.maxEntries = safeZoneSettings.maxEntries;
        safeZoneMeta.entriesUsed = simState.safeZoneEntryState.entriesUsed || 0;

        if (!safeZoneMeta.zoneActive) {
            simState.safeZoneEntryState = { signature: null, entriesUsed: 0 };
        } else {
            if (safeZoneMeta.signal) {
                const signature = buildSafeZoneSignature(safeZoneMeta);
                if (simState.safeZoneEntryState.signature !== signature) {
                    simState.safeZoneEntryState = { signature, entriesUsed: 0 };
                }
                safeZoneMeta.entriesUsed = simState.safeZoneEntryState.entriesUsed;
                if (simState.safeZoneEntryState.entriesUsed >= safeZoneSettings.maxEntries) {
                    safeZoneMeta.signal = false;
                    safeZoneMeta.reason = 'entry_limit_reached';
                }
            }
        }

        if (safeZoneMeta.zoneActive && safeZoneMeta.signal && safeZoneMeta.dominant) {
            safeZoneVote = {
                color: safeZoneMeta.dominant,
                source: 'safe-zone',
                confidence: safeZoneMeta.strength,
                detail: safeZoneMeta
            };
            const signature = buildSafeZoneSignature(safeZoneMeta);
            simState.safeZoneEntryState = {
                signature,
                entriesUsed: Math.min(safeZoneSettings.maxEntries, (simState.safeZoneEntryState.signature === signature ? simState.safeZoneEntryState.entriesUsed : 0) + 1)
            };
            safeZoneMeta.entriesUsed = simState.safeZoneEntryState.entriesUsed;
            safeZoneMeta.reason = 'zone_active_last_is_dominant';
            patternDescription = JSON.stringify({
                type: 'safe_zone',
                dominant: safeZoneMeta.dominant,
                secondary: safeZoneMeta.secondary,
                counts: safeZoneMeta.counts,
                windowSize: safeZoneMeta.windowSize,
                minPrimary: safeZoneMeta.minPrimary,
                minSecondary: safeZoneMeta.minSecondary,
                lastColor: safeZoneMeta.lastColor,
                status: safeZoneMeta.reason,
                entriesUsed: safeZoneMeta.entriesUsed,
                maxEntries: safeZoneSettings.maxEntries
            });
        }
    }

    let patternStrength = 0;
    let patternColor = null;
    let patternDetailsText = n1Enabled ? 'NULO' : 'DESATIVADO';
    if (n1Enabled && safeZoneMeta) {
        if (safeZoneMeta.zoneActive && safeZoneMeta.signal && safeZoneVote && safeZoneVote.color) {
            patternColor = safeZoneVote.color;
            patternStrength = clamp01Local(safeZoneVote.confidence ?? safeZoneMeta.strength ?? 0.5);
            const entriesInfo = safeZoneMeta.maxEntries
                ? `${safeZoneMeta.entriesUsed}/${safeZoneMeta.maxEntries}`
                : `${safeZoneMeta.entriesUsed || 0}`;
            const dominantLabel = safeZoneMeta.dominant
                ? `${safeZoneMeta.dominant.toUpperCase()} ${safeZoneMeta.counts[safeZoneMeta.dominant]}/${safeZoneMeta.windowSize}`
                : 'Zona ativa';
            patternDetailsText = `DominÃ¢ncia ${dominantLabel} â€¢ entradas ${entriesInfo}`;
        }
    }

    levelReports.push({
        id: 'N1',
        name: 'Zona Segura',
        color: patternColor,
        weight: n1Enabled ? weightFor(levelWeights.patterns) : 0,
        strength: patternStrength,
        score: patternColor ? directionValue(patternColor) * patternStrength : 0,
        details: patternDetailsText,
        disabled: !n1Enabled,
        meta: safeZoneMeta
    });

    // N2 - Ritmo AutÃ´nomo
    const n2Enabled = isLevelEnabledLocal('N2');
    const nivel5 = n2Enabled ? analyzeMomentumFromConfig(history, config) : null;
    const momentumColor = n2Enabled && nivel5 ? nivel5.color : null;
    const redMomentum = Number(nivel5?.momentum?.red ?? 0);
    const blackMomentum = Number(nivel5?.momentum?.black ?? 0);
    const diffMomentum = (isFinite(redMomentum) && isFinite(blackMomentum)) ? Math.abs(redMomentum - blackMomentum) : 0;
    // âœ… ForÃ§a deve refletir significÃ¢ncia (confidence do N2)
    let momentumStrength = (n2Enabled && momentumColor && typeof nivel5?.confidence === 'number')
        ? clamp01Local(nivel5.confidence)
        : 0;
    levelReports.push({
        id: 'N2',
        name: 'Ritmo AutÃ´nomo',
        color: momentumColor,
        weight: n2Enabled ? weightFor(levelWeights.momentum) : 0,
        strength: n2Enabled ? momentumStrength : 0,
        score: n2Enabled && momentumColor ? directionValue(momentumColor) * momentumStrength : 0,
        details: !n2Enabled
            ? 'DESATIVADO'
            : (nivel5 && nivel5.details ? nivel5.details : `Î” ${diffMomentum.toFixed(1)} pp (P2+)`),
        disabled: !n2Enabled
    });

    // N3 - AlternÃ¢ncia
    const n3Enabled = isLevelEnabledLocal('N3');
    const n3HistoryWindow = Math.max(1, getDiamondWindowFromConfig(config, 'n3Alternance', historySize));
    const n3ThresholdPctConfigured = Math.max(50, Math.min(95, getDiamondWindowFromConfig(config, 'n3ThresholdPct', 75)));
    const n3MinOccurrencesConfigured = Math.max(1, Math.min(100, getDiamondWindowFromConfig(config, 'n3MinOccurrences', 1)));
    const n3AllowBackoffConfigured = getDiamondBooleanFromConfig(config, 'n3AllowBackoff', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n3AllowBackoff);
    const n3IgnoreWhiteConfigured = getDiamondBooleanFromConfig(config, 'n3IgnoreWhite', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n3IgnoreWhite);

    const nivel7 = n3Enabled ? analyzeAlternancePattern(history, {
        historySize: n3HistoryWindow,
        threshold: n3ThresholdPctConfigured / 100,
        minOccurrences: n3MinOccurrencesConfigured,
        allowBackoff: n3AllowBackoffConfigured,
        ignoreWhite: n3IgnoreWhiteConfigured
    }) : null;

    const alternanceColor = n3Enabled && nivel7 && nivel7.color ? nivel7.color : null;
    const alternanceOverrideActive = n3Enabled && Boolean(nivel7 && nivel7.override && alternanceColor);
    let alternanceStrength = 0;
    if (n3Enabled && alternanceColor) {
        const baseConfidence = typeof nivel7.confidence === 'number' ? nivel7.confidence : (nivel7.probability || 0);
        alternanceStrength = alternanceOverrideActive ? 1 : clamp01Local(baseConfidence);
    }

    levelReports.push({
        id: 'N3',
        name: 'AlternÃ¢ncia',
        color: alternanceColor,
        weight: n3Enabled ? weightFor(levelWeights.alternance) : 0,
        strength: n3Enabled ? alternanceStrength : 0,
        score: n3Enabled && alternanceColor ? directionValue(alternanceColor) * alternanceStrength : 0,
        details: n3Enabled ? (nivel7 && nivel7.details ? nivel7.details : 'NULO') : 'DESATIVADO',
        override: alternanceOverrideActive,
        disabled: !n3Enabled
    });

    // N4 - PersistÃªncia
    const n4Enabled = isLevelEnabledLocal('N4');
    const nivel9 = n4Enabled ? analyzePersistence(history, getDiamondWindowFromConfig(config, 'n4Persistence', historySize)) : null;
    const persistenceColor = n4Enabled && nivel9 && nivel9.color ? nivel9.color : null;
    const persistenceStrength = n4Enabled && nivel9 && nivel9.color ? clamp01Local(nivel9.confidence ?? 0.5) : 0;
    levelReports.push({
        id: 'N4',
        name: 'PersistÃªncia',
        color: persistenceColor,
        weight: n4Enabled ? weightFor(levelWeights.persistence) : 0,
        strength: n4Enabled ? persistenceStrength : 0,
        score: n4Enabled && persistenceColor ? directionValue(persistenceColor) * persistenceStrength : 0,
        details: n4Enabled && nivel9 && nivel9.color ? `Seq ${nivel9.currentSequence} â€¢ mÃ©dia ${nivel9.averageSequence}` : (n4Enabled ? 'NULO' : 'DESATIVADO'),
        disabled: !n4Enabled
    });

    // N5 - Ritmo por giro
    const n5Enabled = isLevelEnabledLocal('N5');
    const minuteSpinWindow = Math.max(10, Math.min(200, getDiamondWindowFromConfig(config, 'n5MinuteBias', 60)));
    const minuteBiasResult = n5Enabled ? analyzeMinuteSpinBias(history, targetMinute, nextSpinPosition, minuteSpinWindow) : null;
    const minuteBiasColor = n5Enabled && minuteBiasResult && minuteBiasResult.color ? minuteBiasResult.color : null;
    const minuteBiasStrength = clamp01Local(minuteBiasResult ? minuteBiasResult.confidence : 0);
    levelReports.push({
        id: 'N5',
        name: 'Ritmo por Giro',
        color: minuteBiasColor,
        weight: n5Enabled ? weightFor(levelWeights.minuteSpin) : 0,
        strength: n5Enabled ? minuteBiasStrength : 0,
        score: n5Enabled && minuteBiasColor ? directionValue(minuteBiasColor) * minuteBiasStrength : 0,
        details: n5Enabled ? (minuteBiasResult ? minuteBiasResult.details : 'NULO') : 'DESATIVADO',
        disabled: !n5Enabled
    });

    // N6 - RetraÃ§Ã£o HistÃ³rica
    const n6Enabled = isLevelEnabledLocal('N6');
    const retracementWindow = Math.max(30, Math.min(120, getDiamondWindowFromConfig(config, 'n6RetracementWindow', 80)));
    const retracementResult = n6Enabled ? analyzeHistoricalRetracement(history, retracementWindow, config.signalIntensity || 'aggressive') : null;
    levelReports.push({
        id: 'N6',
        name: 'RetraÃ§Ã£o HistÃ³rica',
        color: n6Enabled ? retracementResult.color : null,
        weight: n6Enabled ? weightFor(levelWeights.retracement) : 0,
        strength: n6Enabled ? (retracementResult.strength || 0) : 0,
        score: n6Enabled && retracementResult.color ? directionValue(retracementResult.color) * (retracementResult.strength || 0) : 0,
        details: n6Enabled ? retracementResult.details : 'DESATIVADO',
        disabled: !n6Enabled
    });

    // N7 - Continuidade global
    const n7Enabled = isLevelEnabledLocal('N7');
    const decisionWindowConfigured = Math.max(10, Math.min(50, getDiamondWindowFromConfig(config, 'n7DecisionWindow', 20)));
    const historyWindowConfigured = Math.max(decisionWindowConfigured, Math.min(200, getDiamondWindowFromConfig(config, 'n7HistoryWindow', 100)));
    const continuityResult = n7Enabled ? analyzeGlobalContinuity(simState.signalsHistory, decisionWindowConfigured, historyWindowConfigured, config.signalIntensity || 'aggressive') : null;
    levelReports.push({
        id: 'N7',
        name: 'Continuidade Global',
        color: n7Enabled ? continuityResult.color : null,
        weight: n7Enabled ? weightFor(levelWeights.globalContinuity) : 0,
        strength: n7Enabled ? (continuityResult.strength || 0) : 0,
        score: n7Enabled && continuityResult.color ? directionValue(continuityResult.color) * (continuityResult.strength || 0) : 0,
        details: n7Enabled ? continuityResult.details : 'DESATIVADO',
        disabled: !n7Enabled
    });

    // N8 - Walk-forward (id N8)
    const n8Enabled = isLevelEnabledLocal('N8');
    if (n8Enabled) {
        try {
            const windowsCfg = config.diamondLevelWindows || {};
            const n8WindowCfg = getDiamondWindowFromConfig(config, 'n10Window', N8_DEFAULTS.windowSize);
            const n8HistoryCfg = Number(windowsCfg.n10History) > 0 ? Number(windowsCfg.n10History) : N8_DEFAULTS.historySize;
            const n8AnalysesCfg = Number(windowsCfg.n10Analyses) > 0 ? Number(windowsCfg.n10Analyses) : N8_DEFAULTS.analysesToRun;
            const n8MinWindowsCfg = Number(windowsCfg.n10MinWindows) > 0 ? Number(windowsCfg.n10MinWindows) : N8_DEFAULTS.minWindowsRequired;
            const n8ConfMinPctCfg = Number(windowsCfg.n10ConfMin) > 0 ? Number(windowsCfg.n10ConfMin) : N8_DEFAULTS.confMinLive * 100;
            const n8ConfMinCfg = Math.max(0, Math.min(1, n8ConfMinPctCfg / 100));

            const n8Result = runN8Detector(history, {
                windowSize: n8WindowCfg,
                historySize: n8HistoryCfg,
                analysesToRun: n8AnalysesCfg,
                minWindows: n8MinWindowsCfg,
                confMinLive: n8ConfMinCfg
            });

            if (n8Result && n8Result.enabled && n8Result.color) {
                const n8Color = n8Result.color;
                const n8Strength = clamp01Local(n8Result.confidence || 0);
                levelReports.push({
                    id: 'N8',
                    name: 'Walk-forward',
                    color: n8Color,
                    weight: weightFor(levelWeights.walkForward),
                    strength: n8Strength,
                    score: directionValue(n8Color) * n8Strength,
                    details: n8Result.summaryText || 'Walk-forward diversificado',
                    disabled: false
                });
            } else {
                levelReports.push({
                    id: 'N8',
                    name: 'Walk-forward',
                    color: null,
                    weight: weightFor(levelWeights.walkForward),
                    strength: 0,
                    score: 0,
                    details: n8Result && n8Result.summaryText ? n8Result.summaryText : 'NULO',
                    disabled: false
                });
            }
        } catch (_) {
            levelReports.push({
                id: 'N8',
                name: 'Walk-forward',
                color: null,
                weight: weightFor(levelWeights.walkForward),
                strength: 0,
                score: 0,
                details: 'Erro interno em N8',
                disabled: false
            });
        }
    } else {
        levelReports.push({
            id: 'N8',
            name: 'Walk-forward',
            color: null,
            weight: 0,
            strength: 0,
            score: 0,
            details: 'DESATIVADO',
            disabled: true
        });
    }

    // N10 - CalibraÃ§Ã£o Bayesiana (id N10) - sÃ³ calibra
    const n10Enabled = isLevelEnabledLocal('N10');
    let bayesResult = null;
    if (n10Enabled) {
        const bayesHistoryConfigured = Math.max(30, Math.min(400, getDiamondWindowFromConfig(config, 'n9History', 100)));
        const bayesNullThresholdConfigured = Math.max(2, Math.min(20, getDiamondWindowFromConfig(config, 'n9NullThreshold', 8)));
        const bayesPriorStrengthConfigured = Math.max(0.2, Math.min(5, getDiamondWindowFromConfig(config, 'n9PriorStrength', 1)));
        const bayesPriorConfig = {
            red: bayesPriorStrengthConfigured,
            black: bayesPriorStrengthConfigured,
            white: Math.max(0.1, bayesPriorStrengthConfigured * 0.5)
        };
        bayesResult = analyzeBayesianCalibration(
            history,
            bayesHistoryConfigured,
            bayesPriorConfig,
            bayesNullThresholdConfigured / 100
        );

        if (bayesResult && bayesResult.adjustments) {
            levelReports.forEach(level => {
                if (!level.color) return;
                const factor = bayesResult.adjustments[level.color] ?? 1;
                level.strength = clamp01Local((level.strength || 0) * factor);
                level.score = directionValue(level.color) * (level.strength || 0);
            });
        }
    }

    levelReports.push({
        id: 'N10',
        name: 'CalibraÃ§Ã£o Bayesiana',
        color: null,
        weight: 0,
        strength: 0,
        score: 0,
        details: n10Enabled && bayesResult ? bayesResult.details : 'DESATIVADO',
        disabled: !n10Enabled
    });

    // AlternÃ¢ncia override com controle de entradas
    let alternanceOverride = false;
    let alternanceBlocked = false;
    let alternanceBlockReason = '';

    if (alternanceOverrideActive && alternanceColor) {
        const otherLevelsAgreeingCount = levelReports.filter(lvl =>
            lvl.id !== 'N3' && lvl.id !== 'N9' && lvl.color === alternanceColor
        ).length;

        const alternanceSignature = `${nivel7?.pattern}-${alternanceColor}`;
        const now = Date.now();
        const ctrl = simState.alternanceEntryControl;

        if (ctrl.active && ctrl.patternSignature === alternanceSignature) {
            if (ctrl.lastResult === 'loss' && ctrl.entryCount === 1) {
                alternanceBlocked = true;
                alternanceBlockReason = 'LOSS na 1Âª entrada â†’ bloqueado';
            } else if (ctrl.entryCount >= 2) {
                alternanceBlocked = true;
                alternanceBlockReason = 'Limite de 2 entradas atingido';
            } else if (ctrl.lastResult === 'win' && ctrl.entryCount === 1) {
                const { consecutiveMartingale: allowsConsecutiveEntries } = getMartingaleSettings('diamond', config);
                if (!allowsConsecutiveEntries) {
                    alternanceBlocked = true;
                    alternanceBlockReason = 'Entradas consecutivas desativadas';
                }
            }
        }

        if (!alternanceBlocked && otherLevelsAgreeingCount >= 2) {
            alternanceOverride = true;

            levelReports.forEach(lvl => {
                if (lvl.id !== 'N3' && lvl.id !== 'N6') {
                    lvl.score = 0;
                    lvl.strength = 0;
                }
            });

            if (!ctrl.active || ctrl.patternSignature !== alternanceSignature) {
                ctrl.active = true;
                ctrl.patternSignature = alternanceSignature;
                ctrl.entryColor = alternanceColor;
                ctrl.entryCount = 1;
                ctrl.lastResult = null;
                ctrl.lastEntryTimestamp = now;
            } else {
                ctrl.entryCount = 2;
                ctrl.lastEntryTimestamp = now;
            }
        }
    }

    // N0 forÃ§a branco
    if (n0ForceWhite) {
        if (intervalBlocked) return null;
        const whiteConfidencePct = Math.max(0, Math.min(100, Math.round(n0WhiteStrength * 100)));
        return {
            color: 'white',
            confidence: whiteConfidencePct,
            probability: whiteConfidencePct,
            reasoning: 'N0 bloqueou e forÃ§ou branco (simulaÃ§Ã£o)',
            patternDescription: 'Detector de Branco (N0)'
        };
    }

    // Score preliminar e barreira
    const scoreWithoutBarrier = levelReports.reduce((sum, lvl) => sum + (lvl.score * (lvl.weight || 0)), 0);
    let predictedColor = scoreWithoutBarrier === 0
        ? (minuteBiasColor || momentumColor || patternColor || 'red')
        : (scoreWithoutBarrier >= 0 ? 'red' : 'black');
    if (alternanceOverride) {
        predictedColor = alternanceColor;
    }

    const n9Enabled = isLevelEnabledLocal('N9');
    let barrierResult = { allowed: true, alternanceBlocked: false };
    if (alternanceBlocked && alternanceOverrideActive) {
        return null;
    }
    let barrierDetailsText = '';
    if (n9Enabled) {
        barrierResult = validateSequenceBarrier(history, predictedColor, getDiamondWindowFromConfig(config, 'n8Barrier', historySize), {
            override: alternanceOverrideActive,
            targetRuns: nivel7 ? nivel7.alternanceTargetRuns : null,
            maxRuns: nivel7 ? nivel7.alternanceMaxRuns : null
        });
        if (barrierResult && barrierResult.alternanceBlocked) {
            barrierDetailsText = 'BLOQUEADO â€¢ alternÃ¢ncia';
        } else if (barrierResult && barrierResult.allowed) {
            const cur = Number(barrierResult.currentStreak ?? 0);
            const target = Number(barrierResult.targetStreak ?? 0);
            const maxHist = Number(barrierResult.maxStreakFound ?? 0);
            barrierDetailsText = `APROVADO â€¢ atual ${cur} â€¢ alvo ${target} â€¢ mÃ¡xHist ${maxHist}`;
        } else {
            const cur = Number(barrierResult.currentStreak ?? 0);
            const target = Number(barrierResult.targetStreak ?? 0);
            const maxHist = Number(barrierResult.maxStreakFound ?? 0);
            barrierDetailsText = `BLOQUEADO â€¢ atual ${cur} â€¢ alvo ${target} â€¢ mÃ¡xHist ${maxHist}`;
        }
        if (!barrierResult.allowed) {
            return null;
        }
    }

    levelReports.push({
        id: 'N9',
        name: 'Barreira Final',
        color: null,
        weight: 0,
        strength: 0,
        score: 0,
        details: n9Enabled ? (barrierDetailsText || (barrierResult.allowed ? 'APROVADO' : 'BLOQUEADO')) : 'DESATIVADO',
        disabled: !n9Enabled
    });

    // VerificaÃ§Ã£o: precisa existir voto de nÃ­veis 1-8
    const votingLevelsOnly = levelReports.filter(lvl =>
        lvl.id !== 'N0' && lvl.id !== 'N9' && lvl.id !== 'N10' &&
        !lvl.disabled && lvl.color && (lvl.strength || 0) > 0
    );
    if (votingLevelsOnly.length === 0) {
        return null;
    }

    // Intensidade
    let signalIntensity = config.signalIntensity === 'conservative' ? 'conservative' : 'aggressive';
    const votingLevelIds = ['N1','N2','N3','N4','N5','N6','N7','N8'];
    const allVotingLevelsEnabled = votingLevelIds.every(id => diamondLevelEnabledMap[id]);
    if (signalIntensity === 'conservative' && !allVotingLevelsEnabled) {
        signalIntensity = 'aggressive';
    }

    if (intervalBlocked) {
        return null;
    }

    // âœ… SÃ³ nÃ­veis que VOTAM entram na conta de confianÃ§a (N9/N10 sÃ£o validadores)
    const VOTING_LEVEL_IDS = new Set(['N1','N2','N3','N4','N5','N6','N7','N8']);
    const votingLevelsList = levelReports.filter(lvl => VOTING_LEVEL_IDS.has(lvl.id) && !lvl.disabled);
    const positiveVotingLevels = votingLevelsList.filter(lvl => lvl.color && (lvl.strength || 0) > 0);
    const negativeVotingLevels = votingLevelsList.filter(lvl => lvl.color && (lvl.strength || 0) < 0);
    const neutralVotingLevels = votingLevelsList.filter(lvl => !lvl.color || (lvl.strength || 0) === 0);

    const voteCounts = { red: 0, black: 0 };
    positiveVotingLevels.forEach(lvl => {
        if (lvl.color === 'red') voteCounts.red++;
        if (lvl.color === 'black') voteCounts.black++;
    });

    const totalVotes = voteCounts.red + voteCounts.black;
    if (totalVotes === 0) return null;
    if (voteCounts.red === voteCounts.black) return null;

    const consensusColor = voteCounts.red > voteCounts.black ? 'red' : 'black';

    if (signalIntensity === 'conservative') {
        if (voteCounts[consensusColor] < 5) return null;
        if (!n9Enabled) return null;
        if (!barrierResult.allowed) return null;
        const bayesApproves = n10Enabled && bayesResult && bayesResult.color && bayesResult.color === consensusColor;
        if (!n10Enabled || !bayesApproves) return null;
    }

    const maxVotingSlots = votingLevelsList.length;
    const winningVotes = voteCounts[consensusColor];
    let rawConfidence = Math.round((winningVotes / Math.max(1, maxVotingSlots)) * 100);
    rawConfidence = Math.max(0, Math.min(100, rawConfidence));
    const finalConfidence = Math.max(0, Math.min(100, Math.round(rawConfidence)));

    // âœ… Helper local: no modo real existe `describeLevel` (funÃ§Ã£o interna daquele escopo).
    // Na simulaÃ§Ã£o precisamos de um serializer equivalente para o modal conseguir fazer parse.
    const describeLevelLocal = (level) => {
        const id = level?.id ? String(level.id) : 'N?';
        const name = level?.name ? String(level.name) : 'NÃ­vel';
        const disabled = !!level?.disabled;
        const details = level?.details ? String(level.details) : '';
        const color = level?.color === 'red' || level?.color === 'black' || level?.color === 'white'
            ? level.color
            : null;

        if (disabled) {
            return `${id} - ${name} â†’ DESATIVADO`;
        }

        if (color) {
            const pct = Math.max(0, Math.min(100, Number.isFinite(Number(level?.strength))
                ? Math.abs(Number(level.strength)) * 100
                : 0));
            const pctText = pct > 0 ? ` (${pct.toFixed(1)}%)` : '';
            const detailText = details ? ` â€¢ ${details}` : '';
            // Importante: usar RED/BLACK/WHITE em inglÃªs para o parser do `content.js` detectar o voto
            return `${id} - ${name} â†’ Voto: ${color.toUpperCase()}${pctText}${detailText}`;
        }

        if (details) {
            return `${id} - ${name} â†’ ${details}`;
        }

        return `${id} - ${name} â†’ NULO`;
    };

    // âœ… RaciocÃ­nio completo (mesmo formato do modo real, para o modal "PadrÃ£o da Entrada")
    const intensityLabel = signalIntensity === 'conservative' ? 'Conservador' : 'Agressivo';
    const reasoning =
        `${levelReports.map(level => describeLevelLocal(level)).join('\n')}\n` +
        `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
        `Modo: ${intensityLabel}\n` +
        `Score combinado: ${rawConfidence.toFixed(1)}%\n` +
        `DECISÃƒO: ${consensusColor.toUpperCase()}\n` +
        `ConfianÃ§a: ${finalConfidence}%`;

    return {
        color: consensusColor,
        confidence: finalConfidence,
        probability: finalConfidence,
        reasoning,
        patternDescription,
        safeZone: safeZoneMeta,
        meta: {
            votes: voteCounts,
            neutral: neutralVotingLevels.length,
            negative: negativeVotingLevels.length
        }
    };
}

function createDiamondAnalysisForNextSpin(history, simState, aiResult) {
    if (!aiResult) return null;
    const config = simState.config || {};
    let aiColor = aiResult.color;
    let aiPhase = 'G0';

    if (simState.martingaleState.active) {
        const { consecutiveGales } = getMartingaleSettings('diamond', config);
        aiPhase = simState.martingaleState.stage;
        // âœ… SÃ³ forÃ§a a cor quando o estÃ¡gio atual Ã© consecutivo
        if (simState.martingaleState.entryColor && isMartingaleStageConsecutive(simState.martingaleState.stage, consecutiveGales)) {
            aiColor = simState.martingaleState.entryColor;
        }
    }

    const aiHistorySizeUsed = Math.min(Math.max(config.aiHistorySize || 50, 20), history.length);
    const last10SpinsForDescription = history.slice(0, 10).map(spin => ({
        color: spin.color,
        number: spin.number,
        timestamp: spin.timestamp
    }));

    const aiDescriptionData = {
        type: 'AI_ANALYSIS',
        color: aiColor,
        confidence: aiResult.confidence,
        last10Spins: last10SpinsForDescription,
        last5Spins: last10SpinsForDescription ? last10SpinsForDescription.slice(0, 10) : [],
        reasoning: aiResult.reasoning || aiResult.patternDescription || `SimulaÃ§Ã£o baseada nos Ãºltimos ${aiHistorySizeUsed} giros.`,
        historySize: aiHistorySizeUsed
    };
    const aiDescription = JSON.stringify(aiDescriptionData);

    const analysis = {
        color: aiColor,
        confidence: aiResult.confidence,
        patternDescription: aiDescription,
        last10Spins: last10SpinsForDescription,
        last5Spins: last10SpinsForDescription ? last10SpinsForDescription.slice(0, 10) : [],
        patternType: 'ai-analysis',
        phase: aiPhase,
        predictedFor: 'next',
        createdOnTimestamp: history[0].timestamp,
        aiPattern: null
    };

    if (analysis.phase && analysis.phase !== 'G0' && analysis.phase !== 'ENTRADA') {
        analysis.confidence = calculateGaleConfidenceValue(analysis.confidence, analysis, simState.martingaleState);
    }

    return analysis;
}

function maybeGenerateDiamondAnalysisSimulation(history, simState) {
    const config = simState.config || {};
    const { consecutiveGales } = getMartingaleSettings('diamond', config);

    // Se anÃ¡lise pendente, nÃ£o gerar outra
    if (simState.analysis && simState.analysis.createdOnTimestamp && simState.analysis.predictedFor === 'next') {
        const latestTs = history[0]?.timestamp;
        if (latestTs && simState.analysis.createdOnTimestamp !== latestTs) {
            return;
        }
    }

    if (simState.martingaleState.active && isMartingaleStageConsecutive(simState.martingaleState.stage, consecutiveGales)) return;

    const aiResult = analyzeDiamondLevelsSimulation(history, config, simState);
    if (!aiResult) return;

    const analysis = createDiamondAnalysisForNextSpin(history, simState, aiResult);
    if (!analysis) return;

    simState.analysis = analysis;
    simState.lastSignalSpinNumber = history[0]?.number ?? null;
    simState.lastSignalSpinId = history[0]?.id ?? null;
    simState.lastSignalSpinTimestamp = history[0]?.timestamp ?? null;

    // N7 usa signalsHistory.signals verificados
    const signal = {
        timestamp: history[0]?.timestamp ? new Date(history[0].timestamp).getTime() : Date.now(),
        patternType: 'nivel-diamante',
        patternName: 'SimulaÃ§Ã£o Diamante',
        colorRecommended: analysis.color,
        verified: false,
        colorThatCame: null,
        hit: null
    };
    if (simState.signalsHistory && Array.isArray(simState.signalsHistory.signals)) {
        simState.signalsHistory.signals.push(signal);
        if (simState.signalsHistory.signals.length > 200) {
            simState.signalsHistory.signals = simState.signalsHistory.signals.slice(-200);
        }
    }

    simState.totalSignals++;
}

function filterFinalEntries(entriesHistory) {
    const allEntries = Array.isArray(entriesHistory) ? entriesHistory : [];
    return allEntries.filter(e => {
        if (!e) return false;
        if (e.result === 'WIN') return true;
        if (e.result === 'LOSS') {
            if (e.finalResult === 'RET') return true;
            let isContinuing = false;
            for (let key in e) {
                if (key.startsWith('continuingToG')) {
                    isContinuing = true;
                    break;
                }
            }
            if (isContinuing) return false;
            return true;
        }
        return true;
    });
}

async function runDiamondPastSimulation({ config, mode, levelId, senderTabId, jobId, historyLimit }) {
    const job = diamondSimulationJobs.get(jobId);
    const requestedLimit = Number(historyLimit);
    const safeDefault = 1440; // padrÃ£o: 12h (2 giros/min)
    const availableHistory = Array.isArray(cachedHistory) ? cachedHistory.length : 0;
    const limit = (Number.isFinite(requestedLimit) && requestedLimit > 0)
        ? Math.min(requestedLimit, 10000, availableHistory || requestedLimit)
        : Math.min(safeDefault, availableHistory || safeDefault);

    const stableWindow = getStableChronologicalHistoryWindow({ limit, sourceHistory: Array.isArray(cachedHistory) ? cachedHistory : [] });
    const chronological = stableWindow.chronological;
    const totalSpins = chronological.length;

    const simConfigBase = config && typeof config === 'object' ? { ...config } : {};
    simConfigBase.aiMode = true;
    ensureMartingaleProfiles(simConfigBase);

    const simConfig = mode === 'level'
        ? {
            ...simConfigBase,
            diamondLevelEnabled: buildDiamondSingleLevelEnabledMap(levelId, simConfigBase.diamondLevelEnabled || {})
        }
        : simConfigBase;

    const simState = createDiamondSimulationState(simConfig);
    const simHistory = [];

    const fromTimestamp = chronological[0]?.timestamp || null;
    const toTimestamp = chronological[totalSpins - 1]?.timestamp || null;

    for (let i = 0; i < totalSpins; i++) {
        if (job && job.cancelled) {
            if (senderTabId != null) {
                try { chrome.tabs.sendMessage(senderTabId, { type: 'DIAMOND_SIMULATION_CANCELLED', data: { jobId } }); } catch (_) {}
            }
            return {
                cancelled: true,
                fromTimestamp,
                toTimestamp,
                totalSpins,
                requestedLimit,
                usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
                availableHistory: stableWindow.meta.availableHistory,
                uniqueHistory: stableWindow.meta.uniqueCount,
                droppedDuplicates: stableWindow.meta.droppedDuplicates,
                droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
                simState
            };
        }

        const spin = chronological[i];
        simHistory.unshift(spin);
        if (simHistory.length > limit) simHistory.pop();

        // 1) Avaliar anÃ¡lise pendente (giro atual resolve o sinal anterior)
        evaluatePendingAnalysisSimulation(spin, simState, 'diamond');

        // 2) Gerar sinal para o PRÃ“XIMO giro (sem ver o futuro)
        if (i < totalSpins - 1) {
            maybeGenerateDiamondAnalysisSimulation(simHistory, simState);
        }

        if (i % DIAMOND_SIMULATION_BATCH === 0 || i === totalSpins - 1) {
            try {
                // âœ… Enviar via runtime (nÃ£o depende de tabId). Quem nÃ£o for o job atual ignora pelo jobId.
                try {
                    chrome.runtime.sendMessage({
                        type: 'DIAMOND_SIMULATION_PROGRESS',
                        data: { jobId, processed: i + 1, total: totalSpins }
                    });
                } catch (_) {}
            } catch (_) {}
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    return {
        cancelled: false,
        fromTimestamp,
        toTimestamp,
        totalSpins,
        requestedLimit,
        usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
        availableHistory: stableWindow.meta.availableHistory,
        uniqueHistory: stableWindow.meta.uniqueCount,
        droppedDuplicates: stableWindow.meta.droppedDuplicates,
        droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
        simState
    };
}

// Listen for messages from popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    // Log removido: reduÃ§Ã£o de verbosidade
    
    if (request.action === 'start') {
        startDataCollection();
        sendResponse({status: 'started'});
        return true;
    } else if (request.action === 'stop') {
        stopDataCollection();
        sendResponse({status: 'stopped'});
        return true;
    } else if (request.action === 'status') {
        sendResponse({status: isRunning ? 'running' : 'stopped'});
        return true;
    } else if (request.action === 'SET_ANALYSIS_ENABLED') {
        (async () => {
            analysisEnabled = request.enabled !== false;
            console.log(`ğŸ”§ AnÃ¡lise ${analysisEnabled ? 'ativada' : 'pausada'} via UI`);
            
            if (!analysisEnabled) {
                await clearActiveAnalysisState('toggle_ui_off');
            } else if (cachedHistory && cachedHistory.length > 0) {
                runAnalysisIfEnabled(cachedHistory, 'TOGGLE_ON').catch((error) => {
                    console.error('âŒ Falha ao reativar anÃ¡lises apÃ³s toggle:', error);
                });
            }
            
            sendResponse({ status: 'ok', enabled: analysisEnabled });
        })();
        return true;
    } else if (request.action === 'GET_ANALYSIS_STATUS') {
        sendResponse({ status: 'ok', enabled: analysisEnabled });
        return true;
    } else if (request.action === 'GET_MEMORIA_ATIVA_STATUS') {
        // ğŸ§  Retornar status da memÃ³ria ativa para interface
        console.log('%cğŸ§  [BACKGROUND] RequisiÃ§Ã£o de status da memÃ³ria ativa recebida', 'color: #00CED1; font-weight: bold;');
        
        const statusResponse = {
            status: {
                inicializada: memoriaAtiva.inicializada,
                totalAtualizacoes: memoriaAtiva.totalAtualizacoes,
                tempoUltimaAtualizacao: memoriaAtiva.tempoUltimaAtualizacao,
                totalGiros: memoriaAtiva.giros.length,
                ultimaAtualizacao: memoriaAtiva.ultimaAtualizacao
            }
        };
        
        console.log('%cğŸ§  [BACKGROUND] Enviando resposta:', 'color: #00CED1;', statusResponse);
        
        sendResponse(statusResponse);
        return true;
    } else if (request.action === 'getFullHistory') {
        // ğŸ“‚ Retornar histÃ³rico completo para visualizaÃ§Ã£o do banco de padrÃµes
        console.log('%cğŸ“‚ [BACKGROUND] RequisiÃ§Ã£o de histÃ³rico completo recebida', 'color: #667eea; font-weight: bold;');
        console.log(`ğŸ“Š HistÃ³rico em cache: ${cachedHistory.length} giros`);
        
        sendResponse({ history: cachedHistory });
        return true;
	} else if (request.action === 'REQUEST_MODE_SNAPSHOT') {
		const contextLabel = request.reason ? `Solicitado (${request.reason})` : 'Solicitado pela UI';
		const snapshot = buildModeSnapshot(contextLabel, cachedHistory.length);
		sendMessageToContent('MODE_SNAPSHOT', snapshot);
		sendResponse({ status: 'ok', snapshot });
        return true;
    } else if (request.action === 'STANDARD_SIMULATE_PAST') {
        (async () => {
            try {
                const senderTabId = sender && sender.tab ? sender.tab.id : null;
                const config = request.config || {};
                const historyLimit = request.historyLimit;

                const requestedJobId = (typeof request.jobId === 'string' && request.jobId.trim())
                    ? request.jobId.trim()
                    : null;
                const jobId = requestedJobId || makeStandardSimulationJobId();
                standardSimulationJobs.set(jobId, { cancelled: false });

                const result = await runStandardPastSimulation({ config, senderTabId, jobId, historyLimit });
                standardSimulationJobs.delete(jobId);

                if (result.cancelled) {
                    sendResponse({ status: 'cancelled', jobId });
                    return;
                }

                const entries = result.simState.entriesHistory || [];
                const filtered = filterFinalEntries(entries);
                const wins = filtered.filter(e => e.result === 'WIN').length;
                const totalCycles = filtered.length;
                const losses = totalCycles - wins;
                const pct = totalCycles ? ((wins / totalCycles) * 100) : 0;

                sendResponse({
                    status: 'success',
                    jobId,
                    label: 'SimulaÃ§Ã£o â€¢ Premium',
                    entries,
                    stats: { wins, losses, totalCycles, pct: Number(pct.toFixed(1)) },
                    meta: {
                        totalSpins: result.totalSpins,
                        totalSignals: result.simState.totalSignals,
                        fromTimestamp: result.fromTimestamp,
                        toTimestamp: result.toTimestamp,
                        availableHistory: result.availableHistory,
                        uniqueHistory: result.uniqueHistory,
                        droppedDuplicates: result.droppedDuplicates,
                        droppedInvalidTs: result.droppedInvalidTs,
                        requestedHistoryLimit: result.requestedLimit,
                        usedHistoryLimit: result.usedHistoryLimit
                    }
                });
            } catch (e) {
                console.error('âŒ Falha na simulaÃ§Ã£o Premium (passado):', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'STANDARD_OPTIMIZE_PAST') {
        (async () => {
            try {
                const senderTabId = sender && sender.tab ? sender.tab.id : null;
                const config = request.config || {};
                const historyLimit = request.historyLimit;
                const trials = request.trials;

                const requestedJobId = (typeof request.jobId === 'string' && request.jobId.trim())
                    ? request.jobId.trim()
                    : null;
                const jobId = requestedJobId || makeStandardOptimizationJobId();
                standardOptimizationJobs.set(jobId, { cancelled: false });

                const result = await runStandardPastOptimization({ config, senderTabId, jobId, historyLimit, trials });
                standardOptimizationJobs.delete(jobId);

                if (result.cancelled) {
                    sendResponse({ status: 'cancelled', jobId });
                    return;
                }
                if (!result.bestEligible && !result.bestOverall) {
                    sendResponse({ status: 'error', jobId, error: 'Nenhuma configuraÃ§Ã£o elegÃ­vel encontrada' });
                    return;
                }

                const minPct = Number(result.minPct) || STANDARD_OPTIMIZATION_MIN_PCT_DEFAULT;
                const recommended = result.bestEligible || null;
                const overall = result.bestOverall || null;
                const payloadPick = recommended || overall;

                sendResponse({
                    status: 'success',
                    jobId,
                    trials: result.totalTrials,
                    minPct,
                    recommendedFound: !!recommended,
                    recommended: recommended ? {
                        score: Number(recommended.score.toFixed(2)),
                        pct: recommended.pct,
                        wins: recommended.wins,
                        losses: recommended.losses,
                        totalCycles: recommended.totalCycles,
                        totalSignals: recommended.totalSignals,
                        config: recommended.config
                    } : null,
                    bestOverall: overall ? {
                        score: Number(overall.score.toFixed(2)),
                        pct: overall.pct,
                        wins: overall.wins,
                        losses: overall.losses,
                        totalCycles: overall.totalCycles,
                        totalSignals: overall.totalSignals,
                        config: overall.config
                    } : null,
                    config: payloadPick ? payloadPick.config : null,
                    entries: payloadPick ? payloadPick.entries : [],
                    meta: {
                        totalSpins: result.totalSpins,
                        totalSignals: payloadPick ? payloadPick.totalSignals : 0,
                        fromTimestamp: result.fromTimestamp,
                        toTimestamp: result.toTimestamp,
                        availableHistory: result.availableHistory,
                        uniqueHistory: result.uniqueHistory,
                        droppedDuplicates: result.droppedDuplicates,
                        droppedInvalidTs: result.droppedInvalidTs,
                        requestedHistoryLimit: result.requestedLimit,
                        usedHistoryLimit: result.usedHistoryLimit
                    }
                });
            } catch (e) {
                console.error('âŒ Falha na otimizaÃ§Ã£o Premium (passado):', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'DIAMOND_SIMULATE_PAST') {
        (async () => {
            try {
                const senderTabId = sender && sender.tab ? sender.tab.id : null;
                const mode = request.mode === 'level' ? 'level' : 'all';
                const levelId = request.levelId || null;
                const config = request.config || {};
                const historyLimit = request.historyLimit;

                const requestedJobId = (typeof request.jobId === 'string' && request.jobId.trim())
                    ? request.jobId.trim()
                    : null;
                const jobId = requestedJobId || makeDiamondSimulationJobId();
                diamondSimulationJobs.set(jobId, { cancelled: false });

                const result = await runDiamondPastSimulation({ config, mode, levelId, senderTabId, jobId, historyLimit });
                diamondSimulationJobs.delete(jobId);

                if (result.cancelled) {
                    sendResponse({ status: 'cancelled', jobId });
                    return;
                }

                const entries = result.simState.entriesHistory || [];
                const filtered = filterFinalEntries(entries);
                const wins = filtered.filter(e => e.result === 'WIN').length;
                const totalCycles = filtered.length;
                const losses = totalCycles - wins;
                const pct = totalCycles ? ((wins / totalCycles) * 100) : 0;

                const label = mode === 'level' && levelId ? `SimulaÃ§Ã£o â€¢ ${levelId}` : 'SimulaÃ§Ã£o â€¢ Todos os nÃ­veis';

                sendResponse({
                    status: 'success',
                    jobId,
                    label,
                    entries,
                    stats: {
                        wins,
                        losses,
                        totalCycles,
                        pct: Number(pct.toFixed(1))
                    },
                    meta: {
                        totalSpins: result.totalSpins,
                        totalSignals: result.simState.totalSignals,
                        fromTimestamp: result.fromTimestamp,
                        toTimestamp: result.toTimestamp,
                        availableHistory: result.availableHistory,
                        uniqueHistory: result.uniqueHistory,
                        droppedDuplicates: result.droppedDuplicates,
                        droppedInvalidTs: result.droppedInvalidTs,
                        requestedHistoryLimit: result.requestedLimit,
                        usedHistoryLimit: result.usedHistoryLimit
                    }
                });
            } catch (e) {
                console.error('âŒ Falha na simulaÃ§Ã£o Diamante (passado):', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'DIAMOND_OPTIMIZE_PAST') {
        (async () => {
            try {
                const senderTabId = sender && sender.tab ? sender.tab.id : null;
                const levelId = request.levelId || null;
                if (!levelId) {
                    sendResponse({ status: 'error', error: 'levelId obrigatÃ³rio' });
                    return;
                }
                const config = request.config || {};
                const historyLimit = request.historyLimit;
                const trials = request.trials;

                const requestedJobId = (typeof request.jobId === 'string' && request.jobId.trim())
                    ? request.jobId.trim()
                    : null;
                const jobId = requestedJobId || makeDiamondOptimizationJobId();
                diamondOptimizationJobs.set(jobId, { cancelled: false });

                const result = await runDiamondPastOptimization({ config, levelId, senderTabId, jobId, historyLimit, trials });
                diamondOptimizationJobs.delete(jobId);

                if (result.cancelled) {
                    sendResponse({ status: 'cancelled', jobId });
                    return;
                }
                if (!result.bestEligible && !result.bestOverall) {
                    sendResponse({ status: 'error', jobId, error: 'Nenhuma configuraÃ§Ã£o elegÃ­vel encontrada' });
                    return;
                }

                const from = result.fromTimestamp;
                const to = result.toTimestamp;
                const minPct = Number(result.minPct) || DIAMOND_OPTIMIZATION_MIN_PCT_DEFAULT;
                const recommended = result.bestEligible || null;
                const overall = result.bestOverall || null;
                const payloadPick = recommended || overall;

                sendResponse({
                    status: 'success',
                    jobId,
                    levelId,
                    trials: result.totalTrials,
                    minPct,
                    recommendedFound: !!recommended,
                    recommended: recommended ? {
                        score: Number(recommended.score.toFixed(2)),
                        pct: recommended.pct,
                        wins: recommended.wins,
                        losses: recommended.losses,
                        totalCycles: recommended.totalCycles,
                        totalSignals: recommended.totalSignals,
                        config: recommended.config
                    } : null,
                    bestOverall: overall ? {
                        score: Number(overall.score.toFixed(2)),
                        pct: overall.pct,
                        wins: overall.wins,
                        losses: overall.losses,
                        totalCycles: overall.totalCycles,
                        totalSignals: overall.totalSignals,
                        config: overall.config
                    } : null,
                    // âœ… para renderizar a lista/grÃ¡fico: mostra o "recomendado" se existir; senÃ£o, a melhor encontrada (abaixo do mÃ­nimo)
                    config: payloadPick ? payloadPick.config : null,
                    entries: payloadPick ? payloadPick.entries : [],
                    meta: {
                        totalSpins: result.totalSpins,
                        totalSignals: payloadPick ? payloadPick.totalSignals : 0,
                        fromTimestamp: from,
                        toTimestamp: to,
                        availableHistory: result.availableHistory,
                        uniqueHistory: result.uniqueHistory,
                        droppedDuplicates: result.droppedDuplicates,
                        droppedInvalidTs: result.droppedInvalidTs,
                        requestedHistoryLimit: result.requestedLimit,
                        usedHistoryLimit: result.usedHistoryLimit
                    }
                });
            } catch (e) {
                console.error('âŒ Falha na otimizaÃ§Ã£o Diamante (passado):', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'DIAMOND_SIMULATE_CANCEL') {
        const jobId = request.jobId;
        if (jobId && diamondSimulationJobs.has(jobId)) {
            const job = diamondSimulationJobs.get(jobId);
            job.cancelled = true;
            diamondSimulationJobs.set(jobId, job);
            sendResponse({ status: 'ok', cancelled: true });
        } else {
            sendResponse({ status: 'ok', cancelled: false });
        }
        return true;
    } else if (request.action === 'STANDARD_SIMULATE_CANCEL') {
        const jobId = request.jobId;
        if (jobId && standardSimulationJobs.has(jobId)) {
            const job = standardSimulationJobs.get(jobId);
            job.cancelled = true;
            standardSimulationJobs.set(jobId, job);
            sendResponse({ status: 'ok', cancelled: true });
        } else {
            sendResponse({ status: 'ok', cancelled: false });
        }
        return true;
    } else if (request.action === 'DIAMOND_OPTIMIZE_CANCEL') {
        const jobId = request.jobId;
        if (jobId && diamondOptimizationJobs.has(jobId)) {
            const job = diamondOptimizationJobs.get(jobId);
            job.cancelled = true;
            diamondOptimizationJobs.set(jobId, job);
            sendResponse({ status: 'ok', cancelled: true });
        } else {
            sendResponse({ status: 'ok', cancelled: false });
        }
        return true;
    } else if (request.action === 'STANDARD_OPTIMIZE_CANCEL') {
        const jobId = request.jobId;
        if (jobId && standardOptimizationJobs.has(jobId)) {
            const job = standardOptimizationJobs.get(jobId);
            job.cancelled = true;
            standardOptimizationJobs.set(jobId, job);
            sendResponse({ status: 'ok', cancelled: true });
        } else {
            sendResponse({ status: 'ok', cancelled: false });
        }
        return true;
    } else if (request.action === 'applyConfig') {
        console.log('%câœ… ENTROU NO else if applyConfig!', 'color: #00FF00; font-weight: bold; font-size: 16px;');
        (async () => {
            try {
                console.log('%câœ… EXECUTANDO async function...', 'color: #00FF00; font-weight: bold;');
                // âœ… Usar CACHE EM MEMÃ“RIA (nÃ£o buscar de doubleHistory)
                const history = cachedHistory;
                
                const res = await chrome.storage.local.get(['analyzerConfig']);
                if (res && res.analyzerConfig) {
                    mergeAnalyzerConfig(res.analyzerConfig);
                }
                await enforceProfileGateOnAIMode('applyConfig');
                console.log('%câš™ï¸ Nova configuraÃ§Ã£o aplicada via UI:', 'color: #00D4FF; font-weight: bold;');
                console.log('%cğŸ“Š Profundidade de AnÃ¡lise: ' + (analyzerConfig.historyDepth || 2000) + ' giros', 'color: #00FF88; font-weight: bold; background: #003322; padding: 4px 8px; border-radius: 4px;');
                logActiveConfiguration();
                
                // âš ï¸ SÃ“ REANALISAR SE MODO IA ESTIVER ATIVO E HOUVER HISTÃ“RICO SUFICIENTE
                if (analyzerConfig.aiMode && history && history.length >= 10) {
                    if (!analysisEnabled) {
                        console.log('â¸ï¸ AnÃ¡lises pausadas â€“ ignorando reanÃ¡lise automÃ¡tica apÃ³s applyConfig.');
                    } else {
                    console.log('ğŸ“Š Reanalisando com', history.length, 'giros do cache...');
                    await runAnalysisController(history);
                    }
                } else {
                    if (!analyzerConfig.aiMode) {
                        console.log('â„¹ï¸ Modo IA desativado - nÃ£o reanalisando automaticamente');
                    } else if (!history || history.length < 10) {
                        console.log('â„¹ï¸ HistÃ³rico insuficiente para anÃ¡lise - mÃ­nimo 10 giros');
                    }
                }
                
                console.log('%câœ… CHAMANDO sendResponse com status: applied', 'color: #00FF00; font-weight: bold;');
                sendResponse({ status: 'applied' });
            } catch (e) {
                console.error('âŒ Falha ao aplicar configuraÃ§Ã£o:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        console.log('%câœ… RETORNANDO TRUE do listener!', 'color: #00FF00; font-weight: bold; font-size: 16px;');
        return true; // âš ï¸ CRÃTICO: Indicar que vamos responder assincronamente!
    } else if (request.action === 'showPatternStats') {
        // Exibir estatÃ­sticas do banco de padrÃµes
        (async () => {
            try {
                const db = await loadPatternDB();
                sendResponse({ status: 'shown', total: db.patterns_found ? db.patterns_found.length : 0 });
            } catch (e) {
                console.error('Erro ao exibir estatÃ­sticas:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true; // async response
    } else if (request.action === 'getObserverStats') {
        // Enviar estatÃ­sticas do observador inteligente
        const stats = getObserverStats();
        sendResponse({ status: 'success', stats: stats });
        return true;
    } else if (request.action === 'recalibrateObserver') {
        // Recalibrar observador manualmente (botÃ£o "Atualizar")
        console.log('ğŸ”„ RecalibraÃ§Ã£o manual do observador solicitada...');
        recalibrateConfidenceModel();
        const stats = getObserverStats();
        sendResponse({ status: 'success', stats: stats });
        // Enviar atualizaÃ§Ã£o para content.js
        sendObserverUpdate(true); // Mostrar log na recalibraÃ§Ã£o manual
        return true;
    } else if (request.action === 'FORCE_LOGOUT') {
        console.warn('%câš ï¸ [BACKGROUND] Logout forÃ§ado solicitado: ' + (request.reason || 'motivo nÃ£o informado'), 'color: #FF4444; font-weight: bold;');
        stopDataCollection();

        try {
            chrome.storage?.local?.remove(['authToken', 'user', 'lastAuthCheck'], () => {
                if (chrome.runtime?.lastError) {
                    console.warn('âš ï¸ [BACKGROUND] Erro ao limpar chrome.storage.local durante logout forÃ§ado:', chrome.runtime.lastError.message);
                } else {
                    console.log('%cğŸ§¹ [BACKGROUND] SessÃ£o removida do chrome.storage.local', 'color: #FF4444; font-weight: bold;');
                }
            });
        } catch (error) {
            console.error('âŒ [BACKGROUND] Falha ao remover sessÃ£o do chrome.storage.local:', error);
        }

        if (!forceLogoutTabOpened) {
            forceLogoutTabOpened = true;
            const loginUrl = chrome.runtime?.getURL ? chrome.runtime.getURL('auth.html') : 'auth.html';
            chrome.tabs.create({ url: loginUrl }, () => {
                setTimeout(() => { forceLogoutTabOpened = false; }, 2000);
            });
        }

        sendResponse({ status: 'logged_out' });
        return true;
    } else if (request.action === 'aiModeChanged') {
        // Modo IA foi alterado
        (async () => {
            try {
                console.log('%cğŸ”„ MUDANÃ‡A DE MODO DETECTADA!', 'color: #FFAA00; font-weight: bold; font-size: 14px;');
                
                const res = await chrome.storage.local.get(['analyzerConfig']);
                if (res && res.analyzerConfig) {
                    console.log('%cğŸ“¥ ConfiguraÃ§Ã£o lida do storage:', 'color: #00FFFF; font-weight: bold;');
                    console.log('%c   aiMode: ' + res.analyzerConfig.aiMode, 'color: #00FFFF; font-weight: bold; font-size: 13px;');
                    console.log('%c   minOccurrences: ' + res.analyzerConfig.minOccurrences, 'color: #00FFFF;');
                    
                    mergeAnalyzerConfig(res.analyzerConfig);
                    await enforceProfileGateOnAIMode('aiModeChanged');
                    
                    console.log('%cğŸ¤– Modo IA ' + (analyzerConfig.aiMode ? 'ATIVADO' : 'DESATIVADO'), 'color: ' + (analyzerConfig.aiMode ? '#00FF00' : '#FF6666') + '; font-weight: bold; font-size: 16px; background: ' + (analyzerConfig.aiMode ? '#003300' : '#330000') + '; padding: 5px;');
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // âœ… LIMPAR COMPLETAMENTE ANÃLISE ANTERIOR AO TROCAR DE MODO
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    console.log('%cğŸ—‘ï¸ LIMPANDO ANÃLISE ANTERIOR DO MODO ANTIGO...', 'color: #FF6666; font-weight: bold;');
                    
                    // 1. Limpar anÃ¡lise e padrÃ£o do storage
                    await chrome.storage.local.set({ 
                        analysis: null, 
                        pattern: null,
                        lastBet: null
                    });
                    console.log('   âœ… Storage limpo (analysis, pattern, lastBet)');
                    
                    // 2. Resetar estado do Martingale se houver
                    if (martingaleState.active) {
                        console.log('   âœ… Resetando Martingale ativo');
                        resetMartingaleState();
                        await chrome.storage.local.set({ martingaleState });
                    }
                    
                    // 3. Enviar mensagem para limpar UI no content.js
                    sendMessageToContent('CLEAR_ANALYSIS');
                    console.log('   âœ… UI limpa (mensagem CLEAR_ANALYSIS enviada)');
                    
                    // âœ… Se modo IA foi ATIVADO, marcar flag para aguardar 1 giro antes de enviar sinal
                    if (analyzerConfig.aiMode) {
                        aiModeJustActivated = true;
                        console.log('%câ³ MODO IA ATIVADO: Aguardando 1 giro antes de enviar primeiro sinal...', 'color: #FFAA00; font-weight: bold; font-size: 13px; background: #332200; padding: 5px;');
                    } else {
                        // Se desativou, limpar flag
                        aiModeJustActivated = false;
                        console.log('%câœ… MODO PADRÃƒO ATIVADO: Sistema pronto para anÃ¡lise...', 'color: #00FF00; font-weight: bold; font-size: 13px; background: #003300; padding: 5px;');
                    }
                    
                    logActiveConfiguration();
                    
                    // Executar nova anÃ¡lise se houver histÃ³rico (mas nÃ£o enviarÃ¡ sinal se aiModeJustActivated = true)
                    if (cachedHistory.length > 0) {
                        const executed = await runAnalysisIfEnabled(cachedHistory, 'MODE_CHANGE');
                        if (!executed) {
                            console.log('â¸ï¸ AnÃ¡lises pausadas â€“ mudanÃ§a de modo aguardarÃ¡ atÃ© reativaÃ§Ã£o.');
                        }
                    } else {
                        console.log('%câš ï¸ Nenhum histÃ³rico disponÃ­vel para anÃ¡lise', 'color: #FFAA00;');
                    }
                }
                sendResponse({ status: 'success' });
            } catch (e) {
                console.error('%câŒ Erro ao alterar modo IA:', 'color: #FF0000; font-weight: bold;', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'requestImmediateAnalysis') {
        // Solicitar anÃ¡lise imediata (para buscar padrÃ£o quente)
        console.log('ğŸ”¥ ANÃLISE IMEDIATA SOLICITADA PARA BUSCAR PADRÃƒO QUENTE');
        console.log(`ğŸ“Š HistÃ³rico disponÃ­vel: ${cachedHistory ? cachedHistory.length : 0} giros`);
        
        (async () => {
            try {
                if (!analysisEnabled) {
                    console.log('â¸ï¸ AnÃ¡lises pausadas â€“ ignorando requestImmediateAnalysis.');
                    sendResponse({ status: 'paused' });
                    return;
                }
                
                if (cachedHistory && cachedHistory.length > 0) {
                    console.log('âœ… Executando anÃ¡lise...');
                    const startTime = Date.now();
                    
                    await runAnalysisController(cachedHistory);
                    
                    const elapsed = Date.now() - startTime;
                    console.log(`âœ… AnÃ¡lise concluÃ­da em ${elapsed}ms`);
                    
                    sendResponse({ status: 'analyzed' });
                } else {
                    console.log('âš ï¸ Nenhum histÃ³rico disponÃ­vel para anÃ¡lise');
                    sendResponse({ status: 'no_history' });
                }
            } catch (e) {
                console.error('âŒ Erro ao executar anÃ¡lise imediata:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'clearEntriesAndObserver') {
        // Limpar histÃ³rico de entradas E calibrador (mantÃ©m sincronizado)
        (async () => {
            console.log('â•‘  ğŸ—‘ï¸ LIMPANDO ENTRADAS E CALIBRADOR                       â•‘');
            
            // Resetar observerData
            observerData = {
                entries: [],
                calibrationFactor: 1.0,
                lastCalibration: null,
                lastCalibratedCount: 0,
                stats: {
                    high: { predicted: 0, actual: 0, wins: 0, total: 0 },
                    medium: { predicted: 0, actual: 0, wins: 0, total: 0 },
                    low: { predicted: 0, actual: 0, wins: 0, total: 0 }
                }
            };
            
            // Salvar observerData resetado
            await saveObserverData(true); // Mostrar log
            
            console.log('âœ… Calibrador limpo e sincronizado com histÃ³rico de entradas');
            
            // Enviar atualizaÃ§Ã£o para UI
            sendObserverUpdate(true); // Mostrar log apÃ³s limpar
            
            sendResponse({ status: 'success', message: 'Entradas e calibrador limpos com sucesso!' });
        })();
        return true; // async response
    } else if (request.action === 'getDefaultPrompt') {
        // ğŸ”§ Retornar o prompt padrÃ£o para visualizaÃ§Ã£o
        try {
            const historyLength = request.historyLength || 50;
            const historyText = request.historyText || '(exemplo de histÃ³rico)';
            const defaultPrompt = DEFAULT_AI_PROMPT(historyLength, historyText);
            sendResponse({ status: 'success', prompt: defaultPrompt });
        } catch (e) {
            console.error('âŒ Erro ao buscar prompt padrÃ£o:', e);
            sendResponse({ status: 'error', error: String(e) });
        }
        return true;
    } else if (request.action === 'startPatternSearch') {
        console.log('%câœ… ENTROU NO else if startPatternSearch!', 'color: #00FFFF; font-weight: bold; font-size: 16px;');
        // Iniciar busca manual de padrÃµes (30s)
        (async () => {
            try {
                console.log('%cğŸ” Iniciando busca manual de padrÃµes...', 'color: #00FFFF; font-weight: bold;');
                // Verificar se jÃ¡ estÃ¡ buscando
                if (initialSearchActive) {
                    console.log('%câš ï¸ Busca jÃ¡ estÃ¡ ativa!', 'color: #FFAA00; font-weight: bold;');
                    sendResponse({ status: 'already_running' });
                    return;
                }
                
                // âœ… Usar CACHE EM MEMÃ“RIA (mais rÃ¡pido) ou buscar do servidor se vazio
                let historyToAnalyze = cachedHistory;
                
                if (!historyToAnalyze || historyToAnalyze.length < 50) {
                    console.log('ğŸ“¥ Cache vazio, buscando histÃ³rico do servidor...');
                    const serverGiros = await fetchGirosFromAPI();
                    
                    if (!serverGiros || serverGiros.length < 50) {
                        sendResponse({ status: 'insufficient_data', message: `HistÃ³rico insuficiente (<50 giros). Atual: ${serverGiros ? serverGiros.length : 0}` });
                        return;
                    }
                    
                    historyToAnalyze = serverGiros;
                    cachedHistory = serverGiros; // Atualizar cache
                }
                
                // âœ… APLICAR PROFUNDIDADE DE ANÃLISE CONFIGURADA PELO USUÃRIO
                const configuredDepth = analyzerConfig.historyDepth || 2000;
                const actualDepth = Math.min(configuredDepth, historyToAnalyze.length);
                historyToAnalyze = historyToAnalyze.slice(0, actualDepth);
                
                console.log(`%câœ… Iniciando busca de padrÃµes com ${historyToAnalyze.length} giros`, 'color: #00FF88; font-weight: bold;');
                console.log(`%cğŸ“Š Profundidade configurada: ${configuredDepth} giros`, 'color: #00D4FF; font-weight: bold; background: #002244; padding: 2px 6px;');
                
                await clearPatternDiscoveryCutoffFlag();
                
                // âœ… PASSO 1: LIMPAR O BANCO DE PADRÃ•ES
                await clearAllPatterns();
                
                // âœ… VERIFICAR SE REALMENTE ZEROU (DEBUG)
                const dbCheck = await chrome.storage.local.get(['patternDB']);
                const totalAfterClear = dbCheck.patternDB?.patterns_found?.length || 0;
                console.log('%cğŸ” VERIFICAÃ‡ÃƒO PÃ“S-LIMPEZA:', 'color: #FF00FF; font-weight: bold;');
                console.log(`   PadrÃµes no banco: ${totalAfterClear}`);
                
                // âœ… PASSO 2: NOTIFICAR UI IMEDIATAMENTE QUE O BANCO ESTÃ ZERADO (0/5000)
                sendMessageToContent('PATTERN_BANK_UPDATE', { total: totalAfterClear });
                console.log(`%cğŸ—‘ï¸ Banco zerado na UI (${totalAfterClear}/5000)`, 'color: #FF6600; font-weight: bold;');
                
                // âœ… PASSO 3: Aguardar um pouco para garantir que a UI foi atualizada
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // âœ… PASSO 4: Iniciar busca de 30s (isso enviarÃ¡ INITIAL_SEARCH_START)
                await startInitialPatternSearch(historyToAnalyze);
                
                sendResponse({ status: 'started', historySize: historyToAnalyze.length });
            } catch (e) {
                console.error('Erro ao iniciar busca de padrÃµes:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        console.log('%câœ… RETORNANDO TRUE do startPatternSearch!', 'color: #00FFFF; font-weight: bold; font-size: 16px;');
        return true; // async response
    } else if (request.action === 'resetPatterns') {
        console.log('%câœ… ENTROU NO else if resetPatterns!', 'color: #00FF00; font-weight: bold; font-size: 16px;');
        // Resetar/Limpar TUDO: padrÃµes E anÃ¡lise pendente
        (async () => {
            try {
                console.log('%cğŸ—‘ï¸ Executando limpeza de padrÃµes...', 'color: #FFAA00; font-weight: bold;');
                // Parar busca se estiver em andamento
                if (initialSearchActive) {
                    console.log('â¸ï¸ Parando busca ativa...');
                    stopInitialPatternSearch();
                }
                
                // Limpar TUDO (padrÃµes + anÃ¡lise pendente)
                await clearAllPatternsAndAnalysis();
                
                console.log('âœ… Reset completo realizado manualmente pelo usuÃ¡rio.');
                sendResponse({ status: 'success', message: 'PadrÃµes e anÃ¡lise pendente resetados com sucesso!' });
            } catch (e) {
                console.error('Erro ao resetar padrÃµes:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        console.log('%câœ… RETORNANDO TRUE do resetPatterns!', 'color: #00FF00; font-weight: bold; font-size: 16px;');
        return true; // async response
    } else {
        // Log removido: nÃ£o Ã© necessÃ¡rio avisar sobre aÃ§Ãµes nÃ£o correspondidas
    }
});

// âœ… INICIAR APENAS SE HOUVER ABA DA BLAZE ABERTA
(async function initExtension() {
    
    const hasBlaze = await hasBlazeTabOpen();
    
    if (hasBlaze) {
        console.log('â•‘  âœ… ABA DA BLAZE ENCONTRADA - INICIANDO EXTENSÃƒO         â•‘');
startDataCollection();
    } else {
        console.log('â•‘  âš ï¸ NENHUMA ABA DA BLAZE ABERTA                          â•‘');
        console.log('â•‘  ğŸ’¡ Abra blaze.com para ativar a extensÃ£o                â•‘');
    }
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ LISTENER PARA MUDANÃ‡AS NAS CONFIGURAÃ‡Ã•ES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Detecta quando o usuÃ¡rio altera as configuraÃ§Ãµes e atualiza a variÃ¡vel global
chrome.storage.onChanged.addListener((changes, areaName) => {
    if (areaName === 'local' && changes.analyzerConfig) {
        const newConfig = changes.analyzerConfig.newValue;
        if (newConfig) {
            // âœ… ATUALIZAR CONFIGURAÃ‡Ã•ES
            mergeAnalyzerConfig(newConfig);
            
            // âœ… MOSTRAR LOG COMPLETO DAS NOVAS CONFIGURAÃ‡Ã•ES
            console.log('â•‘  ğŸ”„ CONFIGURAÃ‡Ã•ES ATUALIZADAS EM TEMPO REAL!             â•‘');
            
            // âœ… EXIBIR TODAS AS CONFIGURAÃ‡Ã•ES USANDO A FUNÃ‡ÃƒO logActiveConfiguration
            logActiveConfiguration();
            
            console.log('âœ… Novas configuraÃ§Ãµes aplicadas com sucesso!');
            console.log('â„¹ï¸  As regras jÃ¡ estÃ£o ativas - nÃ£o precisa recarregar a extensÃ£o');
        }
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“± LISTENERS DE VISIBILIDADE - Critical para mobile/desktop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detectar quando usuÃ¡rio volta para uma aba da Blaze (mobile/desktop)
chrome.tabs.onActivated.addListener(async (activeInfo) => {
    try {
        const tab = await chrome.tabs.get(activeInfo.tabId);
        
        if (tab.url && (tab.url.includes('blaze.com') || tab.url.includes('blaze.bet.br'))) {
            console.log('%câ•‘  ğŸ“± USUÃRIO VOLTOU PARA ABA DA BLAZE                     â•‘', 'color: #00FFFF; font-weight: bold;');
            
            // âœ… Verificar se WebSocket estÃ¡ conectado
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.warn('âš ï¸ WebSocket desconectado. Reconectando...');
                connectWebSocket();
            }
            
            // âœ… ForÃ§ar busca imediata de dados para garantir que estÃ¡ atualizado
            console.log('ğŸ”„ Buscando dados mais recentes...');
            await collectDoubleData();
            
            // âœ… Resetar timer de Ãºltimo dado recebido
            lastDataReceived = Date.now();
        }
    } catch (error) {
        // Ignorar erros silenciosamente (tab pode ter sido fechada)
    }
});

// Detectar quando uma aba da Blaze Ã© atualizada/recarregada
chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
    try {
        // SÃ³ processar quando a pÃ¡gina terminou de carregar
        if (changeInfo.status === 'complete' && tab.url && (tab.url.includes('blaze.com') || tab.url.includes('blaze.bet.br'))) {
            console.log('%câ•‘  ğŸ”„ ABA DA BLAZE RECARREGADA                             â•‘', 'color: #00FFFF; font-weight: bold;');
            console.log('%câ•‘  Reconectando sistemas...                               â•‘', 'color: #00FFFF;');
            
            // âœ… Aguardar 2 segundos para pÃ¡gina estabilizar
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // âœ… Verificar se WebSocket estÃ¡ conectado
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.warn('âš ï¸ WebSocket desconectado apÃ³s recarregar pÃ¡gina. Reconectando...');
                connectWebSocket();
            }
            
            // âœ… ForÃ§ar busca imediata de dados
            console.log('ğŸ”„ Sincronizando dados apÃ³s reload...');
            await collectDoubleData();
            
            // âœ… Resetar timer
            lastDataReceived = Date.now();
        }
    } catch (error) {
        // Ignorar erros silenciosamente
    }
});

console.log('%câœ… Listeners de visibilidade instalados!', 'color: #00FF88; font-weight: bold;');
console.log('%c   - DetectarÃ¡ quando usuÃ¡rio voltar para aba da Blaze', 'color: #00FF88;');
console.log('%c   - ReconectarÃ¡ automaticamente se necessÃ¡rio', 'color: #00FF88;');
console.log('%c   - Critical para funcionamento no mobile', 'color: #00FF88;');


