// Background service worker for Blaze Double Analyzer

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§¹ LIMPEZA AUTOMÃTICA DO CONSOLE - REMOVIDA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Removido a pedido do usuÃ¡rio - logs nÃ£o serÃ£o mais limpos automaticamente

const originalBackgroundConsoleLog = console.log.bind(console);

const LOG_STYLE = Object.freeze({
    banner: 'color:#0D47A1;font-weight:bold;font-size:14px;',
    section: 'color:#1565C0;font-weight:bold;',
    info: 'color:#37474F;',
    value: 'color:#1B5E20;font-weight:bold;',
    warn: 'color:#E65100;font-weight:bold;',
    error: 'color:#B71C1C;font-weight:bold;',
    divider: 'color:#B0BEC5;'
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’ ADMIN VISIBILITY (Diamond Levels)
// - Controle global: quais nÃ­veis aparecem no site e podem rodar.
// - Fonte de verdade: GET /api/site/diamond-levels (pÃºblico) + cache local.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const DIAMOND_VISIBLE_LEVELS_KEY = 'da_diamond_visible_levels_v1';
let diamondAdminVisibleLevels = null; // { n0: true, ... } | null
let diamondAdminVisibleLevelsUpdatedAt = 0;

function normalizeDiamondVisibleLevelsMap(raw) {
    const base = {};
    try {
        (Array.isArray(DIAMOND_LEVEL_IDS) ? DIAMOND_LEVEL_IDS : []).forEach((id) => {
            const k = getDiamondLevelKeyFromId(id);
            if (k) base[k] = true;
        });
    } catch (_) {}

    if (Array.isArray(raw)) {
        const set = new Set(raw.map((v) => String(v || '').toLowerCase().trim()).filter(Boolean));
        Object.keys(base).forEach((k) => { base[k] = set.has(k); });
        return base;
    }

    if (raw && typeof raw === 'object') {
        Object.keys(base).forEach((k) => {
            if (Object.prototype.hasOwnProperty.call(raw, k)) {
                base[k] = !!raw[k];
            }
        });
        return base;
    }

    return base;
}

async function loadDiamondVisibleLevelsConfig() {
    // Preferir chrome.storage.local (extensÃ£o). Fallback: localStorage (web).
    try {
        if (typeof chrome !== 'undefined' && chrome.storage?.local?.get) {
            const result = await new Promise((resolve) => chrome.storage.local.get([DIAMOND_VISIBLE_LEVELS_KEY], resolve));
            return result && result[DIAMOND_VISIBLE_LEVELS_KEY] ? result[DIAMOND_VISIBLE_LEVELS_KEY] : null;
        }
    } catch (_) {}

    try {
        const raw = localStorage.getItem(DIAMOND_VISIBLE_LEVELS_KEY);
        return raw ? JSON.parse(raw) : null;
    } catch (_) {
        return null;
    }
}

async function saveDiamondVisibleLevelsConfig(levels) {
    try {
        if (typeof chrome !== 'undefined' && chrome.storage?.local?.set) {
            await new Promise((resolve) => chrome.storage.local.set({ [DIAMOND_VISIBLE_LEVELS_KEY]: levels }, resolve));
        }
    } catch (_) {}

    try {
        localStorage.setItem(DIAMOND_VISIBLE_LEVELS_KEY, JSON.stringify(levels));
    } catch (_) {}
}

async function fetchDiamondVisibleLevelsFrom(origin) {
    try {
        const url = `${origin}/api/site/diamond-levels`;
        const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
        const timeoutId = controller ? setTimeout(() => controller.abort(), 5000) : null;
        const resp = await fetch(url, controller
            ? { cache: 'no-store', signal: controller.signal }
            : { cache: 'no-store' }
        ).finally(() => { if (timeoutId) clearTimeout(timeoutId); });
        if (!resp || !resp.ok) return null;
        const data = await resp.json().catch(() => null);
        if (!data || !data.success) return null;
        const normalized = normalizeDiamondVisibleLevelsMap(data.levels);
        return normalized;
    } catch (_) {
        return null;
    }
}

async function refreshDiamondVisibleLevelsFromServer() {
    try {
        const cachedUrls = await loadUrlsConfig().catch(() => null);
        const candidates = getCandidateAuthOrigins(cachedUrls);
        const primary = normalizeOrigin(API_CONFIG.authURL);
        const ordered = primary ? [primary, ...candidates] : candidates;

        for (const origin of ordered) {
            const levels = await fetchDiamondVisibleLevelsFrom(origin);
            if (levels && typeof levels === 'object') {
                diamondAdminVisibleLevels = levels;
                diamondAdminVisibleLevelsUpdatedAt = Date.now();
                await saveDiamondVisibleLevelsConfig(levels);
                return levels;
            }
        }
    } catch (_) {}
    return null;
}

function isDiamondLevelVisibleByAdmin(levelId) {
    try {
        const key = getDiamondLevelKeyFromId(levelId);
        if (!key) return true;
        const map = diamondAdminVisibleLevels && typeof diamondAdminVisibleLevels === 'object'
            ? diamondAdminVisibleLevels
            : null;
        if (map && Object.prototype.hasOwnProperty.call(map, key)) {
            return !!map[key];
        }
        return true; // default: visÃ­vel
    } catch (_) {
        return true;
    }
}

function logBanner(message) {
    originalBackgroundConsoleLog(`%c${message}`, LOG_STYLE.banner);
}

function logSection(message) {
    originalBackgroundConsoleLog(`%c${message}`, LOG_STYLE.section);
}

function logInfo(label, value) {
    originalBackgroundConsoleLog(`%câ€¢ ${label}: %c${value}`, LOG_STYLE.info, LOG_STYLE.value);
}

function logDivider() {
    originalBackgroundConsoleLog('%c------------------------------------------------------------', LOG_STYLE.divider);
}

function getGaleSummary() {
    const martingaleSettings = getMartingaleSettings();
    if (martingaleState.active) {
        return `Ativo â€¢ fase ${martingaleState.stage} (${martingaleState.entryColor || '-'})`;
    }
    if (martingaleSettings.maxGales > 0) {
        return `Configurado â€¢ atÃ© ${martingaleSettings.maxGales} gale(s)`;
    }
    return 'Desativado';
}

function getDiamondConfigSnapshot() {
    const userDiamondWindows = analyzerConfig.diamondLevelWindows || {};
    const getValue = (key, fallback) => {
        const raw = Number(userDiamondWindows[key]);
        return Number.isFinite(raw) && raw > 0 ? raw : fallback;
    };
    return [
        ['N0', `Hist ${getValue('n0History', N0_DEFAULTS.historySize)} | W ${getDiamondWindow('n0Window', N0_DEFAULTS.windowSize)} | BlockAll ${analyzerConfig.n0AllowBlockAll !== false ? 'sim' : 'nÃ£o'}`],
        ['N1', `W ${getDiamondWindow('n1WindowSize', SAFE_ZONE_DEFAULTS.windowSize)} | minA ${getDiamondWindow('n1PrimaryRequirement', SAFE_ZONE_DEFAULTS.primaryRequirement)} | minB ${getDiamondWindow('n1SecondaryRequirement', SAFE_ZONE_DEFAULTS.secondaryRequirement)}`],
        ['N2', `Janela base ${getDiamondWindow('n2Recent', 10)} (auto)`],
        ['N3', `Prof ${getDiamondWindow('n3Alternance', 2000)} | Rigor ${getDiamondWindow('n3BaseThresholdPct', 60)}% | minOcc ${getDiamondWindow('n3MinOccurrences', 3)}`],
        ['N4', `Hist ${getDiamondWindow('n4Persistence', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence)}`],
        ['N5', `${getDiamondWindow('n5MinuteBias', 60)} amostras`],
        ['N6', `${getDiamondWindow('n6RetracementWindow', 80)} giros`],
        ['N7', `Dec ${getDiamondWindow('n7DecisionWindow', 20)} | Hist ${getDiamondWindow('n7HistoryWindow', 100)}`],
        ['N8', `Hist ${getDiamondWindow('n10History', 500)} | W ${getDiamondWindow('n10Window', 20)}`],
        ['N9', `${getDiamondWindow('n8Barrier', 50)} giros`],
        ['N10', `Hist ${getDiamondWindow('n9History', 100)} | Î”${getDiamondWindow('n9NullThreshold', 8)}%`]
    ];
}

function logModeSnapshot(contextLabel = 'Contexto atual', historyLength = cachedHistory.length) {
    const modeLabel = analyzerConfig.aiMode ? 'Modo Diamante' : 'Modo PadrÃ£o';
    logDivider();
    logSection(`[${contextLabel}] ${modeLabel}`);
    logInfo('Giros disponÃ­veis', historyLength || 'N/A');
    logInfo('Controle de gale', getGaleSummary());
    logInfo('ProteÃ§Ã£o no Branco', analyzerConfig.whiteProtectionAsWin ? 'Ativa' : 'Desativada');
    if (analyzerConfig.aiMode) {
        if (memoriaAtiva.inicializada) {
            const tempoDecorrido = Math.round((Date.now() - memoriaAtiva.ultimaAtualizacao) / 1000);
            logInfo('MemÃ³ria IA', `Ativa â€¢ ${memoriaAtiva.totalAtualizacoes} atualizaÃ§Ãµes â€¢ ${memoriaAtiva.tempoUltimaAtualizacao.toFixed(1)}ms â€¢ hÃ¡ ${tempoDecorrido}s`);
        } else {
            logInfo('MemÃ³ria IA', 'Inicializando...');
        }
    } else {
        logInfo('Min. ocorrÃªncias', analyzerConfig.minOccurrences || 1);
    }
    if (analyzerConfig.aiMode) {
        getDiamondConfigSnapshot().forEach(([label, detail]) => logInfo(label, detail));
    }
    logDivider();
    emitModeSnapshotToContent(contextLabel, historyLength);
}

const DEFAULT_AUTOBET_CONFIG = Object.freeze({
    enabled: false,
    simulationOnly: true,
    baseStake: 2,
    galeMultiplier: 2,
    delayMs: 1500,
    stopWin: 0,
    stopLoss: 0,
    simulationBankRoll: 5000,
    whitePayoutMultiplier: 14,
    // âœ… Branco (config exclusiva)
    // - whiteMaxGales: 0..200 (0 = somente 1 entrada)
    // - whiteGaleMode: 'double' (dobrar) | 'same' (manter)
    whiteMaxGales: 2,
    whiteGaleMode: 'double'
});

function buildDiamondLevelSummaries() {
    const list = getDiamondConfigSnapshot();
    // âœ… Admin visibility: nÃ£o enviar nÃ­veis ocultos para a UI do site
    const visible = list.filter(([label]) => isDiamondLevelVisibleByAdmin(label));
    return visible.map(([label, detail]) => {
        const id = label;
        return {
            id,
            enabled: isDiamondLevelEnabled(label),
            detail
        };
    });
}

function buildModeSnapshot(contextLabel = 'Contexto atual', historyLength = cachedHistory.length) {
    const aiModeActive = !!(analyzerConfig && analyzerConfig.aiMode);
    const snapshot = {
        context: contextLabel,
        timestamp: Date.now(),
        aiMode: aiModeActive,
        modeLabel: aiModeActive ? 'AnÃ¡lise Diamante' : 'Modo PadrÃ£o',
        historyAvailable: historyLength || 0,
    signalIntensity: analyzerConfig.signalIntensity || 'aggressive',
        galeSummary: getGaleSummary(),
        galeSettings: getMartingaleSettings(),
        galeState: {
            active: martingaleState.active,
            stage: martingaleState.stage,
            entryColor: martingaleState.entryColor
        },
        whiteProtectionAsWin: !!analyzerConfig.whiteProtectionAsWin
    };

    if (aiModeActive) {
        snapshot.memoriaAtiva = getMemoriaAtivaStatus();
        snapshot.enabledDiamondLevels = countEnabledDiamondLevels();
        snapshot.diamondLevels = buildDiamondLevelSummaries();
    } else {
        snapshot.standardConfig = {
            historyDepth: analyzerConfig.historyDepth,
            minOccurrences: analyzerConfig.minOccurrences,
            maxOccurrences: analyzerConfig.maxOccurrences,
            minIntervalSpins: analyzerConfig.minIntervalSpins,
            minPatternSize: analyzerConfig.minPatternSize,
            maxPatternSize: analyzerConfig.maxPatternSize,
            winPercentOthers: analyzerConfig.winPercentOthers
        };
    }

    return snapshot;
}

function emitModeSnapshotToContent(contextLabel = 'Contexto atual', historyLength = cachedHistory.length) {
    try {
        const snapshot = buildModeSnapshot(contextLabel, historyLength);
        sendMessageToContent('MODE_SNAPSHOT', snapshot);
    } catch (error) {
        console.warn('NÃ£o foi possÃ­vel emitir MODE_SNAPSHOT para content:', error);
    }
}

const BOX_CHAR_PREFIXES = ['%câ•‘', '%câ•”', '%câ•š', '%câ•', '%câ–ˆâ–ˆâ–ˆâ–ˆ'];
const ENABLE_LEGACY_LOGS = false;
console.log = (...args) => {
    const first = args[0];
    if (typeof first === 'string') {
        if (BOX_CHAR_PREFIXES.some(prefix => first.startsWith(prefix)) && !ENABLE_LEGACY_LOGS) {
            return;
        }
    }
    if (ENABLE_LEGACY_LOGS) {
        originalBackgroundConsoleLog(...args);
    }
};

let isRunning = false;
let analysisEnabled = true;
let intervalId = null;
let forceLogoutTabOpened = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ›Ÿ RECUPERAÃ‡ÃƒO (novo) â€” ativaÃ§Ã£o manual via UI
// - Quando ativo, o sistema filtra e sÃ³ envia sinal quando atingir alta certeza.
// - ApÃ³s WIN do sinal de recuperaÃ§Ã£o, desativa automaticamente.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const RECOVERY_MODE_KEY = 'recoveryMode';
// âœ… Persistir o Ãºltimo ciclo de RecuperaÃ§Ã£o (por modo) para a UI exibir na aba "RecuperaÃ§Ã£o"
// mesmo apÃ³s auto-desativar (WIN) ou refresh.
const LAST_RECOVERY_ENTRY_BY_MODE_KEY = 'lastRecoveryEntryByMode';
let recoveryModeEnabled = false;
// HistÃ³rico interno (fase 1 "silenciosa") usado para calcular o ponto seguro da RecuperaÃ§Ã£o.
// NÃƒO Ã© exibido na aba IA; serve apenas como base de anÃ¡lise para "RecuperaÃ§Ã£o segura".
const RECOVERY_SECURE_HISTORY_KEY = 'recoverySecureHistory';
// âœ… RecuperaÃ§Ã£o (fase 2): NÃƒO usa %confidence do sinal.
// A liberaÃ§Ã£o Ã© baseada na leitura do histÃ³rico de CICLOS (distÃ¢ncia entre LOSS/RED + hazard),
// buscando um "momento seguro" com baixa previsÃ£o de LOSS.
const RECOVERY_MIN_CYCLES = 20;

// âœ… UI feedback (RecuperaÃ§Ã£o): mostrar por que ainda nÃ£o liberou sinal
let lastRecoveryGateStatusByMode = { standard: '', diamond: '' };
let lastRecoveryGateStatusSentAtByMode = { standard: 0, diamond: 0 };
const RECOVERY_GATE_STATUS_THROTTLE_MS = 2500;

function emitRecoveryGateStatus(modeRaw, textRaw) {
    try {
        if (!recoveryModeEnabled) return;
        const mode = String(modeRaw || '').toLowerCase().trim() === 'diamond' ? 'diamond' : 'standard';
        const nextText = (typeof textRaw === 'string') ? textRaw : '';
        const now = Date.now();
        const prevText = lastRecoveryGateStatusByMode && lastRecoveryGateStatusByMode[mode] ? lastRecoveryGateStatusByMode[mode] : '';
        const prevAt = Number(lastRecoveryGateStatusSentAtByMode && lastRecoveryGateStatusSentAtByMode[mode]) || 0;

        // throttle: sÃ³ enviar se mudou OU se passou um tempo mÃ­nimo
        if (nextText === prevText && (now - prevAt) < RECOVERY_GATE_STATUS_THROTTLE_MS) {
            return;
        }

        lastRecoveryGateStatusByMode = { ...(lastRecoveryGateStatusByMode || {}), [mode]: nextText };
        lastRecoveryGateStatusSentAtByMode = { ...(lastRecoveryGateStatusSentAtByMode || {}), [mode]: now };

        try {
            sendMessageToContent('RECOVERY_MODE_UPDATE', {
                enabled: true,
                statusText: nextText
            });
        } catch (_) {}
    } catch (_) {}
}

function computeRecoveryGateFromEntries(entriesHistoryRaw, modeRaw) {
    try {
        const mode = normalizeMasterMode(modeRaw);
        const list = Array.isArray(entriesHistoryRaw) ? entriesHistoryRaw : [];
        const hasExplicitMode = list.some(e => e && (e.analysisMode === 'diamond' || e.analysisMode === 'standard'));
        const inMode = (e) => resolveEntryModeMaster(e, hasExplicitMode) === mode;
        const finalsRecentFirst = list.filter(e => inMode(e) && isFinalCycleMaster(e));
        const cyclesChron = finalsRecentFirst.slice().reverse(); // cronolÃ³gico (antigo â†’ recente)
        const totalCycles = cyclesChron.length;
        if (totalCycles < RECOVERY_MIN_CYCLES) {
            return {
                ok: false,
                reason: `Coletando histÃ³rico (${totalCycles}/${RECOVERY_MIN_CYCLES})`,
                stats: { totalCycles }
            };
        }

        const isLossFinal = (e) => {
            if (!e || typeof e !== 'object') return false;
            const r = String(e.result || '').toUpperCase().trim();
            if (r !== 'LOSS') return false;
            const fr = String(e.finalResult || '').toUpperCase().trim();
            if (fr === 'RED' || fr === 'RET') return true;
            // LOSS sem flags de continuaÃ§Ã£o -> tratar como final (sem gales)
            return !hasContinuationFlagMaster(e);
        };

        const lossIdx = [];
        for (let i = 0; i < cyclesChron.length; i++) {
            if (isLossFinal(cyclesChron[i])) lossIdx.push(i);
        }
        const losses = lossIdx.length;
        const sinceLoss = losses ? (totalCycles - lossIdx[lossIdx.length - 1]) : null;
        const winsSinceLoss = losses
            ? Math.max(0, (totalCycles - 1) - lossIdx[lossIdx.length - 1])
            : null;

        if (losses < 2 || sinceLoss == null) {
            return {
                ok: false,
                reason: `Base insuficiente de LOSS (${losses}/2)`,
                stats: { totalCycles, losses, sinceLoss }
            };
        }

        // gaps entre LOSS (cronolÃ³gico)
        const gaps = [];
        for (let i = 1; i < lossIdx.length; i++) {
            const g = Math.floor(lossIdx[i] - lossIdx[i - 1]);
            if (Number.isFinite(g) && g > 0) gaps.push(g);
        }
        // gaps em "vitÃ³rias entre LOSS" (mais intuitivo p/ UI)
        const lossWinGaps = gaps.map(g => Math.max(0, g - 1));

        const hazardAt = (arr, d) => {
            const dist = Math.floor(Number(d));
            if (!Number.isFinite(dist) || dist <= 0) return null;
            const gs = Array.isArray(arr) ? arr.map(Number).filter(n => Number.isFinite(n) && n > 0).map(n => Math.floor(n)) : [];
            if (!gs.length) return null;
            let at = 0;
            let ge = 0;
            for (const g of gs) {
                if (g >= dist) ge++;
                if (g === dist) at++;
            }
            if (ge <= 0) return null;
            return at / ge;
        };

        // targets (gaps mais provÃ¡veis)
        const freq = new Map();
        for (const g of gaps) freq.set(g, (freq.get(g) || 0) + 1);
        const totalGaps = gaps.length || 0;
        const sorted = Array.from(freq.entries())
            .map(([gap, count]) => ({ gap, count, prob: totalGaps ? (count / totalGaps) : 0 }))
            .sort((a, b) => (b.count - a.count) || (a.gap - b.gap));

        const retTopN = 5;
        const retMinCount = 2;
        const retMinSupport = 0.12;
        const strict = sorted
            .filter(it => it.count >= retMinCount && it.prob >= retMinSupport)
            .slice(0, retTopN)
            .map(it => it.gap);
        const retTargets = strict.length ? strict : sorted.slice(0, retTopN).map(it => it.gap);

        const lossHazardNow = hazardAt(gaps, sinceLoss);
        const baselineLossRate = totalCycles > 0 ? (losses / totalCycles) : 0;
        const hazardBlockAbove = 0.12;
        const hazardBlockAboveEffective = Math.max(0.02, Math.min(hazardBlockAbove, baselineLossRate * 0.55));
        const retAvoidWindow = 0; // evitar coincidÃªncia exata
        const nearLossZone = (sinceLoss != null && retTargets.length)
            ? retTargets.some(t => Math.abs(sinceLoss - t) <= retAvoidWindow)
            : false;

        // Regra dinÃ¢mica pÃ³s-LOSS: se jÃ¡ houve 2+ LOSS seguidos no histÃ³rico, apÃ³s 1 LOSS aguardar 1 ciclo
        const computeMaxLossStreak = (arr) => {
            let max = 0;
            let cur = 0;
            for (const c of arr) {
                if (isLossFinal(c)) { cur++; if (cur > max) max = cur; }
                else cur = 0;
            }
            return max;
        };
        const maxLossStreakHist = computeMaxLossStreak(cyclesChron);
        let minAfterLoss = maxLossStreakHist <= 1 ? 1 : 2;

        // âœ… Regra mais previsÃ­vel (pedido do usuÃ¡rio):
        // usar mÃ©dia de distÃ¢ncia entre LOSS para definir um "ponto seguro" mÃ­nimo,
        // e evitar apenas as distÃ¢ncias mais tÃ­picas de LOSS (retTargets).
        const avgGap = gaps.length ? (gaps.reduce((acc, n) => acc + n, 0) / gaps.length) : null;
        let safeDistance = minAfterLoss;
        if (avgGap != null && Number.isFinite(avgGap) && avgGap > 0) {
            // fraÃ§Ã£o conservadora da mÃ©dia; cap para nÃ£o "travar" em gaps grandes
            safeDistance = Math.max(minAfterLoss, Math.max(1, Math.round(avgGap * 0.4)));
            safeDistance = Math.min(safeDistance, 12);
        }
        const signalsUntilSafe = (sinceLoss != null) ? Math.max(0, safeDistance - sinceLoss) : null;
        const postLossOk = sinceLoss >= safeDistance;

        const ok = !!(postLossOk && !nearLossZone);
        const hzTxt = (lossHazardNow != null) ? `${Math.round(lossHazardNow * 100)}%` : 'â€”';
        const reason = ok
            ? `OK â€¢ distLOSS=${sinceLoss} â€¢ seguroâ‰¥${safeDistance} â€¢ hazardâ‰ˆ${hzTxt}`
            : (!postLossOk
                ? `Aguardando dist seguro â€¢ distLOSS=${sinceLoss} (mÃ­n ${safeDistance})`
                : `Bloqueado â€¢ zona tÃ­pica de LOSS (distLOSS=${sinceLoss} em [${retTargets.join(',') || 'â€”'}])`);

        return {
            ok,
            reason,
            stats: {
                totalCycles,
                losses,
                sinceLoss,
                winsSinceLoss,
                lossWinGaps: lossWinGaps.slice(-12),
                retTargets,
                lossHazardNow,
                hazardBlockAboveEffective,
                avgGap,
                safeDistance,
                signalsUntilSafe
            }
        };
    } catch (e) {
        return { ok: false, reason: `Erro ao avaliar recuperaÃ§Ã£o: ${String(e)}`, stats: {} };
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’¾ CACHE EM MEMÃ“RIA (nÃ£o persiste apÃ³s recarregar)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const REALTIME_HISTORY_CAP = 10000;
let cachedHistory = [];  // HistÃ³rico de giros em memÃ³ria (atÃ© 10k)
let historyInitialized = false;  // Flag de inicializaÃ§Ã£o

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§Š BOOTSTRAP ROBUSTO (WEB): cold start do servidor pode retornar vazio/timeout
// - Antes: um timeout marcava historyInitialized=true com cache vazio â†’ nunca mais tentava.
// - Agora: timeout maior no bootstrap + retry com backoff atÃ© conseguir histÃ³rico.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BOOTSTRAP_HISTORY_TIMEOUT_MS = 45000; // tolera cold start / payload grande
const IS_WEB_RUNTIME = (() => {
    try {
        return typeof window !== 'undefined' && typeof document !== 'undefined';
    } catch (_) {
        return false;
    }
})();
let historyBootstrapRetryTimer = null;
let historyBootstrapRetryMs = 0;
let historyBootstrapInFlight = false;

function clearHistoryBootstrapRetry() {
    if (historyBootstrapRetryTimer) {
        try { clearTimeout(historyBootstrapRetryTimer); } catch (_) {}
    }
    historyBootstrapRetryTimer = null;
    historyBootstrapRetryMs = 0;
}

function scheduleHistoryBootstrapRetry(reason = 'unknown') {
    // Retry agressivo sÃ³ no runtime WEB (no service worker da extensÃ£o evitamos loops de fetch 10k).
    if (!IS_WEB_RUNTIME) return;
    if (historyBootstrapInFlight) return;
    if (historyBootstrapRetryTimer) return;

    // backoff: 2.5s â†’ 5s â†’ 10s â†’ 20s â†’ 40s â†’ 60s (cap)
    historyBootstrapRetryMs = historyBootstrapRetryMs > 0
        ? Math.min(60000, Math.floor(historyBootstrapRetryMs * 2))
        : 2500;

    console.warn(`ğŸ§Š [BOOTSTRAP] HistÃ³rico indisponÃ­vel. Retry em ${Math.round(historyBootstrapRetryMs / 1000)}s. Motivo: ${reason}`);
    try { sendAnalysisStatus('â³ Inicializando... aguardando servidor'); } catch (_) {}

    historyBootstrapRetryTimer = setTimeout(async () => {
        historyBootstrapRetryTimer = null;
        historyBootstrapInFlight = true;
        try {
            const ok = await initializeHistoryIfNeeded(true).catch(() => false);
            if (!ok) {
                historyBootstrapInFlight = false;
                scheduleHistoryBootstrapRetry('retry_failed');
                return;
            }
            // Se conseguiu histÃ³rico, tentar rodar anÃ¡lise imediatamente (sem depender de novo giro)
            try {
                if (analysisEnabled && cachedHistory && cachedHistory.length >= 10) {
                    await runAnalysisIfEnabled(cachedHistory, 'BOOTSTRAP_RETRY');
                }
            } catch (_) {}
            historyBootstrapInFlight = false;
        } catch (_) {
            historyBootstrapInFlight = false;
            scheduleHistoryBootstrapRetry('retry_exception');
        }
    }, historyBootstrapRetryMs);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  MEMÃ“RIA ATIVA - SISTEMA INCREMENTAL DE ANÃLISE
// Sistema inteligente que mantÃ©m anÃ¡lises prÃ©-calculadas em memÃ³ria
// Atualiza apenas o delta (novo giro) ao invÃ©s de recalcular tudo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let memoriaAtiva = {
    // ğŸ“Š STATUS
    inicializada: false,
    ultimaAtualizacao: null,
    versao: 1,
    
    // ğŸ“œ HISTÃ“RICO (mÃ­n. 2000 â€¢ atÃ© 10k conforme configuraÃ§Ã£o)
    giros: [],
    ultimos20: [],
    
    // ğŸ¯ PADRÃ•ES PRÃ‰-DETECTADOS (cache)
    padroesDetectados: {
        alternanciaSimples: [],
        alternanciasDupla: [],
        alternanciasTripla: [],
        sequenciasRed: [],
        sequenciasBlack: []
    },
    
    // ğŸ“Š ESTATÃSTICAS PRÃ‰-CALCULADAS
    estatisticas: {
        totalGiros: 0,
        distribuicao: {
            red: { count: 0, percent: 0 },
            black: { count: 0, percent: 0 },
            white: { count: 0, percent: 0 }
        },
        // EstatÃ­sticas por tipo de padrÃ£o
        porPadrao: {}
    },
    
    // ğŸ¯ PADRÃƒO ATIVO ATUAL
    padraoAtual: null,
    
    // ğŸ“ˆ PERFORMANCE
    tempoInicializacao: 0,
    tempoUltimaAtualizacao: 0,
    totalAtualizacoes: 0
};

const PATTERN_DISCOVERY_CUTOFF_KEY = 'patternDiscoveryCutoff';
let patternDiscoveryCutoff = null;

async function loadPatternDiscoveryCutoffFlag() {
    try {
        const stored = await chrome.storage.local.get([PATTERN_DISCOVERY_CUTOFF_KEY]);
        patternDiscoveryCutoff = stored[PATTERN_DISCOVERY_CUTOFF_KEY] || null;
    } catch (error) {
        console.warn('âš ï¸ Erro ao carregar patternDiscoveryCutoff:', error);
        patternDiscoveryCutoff = null;
    }
}

async function setPatternDiscoveryCutoffFlag(timestamp = Date.now()) {
    patternDiscoveryCutoff = timestamp;
    try {
        await chrome.storage.local.set({ [PATTERN_DISCOVERY_CUTOFF_KEY]: timestamp });
    } catch (error) {
        console.warn('âš ï¸ NÃ£o foi possÃ­vel salvar patternDiscoveryCutoff:', error);
    }
}

async function clearPatternDiscoveryCutoffFlag() {
    patternDiscoveryCutoff = null;
    try {
        await chrome.storage.local.remove(PATTERN_DISCOVERY_CUTOFF_KEY);
    } catch (error) {
        console.warn('âš ï¸ NÃ£o foi possÃ­vel limpar patternDiscoveryCutoff:', error);
    }
}

function getSpinTimestampMs(spin) {
    if (!spin) return null;
    const candidates = [spin.timestamp, spin.created_at, spin.createdAt];
    for (const value of candidates) {
        if (value) {
            const parsed = Date.parse(value);
            if (!Number.isNaN(parsed)) {
                return parsed;
            }
        }
    }
    if (typeof spin.time === 'number') return spin.time;
    return null;
}

function filterHistoryByResetCutoff(history) {
    if (!patternDiscoveryCutoff || !Array.isArray(history)) {
        return history;
    }
    return history.filter(spin => {
        const ts = getSpinTimestampMs(spin);
        return ts ? ts >= patternDiscoveryCutoff : false;
    });
}

loadPatternDiscoveryCutoffFlag();

let memoriaAtivaInicializando = false;  // Flag para evitar inicializaÃ§Ãµes simultÃ¢neas

// Runtime analyzer configuration (overridable via chrome.storage.local)
// âœ… CONFIGURAÃ‡Ã•ES PADRÃƒO OTIMIZADAS (Modo de AnÃ¡lise PadrÃ£o do Sistema)
const DEFAULT_ANALYZER_CONFIG = {
    // âœ… Defaults oficiais do Premium (mesmos do botÃ£o "Redefinir configuraÃ§Ãµes" no site)
    historyDepth: 3000,           // profundidade de anÃ¡lise em giros (100-10000) - MODO PADRÃƒO
    minOccurrences: 2,            // âœ… quantidade mÃ­nima de WINS exigida (padrÃ£o: 2) - MODO PADRÃƒO
    maxOccurrences: 0,            // âœ… quantidade MÃXIMA de ocorrÃªncias (0 = sem limite)
    minIntervalSpins: 2,          // âœ… intervalo mÃ­nimo em GIROS entre OCORRÃŠNCIAS do MESMO padrÃ£o (modo padrÃ£o)
    minPatternSize: 4,            // âœ… tamanho MÃNIMO do padrÃ£o (giros)
    maxPatternSize: 0,            // âœ… tamanho MÃXIMO do padrÃ£o (0 = sem limite)
    winPercentOthers: 100,        // âœ… WIN% mÃ­nima para as ocorrÃªncias restantes (100% = apenas padrÃµes perfeitos)
    requireTrigger: true,         // âœ… exigir cor de disparo (ATIVADO)
    consecutiveMartingale: false, // âœ… Legado: valor do modo ativo (mantido para compatibilidade)
    maxGales: 0,                  // âœ… Legado: valor do modo ativo (mantido para compatibilidade)
    n0AllowBlockAll: true,        // âœ… Permite bloqueio total pelo detector de branco (modo informativo se false)
    martingaleProfiles: {         // âœ… Perfis independentes por modo
        // consecutiveGales = quantos gales sÃ£o IMEDIATOS (consecutivos) antes de passar a esperar novo sinal
        // Ex.: maxGales=2 e consecutiveGales=1 => G1 imediato, G2 sÃ³ no prÃ³ximo sinal
        // âœ… Default desejado (print): maxGales=2 e gales consecutivos atÃ© G2 (vale para TODOS os modos)
        standard: { maxGales: 2, consecutiveMartingale: true, consecutiveGales: 2 },
        diamond: { maxGales: 2, consecutiveMartingale: true, consecutiveGales: 2 }
    },
    telegramChatId: '',           // Chat ID do Telegram para enviar sinais
    aiMode: false,                // Modo Diamante (true) ou Modo PadrÃ£o (false)
    signalIntensity: 'aggressive',  // Intensidade de sinais: 'aggressive' ou 'conservative'
    whiteProtectionAsWin: false,  // ProteÃ§Ã£o no Branco (autoaposta): ativa/desativada (NÃƒO conta como acerto da previsÃ£o)
    autoBetConfig: DEFAULT_AUTOBET_CONFIG,
    diamondLevelWindows: {        // ConfiguraÃ§Ã£o dos nÃ­veis do modo Diamante
        n1WindowSize: 20,         // N1 - Zona Segura (tamanho da janela)
        n1PrimaryRequirement: 15, // N1 - Zona Segura (requisito mÃ­nimo A)
        n1SecondaryRequirement: 3,// N1 - Zona Segura (requisito mÃ­nimo B)
        n1MaxEntries: 1,          // N1 - Zona Segura (entradas consecutivas permitidas)
        n2Recent: 10,             // N2 - Ritmo AutÃ´nomo (janela base W)
        n2Previous: 10,           // N2 - (legado) espelha W por compatibilidade
        n3Alternance: 2000,       // N3 - AlternÃ¢ncia (profundidade do histÃ³rico em giros)
        n3PatternLength: 10,      // (LEGADO) N3 - AlternÃ¢ncia (janela anterior) â€” nÃ£o usado
        n3MinOccurrences: 3,      // N3 - AlternÃ¢ncia (ocorrÃªncias mÃ­nimas do padrÃ£o no histÃ³rico)
        n3BaseThresholdPct: 60,   // N3 - AlternÃ¢ncia (rigor): probabilidade mÃ­nima do PRÃ“XIMO GIRO, em %
        n3ThresholdPct: 75,       // (LEGADO) N3 - AlternÃ¢ncia (rigor da janela) â€” nÃ£o usado
        n3AllowBackoff: false,    // N3 - AlternÃ¢ncia (tentar janelas menores se nÃ£o houver dados)
        n3IgnoreWhite: false,     // N3 - AlternÃ¢ncia (ignorar previsÃµes de branco)
        n4Persistence: 500,       // N4 - Autointeligente (histÃ³rico analisado em giros) âœ… default oficial (print)
        n4DynamicGales: true,     // N4 - Permitir mudar a cor no Gale (G1/G2) quando estiver rodando "somente N4"
        n5MinuteBias: 60,         // N5 - Ritmo por Giro / Minuto
        n6RetracementWindow: 80,  // N6 - RetraÃ§Ã£o HistÃ³rica (janela de anÃ¡lise)
        n7DecisionWindow: 20,     // N7 - Continuidade Global (decisÃµes analisadas)
        n7HistoryWindow: 100,     // N7 - Continuidade Global (histÃ³rico base)
        n0History: 2000,          // N0 - Detector de Branco (histÃ³rico analisado)
        n0Window: 100,            // N0 - Detector de Branco (tamanho da janela nÃ£o-sobreposta)
        n8Barrier: 50,            // N9 - Barreira Final (mantido como n8Barrier por compatibilidade)
        n9History: 100,           // N9 - CalibraÃ§Ã£o Bayesiana (histÃ³rico base)
        n9NullThreshold: 8,       // N9 - CalibraÃ§Ã£o Bayesiana (diferenÃ§a mÃ­nima em % para votar)
        n9PriorStrength: 1,       // N9 - CalibraÃ§Ã£o Bayesiana (forÃ§a do prior Dirichlet)
        // N10 - Walk-forward NÃ£o-Sobreposto (janela em giros e histÃ³rico base)
        n10Window: 20,            // Tamanho da janela NÃƒO-SOBREPOSTA (W)
        n10History: 500,          // Quantidade de giros usados no walk-forward
        n10Analyses: 600,         // Quantidade alvo de estratÃ©gias/variaÃ§Ãµes testadas
        n10MinWindows: 8,         // NÃºmero mÃ­nimo de janelas com prediÃ§Ã£o para ser elegÃ­vel
        n10ConfMin: 60            // ConfianÃ§a mÃ­nima global (%) para N10 votar
    },
    diamondLevelEnabled: {        // Controle individual dos 11 nÃ­veis (todos ativos por padrÃ£o)
        n0: true,
        n1: true,
        n2: true,
        n3: true,
        n4: true,
        n5: true,
        n6: true,
        n7: true,
        n8: true,  // N8 - Walk-forward nÃ£o-sobreposto
        n9: true,  // N9 - Barreira Final
        n10: true  // N10 - CalibraÃ§Ã£o Bayesiana
    }
};

const DIAMOND_LEVEL_IDS = Object.freeze(['N0', 'N1', 'N2', 'N3', 'N4', 'N5', 'N6', 'N7', 'N8', 'N9', 'N10']);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ‘‘ SINAL DE ENTRADA (FASE 2) - CUT OFF
// A UI usa cutoffs para "Limpar" sem apagar fisicamente o entriesHistory:
// - entriesClearCutoffByMode: Limpar da ABA IA (base histÃ³rica)  âœ… ESTE Ã© o que afeta a FASE 2
// - masterEntriesClearCutoffByMode: Limpar da ABA SINAIS (apenas visual/lista/graph/bets) âŒ nÃ£o deve afetar a FASE 2
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ENTRIES_CLEAR_CUTOFF_KEY = 'entriesClearCutoffByMode';

function getEntryTimestampMsForHistory(entry) {
    try {
        // âœ… IA Bootstrap: manter timestamp real, mas usar visibleAtTimestamp para cutoff/visibilidade.
        const t = (entry && entry.visibleAtTimestamp != null)
            ? entry.visibleAtTimestamp
            : (entry && entry.timestamp != null ? entry.timestamp : null);
        if (t == null) return 0;
        const ms = (typeof t === 'number') ? t : Date.parse(String(t));
        return Number.isFinite(ms) ? ms : 0;
    } catch (_) {
        return 0;
    }
}

function getMasterCutoffMsForMode(cutoffByModeRaw, modeRaw) {
    const mode = String(modeRaw || '').toLowerCase().trim() === 'diamond' ? 'diamond' : 'standard';
    const obj = cutoffByModeRaw && typeof cutoffByModeRaw === 'object' ? cutoffByModeRaw : null;
    if (!obj) return 0;
    const raw = obj[mode];
    const ms = Number(raw);
    return Number.isFinite(ms) ? ms : 0;
}

function filterEntriesHistoryByCutoff(entriesHistoryRaw, cutoffMs) {
    const list = Array.isArray(entriesHistoryRaw) ? entriesHistoryRaw : [];
    const c = Number(cutoffMs);
    if (!Number.isFinite(c) || c <= 0) return list;
    // âœ… OtimizaÃ§Ã£o: entriesHistory Ã© newest-first; parar assim que cruzar o cutoff (evita varrer histÃ³rico enorme)
    const out = [];
    let prevTs = Infinity;
    let monotonic = true;
    for (let i = 0; i < list.length; i++) {
        const e = list[i];
        const ts = getEntryTimestampMsForHistory(e);
        if (!Number.isFinite(ts) || ts <= 0) {
            // comportamento anterior: ts invÃ¡lido seria filtrado fora (0 < cutoff)
            continue;
        }
        if (ts > prevTs + 2000) {
            // timestamps fora de ordem â†’ nÃ£o podemos fazer early-break com seguranÃ§a
            monotonic = false;
        }
        prevTs = ts;
        if (ts < c) {
            if (monotonic) break;
            continue;
        }
        out.push(e);
    }
    return out;
}

const SAFE_ZONE_DEFAULTS = Object.freeze({
    windowSize: DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n1WindowSize,
    primaryRequirement: DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n1PrimaryRequirement,
    secondaryRequirement: DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n1SecondaryRequirement,
    maxEntries: DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n1MaxEntries
});

function analyzeSafeZone(history, options = {}) {
    const colorPriority = ['black', 'red', 'white'];
    const windowSize = Math.max(5, Math.min(options.windowSize || SAFE_ZONE_DEFAULTS.windowSize, history.length));
    const minPrimary = Math.max(1, options.minPrimary || SAFE_ZONE_DEFAULTS.primaryRequirement);
    const minSecondary = Math.max(1, options.minSecondary || SAFE_ZONE_DEFAULTS.secondaryRequirement);
    const windowSpins = history.slice(0, windowSize);
    const counts = { red: 0, black: 0, white: 0 };
    windowSpins.forEach(spin => {
        if (spin && counts.hasOwnProperty(spin.color)) {
            counts[spin.color]++;
        }
    });

    const result = {
        windowSize,
        minPrimary,
        minSecondary,
        counts,
        dominant: null,
        secondary: null,
        lastColor: windowSpins[0]?.color || history[0]?.color || null,
        zoneActive: false,
        signal: false,
        strength: 0,
        reason: 'req_not_met'
    };

    if (windowSpins.length < windowSize) {
        result.reason = 'insufficient_history';
        return result;
    }

    const eligibleDominants = colorPriority
        .filter(color => counts[color] >= minPrimary)
        .sort((a, b) => {
            if (counts[b] === counts[a]) {
                return colorPriority.indexOf(a) - colorPriority.indexOf(b);
            }
            return counts[b] - counts[a];
        });

    if (!eligibleDominants.length) {
        return result;
    }

    result.dominant = eligibleDominants[0];

    const secondaryCandidates = colorPriority
        .filter(color => color !== result.dominant && counts[color] >= minSecondary)
        .sort((a, b) => counts[b] - counts[a]);

    if (!secondaryCandidates.length) {
        return result;
    }

    result.secondary = secondaryCandidates[0];
    result.zoneActive = true;
    result.strength = Math.min(1, counts[result.dominant] / windowSize);

    if (result.lastColor === result.dominant) {
        result.signal = true;
        result.reason = 'zone_active_last_is_dominant';

        // âœ… NOVO FILTRO FLEXÃVEL (N1):
        // - Permitir entradas mesmo se as Ãºltimas 2 ou 3 forem a dominante (ex.: RR ou RRR),
        //   mas SEMPRE evitando entrar no "topo" da sequÃªncia.
        // - A zona segura decide atÃ© onde "vai" olhando o histÃ³rico *dentro da prÃ³pria janela*:
        //   se a zona sÃ³ tem sequÃªncias de atÃ© 2/3, nÃ£o tentar 3â†’4; se tem atÃ© 4, permitir 3â†’4 etc.
        // - O N9 (Barreira Final) continua sendo o veto final de viabilidade histÃ³rica global.
        const recentColor = result.dominant;
        let recentStreak = 0;
        for (let i = 0; i < history.length; i++) {
            const c = history[i]?.color;
            if (!c) break;
            if (c === recentColor) recentStreak++;
            else break;
        }
        result.recentStreak = recentStreak;

        // Calcular o maior tamanho de sequÃªncia da dominante dentro da janela da zona (exclui brancos como continuidade).
        let dominantRunMax = 0;
        let curLen = 0;
        for (let i = 0; i < windowSpins.length; i++) {
            const c = windowSpins[i]?.color;
            if (c === recentColor) {
                curLen++;
                if (curLen > dominantRunMax) dominantRunMax = curLen;
            } else {
                curLen = 0;
            }
        }
        result.dominantRunMax = dominantRunMax;

        // Regra principal: sÃ³ sinaliza se a prÃ³xima sequÃªncia (recentStreak+1) estiver "dentro do que a zona jÃ¡ mostrou".
        // Ex.: se max na zona Ã© 3, permitir 1â†’2 e 2â†’3, mas bloquear 3â†’4.
        const nextTargetStreak = recentStreak + 1;
        result.nextTargetStreak = nextTargetStreak;
        if (dominantRunMax < 2) {
            result.signal = false;
            result.reason = 'zone_no_pairs';
        } else if (nextTargetStreak > dominantRunMax) {
            result.signal = false;
            result.reason = 'zone_run_limit';
        }
    } else {
        result.signal = false;
        result.reason = 'last_not_dominant';
    }

    return result;
}

function getSafeZoneSettingsFromAnalyzerConfig() {
    const windows = analyzerConfig?.diamondLevelWindows || {};
    let windowSize = Number(windows.n1WindowSize) || SAFE_ZONE_DEFAULTS.windowSize;
    let minPrimary = Number(windows.n1PrimaryRequirement) || SAFE_ZONE_DEFAULTS.primaryRequirement;
    let minSecondary = Number(windows.n1SecondaryRequirement) || SAFE_ZONE_DEFAULTS.secondaryRequirement;
    let maxEntries = Number(windows.n1MaxEntries) || SAFE_ZONE_DEFAULTS.maxEntries;

    windowSize = Math.max(5, Math.min(200, windowSize));
    minPrimary = Math.max(1, Math.min(windowSize - 1, minPrimary));
    minSecondary = Math.max(1, Math.min(minPrimary - 1, minSecondary));
    maxEntries = Math.max(1, Math.min(20, Math.floor(maxEntries)));

    return {
        windowSize,
        minPrimary,
        minSecondary,
        maxEntries
    };
}

let safeZoneEntryState = {
    signature: null,
    entriesUsed: 0
};

function buildSafeZoneSignature(meta) {
    if (!meta || !meta.dominant) return null;
    return `${meta.dominant}-${meta.secondary || 'none'}-${meta.windowSize}`;
}

function describeSafeZoneReason(reason) {
    switch (reason) {
        case 'insufficient_history':
            return 'HistÃ³rico insuficiente';
        case 'last_not_dominant':
            return 'Ãšltima cor nÃ£o confirma a dominante';
        case 'entry_limit_reached':
            return 'Limite de entradas atingido';
        case 'zone_active_last_is_dominant':
            return 'Zona confirmada';
        case 'zone_no_pairs':
            return 'Zona sem duplas (max=1)';
        case 'zone_run_limit':
            return 'Bloqueado: topo da sequÃªncia na zona';
        case 'req_not_met':
        default:
            return 'Requisitos mÃ­nimos nÃ£o atendidos';
    }
}

function getDiamondLevelKeyFromId(levelId = '') {
    return String(levelId).toLowerCase();
}

function isDiamondLevelEnabled(levelId, config = analyzerConfig) {
    // ğŸ”’ Admin: se o nÃ­vel estiver oculto globalmente, ele NÃƒO pode rodar/exibir.
    if (!isDiamondLevelVisibleByAdmin(levelId)) return false;
    const key = getDiamondLevelKeyFromId(levelId);
    const enabledMap = config && config.diamondLevelEnabled ? config.diamondLevelEnabled : DEFAULT_ANALYZER_CONFIG.diamondLevelEnabled;
    if (enabledMap && Object.prototype.hasOwnProperty.call(enabledMap, key)) {
        return !!enabledMap[key];
    }
    return true;
}

function countEnabledDiamondLevels(config = analyzerConfig) {
    return DIAMOND_LEVEL_IDS.reduce((sum, id) => sum + (isDiamondLevelEnabled(id, config) ? 1 : 0), 0);
}

function sanitizeMaxGales(value, fallback = 0) {
    const numeric = Number(value);
    if (!Number.isFinite(numeric)) {
        const fallbackNumeric = Number(fallback);
        return Math.max(0, Math.min(200, Number.isFinite(fallbackNumeric) ? Math.floor(fallbackNumeric) : 0));
    }
    return Math.max(0, Math.min(200, Math.floor(numeric)));
}

function getMartingaleStageNumber(stage) {
    const s = String(stage || '').toUpperCase().trim();
    if (!s || s === 'ENTRADA' || s === 'G0') return 0;
    const m = s.match(/^G(\d+)$/);
    if (!m) return 0;
    const n = Number(m[1]);
    return Number.isFinite(n) && n >= 0 ? n : 0;
}

function roundMoney(value) {
    const n = Number(value);
    return Number.isFinite(n) ? Number(n.toFixed(2)) : 0;
}

function snapshotAutoBetConfig(config = analyzerConfig) {
    try {
        return sanitizeAutoBetConfig(config && config.autoBetConfig ? config.autoBetConfig : null);
    } catch (_) {
        return sanitizeAutoBetConfig(null);
    }
}

function getPayoutMultiplierForBetColor(betColor, autoBetCfg) {
    const c = String(betColor || '').toLowerCase();
    if (c === 'white' || c === 'branco') {
        const wm = Number(autoBetCfg && autoBetCfg.whitePayoutMultiplier);
        return Math.max(2, Number.isFinite(wm) ? wm : 14);
    }
    return 2;
}

function getGaleMultiplierForBetColor(betColor, autoBetCfg) {
    const c = String(betColor || '').toLowerCase();
    const cfg = autoBetCfg && typeof autoBetCfg === 'object' ? autoBetCfg : snapshotAutoBetConfig();
    if (c === 'white' || c === 'branco') {
        return normalizeWhiteGaleMode(cfg.whiteGaleMode) === 'same' ? 1 : 2;
    }
    const m = Number(cfg.galeMultiplier);
    return Math.max(1, Number.isFinite(m) ? m : 2);
}

function calcStakeForStage(stageLabel, autoBetCfg) {
    const cfg = autoBetCfg && typeof autoBetCfg === 'object' ? autoBetCfg : snapshotAutoBetConfig();
    const base = Math.max(0.01, Number(cfg.baseStake) || 0.01);
    const mult = Math.max(1, Number(cfg.galeMultiplier) || 1);
    const k = getMartingaleStageNumber(stageLabel);
    return roundMoney(base * Math.pow(mult, k));
}

function calcTotalInvestedThroughStage(stageLabel, autoBetCfg) {
    const cfg = autoBetCfg && typeof autoBetCfg === 'object' ? autoBetCfg : snapshotAutoBetConfig();
    const base = Math.max(0.01, Number(cfg.baseStake) || 0.01);
    const mult = Math.max(1, Number(cfg.galeMultiplier) || 1);
    const k = getMartingaleStageNumber(stageLabel);
    let sum = 0;
    for (let i = 0; i <= k; i++) {
        sum += base * Math.pow(mult, i);
    }
    return roundMoney(sum);
}

function ensureMartingaleCycleConfig(autoBetCfg, betColor = null) {
    try {
        const cfg = autoBetCfg && typeof autoBetCfg === 'object' ? autoBetCfg : snapshotAutoBetConfig();
        if (!martingaleState || typeof martingaleState !== 'object') return cfg;
        if (!martingaleState.cycleAutoBetConfig || typeof martingaleState.cycleAutoBetConfig !== 'object') {
            const entryColor = betColor || martingaleState.entryColor || null;
            martingaleState.cycleAutoBetConfig = {
                baseStake: Number(cfg.baseStake) || 0,
                galeMultiplier: getGaleMultiplierForBetColor(entryColor, cfg),
                whitePayoutMultiplier: Number(cfg.whitePayoutMultiplier) || 14
            };
        }
        return martingaleState.cycleAutoBetConfig;
    } catch (_) {
        return snapshotAutoBetConfig();
    }
}

function isMartingaleStageConsecutive(stage, consecutiveGales) {
    const k = getMartingaleStageNumber(stage);
    const limit = Math.max(0, Number(consecutiveGales) || 0);
    return k > 0 && k <= limit;
}

function ensureMartingaleProfiles(config) {
    if (!config) return;
    const defaults = DEFAULT_ANALYZER_CONFIG.martingaleProfiles || {};
    if (!config.martingaleProfiles || typeof config.martingaleProfiles !== 'object') {
        config.martingaleProfiles = {};
    }
    ['standard', 'diamond'].forEach(mode => {
        const profile = config.martingaleProfiles[mode] || {};
        const defaultProfile = defaults[mode] || { maxGales: 0, consecutiveMartingale: false, consecutiveGales: 0 };
        const inheritedMax = profile.maxGales != null ? profile.maxGales : config.maxGales;
        const inheritedConsecutive = profile.consecutiveMartingale != null ? profile.consecutiveMartingale : config.consecutiveMartingale;

        const maxGales = sanitizeMaxGales(inheritedMax, defaultProfile.maxGales);

        // âœ… consecutiveGales: 0..maxGales
        // - se vier no profile, respeitar (com clamp)
        // - senÃ£o, compat com boolean antigo: consecutiveMartingale=true => todos os gales consecutivos
        const rawConsecutiveGales =
            profile.consecutiveGales != null
                ? Number(profile.consecutiveGales)
                : (typeof inheritedConsecutive === 'boolean' && inheritedConsecutive ? maxGales : 0);
        const consecutiveGales = Math.max(0, Math.min(maxGales, Math.floor(Number.isFinite(rawConsecutiveGales) ? rawConsecutiveGales : 0)));

        // âœ… Mantido por compatibilidade: agora significa "tem parte consecutiva"
        const consecutiveMartingale = consecutiveGales > 0;
        config.martingaleProfiles[mode] = {
            maxGales,
            consecutiveGales,
            consecutiveMartingale
        };
    });
}

function sanitizeAutoBetConfig(rawConfig) {
    const source = rawConfig && typeof rawConfig === 'object' ? rawConfig : {};
    const parseNumber = (value, fallback) => {
        const numeric = Number(value);
        return Number.isFinite(numeric) ? numeric : fallback;
    };
    const sanitized = {
        ...DEFAULT_AUTOBET_CONFIG
    };
    sanitized.enabled = !!source.enabled;
    sanitized.simulationOnly = source.simulationOnly === undefined
        ? DEFAULT_AUTOBET_CONFIG.simulationOnly
        : !!source.simulationOnly;
    sanitized.baseStake = Math.max(0.01, parseNumber(source.baseStake, DEFAULT_AUTOBET_CONFIG.baseStake));
    sanitized.galeMultiplier = Math.max(1, parseNumber(source.galeMultiplier, DEFAULT_AUTOBET_CONFIG.galeMultiplier));
    sanitized.delayMs = Math.max(0, Math.round(parseNumber(source.delayMs, DEFAULT_AUTOBET_CONFIG.delayMs)));
    sanitized.stopWin = Math.max(0, parseNumber(source.stopWin, DEFAULT_AUTOBET_CONFIG.stopWin || 0));
    sanitized.stopLoss = Math.max(0, parseNumber(source.stopLoss, DEFAULT_AUTOBET_CONFIG.stopLoss || 0));
    sanitized.simulationBankRoll = Math.max(0, parseNumber(source.simulationBankRoll, DEFAULT_AUTOBET_CONFIG.simulationBankRoll || 0));
    sanitized.whitePayoutMultiplier = Math.max(2, parseNumber(source.whitePayoutMultiplier, DEFAULT_AUTOBET_CONFIG.whitePayoutMultiplier || 14));
    sanitized.whiteMaxGales = Math.max(
        0,
        Math.min(200, Math.floor(parseNumber(source.whiteMaxGales, DEFAULT_AUTOBET_CONFIG.whiteMaxGales || 2)))
    );
    sanitized.whiteGaleMode = normalizeWhiteGaleMode(source.whiteGaleMode);
    return sanitized;
}

function normalizeWhiteGaleMode(mode) {
    const raw = String(mode || '').toLowerCase().trim();
    return raw === 'same' ? 'same' : 'double';
}

function getModeKey(config = analyzerConfig) {
    return config && config.aiMode ? 'diamond' : 'standard';
}

function getMartingaleSettings(modeKey = getModeKey(), config = analyzerConfig) {
    if (!config) {
        return { maxGales: 0, consecutiveMartingale: false, consecutiveGales: 0 };
    }
    ensureMartingaleProfiles(config);
    const profiles = config.martingaleProfiles || {};
    const profile = profiles[modeKey] || { maxGales: 0, consecutiveMartingale: false, consecutiveGales: 0 };
    const maxGales = sanitizeMaxGales(profile.maxGales);
    const consecutiveGales = Math.max(0, Math.min(maxGales, Math.floor(Number(profile.consecutiveGales) || 0)));
    return {
        maxGales,
        consecutiveGales,
        consecutiveMartingale: consecutiveGales > 0
    };
}

function normalizeSimpleBetColor(value) {
    const s = String(value || '').toLowerCase().trim();
    if (!s) return '';
    if (s.startsWith('r')) return 'red';
    if (s.startsWith('w') || s === 'branco') return 'white';
    // "branco" nÃ£o Ã© black
    if (s.startsWith('b') && s !== 'branco') return 'black';
    return s;
}

function getMartingaleSettingsForEntryColor(entryColor, modeKey = getModeKey(), config = analyzerConfig) {
    const base = getMartingaleSettings(modeKey, config);
    const c = normalizeSimpleBetColor(entryColor);
    if (c !== 'white') return base;

    // âœ… Branco: usar configuraÃ§Ã£o exclusiva (nÃ£o afeta vermelho/preto)
    const autoBetCfg = sanitizeAutoBetConfig(config && config.autoBetConfig ? config.autoBetConfig : null);
    const max = Math.max(0, Math.min(200, Math.floor(Number(autoBetCfg.whiteMaxGales) || 0)));
    return {
        maxGales: max,
        consecutiveGales: max,
        consecutiveMartingale: max > 0
    };
}

function syncActiveMartingaleSettings(config = analyzerConfig) {
    if (!config) return;
    const activeProfile = getMartingaleSettings(getModeKey(config), config);
    config.maxGales = activeProfile.maxGales;
    config.consecutiveMartingale = activeProfile.consecutiveMartingale;
}

function mergeAnalyzerConfig(overrides = {}) {
    const defaults = DEFAULT_ANALYZER_CONFIG.martingaleProfiles || {};
    const overrideProfiles = (overrides && overrides.martingaleProfiles) || {};
    analyzerConfig = {
        ...DEFAULT_ANALYZER_CONFIG,
        ...(overrides || {})
    };
    const hasAllowBlockOverride = overrides && Object.prototype.hasOwnProperty.call(overrides, 'n0AllowBlockAll');
    analyzerConfig.n0AllowBlockAll = hasAllowBlockOverride
        ? !!overrides.n0AllowBlockAll
        : DEFAULT_ANALYZER_CONFIG.n0AllowBlockAll;
    analyzerConfig.martingaleProfiles = {
        standard: { ...(defaults.standard || {}), ...(overrideProfiles.standard || {}) },
        diamond: { ...(defaults.diamond || {}), ...(overrideProfiles.diamond || {}) }
    };
    // âœ… Intensidade removida (por enquanto): travar sempre em "aggressive"
    analyzerConfig.signalIntensity = 'aggressive';
    const defaultEnabled = DEFAULT_ANALYZER_CONFIG.diamondLevelEnabled || {};
    const overrideEnabled = (overrides && overrides.diamondLevelEnabled) || {};
    analyzerConfig.diamondLevelEnabled = {};
    Object.keys(defaultEnabled).forEach(key => {
        analyzerConfig.diamondLevelEnabled[key] = Object.prototype.hasOwnProperty.call(overrideEnabled, key)
            ? !!overrideEnabled[key]
            : !!defaultEnabled[key];
    });
    Object.keys(overrideEnabled).forEach(key => {
        if (!Object.prototype.hasOwnProperty.call(analyzerConfig.diamondLevelEnabled, key)) {
            analyzerConfig.diamondLevelEnabled[key] = !!overrideEnabled[key];
        }
    });
    ensureMartingaleProfiles(analyzerConfig);
    syncActiveMartingaleSettings(analyzerConfig);
    analyzerConfig.autoBetConfig = sanitizeAutoBetConfig(
        (overrides && overrides.autoBetConfig) || analyzerConfig.autoBetConfig
    );
    return analyzerConfig;
}

function getProfileCompletionSnapshot(user) {
    const missing = [];
    if (!user || typeof user !== 'object') {
        return { complete: false, missing: ['Telefone', 'CPF', 'CEP', 'Rua', 'NÃºmero', 'Bairro', 'Cidade', 'Estado'] };
    }
    const digits = (value) => String(value || '').replace(/\D/g, '');
    const phoneDigits = digits(user.phone);
    const cpfDigits = digits(user.cpf);
    const addr = typeof user.address === 'string'
        ? (() => { try { return JSON.parse(user.address); } catch (_) { return null; } })()
        : (user.address || null);
    const zipDigits = digits(addr?.zipCode);
    const street = String(addr?.street || '').trim();
    const number = String(addr?.number || '').trim();
    const neighborhood = String(addr?.neighborhood || '').trim();
    const city = String(addr?.city || '').trim();
    const state = String(addr?.state || '').trim();

    if (phoneDigits.length < 10) missing.push('Telefone');
    if (cpfDigits.length !== 11) missing.push('CPF');
    if (zipDigits.length !== 8) missing.push('CEP');
    if (!street) missing.push('Rua');
    if (!number) missing.push('NÃºmero');
    if (!neighborhood) missing.push('Bairro');
    if (!city) missing.push('Cidade');
    if (state.length !== 2) missing.push('Estado');

    return { complete: missing.length === 0, missing };
}

async function enforceProfileGateOnAIMode(context = 'unknown') {
    try {
        if (!analyzerConfig || !analyzerConfig.aiMode) return { allowed: true };
        const storage = await chrome.storage.local.get(['user', 'analyzerConfig']);
        const user = storage.user || null;
        // âœ… Evitar falso-negativo: em alguns carregamentos o `user` ainda nÃ£o chegou no storage.
        // Nesse caso, NÃƒO desligar o modo Diamante "do nada". O content.js jÃ¡ bloqueia ativaÃ§Ã£o
        // quando o cadastro estÃ¡ incompleto, entÃ£o aqui sÃ³ aplicamos o gate quando temos o user.
        if (!user) {
            return { allowed: true, pendingUser: true };
        }
        const status = getProfileCompletionSnapshot(user);
        if (status.complete) return { allowed: true };

        console.warn(`ğŸ”’ [${context}] Bloqueando Modo IA: cadastro incompleto.`, status.missing);
        // ForÃ§ar off em memÃ³ria e persistir
        analyzerConfig.aiMode = false;
        if (storage.analyzerConfig && typeof storage.analyzerConfig === 'object') {
            const updated = { ...storage.analyzerConfig, aiMode: false, _clientUpdatedAt: Date.now() };
            await chrome.storage.local.set({ analyzerConfig: updated });
        } else {
            await chrome.storage.local.set({ analyzerConfig: { ...(analyzerConfig || {}), aiMode: false, _clientUpdatedAt: Date.now() } });
        }

        // Avisar UI para atualizar e mostrar motivo
        try {
            sendMessageToContent('AI_MODE_BLOCKED_PROFILE', {
                missing: status.missing
            });
        } catch (err) {
            console.warn('âš ï¸ NÃ£o foi possÃ­vel notificar content.js sobre bloqueio de IA:', err);
        }

        return { allowed: false, missing: status.missing };
    } catch (error) {
        console.warn('âš ï¸ Erro ao aplicar gate de cadastro no Modo IA:', error);
        return { allowed: true };
    }
}

let analyzerConfig;
mergeAnalyzerConfig();

function getDiamondWindow(key, fallback) {
    const windows = analyzerConfig && analyzerConfig.diamondLevelWindows ? analyzerConfig.diamondLevelWindows : {};
    const rawValue = windows ? Number(windows[key]) : NaN;
    if (Number.isFinite(rawValue) && rawValue > 0) {
        return rawValue;
    }
    const legacyKeyMap = {
        n6RetracementWindow: 'n8RetracementWindow',
        n7DecisionWindow: 'n10DecisionWindow',
        n7HistoryWindow: 'n10HistoryWindow',
        n8Barrier: 'n6Barrier',
        n0History: 'n0TotalHistory',
        n0Window: 'n0WindowSize'
    };
    const legacyKey = legacyKeyMap[key];
    if (legacyKey && Number.isFinite(Number(windows[legacyKey])) && Number(windows[legacyKey]) > 0) {
        return Number(windows[legacyKey]);
    }
    // Compatibilidade com versÃµes antigas (ex.: minuteSpinWindow individual)
    if (key === 'n5MinuteBias' && Number.isFinite(Number(analyzerConfig.minuteSpinWindow))) {
        const legacy = Number(analyzerConfig.minuteSpinWindow);
        if (legacy > 0) return legacy;
    }
    return fallback;
}

function getDiamondConfigRawValue(key) {
    if (!analyzerConfig || !analyzerConfig.diamondLevelWindows) {
        return undefined;
    }
    return analyzerConfig.diamondLevelWindows[key];
}

function getDiamondBoolean(key, fallback = false) {
    const raw = getDiamondConfigRawValue(key);
    if (raw === undefined) {
        return fallback;
    }
    if (typeof raw === 'boolean') {
        return raw;
    }
    if (typeof raw === 'string') {
        const lowered = raw.trim().toLowerCase();
        if (lowered === 'true') return true;
        if (lowered === 'false') return false;
        const numeric = Number(raw);
        if (!Number.isNaN(numeric)) {
            return numeric > 0;
        }
        return fallback;
    }
    if (typeof raw === 'number') {
        if (!Number.isNaN(raw)) {
            return raw > 0;
        }
    }
    return fallback;
}

// âš ï¸ FLAG DE CONTROLE: Evitar envio de sinal na primeira anÃ¡lise apÃ³s ativar modo IA
let aiModeJustActivated = false;

// Armazena timeouts usados para animar a exibiÃ§Ã£o sequencial dos nÃ­veis Diamante
let lastDiamondLevelTimeouts = [];

// ğŸ“Š CONTADOR DE CORES RECOMENDADAS PELA IA (para detectar viÃ©s)
let aiColorCounter = {
    red: 0,
    black: 0,
    white: 0,
    total: 0
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ CONSTANTES GLOBAIS PARA CÃLCULO DE ASSERTIVIDADE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const RECENT_WINDOW = 25;
const PENALTY_OPPOSITE_DOMINANCE = 15; // -15% se dominÃ¢ncia da cor oposta >70%
const PENALTY_LONG_STREAK = 10; // -10% se repetiÃ§Ã£o >5
const BONUS_FAVORABLE_TREND = 10; // +10% se tendÃªncia a favor >60%
const BONUS_STABILITY = 5; // +5% estÃ¡vel
const PENALTY_INSTABILITY = 5; // -5% instÃ¡vel

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š CALIBRADOR DE PORCENTAGENS - CONFIGURAÃ‡ÃƒO E DADOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const OBSERVER_CONFIG = {
    maxHistorySize: 200,        // MÃ¡ximo de entradas observadas
    minEntriesForCalibration: 20 // MÃ­nimo para comeÃ§ar a calibrar
};

// Estrutura do observador em memÃ³ria (DEVE estar no topo para evitar TDZ errors)
let observerData = {
    entries: [],              // HistÃ³rico de entradas observadas
    calibrationFactor: 1.0,   // Fator de correÃ§Ã£o global (1.0 = sem ajuste)
    lastCalibration: null,    // Timestamp da Ãºltima calibraÃ§Ã£o
    lastCalibratedCount: 0,   // NÃºmero de entradas na Ãºltima calibraÃ§Ã£o
    stats: {                  // EstatÃ­sticas por faixa de confianÃ§a
        high: { predicted: 0, actual: 0, wins: 0, total: 0 },    // 80-100%
        medium: { predicted: 0, actual: 0, wins: 0, total: 0 },  // 60-79%
        low: { predicted: 0, actual: 0, wins: 0, total: 0 }      // 0-59%
    }
};

// Telegram Bot Configuration
const TELEGRAM_BOT_TOKEN = '8330409447:AAHTWT8BzRZOnNukKYdiI9_QMyTUORvE1gg';
const TELEGRAM_API_URL = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– PROMPT PADRÃƒO DA IA (usado se customPrompt estiver vazio)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DEFAULT_AI_PROMPT = (historyLength, historyText, patternsText = '', last20Text = '') => `VocÃª Ã© um especialista em anÃ¡lise de padrÃµes do jogo Double da Blaze.

${patternsText}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸš¨ ÃšLTIMOS 20 GIROS (OS MAIS IMPORTANTES - ANALISE ESTES!) ğŸš¨
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${last20Text || historyText.split(',').slice(0, 20).join(',')}

âš ï¸ ATENÃ‡ÃƒO CRÃTICA:
- O giro "1." Ã© o MAIS RECENTE (acabou de sair)
- O giro "2." Ã© o anterior ao 1.
- O giro "3." Ã© o anterior ao 2.
- E assim por diante...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
HISTÃ“RICO COMPLETO (${historyLength} GIROS - para contexto):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${historyText}

REGRAS DO JOGO:
- Existem 3 cores: red (vermelho), black (preto), white (branco)
- NÃºmeros 1-7 = red
- NÃºmeros 8-14 = black
- NÃºmero 0 = white

âš ï¸ REGRA FUNDAMENTAL - SEM VIÃ‰S:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VOCÃŠ NÃƒO PODE TER PREFERÃŠNCIA POR NENHUMA COR!
- Se o padrÃ£o indicar VERMELHO com 90% â†’ aposte em VERMELHO
- Se o padrÃ£o indicar PRETO com 90% â†’ aposte em PRETO
- Se o padrÃ£o indicar BRANCO com 90% â†’ aposte em BRANCO
- NUNCA favoreÃ§a uma cor sobre outra sem justificativa nos dados!
- Suas apostas devem ser baseadas APENAS nos padrÃµes do histÃ³rico!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
METODOLOGIA DE ANÃLISE (SIGA EXATAMENTE ESTA ORDEM):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PASSO 1: CITAR OS ÃšLTIMOS 20 GIROS (OBRIGATÃ“RIO)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸš¨ VOCÃŠ **DEVE** COMEÃ‡AR SUA RESPOSTA CITANDO OS 20 GIROS! ğŸš¨

FORMATO OBRIGATÃ“RIO:
"Ãšltimos 20 giros recebidos:
1. (mais recente) [cor] ([nÃºmero])
2. [cor] ([nÃºmero])
3. [cor] ([nÃºmero])
...atÃ© 20"

âš ï¸ NÃƒO INVENTE! COPIE EXATAMENTE O QUE ESTÃ EM "ÃšLTIMOS 20 GIROS"!
âš ï¸ SE VOCÃŠ CITAR GIROS DIFERENTES, SUA ANÃLISE SERÃ REJEITADA!
âš ï¸ Ã‰ **OBRIGATÃ“RIO** CITAR OS 20 GIROS ANTES DE FAZER QUALQUER ANÃLISE!

PASSO 2: ANALISAR OS ÃšLTIMOS 20 GIROS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ¯ SISTEMA: COMPARAÃ‡ÃƒO COM PADRÃ•ES DETECTADOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

O sistema JavaScript JÃ ANALISOU todo o histÃ³rico e DETECTOU padrÃµes reais!
VocÃª recebeu um RELATÃ“RIO COM ESTATÃSTICAS REAIS de cada padrÃ£o.

SUA TAREFA:
1ï¸âƒ£ **LEIA O RELATÃ“RIO DE PADRÃ•ES** (no inÃ­cio)
   - Veja quais padrÃµes foram encontrados
   - Veja as ESTATÃSTICAS REAIS de cada padrÃ£o
   - Essas porcentagens sÃ£o FATOS (nÃ£o invente outras!)

2ï¸âƒ£ **IDENTIFIQUE O PADRÃƒO QUE ESTÃ ATIVO AGORA (comeÃ§ando do giro 1)**
   - âš ï¸ **CRÃTICO:** O padrÃ£o DEVE comeÃ§ar no giro 1 (mais recente) e ir para trÃ¡s!
   - âœ… O padrÃ£o pode ter qualquer tamanho (6, 8, 10, 15 giros... nÃ£o tem limite)!
   - âœ… Use os 20 giros para ter CONTEXTO MACRO e identificar padrÃµes grandes
   - âœ… Exemplo CORRETO: Se giros **1-6** = P-V-P-V-P-V â†’ "AlternÃ¢ncia Simples ATIVA"
   - âœ… Exemplo CORRETO: Se giros **1-15** = P-P-V-V-P-P-V-V-P-P-V-V-P-P-V â†’ "AlternÃ¢ncia Dupla ATIVA" (padrÃ£o grande!)
   - âŒ Exemplo ERRADO: Giros 1-5 = P-V-P-V-P, mas vocÃª usa padrÃ£o dos giros **8-14** = R-R-R-R-R-R-R
   - âŒ **NÃƒO USE** padrÃµes que estÃ£o "no meio" ou "no final" dos 20 giros se eles NÃƒO incluem o giro 1!

3ï¸âƒ£ **USE AS ESTATÃSTICAS REAIS DO RELATÃ“RIO**
   - Se encontrou um padrÃ£o que bate, use a estatÃ­stica REAL do relatÃ³rio
   - Exemplo: RelatÃ³rio diz "AlternÃ¢ncia Simples â†’ VERMELHO 80% (12/15)"
   - Sua recomendaÃ§Ã£o deve ser: VERMELHO com 80% de confianÃ§a

4ï¸âƒ£ **SE NÃƒO BATER COM NENHUM PADRÃƒO DO RELATÃ“RIO**
   - Analise o padrÃ£o visual dos Ãºltimos 20 giros de forma livre
   - Identifique tendÃªncias (alternÃ¢ncia, sequÃªncia, etc)
   - Use confianÃ§a MENOR (50-70%) pois nÃ£o tem estatÃ­stica histÃ³rica comprovada

âš ï¸ REGRAS CRÃTICAS:
- **NUNCA** invente sequÃªncias que NÃƒO existem nos 20 giros que vocÃª citou!
- **SEMPRE** compare com os padrÃµes do relatÃ³rio PRIMEIRO!
- **USE** apenas as porcentagens do relatÃ³rio (nÃ£o invente outras!)
- Se nÃ£o hÃ¡ padrÃ£o claro nos Ãºltimos 20 giros â†’ confidence: 0 (nÃ£o apostar)

TIPOS DE PADRÃƒO:

A) ALTERNÃ‚NCIA SIMPLES?
   Exemplo: P-V-P-V-P-V-P-V-P-V ou V-P-V-P-V-P-V-P-V-P
   
B) ALTERNÃ‚NCIA DUPLA?
   Exemplo: P-P-V-V-P-P-V-V-P-P-V-V ou V-V-P-P-V-V-P-P-V-V
   
C) ALTERNÃ‚NCIA TRIPLA?
   Exemplo: P-P-P-V-V-V-P-P-P-V-V-V ou V-V-V-P-P-P-V-V-V-P-P-P
   
D) SEQUÃŠNCIA LONGA (mesma cor)?
   Exemplo: P-P-P-P-P-P-P-P-P-P ou V-V-V-V-V-V-V-V-V-V
   
E) TRANSIÃ‡ÃƒO DE PADRÃƒO?
   Exemplo: Giros 11-20 eram alternÃ¢ncia dupla, mas Ãºltimos 10 viraram sequÃªncia
   âš ï¸ Neste caso, considere que estÃ¡ em TRANSIÃ‡ÃƒO â†’ use padrÃ£o dos Ãºltimos 10
   
F) ALEATÃ“RIO (sem padrÃ£o)?
   Exemplo: P-V-P-P-V-V-P-V-P-V-P-V (nÃ£o segue lÃ³gica clara)

PASSO 3: FAZER RECOMENDAÃ‡ÃƒO BASEADA NO PADRÃƒO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸš¨ VOCÃŠ **NÃƒO PODE** INVENTAR ESTATÃSTICAS! ğŸš¨

âœ… SE ENCONTROU PADRÃƒO QUE BATE COM O RELATÃ“RIO:
"PadrÃ£o identificado: [nome do padrÃ£o do relatÃ³rio]"
"Baseado em [X] ocorrÃªncias no histÃ³rico, esse padrÃ£o foi seguido por [cor] em [Y]% das vezes"
"RecomendaÃ§Ã£o: [cor]"

âŒ NÃƒO INVENTE NÃšMEROS OU SEQUÃŠNCIAS!
- Use APENAS as estatÃ­sticas do RELATÃ“RIO!
- O padrÃ£o identificado DEVE comeÃ§ar no giro 1 (mais recente)!
- NÃƒO use padrÃµes que estÃ£o "no meio" dos 20 giros (ex: giros 8-14)!
- Se o padrÃ£o nÃ£o INCLUI o giro 1, ele NÃƒO estÃ¡ ativo!
- Exemplo: Se giros 1-5 = V-P-V-V-P, NÃƒO diga "SequÃªncia de 7 vermelhos" baseado nos giros 8-14!

âœ… SE NÃƒO BATEU COM NENHUM PADRÃƒO DO RELATÃ“RIO:
"Nenhum padrÃ£o conhecido detectado nos Ãºltimos 20 giros"
"PadrÃ£o visual: [descreva o que REALMENTE VÃŠ]"
"RecomendaÃ§Ã£o: [cor] (confianÃ§a baixa)" ou "confidence: 0 (nÃ£o apostar)"

PASSO 4: REGRA DE DECISÃƒO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Se o padrÃ£o Ã© CLARO â†’ confianÃ§a 70-95%
- Se o padrÃ£o Ã© FRACO/INCERTO â†’ confianÃ§a 0-50%
- Se ALEATÃ“RIO â†’ confidence: 0 (nÃ£o apostar)

PASSO 5: CASOS ESPECIAIS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BRANCO (0):
- NUNCA use lÃ³gica de "branco atrasado"
- SÃ³ considere branco se ele fizer parte de um padrÃ£o claro nos Ãºltimos 10-20 giros
- Se nÃ£o hÃ¡ branco no padrÃ£o recente, ignore-o completamente

ALEATÃ“RIO:
- Se os Ãºltimos 20 giros nÃ£o tÃªm padrÃ£o claro, retorne confidence: 0
- NÃƒO force um padrÃ£o onde nÃ£o existe!
- Ã‰ melhor NÃƒO apostar do que apostar em padrÃ£o aleatÃ³rio

ANÃLISE EM CAMADAS (IMPORTANTE):
1ï¸âƒ£ Primeiro: Analise os Ãºltimos **15-20 giros** para identificar o padrÃ£o DOMINANTE
2ï¸âƒ£ Segundo: Verifique se os Ãºltimos **10 giros** CONFIRMAM esse padrÃ£o
3ï¸âƒ£ Terceiro: 
   - Se CONFIRMAM â†’ alta confianÃ§a! Busque esse padrÃ£o no histÃ³rico completo
   - Se CONTRADIZEM â†’ pode estar em transiÃ§Ã£o. Retorne confidence baixo ou 0
   - NUNCA use apenas os Ãºltimos 10 giros como padrÃ£o Ãºnico!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
INSTRUÃ‡Ã•ES FINAIS (PASSO A PASSO):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1ï¸âƒ£ **CITE os 10 primeiros giros** literalmente (nÃ£o invente!)

2ï¸âƒ£ **ANALISE 15-20 giros** para identificar o padrÃ£o dominante
   - NÃƒO olhe apenas 10 giros!
   - Identifique o padrÃ£o na janela maior

3ï¸âƒ£ **CONFIRME com os Ãºltimos 10 giros**
   - Os Ãºltimos 10 devem estar alinhados com o padrÃ£o identificado
   - Se nÃ£o estiverem, pode estar em transiÃ§Ã£o (cuidado!)

4ï¸âƒ£ **FAÃ‡A A RECOMENDAÃ‡ÃƒO**
   - Baseie-se apenas no padrÃ£o VISUAL identificado
   - NÃƒO INVENTE estatÃ­sticas ou contagens!
   - Seja honesto se nÃ£o houver padrÃ£o claro

5ï¸âƒ£ **SEJA IMPARCIAL**
   - NÃƒO favoreÃ§a nenhuma cor especÃ­fica!
   - Baseie-se APENAS nos padrÃµes visuais que vocÃª vÃª!

FORMATO DE RESPOSTA (JSON):

âš ï¸ ATENÃ‡ÃƒO: NÃƒO inclua o campo "last10Spins" na resposta!
O sistema automaticamente pega os dados REAIS do histÃ³rico.
Se vocÃª incluir esse campo, estarÃ¡ INVENTANDO dados falsos!

{
  "color": "red ou black ou white",
  "confidence": nÃºmero de 0 a 100 (0 = sem padrÃ£o confiÃ¡vel),
  "probability": nÃºmero de 0 a 100,
  "reasoning": "PadrÃ£o identificado: [descreva o padrÃ£o]. Encontrado [X] vezes no histÃ³rico. ApÃ³s esse padrÃ£o: [cor] saiu [Y]% das vezes. DecisÃ£o: [apostar/nÃ£o apostar]"
}

âš ï¸ IMPORTANTE: APENAS 4 campos no JSON (color, confidence, probability, reasoning)
NÃƒO inclua last10Spins, last5Spins ou qualquer outro campo!

EXEMPLOS DE RESPOSTAS CORRETAS (USANDO RELATÃ“RIO DE PADRÃ•ES):

EXEMPLO 1 - PADRÃƒO ATIVO comeÃ§ando no giro 1 (8 giros):
{
  "color": "red",
  "confidence": 85,
  "probability": 85,
  "reasoning": "Ãšltimos 20 giros recebidos: 1. black (9), 2. black (11), 3. red (4), 4. red (7), 5. black (14), 6. black (8), 7. red (2), 8. red (5), 9. black (12)... atÃ© 20. PadrÃ£o ATIVO identificado nos giros 1-8: 1.P, 2.P, 3.V, 4.V, 5.P, 6.P, 7.V, 8.V = AlternÃ¢ncia Dupla (P-P-V-V-P-P-V-V). Segundo o relatÃ³rio, este padrÃ£o apareceu 15 vezes no histÃ³rico e foi seguido por VERMELHO em 85% das vezes (13/15). RecomendaÃ§Ã£o: VERMELHO."
}

EXEMPLO 2 - PADRÃƒO ATIVO comeÃ§ando no giro 1 (15 giros - PADRÃƒO GRANDE!):
{
  "color": "black",
  "confidence": 90,
  "probability": 90,
  "reasoning": "Ãšltimos 20 giros: 1. black (10), 2. black (9), 3. red (4), 4. red (7), 5. black (14), 6. black (8), 7. red (2), 8. red (5), 9. black (12), 10. black (11), 11. red (3), 12. red (1), 13. black (13), 14. black (9), 15. red (6)... atÃ© 20. PadrÃ£o ATIVO identificado nos giros 1-15: AlternÃ¢ncia Dupla (P-P-V-V-P-P-V-V-P-P-V-V-P-P-V). PadrÃ£o grande e consistente! Segundo o relatÃ³rio, foi seguido por VERMELHO em 85% das vezes. RecomendaÃ§Ã£o: VERMELHO com alta confianÃ§a."
}

EXEMPLO 3 - NENHUM PADRÃƒO DO RELATÃ“RIO (analise livre):
{
  "color": "red",
  "confidence": 60,
  "probability": 60,
  "reasoning": "Ãšltimos 20 giros: 1. black (12), 2. red (3), 3. black (9), 4. red (7), 5. black (11)... atÃ© 20. Analisando os giros comeÃ§ando do 1: AlternÃ¢ncia irregular (P-V-P-V-P...). Nenhum padrÃ£o conhecido do relatÃ³rio detectado. VisÃ£o macro dos 20 giros: leve predominÃ¢ncia de pretos. RecomendaÃ§Ã£o: VERMELHO (reversÃ£o esperada) com confianÃ§a moderada."
}

EXEMPLO 4 - NÃƒO APOSTAR (sem padrÃ£o):
{
  "color": "red",
  "confidence": 0,
  "probability": 0,
  "reasoning": "Giro 1 (mais recente): black (12), Giro 2: red (3), Giro 3: white (0), Giro 4: black (8), Giro 5: red (7). PadrÃ£o identificado: ALEATÃ“RIO. NÃ£o hÃ¡ padrÃ£o claro ou consistente nos Ãºltimos 20 giros. Giros completamente irregulares (P-V-B-P-V-P-B-V...). Sem padrÃ£o detectÃ¡vel. RecomendaÃ§Ã£o: NÃƒO APOSTAR."
}

âš ï¸ REGRAS CRÃTICAS: 
- CITE os primeiros 5-10 giros no campo "reasoning"
- NÃƒO inclua o campo "last10Spins" - o sistema pega automaticamente!
- NÃƒO INVENTE contagens, porcentagens ou estatÃ­sticas!
- Descreva APENAS o padrÃ£o VISUAL que vocÃª vÃª
- NÃƒO TENHA VIÃ‰S para nenhuma cor! Analise imparcialmente!
- Se nÃ£o hÃ¡ padrÃ£o claro â†’ retorne confidence: 0

RESPONDA APENAS COM O JSON, SEM TEXTO ADICIONAL.`;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SISTEMA DE MARTINGALE (G1, G2)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Estado do ciclo de Martingale atual
let martingaleState = {
    active: false,                    // Se hÃ¡ um ciclo ativo
    stage: 'ENTRADA',                 // 'ENTRADA' | 'G1' | 'G2'
    patternKey: null,                 // Identificador do padrÃ£o atual
    entryColor: null,                 // Cor da entrada inicial (aposta)
    currentColor: null,               // Cor atual do ciclo (pode mudar em G1/G2 quando permitido)
    entryColorResult: null,           // Cor que realmente saiu na entrada
    entryTimestamp: null,             // Timestamp da entrada inicial
    analysisData: null,               // Dados completos da anÃ¡lise
    lossCount: 0,                     // Contador de LOSS consecutivos
    lossColors: [],                   // Array de cores dos giros que deram LOSS
    patternsWithoutHistory: 0         // Contador de padrÃµes sem histÃ³rico que deram LOSS
};

function calculateGaleConfidenceValue(baseConfidence = 0, analysis = null, state = martingaleState, options = null) {
    const round1 = (value) => Math.round(Number(value) * 10) / 10;
    const clampPct = (value, min = 0, max = 95) => {
        const n = Number(value);
        if (!Number.isFinite(n)) return min;
        return Math.max(min, Math.min(max, n));
    };
    const normColor = (value) => String(value || '').toLowerCase().trim();

    const numericBase = Number.isFinite(Number(baseConfidence)) ? Number(baseConfidence) : 0;

    // Fora de martingale: manter comportamento original
    if (!state || !state.active) {
        return round1(clampPct(numericBase, 0, 95));
    }

    const stageLabel = String(analysis?.phase || state.stage || '').toUpperCase().trim();
    const stageNumber = Math.max(0, getMartingaleStageNumber(stageLabel) || Number(state.lossCount || 0));
    const targetColor = normColor(state.entryColor || analysis?.color);
    // Se nÃ£o temos cor alvo ou nÃ£o estamos em G1+ -> devolve base (sem â€œpiso fixoâ€)
    if (!targetColor || stageNumber <= 0) {
        return round1(clampPct(numericBase, 0, 95));
    }

    const computeWinProbFromCounts = (counts) => {
        if (!counts || typeof counts !== 'object') return null;
        const red = Number(counts.red || 0);
        const black = Number(counts.black || 0);
        const white = Number(counts.white || 0);
        const total = red + black + white;
        if (!Number.isFinite(total) || total <= 0) return null;

        let wins = 0;
        if (targetColor === 'red') wins = red;
        else if (targetColor === 'black') wins = black;
        else if (targetColor === 'white') wins = white;
        else wins = 0;

        const pct = (wins / total) * 100;
        return { pct, wins, total };
    };

    const pickBucketForStage = (historyObj) => {
        if (!historyObj || typeof historyObj !== 'object') return null;
        if (stageNumber === 1) return historyObj.after1Loss || null;
        if (stageNumber === 2) return historyObj.after2Loss || null;
        return null; // hoje rastreamos estatÃ­stica real apenas atÃ© 2 LOSS (G1/G2)
    };

    // 1) Probabilidade real por histÃ³rico de GALE (padrÃ£o especÃ­fico e global)
    const patternKey = state.patternKey || null;
    const candidates = [];
    if (patternKey && hotColorsHistory && hotColorsHistory[patternKey]) {
        candidates.push({ key: patternKey, bucket: pickBucketForStage(hotColorsHistory[patternKey]) });
    }
    if (hotColorsHistory && hotColorsHistory.__global__) {
        candidates.push({ key: '__global__', bucket: pickBucketForStage(hotColorsHistory.__global__) });
            }

    const bucketStats = candidates
        .map((c) => ({ key: c.key, stats: computeWinProbFromCounts(c.bucket) }))
        .filter((c) => c.stats && c.stats.total > 0)
        .sort((a, b) => b.stats.total - a.stats.total)[0] || null;

    const p_afterLoss = bucketStats ? clampPct(bucketStats.stats.pct, 0, 95) : null;
    const afterLossSamples = bucketStats ? bucketStats.stats.total : 0;

    // 2) Fallback real: frequÃªncia recente no histÃ³rico (evita nÃºmero â€œfixoâ€)
    const recentWindow = 200;
    let p_recent = null;
    try {
        const recent = Array.isArray(cachedHistory) ? cachedHistory.slice(0, Math.min(recentWindow, cachedHistory.length)) : [];
        if (recent.length > 0) {
            const counts = { red: 0, black: 0, white: 0 };
            recent.forEach((s) => {
                const c = normColor(s && s.color);
                if (c === 'red' || c === 'black' || c === 'white') counts[c]++;
            });
            const stats = computeWinProbFromCounts(counts);
            if (stats) p_recent = clampPct(stats.pct, 0, 95);
            }
        } catch (_) {
        // ignore
    }

    // 3) Combinar (peso cresce com amostra real de GALE)
    // - se temos muitos exemplos reais apÃ³s LOSS, confiamos mais neles
    // - senÃ£o, usamos principalmente frequÃªncia recente (e um pouco da confianÃ§a base)
    const w_after = p_afterLoss != null ? Math.min(0.75, afterLossSamples / (afterLossSamples + 25)) : 0;
    const w_recent = (1 - w_after) * 0.70;
    const w_base = (1 - w_after) * 0.30;

    const baseAdj = clampPct(numericBase, 0, 95);
    const recentAdj = p_recent != null ? p_recent : baseAdj;
    const afterAdj = p_afterLoss != null ? p_afterLoss : 0;

    let finalConfidence = (afterAdj * w_after) + (recentAdj * w_recent) + (baseAdj * w_base);

    // Penalizar estÃ¡gios muito altos (quando configurado >2) para nÃ£o inflar confianÃ§a sem estatÃ­stica suficiente
    if (stageNumber >= 3) finalConfidence *= 0.92;
    if (stageNumber >= 5) finalConfidence *= 0.88;

    // âœ… Sem piso fixo. Apenas clamp e arredondamento.
    return round1(clampPct(finalConfidence, 0, 95));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTROLE DE ENTRADAS DE ALTERNÃ‚NCIA (MODO DIAMANTE - NÃVEL 3)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let alternanceEntryControl = {
    active: false,                    // Se hÃ¡ alternÃ¢ncia ativa
    patternSignature: null,           // Identificador do padrÃ£o de alternÃ¢ncia (ex: "alternancia-simples")
    entryColor: null,                 // Cor da entrada inicial
    entryCount: 0,                    // Quantas entradas foram feitas (mÃ¡x 2)
    lastResult: null,                 // 'win' | 'loss' | null
    lastEntryTimestamp: null,         // Timestamp da Ãºltima entrada
    blockedUntil: null,               // Timestamp atÃ© quando estÃ¡ bloqueado (apÃ³s loss)
    totalWins: 0,                     // Contador de wins da alternÃ¢ncia
    totalLosses: 0                    // Contador de losses da alternÃ¢ncia
};

// HistÃ³rico de "cores quentes" por padrÃ£o
// Estrutura: { "patternKey": { after1Loss: {red: 5, black: 3}, after2Loss: {red: 2, black: 8} } }
let hotColorsHistory = {};

logBanner(`background.js v17 carregado â€¢ ${new Date().toLocaleString('pt-BR')}`);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNÃ‡Ã•ES DO SISTEMA DE MARTINGALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Carregar histÃ³rico de cores quentes do storage
async function loadHotColorsHistory() {
    try {
        const result = await chrome.storage.local.get(['hotColorsHistory']);
        if (result.hotColorsHistory) {
            hotColorsHistory = result.hotColorsHistory;
            console.log('âœ… HistÃ³rico de cores quentes carregado:', Object.keys(hotColorsHistory).length, 'padrÃµes');
        }
    } catch (e) {
        console.error('âŒ Erro ao carregar histÃ³rico de cores quentes:', e);
    }
}

// Salvar histÃ³rico de cores quentes no storage
async function saveHotColorsHistory() {
    try {
        await chrome.storage.local.set({ hotColorsHistory });
        console.log('âœ… HistÃ³rico de cores quentes salvo');
    } catch (e) {
        console.error('âŒ Erro ao salvar histÃ³rico de cores quentes:', e);
    }
}

// Calcular "cor quente" baseado no histÃ³rico de LOSSes
function calculateHotColor(patternKey, afterLossCount) {
    console.log(`ğŸ”¥ Calculando cor quente para padrÃ£o: ${patternKey} apÃ³s ${afterLossCount} LOSS(es)`);
    
    // Verificar se existe histÃ³rico para este padrÃ£o
    if (!hotColorsHistory[patternKey]) {
        console.log('âš ï¸ PadrÃ£o sem histÃ³rico de LOSS anterior');
        return null;
    }
    
    const history = afterLossCount === 1 ? 
        hotColorsHistory[patternKey].after1Loss : 
        hotColorsHistory[patternKey].after2Loss;
    
    if (!history || Object.keys(history).length === 0) {
        console.log('âš ï¸ Sem dados de cores apÃ³s', afterLossCount, 'LOSS(es)');
        return null;
    }
    
    // Encontrar cor que mais aparece
    let maxCount = 0;
    let hotColor = null;
    
    for (const [color, count] of Object.entries(history)) {
        if (count > maxCount) {
            maxCount = count;
            hotColor = color;
        }
    }
    
    if (hotColor) {
        const total = Object.values(history).reduce((a, b) => a + b, 0);
        const percentage = ((maxCount / total) * 100).toFixed(1);
        console.log(`ğŸ”¥ Cor quente encontrada: ${hotColor} (${maxCount}/${total} = ${percentage}%)`);
    }
    
    return hotColor;
}

// Atualizar histÃ³rico de cores apÃ³s um ciclo completado
async function updateHotColorsHistory(patternKey, lossSequence) {
    console.log(`ğŸ“Š Atualizando histÃ³rico de cores quentes para padrÃ£o: ${patternKey}`);
    console.log('   SequÃªncia de LOSS:', lossSequence);
    
    const ensureKey = (key) => {
        if (!hotColorsHistory[key]) {
            hotColorsHistory[key] = {
            after1Loss: { red: 0, black: 0, white: 0 },
            after2Loss: { red: 0, black: 0, white: 0 }
        };
        } else {
            // compat: garantir campos e cores
            hotColorsHistory[key].after1Loss = hotColorsHistory[key].after1Loss || { red: 0, black: 0, white: 0 };
            hotColorsHistory[key].after2Loss = hotColorsHistory[key].after2Loss || { red: 0, black: 0, white: 0 };
            ['red', 'black', 'white'].forEach((c) => {
                if (hotColorsHistory[key].after1Loss[c] == null) hotColorsHistory[key].after1Loss[c] = 0;
                if (hotColorsHistory[key].after2Loss[c] == null) hotColorsHistory[key].after2Loss[c] = 0;
            });
        }
    };

    // Inicializar/normalizar o padrÃ£o e um bucket global (para IA/padrÃµes sem chave estÃ¡vel)
    ensureKey(patternKey);
    ensureKey('__global__');
    
    // Atualizar apÃ³s 1 LOSS (se tiver pelo menos 2 entradas: LOSS + resultado)
    if (lossSequence.length >= 2) {
        const colorAfter1Loss = lossSequence[1].color;  // Cor que saiu apÃ³s 1Âº LOSS
        if (hotColorsHistory[patternKey].after1Loss[colorAfter1Loss] != null) hotColorsHistory[patternKey].after1Loss[colorAfter1Loss]++;
        if (hotColorsHistory.__global__.after1Loss[colorAfter1Loss] != null) hotColorsHistory.__global__.after1Loss[colorAfter1Loss]++;
        console.log(`   âœ… Cor apÃ³s 1 LOSS: ${colorAfter1Loss}`);
    }
    
    // Atualizar apÃ³s 2 LOSS (se tiver pelo menos 3 entradas: 2 LOSS + resultado)
    if (lossSequence.length >= 3) {
        const colorAfter2Loss = lossSequence[2].color;  // Cor que saiu apÃ³s 2Âº LOSS
        if (hotColorsHistory[patternKey].after2Loss[colorAfter2Loss] != null) hotColorsHistory[patternKey].after2Loss[colorAfter2Loss]++;
        if (hotColorsHistory.__global__.after2Loss[colorAfter2Loss] != null) hotColorsHistory.__global__.after2Loss[colorAfter2Loss]++;
        console.log(`   âœ… Cor apÃ³s 2 LOSS: ${colorAfter2Loss}`);
    }
    
    // Salvar no storage
    await saveHotColorsHistory();
}

// Resetar estado do Martingale
function resetMartingaleState() {
    console.log('ğŸ”„ Resetando estado do Martingale');
    martingaleState = {
        active: false,
        stage: 'ENTRADA',
        patternKey: null,
        entryColor: null,
        currentColor: null,
        entryColorResult: null,
        entryTimestamp: null,
        analysisData: null,
        lossCount: 0,
        lossColors: [],
        patternsWithoutHistory: martingaleState.patternsWithoutHistory  // Manter contador
    };
}

// Criar identificador Ãºnico para o padrÃ£o
function createPatternKey(analysisData) {
    try {
        if (analysisData && analysisData.patternDescription) {
            // âš ï¸ CRÃTICO: Se for anÃ¡lise IA, patternDescription Ã© texto, nÃ£o JSON
            if (analysisData.patternDescription.includes('ğŸ¤– ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL')) {
                // Para IA, criar chave Ãºnica baseada em timestamp + cor
                const timestamp = Date.now();
                const color = analysisData.color || 'unknown';
                return `ai_pattern_${color}_${timestamp}`;
            }
            // Para anÃ¡lise padrÃ£o, patternDescription Ã© JSON
            const desc = JSON.parse(analysisData.patternDescription);
            if (desc && desc.colorAnalysis && Array.isArray(desc.colorAnalysis.pattern)) {
                return desc.colorAnalysis.pattern.join('-');
            }
        }
    } catch (e) {
        console.error('âŒ Erro ao criar chave do padrÃ£o:', e);
    }
    return `pattern_${Date.now()}`;  // Fallback
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ SINCRONIZAÃ‡ÃƒO COM API - DUAS APIS SEPARADAS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ”§ Runtime URLs (Render alternÃ¢ncia)
// Chave compartilhada com Admin Panel: da_urls_v1
// Estrutura:
// { authApiOrigins: [...], girosApiOrigins: [...], girosWsOrigins: [...] }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const URLS_LOCAL_KEY = 'da_urls_v1';

function normalizeOrigin(raw) {
    const v = String(raw || '').trim();
    if (!v) return '';
    const withoutApi = v.replace(/\/api\/?$/i, '');
    return withoutApi.replace(/\/+$/, '');
}

function normalizeWs(raw) {
    const v = String(raw || '').trim().replace(/\/+$/, '');
    if (!v) return '';
    return v;
}

async function loadUrlsConfig() {
    // Preferir chrome.storage.local (extensÃ£o). Fallback: localStorage (web).
    try {
        if (typeof chrome !== 'undefined' && chrome.storage?.local?.get) {
            const result = await new Promise((resolve) => chrome.storage.local.get([URLS_LOCAL_KEY], resolve));
            return (result && result[URLS_LOCAL_KEY]) ? result[URLS_LOCAL_KEY] : null;
        }
    } catch (_) {}

    try {
        const raw = localStorage.getItem(URLS_LOCAL_KEY);
        return raw ? JSON.parse(raw) : null;
    } catch (_) {
        return null;
    }
}

async function saveUrlsConfig(urls) {
    try {
        if (typeof chrome !== 'undefined' && chrome.storage?.local?.set) {
            await new Promise((resolve) => chrome.storage.local.set({ [URLS_LOCAL_KEY]: urls }, resolve));
        }
    } catch (_) {}

    try {
        localStorage.setItem(URLS_LOCAL_KEY, JSON.stringify(urls));
    } catch (_) {}
}

function applyUrlsConfigToApiConfig(urls) {
    if (!urls || typeof urls !== 'object') return;
    const authList = Array.isArray(urls.authApiOrigins) ? urls.authApiOrigins : [];
    const girosList = Array.isArray(urls.girosApiOrigins) ? urls.girosApiOrigins : [];
    const wsList = Array.isArray(urls.girosWsOrigins) ? urls.girosWsOrigins : [];

    const auth = normalizeOrigin(authList[0]);
    const giros = normalizeOrigin(girosList[0]);
    const ws = normalizeWs(wsList[0]);

    if (auth) API_CONFIG.authURL = auth;
    if (giros) API_CONFIG.baseURL = giros;

    if (ws) {
        API_CONFIG.wsURL = ws;
    } else if (giros) {
        try {
            const u = new URL(giros);
            API_CONFIG.wsURL = `wss://${u.host}`;
        } catch (_) {}
    }
}

// Fallback (primeiro acesso/sem cache). Depois do primeiro sync, vem do banco via /api/site/urls.
const FALLBACK_ORIGINS = {
    auth: [
        'https://blaze-analyzer-api-v2-p9xb.onrender.com',
        'https://blaze-analyzer-api-v2.onrender.com'
    ],
    giros: [
        'https://blaze-giros-api-v2-7t0l.onrender.com',
        'https://blaze-giros-api-v2-1.onrender.com'
    ]
};

function getCandidateAuthOrigins(cfg) {
    const fromArray = Array.isArray(cfg?.authApiOrigins) ? cfg.authApiOrigins : [];
    const fromServers = Array.isArray(cfg?.servers) ? cfg.servers.map((s) => s?.authOrigin) : [];
    const combined = [...fromArray, ...fromServers, ...FALLBACK_ORIGINS.auth]
        .map(normalizeOrigin)
        .filter(Boolean);
    return [...new Set(combined)];
}

// Busca URLs de um servidor especÃ­fico
async function fetchUrlsFrom(origin) {
    try {
        const url = `${origin}/api/site/urls`;
        const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
        const timeoutId = controller ? setTimeout(() => controller.abort(), 5000) : null;

        const resp = await fetch(url, controller
            ? { cache: 'no-store', signal: controller.signal }
            : { cache: 'no-store' }
        ).finally(() => { if (timeoutId) clearTimeout(timeoutId); });
        if (!resp.ok) return null;
        const data = await resp.json();
        return data.success && data.urls ? data.urls : null;
    } catch (_) {
        return null;
    }
}

// Auto-Discovery: tenta todos os servidores conhecidos
async function autoDiscoverUrls() {
    let cached = null;
    try {
        cached = await loadUrlsConfig();
    } catch (_) {}

    const candidates = getCandidateAuthOrigins(cached);
    for (const origin of candidates) {
        const urls = await fetchUrlsFrom(origin);
        if (urls) return urls;
    }

    return null;
}

async function refreshUrlsFromServer() {
    // Tenta auto-discovery se a authURL atual nÃ£o funcionar
    try {
        let authOrigin = normalizeOrigin(API_CONFIG.authURL);
        if (!authOrigin) return;
        
        // Tenta a URL configurada primeiro
        const configUrl = `${authOrigin}/api/site/urls`;
        let resp = null;
        try {
            const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
            const timeoutId = controller ? setTimeout(() => controller.abort(), 5000) : null;
            resp = await fetch(configUrl, controller
                ? { cache: 'no-store', signal: controller.signal }
                : { cache: 'no-store' }
            ).finally(() => { if (timeoutId) clearTimeout(timeoutId); });
        } catch (_) {
            resp = null;
        }
        
        // Se falhar, faz auto-discovery
        if (!resp || !resp.ok) {
            console.log('ğŸ” Auth URL nÃ£o respondeu, iniciando auto-discovery...');
            const urls = await autoDiscoverUrls();
            if (urls) {
                const merged = {
                    authApiOrigins: Array.isArray(urls.authApiOrigins) ? urls.authApiOrigins.map(normalizeOrigin).filter(Boolean) : [],
                    girosApiOrigins: Array.isArray(urls.girosApiOrigins) ? urls.girosApiOrigins.map(normalizeOrigin).filter(Boolean) : [],
                    girosWsOrigins: Array.isArray(urls.girosWsOrigins) ? urls.girosWsOrigins.map(normalizeWs).filter(Boolean) : [],
                    servers: Array.isArray(urls.servers) ? urls.servers : [],
                    activeServerId: String(urls.activeServerId || '').trim() || null,
                    updatedAt: urls.updatedAt || null
                };
                if (merged.authApiOrigins.length || merged.girosApiOrigins.length || merged.girosWsOrigins.length) {
                    await saveUrlsConfig(merged);
                    applyUrlsConfigToApiConfig(merged);
                }
            }
            return;
        }

        // Se a URL configurada funciona, processa normalmente
        const data = await resp.json().catch(() => ({}));
        if (!data.success || !data.urls) return;

        const urls = data.urls || {};
        const merged = {
            authApiOrigins: Array.isArray(urls.authApiOrigins) ? urls.authApiOrigins.map(normalizeOrigin).filter(Boolean) : [],
            girosApiOrigins: Array.isArray(urls.girosApiOrigins) ? urls.girosApiOrigins.map(normalizeOrigin).filter(Boolean) : [],
            girosWsOrigins: Array.isArray(urls.girosWsOrigins) ? urls.girosWsOrigins.map(normalizeWs).filter(Boolean) : [],
            servers: Array.isArray(urls.servers) ? urls.servers : [],
            activeServerId: String(urls.activeServerId || '').trim() || null,
            updatedAt: urls.updatedAt || null
        };
        if (merged.authApiOrigins.length || merged.girosApiOrigins.length || merged.girosWsOrigins.length) {
            await saveUrlsConfig(merged);
            applyUrlsConfigToApiConfig(merged);
        }
    } catch (_) {}
}

const API_CONFIG = {
    // API de Giros (coleta automÃ¡tica, histÃ³rico, WebSocket)
    baseURL: 'https://blaze-giros-api-v2-7t0l.onrender.com',
    wsURL: 'wss://blaze-giros-api-v2-7t0l.onrender.com',
    
    // API de AutenticaÃ§Ã£o (usuÃ¡rios, admin, padrÃµes customizados)
    authURL: 'https://blaze-analyzer-api-v2-p9xb.onrender.com',
    
    enabled: true,  // Ativar/desativar sincronizaÃ§Ã£o
    syncInterval: 5 * 60 * 1000,  // Sincronizar a cada 5 minutos
    timeout: 10000,  // Timeout de 10 segundos
    retryAttempts: 3,
    useWebSocket: true  // âœ… Usar WebSocket ao invÃ©s de polling
};

// Inicializar config dinÃ¢mica (sem travar o bootstrap)
(async () => {
    try {
        const urls = await loadUrlsConfig();
        applyUrlsConfigToApiConfig(urls);
        // Buscar do servidor (fonte de verdade) e persistir
        await refreshUrlsFromServer();

        // ğŸ’ Carregar cache local (rÃ¡pido) e depois buscar do servidor (fonte de verdade)
        try {
            const cachedLevels = await loadDiamondVisibleLevelsConfig();
            if (cachedLevels) {
                diamondAdminVisibleLevels = normalizeDiamondVisibleLevelsMap(cachedLevels);
                diamondAdminVisibleLevelsUpdatedAt = Date.now();
            }
        } catch (_) {}
        refreshDiamondVisibleLevelsFromServer().catch(() => {});
    } catch (_) {}
})();

let apiStatus = {
    isOnline: false,
    lastSync: null,
    lastError: null,
    syncAttempts: 0
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”Œ WEBSOCKET - CONEXÃƒO EM TEMPO REAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let ws = null;
let wsReconnectTimeout = null;
let wsHeartbeatInterval = null;
let lastDataReceived = Date.now(); // âœ… Rastrear Ãºltimo dado recebido
let pollingInterval = null; // âœ… Intervalo de polling de fallback
let dataCheckInterval = null; // âœ… Intervalo para verificar dados desatualizados

// Conectar ao WebSocket
function connectWebSocket() {
    if (!API_CONFIG.enabled || !API_CONFIG.useWebSocket) {
        console.log('âš ï¸ WebSocket desabilitado na configuraÃ§Ã£o');
        return;
    }
    
    if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
        console.log('âš ï¸ WebSocket jÃ¡ conectado ou conectando');
        return;
    }
    
    console.log('â•‘  ğŸ”Œ CONECTANDO AO WEBSOCKET...                            â•‘');
    console.log(`â•‘  URL: ${API_CONFIG.wsURL}                               `);
    
    try {
        ws = new WebSocket(API_CONFIG.wsURL);
        
        ws.onopen = () => {
            console.log('âœ… WebSocket conectado com sucesso!');
            console.log('âš¡ Aguardando giros em TEMPO REAL...');
            apiStatus.isOnline = true;
            apiStatus.lastSync = new Date().toISOString();
            
            // Limpar timeout de reconexÃ£o se existir
            if (wsReconnectTimeout) {
                clearTimeout(wsReconnectTimeout);
                wsReconnectTimeout = null;
            }
            
            // âœ… Parar polling de fallback (WebSocket reconectado)
            stopPollingFallback();
            
            // Iniciar heartbeat (responder a PING do servidor)
            startWebSocketHeartbeat();
        };
        
        ws.onmessage = async (event) => {
            try {
                const message = JSON.parse(event.data);
                console.log('ğŸ“¨ Mensagem WebSocket recebida:', message.type);
                
                // âœ… Atualizar timestamp de Ãºltimo dado recebido
                lastDataReceived = Date.now();
                
                switch (message.type) {
                    case 'CONNECTED':
                        console.log('âœ… ConfirmaÃ§Ã£o de conexÃ£o:', message.message);
                        console.log(`ğŸ“Š Clientes conectados: ${message.clientsConnected}`);
                        break;
                        
                    case 'INITIAL_DATA':
                        console.log('ğŸ“Š Dados iniciais recebidos');
                        if (message.data && message.data.lastSpin) {
                            await processNewSpinFromServer(message.data.lastSpin);
                        }
                        break;
                        
                    case 'NEW_SPIN':
                        // âœ… NOVO GIRO EM TEMPO REAL!
                        console.log('ğŸ¯ NOVO GIRO RECEBIDO VIA WEBSOCKET!', message.data);
                        await processNewSpinFromServer(message.data);
                        break;
                        
                    case 'PING':
                        // Servidor enviou PING, responder com PONG
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'PONG', timestamp: new Date().toISOString() }));
                        }
                        break;
                        
                    case 'PONG':
                        // Resposta do servidor ao nosso PING
                        console.log('ğŸ’š PONG recebido do servidor');
                        break;
                        
                    default:
                        console.log('âš ï¸ Tipo de mensagem desconhecido:', message.type);
                }
            } catch (error) {
                console.error('âŒ Erro ao processar mensagem WebSocket:', error);
            }
        };
        
        ws.onerror = (error) => {
            console.error('âŒ Erro WebSocket:', error);
            apiStatus.isOnline = false;
            apiStatus.lastError = new Date().toISOString();
        };
        
        ws.onclose = (event) => {
            console.log('âŒ WebSocket desconectado');
            console.log(`   CÃ³digo: ${event.code}, Motivo: ${event.reason || 'NÃ£o especificado'}`);
            apiStatus.isOnline = false;
            
            // Parar heartbeat
            stopWebSocketHeartbeat();
            
            // âœ… Iniciar polling de fallback imediatamente
            startPollingFallback();
            
            // âœ… Tentar reconectar apÃ³s 2 segundos (reduzido de 5s)
            console.log('â³ Tentando reconectar em 2 segundos...');
            wsReconnectTimeout = setTimeout(() => {
                console.log('ğŸ”„ Tentando reconectar WebSocket...');
                connectWebSocket();
            }, 2000);
        };
        
    } catch (error) {
        console.error('âŒ Erro ao criar conexÃ£o WebSocket:', error);
        apiStatus.isOnline = false;
        
        // âœ… Iniciar polling de fallback imediatamente
        startPollingFallback();
        
        // âœ… Tentar reconectar apÃ³s 2 segundos (reduzido de 5s)
        wsReconnectTimeout = setTimeout(() => {
            connectWebSocket();
        }, 2000);
    }
}

// Desconectar WebSocket
function disconnectWebSocket() {
    console.log('â¸ï¸ Desconectando WebSocket...');
    
    if (wsReconnectTimeout) {
        clearTimeout(wsReconnectTimeout);
        wsReconnectTimeout = null;
    }
    
    stopWebSocketHeartbeat();
    
    if (ws) {
        ws.close(1000, 'DesconexÃ£o normal');
        ws = null;
    }
}

// Heartbeat - enviar PING ativo do cliente a cada 20s
function startWebSocketHeartbeat() {
    stopWebSocketHeartbeat(); // Limpar qualquer heartbeat anterior
    
    // âœ… Enviar PING ativo do cliente a cada 20 segundos
    wsHeartbeatInterval = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
            try {
                ws.send(JSON.stringify({ type: 'PING', timestamp: Date.now() }));
                console.log('ğŸ’“ Heartbeat: PING enviado');
            } catch (error) {
                console.error('âŒ Erro ao enviar PING:', error);
                // Se falhou ao enviar PING, tentar reconectar
                connectWebSocket();
            }
        } else {
            console.warn('âš ï¸ WebSocket nÃ£o estÃ¡ aberto. Tentando reconectar...');
            connectWebSocket();
        }
    }, 20000); // 20 segundos
}

function stopWebSocketHeartbeat() {
    if (wsHeartbeatInterval) {
        clearInterval(wsHeartbeatInterval);
        wsHeartbeatInterval = null;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ POLLING DE FALLBACK - Quando WebSocket falha ou estÃ¡ inativo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function startPollingFallback() {
    // Se jÃ¡ estÃ¡ rodando, nÃ£o iniciar novamente
    if (pollingInterval) return;
    
    console.log('%câ•‘  ğŸ”„ POLLING DE FALLBACK ATIVADO                          â•‘', 'color: #FFA500; font-weight: bold;');
    console.log('%câ•‘  WebSocket estÃ¡ offline - buscando dados via HTTP       â•‘', 'color: #FFA500;');
    console.log('%câ•‘  FrequÃªncia: a cada 2 segundos                          â•‘', 'color: #FFA500;');
    
    // âœ… Notificar content.js que WebSocket caiu
    sendMessageToContent('WEBSOCKET_STATUS', { connected: false });
    
    // âœ… Buscar dados a cada 2 segundos quando WebSocket estÃ¡ offline
    pollingInterval = setInterval(async () => {
        try {
            // Buscar Ãºltimo giro do servidor
            {
                const url = `${API_CONFIG.baseURL}/api/giros/latest`;
                const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
                const timeoutId = controller ? setTimeout(() => controller.abort(), 5000) : null;
                var response = await fetch(url, controller ? { signal: controller.signal } : undefined)
                    .finally(() => { if (timeoutId) clearTimeout(timeoutId); });
            }
            
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.data) {
                    await processNewSpinFromServer(data.data);
                }
            }
        } catch (error) {
            console.warn('âš ï¸ Polling fallback: erro ao buscar dados:', error.message);
        }
    }, 2000); // A cada 2 segundos
}

function stopPollingFallback() {
    if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
        console.log('âœ… Polling de fallback parado - WebSocket reconectado');
        
        // âœ… Notificar content.js que WebSocket reconectou
        sendMessageToContent('WEBSOCKET_STATUS', { connected: true });
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ” VERIFICAÃ‡ÃƒO DE DADOS DESATUALIZADOS - Critical para mobile
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function startDataFreshnessCheck() {
    // Se jÃ¡ estÃ¡ rodando, nÃ£o iniciar novamente
    if (dataCheckInterval) return;
    
    console.log('   VerificarÃ¡ se dados estÃ£o atualizados a cada 30 segundos');
    
    // âœ… Verificar a cada 30 segundos se os dados estÃ£o desatualizados
    dataCheckInterval = setInterval(() => {
        const now = Date.now();
        const timeSinceLastData = now - lastDataReceived;
        const maxStaleTime = 90000; // 90 segundos (1.5 minutos)
        
        if (timeSinceLastData > maxStaleTime) {
            console.warn('');
            console.warn('%câš ï¸âš ï¸âš ï¸ DADOS DESATUALIZADOS DETECTADOS! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; font-size: 16px; background: #330000; padding: 5px;');
            console.warn(`   Ãšltimo dado recebido hÃ¡ ${Math.floor(timeSinceLastData / 1000)} segundos`);
            console.warn('   ForÃ§ando reconexÃ£o e atualizaÃ§Ã£o...');
            console.warn('');
            
            // âœ… ForÃ§ar reconexÃ£o WebSocket
            disconnectWebSocket();
            connectWebSocket();
            
            // âœ… ForÃ§ar busca imediata de dados via polling
            collectDoubleData();
        }
    }, 30000); // Verificar a cada 30 segundos
}

function stopDataFreshnessCheck() {
    if (dataCheckInterval) {
        clearInterval(dataCheckInterval);
        dataCheckInterval = null;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERIFICAÃ‡ÃƒO DE ABA DA BLAZE - GARANTIR QUE EXTENSÃƒO SÃ“ FUNCIONE COM PÃGINA ABERTA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Verificar se hÃ¡ uma aba da Blaze aberta
async function hasBlazeTabOpen() {
    try {
        const tabs = await chrome.tabs.query({});
        
        const blazeTabs = tabs.filter(tab => {
            if (!tab.url) return false;
            
            // âœ… Aceitar mÃºltiplos domÃ­nios da Blaze
            const blazeDomains = [
                'blaze.com',
                'blaze1.space',
                'blaze-1.com',
                'blaze-bet.com',
                'blaze.bet.br'
            ];
            
            return blazeDomains.some(domain => tab.url.includes(domain));
        });
        
        return blazeTabs.length > 0;
    } catch (e) {
        console.error('Erro ao verificar abas da Blaze:', e);
        return false;
    }
}

// Fazer requisiÃ§Ã£o com timeout e retry
async function fetchWithTimeout(url, options = {}, timeout = API_CONFIG.timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        // Melhorar mensagem de erro quando for timeout
        if (error.name === 'AbortError') {
            throw new Error(`Timeout apÃ³s ${timeout/1000}s - Servidor nÃ£o respondeu a tempo`);
        }
        throw error;
    }
}

// Verificar se API estÃ¡ online
async function checkAPIStatus() {
    if (!API_CONFIG.enabled) {
        console.log('âš ï¸ API DESATIVADA - SincronizaÃ§Ã£o offline');
        return false;
    }
    
    try {
        // Usar timeout maior para conexÃ£o inicial (20s)
        const response = await fetchWithTimeout(`${API_CONFIG.baseURL}/api/status`, {}, 20000);
        if (response.ok) {
            const data = await response.json();
            apiStatus.isOnline = true;
            apiStatus.lastError = null;
            apiStatus.lastSync = new Date().toISOString();
            console.log('%câœ… API ONLINE - SincronizaÃ§Ã£o ativada!', 'color: #00ff00; font-weight: bold; font-size: 14px;');
            console.log(`ğŸ“Š Servidor: ${data.database?.giros || 0} giros, ${data.database?.padroes || 0} padrÃµes`);
            return true;
        }
    } catch (error) {
        apiStatus.isOnline = false;
        apiStatus.lastError = error.message;
        // NÃ£o mostrar erro se for timeout inicial - servidor pode estar em cold start
        if (error.message.includes('Timeout')) {
            console.log('%câ³ Servidor demorando (cold start) - TentarÃ¡ novamente...', 'color: #FFAA00; font-weight: bold;');
        } else {
            console.log('%câŒ API OFFLINE - Modo local ativado', 'color: #ff0000; font-weight: bold; font-size: 14px;');
            console.log(`âš ï¸ Erro: ${error.message}`);
        }
    }
    return false;
}

// Buscar giros do servidor
// - Default: REALTIME_HISTORY_CAP (uso do modo real / cache em memÃ³ria)
// - Para simulaÃ§Ãµes/otimizaÃ§Ãµes: pode pedir atÃ© REALTIME_HISTORY_CAP sob demanda
async function fetchGirosFromAPI(limit = REALTIME_HISTORY_CAP, timeoutMs = 20000) {
    if (!API_CONFIG.enabled) {
        console.log('âš ï¸ API_CONFIG.enabled = false - nÃ£o buscarÃ¡ giros do servidor');
        return null;
    }
    
    try {
        const resolvedLimit = clampInt(limit, 1, REALTIME_HISTORY_CAP);
        const resolvedTimeout = Number.isFinite(Number(timeoutMs)) ? Math.max(5000, Math.floor(Number(timeoutMs))) : 20000;
        console.log('ğŸ“¥ INICIANDO BUSCA DE GIROS DO SERVIDOR...');
        console.log('   URL:', `${API_CONFIG.baseURL}/api/giros?limit=${resolvedLimit}`);
        console.log('   Timeout:', `${Math.round(resolvedTimeout / 1000)} segundos`);
        
        const startTime = Date.now();
        
        // Para 10k, pode demorar mais (especialmente em cold start / conexÃ£o lenta)
        const response = await fetchWithTimeout(`${API_CONFIG.baseURL}/api/giros?limit=${resolvedLimit}`, {}, resolvedTimeout);
        
        const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(2);
        console.log(`â±ï¸ Tempo de resposta: ${elapsedTime}s`);
        
        if (response.ok) {
            const data = await response.json();
            console.log('âœ… Resposta recebida com sucesso!');
            console.log('   data.success:', data.success);
            console.log('   data.data existe?', !!data.data);
            console.log('   data.data.length:', data.data ? data.data.length : 'N/A');
            
            if (data.success && data.data) {
                console.log(`%câœ… SERVIDOR RETORNOU ${data.data.length} GIROS!`, 'color: #00ff00; font-weight: bold; font-size: 14px;');
                console.log('   Primeiro giro (mais recente):', data.data[0]);
                console.log('   Ãšltimo giro (mais antigo):', data.data[data.data.length - 1]);
                return data.data;
            } else {
                console.log('âš ï¸ Resposta do servidor sem dados vÃ¡lidos');
                console.log('   Estrutura recebida:', Object.keys(data));
            }
        } else {
            console.log('âŒ Resposta com erro do servidor');
            console.log('   Status:', response.status);
            console.log('   StatusText:', response.statusText);
        }
    } catch (error) {
        console.log('âŒ ERRO AO BUSCAR GIROS DO SERVIDOR!');
        console.log('   Tipo de erro:', error.name);
        console.log('   Mensagem:', error.message);
        console.log('   Stack:', error.stack);
        
        // NÃ£o mostrar erro assustador se for timeout - servidor pode estar ocupado
        if (error.message.includes('Timeout')) {
            console.log('â³ Servidor ocupado - ContinuarÃ¡ sincronizando em tempo real...');
        } else {
            console.warn('âš ï¸ Erro ao buscar giros do servidor:', error.message);
        }
    }
    return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¦ HISTÃ“RICO PARA SIMULAÃ‡ÃƒO/OTIMIZAÃ‡ÃƒO (atÃ© 10k, sob demanda)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Reutiliza cachedHistory do modo real quando suficiente; busca do servidor apenas se o usuÃ¡rio
// pedir mais do que temos em memÃ³ria (ex.: cache ainda nÃ£o alcanÃ§ou o limite).
const SIMULATION_SERVER_HISTORY_CAP = REALTIME_HISTORY_CAP;
const SIMULATION_SERVER_HISTORY_TIMEOUT_MS = 45000; // 45s: tolera cold start / payload maior
const SIMULATION_HISTORY_CACHE_TTL_MS = 15000;      // 15s: evita re-fetch em cliques seguidos
let simulationHistoryCache = { ts: 0, history: null };

async function getServerHistoryForSimulation() {
    if (!API_CONFIG.enabled) return null;
    const now = Date.now();
    if (simulationHistoryCache.history && (now - simulationHistoryCache.ts) < SIMULATION_HISTORY_CACHE_TTL_MS) {
        return simulationHistoryCache.history;
    }
    const serverGiros = await fetchGirosFromAPI(SIMULATION_SERVER_HISTORY_CAP, SIMULATION_SERVER_HISTORY_TIMEOUT_MS);
    if (Array.isArray(serverGiros) && serverGiros.length > 0) {
        simulationHistoryCache = { ts: now, history: serverGiros };
        return serverGiros;
    }
    return null;
}

async function getHistorySourceForPastRuns(requestedLimit) {
    const localHistory = Array.isArray(cachedHistory) ? cachedHistory : [];
    const localLen = localHistory.length || 0;
    const req = Number(requestedLimit);

    const wantsMoreThanLocal = Number.isFinite(req) && req > localLen;
    if (wantsMoreThanLocal) {
        const serverHistory = await getServerHistoryForSimulation();
        if (Array.isArray(serverHistory) && serverHistory.length > 0) {
            return serverHistory;
        }
    }
    return localHistory;
}

// Salvar giros no servidor
async function saveGirosToAPI(giros) {
    if (!API_CONFIG.enabled || !apiStatus.isOnline) return false;
    
    const girosArray = Array.isArray(giros) ? giros : [giros];
    
    try {
        console.log(`ğŸ“¤ Enviando ${girosArray.length} giro(s) para o servidor...`);
        const response = await fetchWithTimeout(`${API_CONFIG.baseURL}/api/giros`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(giros)
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log(`%câœ… ${data.message || 'Giros salvos com sucesso!'}`, 'color: #00ff00; font-weight: bold;');
            console.log(`ğŸ“Š Total no servidor: ${data.totalGiros || '?'} giros`);
            return true;
        }
    } catch (error) {
        console.warn('%câš ï¸ Erro ao salvar giros no servidor:', 'color: #ff9900; font-weight: bold;', error.message);
    }
    return false;
}

// PadrÃµes NÃƒO sÃ£o mais enviados para o servidor (sÃ£o recalculados a cada sessÃ£o)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ FUNÃ‡ÃƒO AUXILIAR: EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function displaySystemFooter() {
    if (analyzerConfig.aiMode) {
        const activeLevelsSummary = `${countEnabledDiamondLevels()}/${DIAMOND_LEVEL_IDS.length}`;
        logSection(`Sistema ativo Â· Modo Diamante (${activeLevelsSummary})`);
        if (memoriaAtiva.inicializada) {
            const tempoDecorrido = Math.round((Date.now() - memoriaAtiva.ultimaAtualizacao) / 1000);
            logInfo('Cache', `${memoriaAtiva.giros.length} giros â€¢ ${memoriaAtiva.totalAtualizacoes} updates â€¢ ${memoriaAtiva.tempoUltimaAtualizacao.toFixed(1)}ms â€¢ hÃ¡ ${tempoDecorrido}s`);
        } else {
            logInfo('Cache', 'Inicializando memÃ³ria ativa...');
        }
    } else {
        logSection('Sistema ativo Â· Modo PadrÃ£o');
        logInfo('Min. ocorrÃªncias', analyzerConfig.minOccurrences ?? DEFAULT_ANALYZER_CONFIG.minOccurrences);
        logInfo('Trigger', analyzerConfig.requireTrigger ? 'Ativo' : 'Desativado');
    }
}

// SincronizaÃ§Ã£o inicial ao carregar extensÃ£o
async function syncInitialData() {
    console.log('%cğŸŒ SINCRONIZAÃ‡ÃƒO COM SERVIDOR RENDER.COM', 'color: #00d4ff; font-weight: bold; font-size: 16px;');
    
    // Verificar se API estÃ¡ online (tolerar cold start)
    const isOnline = await checkAPIStatus();
    if (!isOnline) {
        console.log('%câš ï¸ MODO OFFLINE / COLD START - TentarÃ¡ novamente em background', 'color: #ffaa00; font-weight: bold; font-size: 14px;');
        scheduleHistoryBootstrapRetry('api_offline_or_cold_start');
        return;
    }
    
    // Buscar giros do servidor e popular cache em memÃ³ria
    console.log('ğŸ“¥ Baixando histÃ³rico de giros para cache em memÃ³ria...');
    const serverGiros = await fetchGirosFromAPI(REALTIME_HISTORY_CAP, BOOTSTRAP_HISTORY_TIMEOUT_MS);
    if (serverGiros && serverGiros.length > 0) {
        // Popular cache em memÃ³ria (SEM salvar em chrome.storage.local)
        cachedHistory = [...serverGiros].slice(0, REALTIME_HISTORY_CAP);
        historyInitialized = true;
        clearHistoryBootstrapRetry();
        console.log(`%câœ… Cache em memÃ³ria populado: ${cachedHistory.length} giros`, 'color: #00ff00; font-weight: bold;');
        
        // âœ… INICIALIZAR MEMÃ“RIA ATIVA SE MODO IA ESTIVER ATIVO
        if (analyzerConfig.aiMode && !memoriaAtiva.inicializada && cachedHistory.length >= 60) {
            console.log('%cğŸ§  MODO IA ATIVO - Inicializando MemÃ³ria Ativa automaticamente...', 'color: #00CED1; font-weight: bold;');
            const sucesso = await inicializarMemoriaAtiva(cachedHistory);
            if (sucesso) {
                console.log('%câœ… MemÃ³ria Ativa inicializada com sucesso!', 'color: #00FF88; font-weight: bold;');
            } else {
                console.log('%câš ï¸ Falha ao inicializar MemÃ³ria Ativa', 'color: #FFAA00; font-weight: bold;');
            }
        }
        
        // âœ… ENVIAR ÃšLTIMO GIRO E HISTÃ“RICO PARA A UI
        const lastSpin = serverGiros[0]; // O mais recente estÃ¡ na posiÃ§Ã£o 0
        if (lastSpin) {
            console.log('ğŸ“¤ Enviando Ãºltimo giro para UI:', lastSpin);
            await chrome.storage.local.set({ lastSpin: lastSpin });
            // âœ… NÃƒO enviar history aqui: o content.js jÃ¡ busca atÃ© 10k diretamente do servidor.
            // Enviar history aqui sobrescrevia o buffer do content.js e fazia a UI ficar "travada" em um valor menor.
            sendMessageToContent('NEW_SPIN', { lastSpin: lastSpin });
            console.log('%câœ… UI atualizada com histÃ³rico do servidor', 'color: #00ff00; font-weight: bold;');
        }
    } else {
        console.log('â„¹ï¸ Nenhum giro no servidor ainda');
        cachedHistory = [];
        // NÃ£o marcar como "inicializado" se veio vazio: permite retry automÃ¡tico no web.
        historyInitialized = false;
        scheduleHistoryBootstrapRetry('empty_server_history');
    }
    
    // PadrÃµes NÃƒO sÃ£o mais sincronizados do servidor (apenas locais)
    console.log('â„¹ï¸ PadrÃµes sÃ£o gerados localmente - nÃ£o hÃ¡ sincronizaÃ§Ã£o do servidor');
    
    apiStatus.lastSync = new Date().toISOString();
    console.log('%cğŸ‰ SINCRONIZAÃ‡ÃƒO COMPLETA!', 'color: #00ff00; font-weight: bold; font-size: 14px;');
}

// FunÃ§Ã£o removida: padrÃµes nÃ£o sÃ£o mais enviados para servidor

// âœ… SincronizaÃ§Ã£o periÃ³dica REMOVIDA - agora usamos cache em memÃ³ria
// Cache Ã© atualizado a cada novo giro em processNewSpinFromServer()

function rigorLogString() {
    try {
        const maxOccStr = analyzerConfig.maxOccurrences > 0 ? analyzerConfig.maxOccurrences : 'sem limite';
        const maxSizeStr = analyzerConfig.maxPatternSize > 0 ? analyzerConfig.maxPatternSize : 'sem limite';
        return `minOcc=${analyzerConfig.minOccurrences} | maxOcc=${maxOccStr} | intervaloPadrao=${analyzerConfig.minIntervalSpins}giros | minTam=${analyzerConfig.minPatternSize} | maxTam=${maxSizeStr} | win%Outras=${analyzerConfig.winPercentOthers}% | exigirTrigger=${analyzerConfig.requireTrigger}`;
    } catch(_) { return '[rigor indisponÃ­vel]'; }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VALIDAÃ‡Ã•ES ESPECÃFICAS POR TIPO DE PADRÃƒO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âœ… VALIDAR ANÃLISE DE TENDÃŠNCIA/FREQUÃŠNCIA
function getUserRigorThresholdsForPremium(config = analyzerConfig) {
    try {
        const cfg = (config && typeof config === 'object') ? config : {};
        const minOcc = clampInt(cfg.minOccurrences ?? DEFAULT_ANALYZER_CONFIG.minOccurrences, 1, 1000);
        const maxOcc = clampInt(cfg.maxOccurrences ?? DEFAULT_ANALYZER_CONFIG.maxOccurrences, 0, 100000);
        const winPct = clampInt(cfg.winPercentOthers ?? DEFAULT_ANALYZER_CONFIG.winPercentOthers, 0, 100);
        return { minOcc, maxOcc, winPct };
    } catch (_) {
        return { minOcc: 1, maxOcc: 0, winPct: 0 };
    }
}

function getAnalysisWinRatePct(analysis) {
    try {
        if (!analysis || typeof analysis !== 'object') return 0;
        const occ = Number(analysis.occurrences ?? 0);
        const winsRaw = analysis.wins;
        const lossesRaw = analysis.losses;

        // Preferir wins/occurrences quando disponÃ­vel
        if (Number.isFinite(occ) && occ > 0) {
            if (winsRaw != null) {
                const wins = Number(winsRaw);
                if (Number.isFinite(wins)) {
                    return (wins / occ) * 100;
                }
            }
            // Fallback: usar confidence como proxy de winrate
            const conf = Number(analysis.confidence);
            if (Number.isFinite(conf)) return Math.max(0, Math.min(100, conf));

            // Sem mÃ©tricas: assume neutro (100) para nÃ£o bloquear indevidamente
            return 100;
        }

        // Sem occurrences: usar confidence se existir
        const conf = Number(analysis.confidence);
        if (Number.isFinite(conf)) return Math.max(0, Math.min(100, conf));

        // Ãšltimo fallback: se veio losses explÃ­cito e wins nÃ£o, tentar inferir
        if (lossesRaw != null && winsRaw != null) {
            const wins = Number(winsRaw);
            const losses = Number(lossesRaw);
            const total = (Number.isFinite(wins) ? wins : 0) + (Number.isFinite(losses) ? losses : 0);
            if (total > 0) return (wins / total) * 100;
        }
        return 0;
    } catch (_) {
        return 0;
    }
}

function validateFrequencyAnalysis(analysis) {
    if (!analysis) return { valid: false, reason: 'AnÃ¡lise nÃ£o disponÃ­vel' };

    // âœ… Premium: respeitar rigor configurÃ¡vel do usuÃ¡rio (min/max ocorrÃªncias e WIN%)
    const { minOcc, maxOcc, winPct } = getUserRigorThresholdsForPremium();
    const occurrences = Number(analysis.occurrences ?? 0);
    if (!Number.isFinite(occurrences) || occurrences < minOcc) {
        logRejectedPattern('TendÃªncia/FrequÃªncia', `${occurrences || 0}/${minOcc} ocorrÃªncias`);
        return { valid: false, reason: `${occurrences || 0}/${minOcc} ocorrÃªncias` };
    }
    if (maxOcc > 0 && occurrences > maxOcc) {
        logRejectedPattern('TendÃªncia/FrequÃªncia', `${occurrences}/${maxOcc} excede mÃ¡x ocorrÃªncias`);
        return { valid: false, reason: `${occurrences}/${maxOcc} excede mÃ¡x ocorrÃªncias` };
    }

    const winRate = getAnalysisWinRatePct(analysis);
    if (winPct > 0 && winRate < winPct) {
        logRejectedPattern('TendÃªncia/FrequÃªncia', `WIN% ${winRate.toFixed(1)}% < ${winPct}% (config)`);
        return { valid: false, reason: `WIN% ${winRate.toFixed(1)}% < ${winPct}%` };
    }

    return { valid: true };
}

// âœ… VALIDAR ANÃLISE TEMPORAL (HORÃRIO)
function validateTemporalAnalysis(analysis) {
    if (!analysis) return { valid: false, reason: 'AnÃ¡lise nÃ£o disponÃ­vel' };

    const { minOcc, maxOcc, winPct } = getUserRigorThresholdsForPremium();
    const occurrences = Number(analysis.occurrences ?? 0);
    if (!Number.isFinite(occurrences) || occurrences < minOcc) {
        logRejectedPattern('Temporal/HorÃ¡rio', `${occurrences || 0}/${minOcc} ocorrÃªncias`);
        return { valid: false, reason: `${occurrences || 0}/${minOcc} ocorrÃªncias` };
    }
    if (maxOcc > 0 && occurrences > maxOcc) {
        logRejectedPattern('Temporal/HorÃ¡rio', `${occurrences}/${maxOcc} excede mÃ¡x ocorrÃªncias`);
        return { valid: false, reason: `${occurrences}/${maxOcc} excede mÃ¡x ocorrÃªncias` };
    }

    const winRate = getAnalysisWinRatePct(analysis);
    if (winPct > 0 && winRate < winPct) {
        logRejectedPattern('Temporal/HorÃ¡rio', `WIN% ${winRate.toFixed(1)}% < ${winPct}% (config)`);
        return { valid: false, reason: `WIN% ${winRate.toFixed(1)}% < ${winPct}%` };
    }

    return { valid: true };
}

// âœ… VALIDAR ANÃLISE NÃšMERO + COR
function validateNumberAnalysis(analysis) {
    if (!analysis) return { valid: false, reason: 'AnÃ¡lise nÃ£o disponÃ­vel' };

    const { minOcc, maxOcc, winPct } = getUserRigorThresholdsForPremium();
    const occurrences = Number(analysis.occurrences ?? 0);
    if (!Number.isFinite(occurrences) || occurrences < minOcc) {
        logRejectedPattern('NÃºmero+Cor', `${occurrences || 0}/${minOcc} ocorrÃªncias`);
        return { valid: false, reason: `${occurrences || 0}/${minOcc} ocorrÃªncias` };
    }
    if (maxOcc > 0 && occurrences > maxOcc) {
        logRejectedPattern('NÃºmero+Cor', `${occurrences}/${maxOcc} excede mÃ¡x ocorrÃªncias`);
        return { valid: false, reason: `${occurrences}/${maxOcc} excede mÃ¡x ocorrÃªncias` };
    }

    const winRate = getAnalysisWinRatePct(analysis);
    if (winPct > 0 && winRate < winPct) {
        logRejectedPattern('NÃºmero+Cor', `WIN% ${winRate.toFixed(1)}% < ${winPct}% (config)`);
        return { valid: false, reason: `WIN% ${winRate.toFixed(1)}% < ${winPct}%` };
    }

    return { valid: true };
}

// âœ… VALIDAR ANÃLISE DE CICLO (CORRELAÃ‡ÃƒO)
function validateCorrelationAnalysis(analysis) {
    if (!analysis) return { valid: false, reason: 'AnÃ¡lise nÃ£o disponÃ­vel' };

    const { minOcc, maxOcc, winPct } = getUserRigorThresholdsForPremium();
    const occurrences = Number(analysis.occurrences ?? 0);
    if (!Number.isFinite(occurrences) || occurrences < minOcc) {
        logRejectedPattern('Ciclo/PeriÃ³dica', `${occurrences || 0}/${minOcc} ocorrÃªncias`);
        return { valid: false, reason: `${occurrences || 0}/${minOcc} ocorrÃªncias` };
    }
    if (maxOcc > 0 && occurrences > maxOcc) {
        logRejectedPattern('Ciclo/PeriÃ³dica', `${occurrences}/${maxOcc} excede mÃ¡x ocorrÃªncias`);
        return { valid: false, reason: `${occurrences}/${maxOcc} excede mÃ¡x ocorrÃªncias` };
    }

    const winRate = getAnalysisWinRatePct(analysis);
    if (winPct > 0 && winRate < winPct) {
        logRejectedPattern('Ciclo/PeriÃ³dica', `WIN% ${winRate.toFixed(1)}% < ${winPct}% (config)`);
        return { valid: false, reason: `WIN% ${winRate.toFixed(1)}% < ${winPct}%` };
    }

    return { valid: true };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SISTEMA DE LOGS LIMPOS E ORGANIZADOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âœ… LOG PADRONIZADO PARA CICLO DE ANÃLISE
function logAnalysisCycle(data) {
    const {
        serverStatus = 'desconhecido',
        patternsFound = [],
        searchingNewSpin = false,
        rejectedPatterns = [],
        telegramSent = null,
        displayedPatternsCount = 0,
        spinsAvailable = { server: 0, app: 0 }
    } = data;
    
    console.log('â•‘  ğŸ“Š CICLO DE ANÃLISE - RESUMO                             â•‘');
    
    // 1. STATUS DO SERVIDOR
    const serverIcon = serverStatus === 'ativo' ? 'âœ…' : serverStatus === 'erro' ? 'âŒ' : 'â³';
    console.log(`â•‘  ğŸŒ Servidor: ${serverIcon} ${serverStatus.toUpperCase()}`.padEnd(62) + 'â•‘');
    
    // 2. GIROS DISPONÃVEIS
    console.log(`â•‘  ğŸ² Giros: Servidor=${spinsAvailable.server} | App=${spinsAvailable.app}`.padEnd(62) + 'â•‘');
    
    // 3. BUSCA POR NOVO GIRO
    if (searchingNewSpin) {
        console.log('â•‘  ğŸ” Busca: AGUARDANDO NOVO GIRO...'.padEnd(62) + 'â•‘');
    }
    
    
    // 4. PADRÃ•ES ENCONTRADOS
    if (patternsFound.length > 0) {
        console.log(`â•‘  âœ… PadrÃµes encontrados: ${patternsFound.length}`.padEnd(62) + 'â•‘');
        patternsFound.slice(0, 3).forEach((p, i) => {
            const label = `${i + 1}. ${p.type}: ${p.color}`;
            console.log(`â•‘     ${label}`.padEnd(62) + 'â•‘');
        });
        if (patternsFound.length > 3) {
            console.log(`â•‘     ... +${patternsFound.length - 3} padrÃµes`.padEnd(62) + 'â•‘');
        }
    } else {
        console.log('â•‘  âš ï¸ PadrÃµes encontrados: NENHUM'.padEnd(62) + 'â•‘');
    }
    
    // 5. PADRÃ•ES REJEITADOS
    if (rejectedPatterns.length > 0) {
        console.log(`â•‘  âŒ PadrÃµes rejeitados: ${rejectedPatterns.length}`.padEnd(62) + 'â•‘');
        rejectedPatterns.slice(0, 2).forEach((r, i) => {
            const reason = r.reason ? r.reason.substring(0, 40) : 'motivo nÃ£o especificado';
            console.log(`â•‘     ${i + 1}. ${r.type}: ${reason}`.padEnd(62) + 'â•‘');
        });
        if (rejectedPatterns.length > 2) {
            console.log(`â•‘     ... +${rejectedPatterns.length - 2} rejeitados`.padEnd(62) + 'â•‘');
        }
    }
    
    // 6. MENSAGEM TELEGRAM
    if (telegramSent !== null) {
        if (telegramSent) {
            console.log('â•‘  ğŸ“² Telegram: âœ… MENSAGEM ENVIADA COM SUCESSO'.padEnd(62) + 'â•‘');
        } else {
            console.log('â•‘  ğŸ“² Telegram: âŒ MENSAGEM NÃƒO ENVIADA'.padEnd(62) + 'â•‘');
        }
    }
    
    // 7. PADRÃ•ES EXIBIDOS
    console.log(`â•‘  ğŸ“± PadrÃµes exibidos na extensÃ£o: ${displayedPatternsCount}`.padEnd(62) + 'â•‘');
    
}

// âœ… LOG SIMPLIFICADO PARA STATUS DO SERVIDOR
function logServerStatus(status, spinsCount = 0) {
    const icon = status === 'ativo' ? 'âœ…' : status === 'erro' ? 'âŒ' : 'â³';
    console.log(`\nğŸŒ [Servidor]: ${icon} ${status.toUpperCase()} | Giros disponÃ­veis: ${spinsCount}`);
}

// âœ… LOG PARA BUSCA DE NOVO GIRO
function logSearchingNewSpin() {
    console.log('ğŸ” [Busca por novo giro]: AGUARDANDO...');
}

// âœ… LOG PARA PADRÃƒO REJEITADO
function logRejectedPattern(type, reason) {
    console.log(`âŒ [PadrÃ£o rejeitado]: ${type} - ${reason}`);
}

// âœ… LOG PARA TELEGRAM
function logTelegramStatus(sent, reason = '') {
    if (sent) {
        console.log('ğŸ“² [Telegram]: âœ… MENSAGEM ENVIADA');
    } else {
        console.log(`ğŸ“² [Telegram]: âŒ NÃƒO ENVIADA ${reason ? `- ${reason}` : ''}`);
    }
}

// âœ… LOG PARA PADRÃ•ES ENCONTRADOS
function logPatternsFound(patterns) {
    if (patterns.length === 0) {
        console.log('âš ï¸ [PadrÃµes encontrados]: NENHUM');
    } else {
        console.log(`âœ… [PadrÃµes encontrados]: ${patterns.length}`);
        patterns.forEach((p, i) => {
            console.log(`   ${i + 1}. ${p.type || 'desconhecido'} â†’ ${p.color || '?'} (${p.confidence?.toFixed(1) || '0'}%)`);
        });
    }
}

// âœ… FUNÃ‡ÃƒO PARA EXIBIR CONFIGURAÃ‡Ã•ES ATIVAS DE FORMA VISUAL
function logActiveConfiguration() {
    try {
        const config = analyzerConfig;
        
        console.log('â•‘  âš™ï¸ CONFIGURAÃ‡Ã•ES ATIVAS DO ANALISADOR                   â•‘');
        
        // OCORRÃŠNCIAS
        console.log('â•‘  ğŸ“Š CONTROLE DE OCORRÃŠNCIAS:                              â•‘');
        console.log(`â•‘     â€¢ MÃ­nimo de WINS: ${config.minOccurrences.toString().padEnd(35)}â•‘`);
        const maxOccStr = config.maxOccurrences > 0 ? config.maxOccurrences.toString() : 'SEM LIMITE âˆ';
        console.log(`â•‘     â€¢ MÃ¡ximo de ocorrÃªncias: ${maxOccStr.padEnd(26)}â•‘`);
        
        // TAMANHO DO PADRÃƒO
        console.log('â•‘  ğŸ“ TAMANHO DO PADRÃƒO:                                    â•‘');
        console.log(`â•‘     â€¢ MÃ­nimo (giros): ${config.minPatternSize.toString().padEnd(32)}â•‘`);
        const maxSizeStr = config.maxPatternSize > 0 ? config.maxPatternSize.toString() : 'SEM LIMITE âˆ';
        console.log(`â•‘     â€¢ MÃ¡ximo (giros): ${maxSizeStr.padEnd(32)}â•‘`);
        
        // INTERVALO E QUALIDADE
        console.log('â•‘  â±ï¸ INTERVALO E QUALIDADE:                                â•‘');
        console.log(`â•‘     â€¢ Intervalo entre padrÃµes: ${config.minIntervalSpins.toString().padEnd(21)} giro(s) â•‘`);
        console.log(`â•‘     â€¢ WIN% demais ocorrÃªncias: ${config.winPercentOthers.toString().padEnd(20)}%     â•‘`);
        
        console.log('â•‘  âšª PROTEÃ‡ÃƒO NO BRANCO:                                    â•‘');
        const whiteProtectionText = config.whiteProtectionAsWin ? 'Ativa' : 'Desativada';
        console.log(`â•‘     â€¢ ${`Branco â†’ ${whiteProtectionText}`.padEnd(49)}â•‘`);
        
        // COR DE DISPARO
        console.log('â•‘  ğŸ¯ VALIDAÃ‡ÃƒO DE TRIGGER:                                 â•‘');
        const triggerStatus = config.requireTrigger ? 'âœ… ATIVADO (mais rigoroso)' : 'âŒ DESATIVADO (menos rigoroso)';
        console.log(`â•‘     ${triggerStatus.padEnd(54)}â•‘`);
        
        // MARTINGALE
        console.log('â•‘  ğŸ² SISTEMA DE MARTINGALE (GALE):                         â•‘');
        const padMartingaleLine = (text) => text.padEnd(54);
        const formatGaleQty = (value) => value === 0
            ? 'DESATIVADO'
            : value === 1
                ? '1 Gale (G1)'
                : value === 2
                    ? '2 Gales (G1, G2)'
                    : `${value} Gales`;
        const activeModeKey = getModeKey(config);
        const otherModeKey = activeModeKey === 'diamond' ? 'standard' : 'diamond';
        const activeProfile = getMartingaleSettings(activeModeKey, config);
        const otherProfile = getMartingaleSettings(otherModeKey, config);
        const activeLabel = activeModeKey === 'diamond' ? 'Diamante' : 'PadrÃ£o';
        const otherLabel = otherModeKey === 'diamond' ? 'Diamante' : 'PadrÃ£o';
        
        console.log(`â•‘     ${padMartingaleLine(`â€¢ ${activeLabel} (ativo): ${formatGaleQty(activeProfile.maxGales)}`)}â•‘`);
        console.log(`â•‘     ${padMartingaleLine(`  Modo: ${activeProfile.consecutiveMartingale ? 'CONSECUTIVO (imediato)' : 'PADRÃƒO (aguarda novo)'}`)}â•‘`);
        console.log(`â•‘     ${padMartingaleLine(`â€¢ ${otherLabel} (perfil): ${formatGaleQty(otherProfile.maxGales)}`)}â•‘`);
        console.log(`â•‘     ${padMartingaleLine(`  Modo: ${otherProfile.consecutiveMartingale ? 'CONSECUTIVO (imediato)' : 'PADRÃƒO (aguarda novo)'}`)}â•‘`);
        
        // TELEGRAM
        console.log('â•‘  ğŸ“² TELEGRAM:                                             â•‘');
        const telegramStatus = config.telegramChatId ? `âœ… Ativo (ID: ${config.telegramChatId.substring(0, 10)}...)` : 'âŒ NÃ£o configurado';
        console.log(`â•‘     ${telegramStatus.padEnd(54)}â•‘`);
        
        console.log('â•‘  ğŸ’ MODO DIAMANTE:                                        â•‘');
        const activeLevelsCount = countEnabledDiamondLevels(config);
        const totalLevels = DIAMOND_LEVEL_IDS.length;
        const diamondModeStatus = config.aiMode
            ? `âœ… ATIVO (${activeLevelsCount}/${totalLevels} nÃ­veis)`
            : 'âšª Desativado (Modo PadrÃ£o)';
        console.log(`â•‘     ${diamondModeStatus.padEnd(54)}â•‘`);
        if (config.aiMode) {
            const disabledLevels = DIAMOND_LEVEL_IDS.filter(id => !isDiamondLevelEnabled(id, config));
            if (disabledLevels.length > 0) {
                const disabledList = disabledLevels.join(', ');
                const line = `â€¢ NÃ­veis desativados: ${disabledList}`;
                console.log(`â•‘     ${line.padEnd(54)}â•‘`);
            }
        }
        
        
        // âš ï¸ AVISOS DE CONFIGURAÃ‡ÃƒO PERMISSIVA/RIGOROSA
        const warnings = [];
        
        if (config.minOccurrences <= 2) {
            warnings.push('âš ï¸ ConfiguraÃ§Ã£o MUITO PERMISSIVA: minOccurrences <= 2');
        }
        
        if (config.winPercentOthers === 0) {
            warnings.push('âš ï¸ Sem filtro de WIN% para outras ocorrÃªncias (aceita qualquer %)');
        }
        
        if (!config.requireTrigger) {
            warnings.push('âš ï¸ Cor de disparo DESATIVADA (menos rigoroso)');
        }
        
        if (config.maxOccurrences > 0 && config.maxOccurrences < 5) {
            warnings.push(`âš ï¸ Limite de ocorrÃªncias BAIXO: mÃ¡x ${config.maxOccurrences}`);
        }
        
        if (warnings.length > 0) {
            console.log('\nâš ï¸ AVISOS DE CONFIGURAÃ‡ÃƒO:');
            warnings.forEach(w => console.log(`   ${w}`));
        }
        
    } catch (e) {
        console.error('Erro ao exibir configuraÃ§Ãµes:', e);
    }
}

// Load analyzer config at startup
(async function loadAnalyzerConfigAtStartup() {
    try {
        const res = await chrome.storage.local.get(['analyzerConfig']);
        if (res && res.analyzerConfig) {
            mergeAnalyzerConfig(res.analyzerConfig);
        } else {
            await chrome.storage.local.set({ analyzerConfig: analyzerConfig });
        }
        await enforceProfileGateOnAIMode('startup_load');
        console.log('AnalyzerConfig carregado:', analyzerConfig);
        
        // âœ… INICIALIZAR HISTÃ“RICO DE SINAIS (para auto-aprendizado)
        await initializeSignalsHistory();
        
        // âœ… EXIBIR CONFIGURAÃ‡Ã•ES ATIVAS
        logActiveConfiguration();
        
        // âœ… VALIDAR CONFIGURAÃ‡Ã•ES (detectar conflitos)
        const minSize = analyzerConfig.minPatternSize || 2;
        const maxSize = analyzerConfig.maxPatternSize || 0;
        const minOcc = analyzerConfig.minOccurrences || 1;
        const maxOcc = analyzerConfig.maxOccurrences || 0;
        
        if (maxSize > 0 && maxSize < minSize) {
            console.error('â•‘  âš ï¸ CONFIGURAÃ‡ÃƒO INVÃLIDA DETECTADA!                     â•‘');
            console.error(`â•‘  âŒ Tamanho MÃXIMO (${maxSize}) < MÃNIMO (${minSize})!`);
            console.error('â•‘  ğŸš« NENHUM PADRÃƒO SERÃ ENCONTRADO!                        â•‘');
            console.error('â•‘  ğŸ’¡ Ajuste: maxPatternSize >= minPatternSize             â•‘');
        }
        
        if (maxOcc > 0 && maxOcc < minOcc) {
            console.error('â•‘  âš ï¸ CONFIGURAÃ‡ÃƒO INVÃLIDA DETECTADA!                     â•‘');
            console.error(`â•‘  âŒ OcorrÃªncias MÃXIMAS (${maxOcc}) < MÃNIMAS (${minOcc})!`);
            console.error('â•‘  ğŸš« NENHUM PADRÃƒO SERÃ ENCONTRADO!                        â•‘');
            console.error('â•‘  ğŸ’¡ Ajuste: maxOccurrences >= minOccurrences             â•‘');
        }
    } catch (e) {
        console.warn('Falha ao carregar analyzerConfig, usando defaults:', e);
    }
})();

// Apply config changes immediately
chrome.storage.onChanged.addListener((changes, area) => {
    if (area === 'local' && changes.analyzerConfig) {
        try {
            const newVal = changes.analyzerConfig.newValue || {};
            mergeAnalyzerConfig(newVal);
            (async () => {
                await enforceProfileGateOnAIMode('storage_changed');
            })();
            console.log('AnalyzerConfig aplicado imediatamente:', analyzerConfig);
            
            // âœ… EXIBIR NOVAS CONFIGURAÃ‡Ã•ES
            console.log('\nğŸ”„ CONFIGURAÃ‡Ã•ES ATUALIZADAS:');
            logActiveConfiguration();
            
            // âœ… VALIDAR CONFIGURAÃ‡Ã•ES (detectar conflitos)
            const minSize = analyzerConfig.minPatternSize || 2;
            const maxSize = analyzerConfig.maxPatternSize || 0;
            const minOcc = analyzerConfig.minOccurrences || 1;
            const maxOcc = analyzerConfig.maxOccurrences || 0;
            
            if (maxSize > 0 && maxSize < minSize) {
                console.error('â•‘  âš ï¸ CONFIGURAÃ‡ÃƒO INVÃLIDA DETECTADA!                     â•‘');
                console.error(`â•‘  âŒ Tamanho MÃXIMO (${maxSize}) < MÃNIMO (${minSize})!`);
                console.error('â•‘  ğŸš« NENHUM PADRÃƒO SERÃ ENCONTRADO!                        â•‘');
                console.error('â•‘  ğŸ’¡ Ajuste: maxPatternSize >= minPatternSize             â•‘');
            }
            
            if (maxOcc > 0 && maxOcc < minOcc) {
                console.error('â•‘  âš ï¸ CONFIGURAÃ‡ÃƒO INVÃLIDA DETECTADA!                     â•‘');
                console.error(`â•‘  âŒ OcorrÃªncias MÃXIMAS (${maxOcc}) < MÃNIMAS (${minOcc})!`);
                console.error('â•‘  ğŸš« NENHUM PADRÃƒO SERÃ ENCONTRADO!                        â•‘');
                console.error('â•‘  ğŸ’¡ Ajuste: maxOccurrences >= minOccurrences             â•‘');
            }

        // âœ… Notificar todas as abas do Blaze para atualizar UI imediatamente (sem refresh)
        try {
            chrome.tabs.query({ url: '*://blaze.com/*' }, function(tabs) {
                tabs.forEach(tab => {
                    chrome.tabs.sendMessage(tab.id, {
                        type: 'ANALYZER_CONFIG_UPDATED',
                        analyzerConfig
                    }).catch(() => {});
                });
            });
        } catch (err) {
            console.warn('âš ï¸ Falha ao notificar abas sobre atualizaÃ§Ã£o de config:', err);
        }
        } catch (e) {
            console.warn('Falha ao aplicar analyzerConfig:', e);
        }
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALIBRADOR DE PORCENTAGENS - INICIALIZAÃ‡ÃƒO
// (VariÃ¡veis movidas para o topo do arquivo para evitar TDZ errors)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âœ… Carregar histÃ³rico de cores quentes ao iniciar
loadHotColorsHistory();

// Carregar dados do observador ao iniciar
(async function loadObserverDataAtStartup() {
    try {
        const res = await chrome.storage.local.get(['observerData', 'entriesHistory', 'martingaleState']);
        if (res && res.observerData) {
            observerData = { ...observerData, ...res.observerData };
            console.log('â•‘  ğŸ“Š CALIBRADOR DE PORCENTAGENS CARREGADO                 â•‘');
            console.log(`â•‘  ğŸ“ˆ Entradas monitoradas: ${observerData.entries.length}`);
            console.log(`â•‘  ğŸ“Š Ãšltima calibraÃ§Ã£o: ${observerData.lastCalibratedCount} entradas`);
            console.log(`â•‘  ğŸ”§ Fator de calibraÃ§Ã£o: ${(observerData.calibrationFactor * 100).toFixed(1)}%`);
            console.log(`â•‘  ğŸ¯ Alta (â‰¥80%): ${observerData.stats.high.total} entradas`);
            console.log(`â•‘  ğŸŸ¡ MÃ©dia (60-79%): ${observerData.stats.medium.total} entradas`);
            console.log(`â•‘  ğŸŸ¢ Baixa (<60%): ${observerData.stats.low.total} entradas`);
        } else {
            console.log('â„¹ï¸ Calibrador de porcentagens: Nenhum dado anterior encontrado (primeira execuÃ§Ã£o)');
        }
        
        // âœ… SINCRONIZAR: Sempre manter observerData sincronizado com entriesHistory
        const entriesHistory = res.entriesHistory || [];
        console.log(`   entriesHistory existe?`, !!entriesHistory);
        console.log(`   entriesHistory.length:`, entriesHistory.length);
        console.log(`   observerData.entries.length:`, observerData.entries.length);
        
        // âœ… CASO 1: entriesHistory foi LIMPO (menos entradas que observerData)
        // Isso significa que o usuÃ¡rio limpou o histÃ³rico, entÃ£o resetar observerData
        if (entriesHistory.length < observerData.entries.length) {
            console.log('â•‘  ğŸ—‘ï¸ HISTÃ“RICO FOI LIMPO - RESETANDO CALIBRADOR          â•‘');
            console.log(`â•‘  Entradas antigas no calibrador: ${observerData.entries.length}`);
            console.log(`â•‘  Entradas atuais no histÃ³rico: ${entriesHistory.length}`);
            
            // Resetar observerData e reconstruir a partir do entriesHistory
            observerData = {
                entries: [],
                calibrationFactor: 1.0,
                lastCalibration: null,
                lastCalibratedCount: 0,
                stats: {
                    high: { predicted: 0, actual: 0, wins: 0, total: 0 },
                    medium: { predicted: 0, actual: 0, wins: 0, total: 0 },
                    low: { predicted: 0, actual: 0, wins: 0, total: 0 }
                }
            };
            
            // Reconstruir observerData a partir das entradas restantes
            for (const entry of entriesHistory) {
                if (entry.confidence && entry.result) {
                    observerData.entries.push({
                        timestamp: entry.timestamp,
                        predicted: Math.round(entry.confidence),
                        result: entry.result.toLowerCase() === 'win' ? 'win' : 'loss',
                        pattern: entry.patternData ? {
                            type: entry.patternData.type || 'unknown',
                            occurrences: entry.patternData.occurrences || 0
                        } : null
                    });
                }
            }
            
            console.log(`âœ… Calibrador resetado e reconstruÃ­do: ${observerData.entries.length} entradas`);
            
            // Atualizar estatÃ­sticas
            updateObserverStats();
            
            // Salvar dados sincronizados
            await saveObserverData(true);
            
            // Enviar atualizaÃ§Ã£o para UI
            sendObserverUpdate(true);
        }
        // âœ… CASO 2: entriesHistory tem MAIS entradas (adicionar novas)
        else if (entriesHistory.length > observerData.entries.length) {
            console.log('â•‘  ğŸ”„ SINCRONIZANDO ENTRADAS COM OBSERVADOR                â•‘');
            console.log(`â•‘  Entradas no histÃ³rico: ${entriesHistory.length}`);
            console.log(`â•‘  Entradas no observador: ${observerData.entries.length}`);
            
            // Adicionar entradas que estÃ£o faltando no observador
            let syncedCount = 0;
            for (const entry of entriesHistory) {
                // Verificar se jÃ¡ existe no observador (por timestamp)
                const exists = observerData.entries.some(e => e.timestamp === entry.timestamp);
                
                console.log(`   Entrada ${syncedCount + 1}/${entriesHistory.length}:`, {
                    timestamp: entry.timestamp,
                    confidence: entry.confidence,
                    result: entry.result,
                    exists: exists
                });
                
                if (!exists && entry.confidence && entry.result) {
                    observerData.entries.push({
                        timestamp: entry.timestamp,
                        predicted: Math.round(entry.confidence),
                        result: entry.result.toLowerCase() === 'win' ? 'win' : 'loss',
                        pattern: entry.patternData ? {
                            type: entry.patternData.type || 'unknown',
                            occurrences: entry.patternData.occurrences || 0
                        } : null
                    });
                    syncedCount++;
                    console.log(`      âœ… Adicionado ao observador (${syncedCount} sincronizadas)`);
                } else if (exists) {
                    console.log(`      â­ï¸ JÃ¡ existe no observador`);
                } else {
                    console.log(`      âš ï¸ Entrada invÃ¡lida (sem confidence ou result)`);
                }
            }
            
            console.log(`â•‘  Total sincronizado: ${syncedCount} novas entradas`);
            
            // Limitar ao mÃ¡ximo configurado
            if (observerData.entries.length > OBSERVER_CONFIG.maxHistorySize) {
                observerData.entries = observerData.entries.slice(-OBSERVER_CONFIG.maxHistorySize);
            }
            
            // Atualizar estatÃ­sticas
            updateObserverStats();
            
            // Salvar dados sincronizados
            await saveObserverData();
            
            console.log(`âœ… SincronizaÃ§Ã£o concluÃ­da: ${observerData.entries.length} entradas no observador`);
            
            // Enviar atualizaÃ§Ã£o para UI
            sendObserverUpdate(true); // Mostrar log ao carregar
        }
        // âœ… CASO 3: JÃ¡ estÃ£o sincronizados (mesmo nÃºmero de entradas)
        else {
            console.log('âœ… Calibrador jÃ¡ estÃ¡ sincronizado com histÃ³rico de entradas');
        }
        
        // âœ… RESTAURAR ESTADO DO MARTINGALE (se houver ciclo ativo)
        if (res.martingaleState && res.martingaleState.active) {
            martingaleState = res.martingaleState;
            console.log('â•‘  ğŸ”„ CICLO DE MARTINGALE RESTAURADO                       â•‘');
            console.log(`â•‘  EstÃ¡gio: ${martingaleState.stage}`);
            console.log(`â•‘  PadrÃ£o: ${martingaleState.patternKey}`);
            console.log(`â•‘  Cor: ${martingaleState.entryColor}`);
            console.log(`â•‘  LOSS consecutivos: ${martingaleState.lossCount}`);
        }
    } catch (e) {
        console.warn('âš ï¸ Falha ao carregar observerData:', e);
    }
})();

// Salvar dados do observador
async function saveObserverData(showLog = false) {
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO
    if (!observerData || !observerData.entries) {
        return;
    }
    
    try {
        await chrome.storage.local.set({ observerData: observerData });
        if (showLog) {
            console.log(`ğŸ’¾ Calibrador salvo: ${observerData.entries.length} entradas, fator ${(observerData.calibrationFactor * 100).toFixed(1)}%, Ãºltima calibraÃ§Ã£o em ${observerData.lastCalibratedCount}`);
        }
    } catch (e) {
        console.error('Erro ao salvar observerData:', e);
    }
}

// Enviar atualizaÃ§Ã£o do observador para content.js
function sendObserverUpdate(showLog = false) {
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO
    if (!observerData || !observerData.entries) {
        return;
    }
    
    const stats = getObserverStats();
    if (showLog) {
        console.log('ğŸ“¤ Enviando OBSERVER_UPDATE para UI:', {
            total: stats.total,
            wins: stats.wins,
            losses: stats.losses,
            winRate: stats.winRate,
            calibrationFactor: stats.calibrationFactor
        });
    }
    sendMessageToContent('OBSERVER_UPDATE', stats);
}

// Registrar uma nova entrada no observador
async function registerEntryInObserver(predictedConfidence, actualResult, entryTime, patternInfo = null) {
    const entry = {
        timestamp: entryTime || Date.now(),
        predicted: Math.round(predictedConfidence),
        result: actualResult, // 'win' ou 'loss'
        pattern: patternInfo ? {
            type: patternInfo.type || 'unknown',
            occurrences: patternInfo.occurrences || 0
        } : null
    };
    
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO (com try/catch para evitar TDZ)
    try {
        if (!observerData || !observerData.entries) {
            console.warn('âš ï¸ observerData nÃ£o inicializado ainda - pulando registro');
            return;
        }
    } catch (error) {
        console.warn('âš ï¸ Erro ao acessar observerData - pulando registro:', error.message);
        return;
    }
    
    // Adicionar ao histÃ³rico
    observerData.entries.push(entry);
    
    // Limitar tamanho do histÃ³rico (manter apenas as Ãºltimas N)
    if (observerData.entries.length > OBSERVER_CONFIG.maxHistorySize) {
        observerData.entries.shift(); // Remove mais antiga
    }
    
    // Atualizar estatÃ­sticas
    updateObserverStats();
    
    // âœ… RECALIBRAR A CADA NOVA ENTRADA (apÃ³s ter o mÃ­nimo de 20 entradas)
    // Isso garante que o peso da calibraÃ§Ã£o usado nos prÃ³ximos cÃ¡lculos esteja sempre atualizado
    if (observerData.entries.length >= OBSERVER_CONFIG.minEntriesForCalibration) {
        console.log(`ğŸ”„ Recalibrando automaticamente apÃ³s nova entrada (${observerData.entries.length} entradas)...`);
        recalibrateConfidenceModel();
    } else {
        console.log(`â³ Aguardando ${OBSERVER_CONFIG.minEntriesForCalibration - observerData.entries.length} entradas para iniciar calibraÃ§Ã£o automÃ¡tica`);
    }
    
    // Salvar dados
    await saveObserverData();
    
    // âœ… Enviar atualizaÃ§Ã£o para UI automaticamente
    sendObserverUpdate();
    
    // Log visual
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“Š ENTRADA OBSERVADA                                     
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ¯ Previsto: ${entry.predicted}%
â•‘  ${actualResult === 'win' ? 'âœ… Resultado: WIN' : 'âŒ Resultado: LOSS'}
â•‘  ğŸ“ˆ Total observado: ${observerData.entries.length}/${OBSERVER_CONFIG.maxHistorySize}
â•‘  ğŸ”§ Fator de calibraÃ§Ã£o: ${(observerData.calibrationFactor * 100).toFixed(1)}%
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `.trim());
}

// Atualizar estatÃ­sticas do observador
function updateObserverStats() {
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO
    if (!observerData || !observerData.entries) {
        return;
    }
    
    // Resetar stats
    observerData.stats = {
        high: { predicted: 0, actual: 0, wins: 0, total: 0 },
        medium: { predicted: 0, actual: 0, wins: 0, total: 0 },
        low: { predicted: 0, actual: 0, wins: 0, total: 0 }
    };
    
    // Calcular para cada faixa
    for (const entry of observerData.entries) {
        let bucket;
        if (entry.predicted >= 80) bucket = 'high';
        else if (entry.predicted >= 60) bucket = 'medium';
        else bucket = 'low';
        
        observerData.stats[bucket].predicted += entry.predicted;
        observerData.stats[bucket].total++;
        
        if (entry.result === 'win') {
            observerData.stats[bucket].wins++;
        }
    }
    
    // Calcular taxas reais
    for (const bucket of ['high', 'medium', 'low']) {
        const stat = observerData.stats[bucket];
        if (stat.total > 0) {
            stat.actual = (stat.wins / stat.total) * 100;
            stat.predicted = stat.predicted / stat.total; // MÃ©dia prevista
        }
    }
}

// Recalibrar o modelo de confianÃ§a baseado no histÃ³rico
// Esta funÃ§Ã£o Ã© chamada:
// - AUTOMATICAMENTE: A cada nova entrada registrada (apÃ³s ter 20+ entradas)
// - MANUALMENTE: Quando o usuÃ¡rio clica no botÃ£o "Atualizar"
function recalibrateConfidenceModel() {
    // âš ï¸ VERIFICAR SE observerData FOI INICIALIZADO
    if (!observerData || !observerData.entries) {
        return;
    }
    
    const entries = observerData.entries;
    if (entries.length < OBSERVER_CONFIG.minEntriesForCalibration) {
        console.log(`âš ï¸ CalibraÃ§Ã£o cancelada: apenas ${entries.length} entradas (mÃ­nimo: ${OBSERVER_CONFIG.minEntriesForCalibration})`);
        return;
    }
    
    // âœ… VERIFICAR SE HÃ NOVAS ENTRADAS desde a Ãºltima calibraÃ§Ã£o
    if (entries.length === observerData.lastCalibratedCount) {
        console.log(`â„¹ï¸ CalibraÃ§Ã£o nÃ£o necessÃ¡ria: nenhuma entrada nova desde a Ãºltima calibraÃ§Ã£o (${entries.length} entradas)`);
        return;
    }
    
    // Calcular taxa de acerto global
    const totalWins = entries.filter(e => e.result === 'win').length;
    const totalEntries = entries.length;
    const actualWinRate = totalWins / totalEntries;
    
    // Calcular mÃ©dia das previsÃµes
    const avgPredicted = entries.reduce((sum, e) => sum + e.predicted, 0) / totalEntries;
    const predictedWinRate = avgPredicted / 100;
    
    // Calcular fator de correÃ§Ã£o
    // Se real = 0.7 (70%) e previsto = 0.85 (85%), fator = 0.7/0.85 = 0.82
    // Isso vai reduzir as prÃ³ximas previsÃµes em ~18%
    let newFactor = predictedWinRate > 0 ? actualWinRate / predictedWinRate : 1.0;
    
    // âœ… REMOVIDA SUAVIZAÃ‡ÃƒO: CÃ¡lculo agora Ã© determinÃ­stico (sempre retorna o mesmo valor para os mesmos dados)
    // NÃ£o hÃ¡ mais mÃ©dia ponderada com valor anterior - o cÃ¡lculo Ã© puro e baseado apenas nos dados atuais
    
    // Limitar fator entre 0.5 e 1.5 (nÃ£o permitir correÃ§Ãµes muito drÃ¡sticas)
    newFactor = Math.max(0.5, Math.min(1.5, newFactor));
    
    const oldFactor = observerData.calibrationFactor;
    observerData.calibrationFactor = newFactor;
    observerData.lastCalibration = new Date().toISOString();
    observerData.lastCalibratedCount = entries.length; // âœ… Salvar quantas entradas foram calibradas
    
    // Log detalhado da calibraÃ§Ã£o
    console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ”§ RECALIBRAÃ‡ÃƒO DO MODELO (${entries.length} entradas)              
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“Š Entradas analisadas: ${totalEntries}
â•‘  
â•‘  ğŸ¯ GLOBAL:
â•‘     Previsto mÃ©dio: ${(predictedWinRate * 100).toFixed(1)}%
â•‘     Real: ${(actualWinRate * 100).toFixed(1)}%
â•‘     DiferenÃ§a: ${((actualWinRate - predictedWinRate) * 100).toFixed(1)}%
â•‘  
â•‘  ğŸ”´ ALTA (â‰¥80%):
â•‘     Previsto: ${observerData.stats.high.predicted.toFixed(1)}%
â•‘     Real: ${observerData.stats.high.actual.toFixed(1)}%
â•‘     Total: ${observerData.stats.high.total} entradas
â•‘  
â•‘  ğŸŸ¡ MÃ‰DIA (60-79%):
â•‘     Previsto: ${observerData.stats.medium.predicted.toFixed(1)}%
â•‘     Real: ${observerData.stats.medium.actual.toFixed(1)}%
â•‘     Total: ${observerData.stats.medium.total} entradas
â•‘  
â•‘  ğŸŸ¢ BAIXA (<60%):
â•‘     Previsto: ${observerData.stats.low.predicted.toFixed(1)}%
â•‘     Real: ${observerData.stats.low.actual.toFixed(1)}%
â•‘     Total: ${observerData.stats.low.total} entradas
â•‘  
â•‘  âš™ï¸ AJUSTE:
â•‘     Fator anterior: ${(oldFactor * 100).toFixed(1)}%
â•‘     Fator novo: ${(newFactor * 100).toFixed(1)}%
â•‘     CorreÃ§Ã£o: ${((newFactor - oldFactor) * 100).toFixed(1)}%
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    `.trim());
}

// Aplicar calibraÃ§Ã£o a uma porcentagem de confianÃ§a
function applyCalibratedConfidence(rawConfidence) {
    // âœ… VERIFICAÃ‡ÃƒO DEFENSIVA: observerData pode nÃ£o estar inicializado ainda
    if (!observerData || !observerData.entries) {
        console.log(`âš ï¸ CalibraÃ§Ã£o indisponÃ­vel: observerData nÃ£o inicializado (retornando confianÃ§a original)`);
        return Math.round(rawConfidence);
    }
    
    // âœ… REGRA: SÃ³ aplicar calibraÃ§Ã£o apÃ³s 10+ entradas no observador
    const minEntriesForCalibration = 10;
    const currentEntries = observerData.entries.length;
    
    if (currentEntries < minEntriesForCalibration) {
        console.log(`â„¹ï¸ CalibraÃ§Ã£o desativada: ${currentEntries}/${minEntriesForCalibration} entradas (coletando dados)`);
        return Math.round(rawConfidence); // Retorna confianÃ§a original
    }
    
    // Aplicar fator de calibraÃ§Ã£o
    let calibrated = rawConfidence * observerData.calibrationFactor;
    
    // Garantir que fique entre 0-100
    calibrated = Math.max(0, Math.min(100, calibrated));
    
    console.log(`ğŸ”§ CalibraÃ§Ã£o aplicada: ${rawConfidence.toFixed(1)}% â†’ ${Math.round(calibrated)}% (fator: ${(observerData.calibrationFactor * 100).toFixed(1)}%, ${currentEntries} entradas)`);
    
    return Math.round(calibrated);
}

// Obter estatÃ­sticas do observador para exibiÃ§Ã£o
function getObserverStats() {
    const entries = observerData.entries;
    if (entries.length === 0) {
        return {
            total: 0,
            wins: 0,
            losses: 0,
            winRate: 0,
            calibrationFactor: observerData.calibrationFactor,
            byConfidence: observerData.stats
        };
    }
    
    const wins = entries.filter(e => e.result === 'win').length;
    const losses = entries.length - wins;
    
    return {
        total: entries.length,
        wins: wins,
        losses: losses,
        winRate: (wins / entries.length) * 100,
        calibrationFactor: observerData.calibrationFactor,
        byConfidence: observerData.stats,
        lastCalibration: observerData.lastCalibration,
        lastCalibratedCount: observerData.lastCalibratedCount // Quantas entradas foram processadas na Ãºltima calibraÃ§Ã£o
    };
}

// Start data collection
async function startDataCollection() {
    if (isRunning) return;
    
    // âœ… VERIFICAR SE HÃ ABA DA BLAZE ABERTA ANTES DE INICIAR
    const hasBlaze = await hasBlazeTabOpen();
    if (!hasBlaze) {
        console.log('â•‘  â›” IMPOSSÃVEL INICIAR: NENHUMA ABA DA BLAZE ABERTA      â•‘');
        console.log('â•‘  ğŸ’¡ Abra blaze.com para usar a extensÃ£o                  â•‘');
        return;
    }
    
    isRunning = true;
    
    // âœ… CARREGAR CONFIGURAÃ‡Ã•ES E ESTADO DO MARTINGALE DO STORAGE IMEDIATAMENTE
    try {
        const storageData = await chrome.storage.local.get(['analyzerConfig', 'martingaleState', RECOVERY_MODE_KEY]);
        
        // Carregar configuraÃ§Ãµes
        if (storageData.analyzerConfig) {
            mergeAnalyzerConfig(storageData.analyzerConfig);
            console.log('âœ… ConfiguraÃ§Ãµes carregadas do storage com sucesso!');
            console.log('ğŸ”§ DEBUG - Config carregada:', {
                aiMode: analyzerConfig.aiMode,
                modoDiamante: analyzerConfig.aiMode ? 'ATIVO' : 'Desativado',
                minOccurrences: analyzerConfig.minOccurrences
            });
            
            // âœ… Se Modo Diamante jÃ¡ estava ativo ao iniciar, marcar flag para aguardar 1 giro
            if (analyzerConfig.aiMode) {
                aiModeJustActivated = true;
                console.log('%câ³ MODO DIAMANTE DETECTADO AO INICIAR: Aguardando 1 giro antes de enviar primeiro sinal...', 'color: #FFAA00; font-weight: bold;');
            }
        } else {
            console.log('â„¹ï¸ Usando configuraÃ§Ãµes padrÃ£o (nenhuma personalizaÃ§Ã£o salva)');
        }
        
        // âš ï¸ CRÃTICO: Carregar estado do Martingale do storage (pode haver ciclo em andamento)
        if (storageData.martingaleState && storageData.martingaleState.active) {
            martingaleState = storageData.martingaleState;
            console.log('ğŸ”„ Ciclo de Martingale em andamento detectado:', {
                stage: martingaleState.stage,
                entryColor: martingaleState.entryColor,
                lossCount: martingaleState.lossCount
            });
        }

        // ğŸ§¼ RecuperaÃ§Ã£o (manual) DESATIVADA:
        // A UI foi migrada para o painel "Branco" (24h + puxadores). NÃ£o permitir que recovery esconda sinais.
        recoveryModeEnabled = false;
        try {
            await chrome.storage.local.set({ [RECOVERY_MODE_KEY]: { enabled: false, updatedAt: Date.now(), disabledBy: 'white_panel' } });
        } catch (_) {}
    } catch (e) {
        console.warn('âš ï¸ Erro ao carregar configuraÃ§Ãµes/estado, usando padrÃ£o:', e);
    }
    
    console.log('â•‘  ğŸš€ BLAZE ANALYZER - INICIANDO                            â•‘');
    console.log('â•‘  ğŸ“¡ Modo: SERVIDOR (coleta do Render.com)                 â•‘');
    console.log('â•‘  âš¡ AtualizaÃ§Ã£o: TEMPO REAL via WebSocket                 â•‘');
    console.log('â•‘  ğŸ“Š Limite: 10000 giros | 5000 padrÃµes                    â•‘');
    console.log('â•‘  ğŸ’¾ Cache: Em memÃ³ria (nÃ£o persiste apÃ³s recarregar)      â•‘');
    
    // âœ… EXIBIR CONFIGURAÃ‡Ã•ES ATIVAS AO INICIAR
    logActiveConfiguration();
	logModeSnapshot('InicializaÃ§Ã£o', cachedHistory.length);
    
    // 1. Limpar padrÃµes locais (comeÃ§ar do zero)
    // âœ… Isso NÃƒO limpa: entriesHistory, anÃ¡lise pendente, calibrador
    // âœ… Limpa APENAS: banco de padrÃµes (patterns_found)
    await clearAllPatterns();
    
    // âœ… Verificar se entriesHistory foi preservado
    const checkData = await chrome.storage.local.get(['entriesHistory', 'analysis']);
    console.log(`âœ… HistÃ³rico de entradas preservado: ${(checkData.entriesHistory || []).length} entradas`);
    
    // âœ… Verificar se hÃ¡ anÃ¡lise pendente (aguardando resultado)
    if (checkData.analysis && checkData.analysis.createdOnTimestamp) {
        console.log('â•‘  ğŸ¯ ANÃLISE PENDENTE DETECTADA!                          â•‘');
        console.log(`â•‘  Cor recomendada: ${checkData.analysis.color}`);
        console.log(`â•‘  ConfianÃ§a: ${checkData.analysis.confidence}%`);
        console.log(`â•‘  Fase: ${checkData.analysis.phase || 'G0'}`);
        console.log(`â•‘  Criada em: ${checkData.analysis.createdOnTimestamp}`);
        console.log('â•‘  Status: Aguardando resultado do prÃ³ximo giro           â•‘');
    } else {
        console.log('â„¹ï¸ Nenhuma anÃ¡lise pendente no momento');
    }
    
    // 2. Resetar cache em memÃ³ria
    console.log('ğŸ—‘ï¸ Resetando cache em memÃ³ria...');
    cachedHistory = [];
    historyInitialized = false;
    console.log('âœ… Cache em memÃ³ria resetado.');
    
    // 3. Sincronizar dados com servidor primeiro (popula cache em memÃ³ria)
    await syncInitialData().catch(e => console.warn('Falha ao sincronizar com servidor:', e));
    
    // 4. Inicializar histÃ³rico completo (atÃ© 10k) uma vez ao iniciar
    await initializeHistoryIfNeeded().catch(e => console.warn('Falha ao inicializar histÃ³rico completo:', e));

    // âœ… AUTO-HEAL: se existe anÃ¡lise pendente OU martingale consecutivo travado, limpar para nÃ£o travar o sistema.
    // Motivo: apÃ³s refresh/erro, pode ficar martingale ativo (G1/G2) sem analysis correspondente â†’ trava sinais para sempre.
    try {
        const latestSpinObj = (cachedHistory && cachedHistory.length > 0) ? cachedHistory[0] : null;
        const latestMs = Number.isFinite(parseSpinTimestamp(latestSpinObj)) ? parseSpinTimestamp(latestSpinObj) : 0;

        const stored = await chrome.storage.local.get(['analysis', 'martingaleState']);
        const a = stored && stored.analysis ? stored.analysis : null;
        const storedMart = stored && stored.martingaleState ? stored.martingaleState : null;
        const effectiveMart = (storedMart && storedMart.active) ? storedMart : martingaleState;

        const parseMs = (v) => {
            try {
                if (v == null) return 0;
                if (typeof v === 'number') return Number.isFinite(v) ? v : 0;
                const n = Number(v);
                if (Number.isFinite(n)) return n;
                const ms = Date.parse(String(v));
                return Number.isFinite(ms) ? ms : 0;
            } catch (_) { return 0; }
        };
        const aMs = parseMs(a && a.createdOnTimestamp);
        const entryMs = parseMs(effectiveMart && (effectiveMart.entryTimestamp || (effectiveMart.analysisData && effectiveMart.analysisData.createdOnTimestamp)));

        // Se o histÃ³rico jÃ¡ avanÃ§ou bem alÃ©m do timestamp do sinal, entÃ£o ele nÃ£o deveria seguir pendente.
        // 3 minutos Ã© extremamente conservador (o jogo resolve em poucos segundos).
        const STALE_MS = 3 * 60 * 1000;

        const { consecutiveGales } = getMartingaleSettingsForEntryColor(effectiveMart && effectiveMart.entryColor);
        const isConsecutiveStage = !!(effectiveMart && effectiveMart.active && isMartingaleStageConsecutive(effectiveMart.stage, consecutiveGales));
        const analysisStale = !!(a && aMs > 0 && latestMs > 0 && latestMs > aMs && (latestMs - aMs) > STALE_MS);
        const martingaleStale = !!(
            isConsecutiveStage &&
            // se nÃ£o hÃ¡ analysis pendente, Ã© inconsistente (consecutivo exige analysis para avaliar prÃ³ximo giro)
            (!a || !a.createdOnTimestamp) &&
            // e se jÃ¡ passou tempo suficiente desde o inÃ­cio do ciclo (ou estado estÃ¡ sem timestamp)
            (entryMs <= 0 || (latestMs > 0 && entryMs > 0 && latestMs > entryMs && (latestMs - entryMs) > STALE_MS))
        );

        if (analysisStale || martingaleStale) {
            const reason = analysisStale ? 'analysis_stale_startup' : 'martingale_consecutive_stale_no_analysis_startup';
            console.warn('ğŸ§¯ [AUTO-HEAL] Estado travado detectado no startup. Limpando para destravar.', {
                reason,
                stage: effectiveMart && effectiveMart.stage,
                entryTimestamp: effectiveMart && effectiveMart.entryTimestamp,
                analysisCreatedOnTimestamp: a && a.createdOnTimestamp,
                latestMs,
                deltaSec: Math.round(((analysisStale ? (latestMs - aMs) : (latestMs - entryMs)) || 0) / 1000)
            });
            resetMartingaleState();
            await chrome.storage.local.set({
                analysis: null,
                pattern: null,
                lastBet: { status: 'loss', phase: (a && a.phase) || (effectiveMart && effectiveMart.stage) || 'G0', resolvedAtTimestamp: (latestSpinObj && (latestSpinObj.timestamp ?? latestSpinObj.created_at)) || Date.now(), clearedReason: reason },
                martingaleState
            });
            sendMessageToContent('CLEAR_ANALYSIS');
        }
    } catch (e) {
        console.warn('âš ï¸ Falha no auto-heal de anÃ¡lise pendente:', e);
    }
    
    // âœ… Rodar anÃ¡lise imediatamente apÃ³s o bootstrap.
    // Isso evita o â€œtravamentoâ€ percebido onde sÃ³ comeÃ§a apÃ³s clicar em "Salvar".
    // (NÃ£o depende do prÃ³ximo giro.)
    try {
        if (cachedHistory && cachedHistory.length >= 10) {
            await runAnalysisIfEnabled(cachedHistory, 'STARTUP_BOOTSTRAP');
        } else {
            console.log('â„¹ï¸ HistÃ³rico insuficiente para anÃ¡lise imediata no startup (mÃ­n. 10 giros).');
        }
    } catch (e) {
        console.warn('âš ï¸ Falha ao executar anÃ¡lise inicial no startup:', e);
    }

    // 5. Busca de padrÃµes agora Ã© MANUAL (usuÃ¡rio clica no botÃ£o)
    // â±ï¸ DuraÃ§Ã£o atual: 30s (busca rÃ¡pida e intensiva)
    console.log('ğŸ’¡ Para buscar padrÃµes, clique em "ğŸ” Buscar PadrÃµes (30s)" na interface.');
    
    // 6. âœ… CONECTAR AO WEBSOCKET PARA RECEBER GIROS EM TEMPO REAL
    if (API_CONFIG.useWebSocket) {
        console.log('â•‘  âš¡ MODO WEBSOCKET ATIVO                                   â•‘');
        console.log('â•‘  Giros serÃ£o recebidos em TEMPO REAL (sem delay)         â•‘');
        connectWebSocket();
        
        // âœ… Iniciar sistema de verificaÃ§Ã£o de dados desatualizados
        startDataFreshnessCheck();
    } else {
        // Fallback: Polling com fetch (modo antigo)
        console.log('âš ï¸ Modo polling ativo (a cada 2s)');
        intervalId = setInterval(async () => {
            try {
                // âœ… VERIFICAR SE ABA DA BLAZE AINDA ESTÃ ABERTA (A CADA TICK)
                const hasBlaze = await hasBlazeTabOpen();
                if (!hasBlaze) {
                    console.log('â•‘  âš ï¸ ABA DA BLAZE FECHADA - PARANDO COLETA                â•‘');
                    stopDataCollection();
                    return;
                }
                
                await collectDoubleData();
            } catch (error) {
                console.error('Erro na coleta de dados:', error);
            }
        }, 2000);
    }
}

// Stop data collection
function stopDataCollection() {
    if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
    }
    
    // âœ… DESCONECTAR WEBSOCKET
    disconnectWebSocket();
    
    // âœ… PARAR POLLING DE FALLBACK
    stopPollingFallback();
    
    // âœ… PARAR VERIFICAÃ‡ÃƒO DE DADOS DESATUALIZADOS
    stopDataFreshnessCheck();
    
    isRunning = false;
    console.log('Blaze Double Analyzer: Parando coleta de dados');
}

// Collect data from SERVER (agora busca do servidor que estÃ¡ coletando 24/7)
async function collectDoubleData() {
    try {
        // Buscar Ãºltimo giro do SERVIDOR
        {
            const url = `${API_CONFIG.baseURL}/api/giros/latest`;
            const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
            const timeoutId = controller ? setTimeout(() => controller.abort(), 5000) : null;
            var response = await fetch(url, controller ? { signal: controller.signal } : undefined)
                .finally(() => { if (timeoutId) clearTimeout(timeoutId); });
        }
        
        if (!response.ok) {
            // Se servidor offline, tenta buscar direto da Blaze (fallback)
            console.warn('âš ï¸ Servidor offline, buscando direto da Blaze...');
            const blazeResponse = await fetch('https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/1');
            if (!blazeResponse.ok) throw new Error('Blaze API offline');
            const dataArr = await blazeResponse.json();
            if (!Array.isArray(dataArr) || dataArr.length === 0) return;
            
            const latestSpin = dataArr[0];
            const rollNumber = latestSpin.roll;
            const rollColor = getColorFromNumber(rollNumber);
            
            processNewSpin({
                id: `spin_${latestSpin.created_at}`,
                number: rollNumber,
                color: rollColor,
                timestamp: latestSpin.created_at,
                created_at: latestSpin.created_at,
                source: 'blaze_direct'
            });
            return;
        }
        
        const data = await response.json();
        
        if (data.success && data.data) {
            const latestSpin = data.data;
            
            // Verificar se jÃ¡ temos esse giro localmente e processar
            await processNewSpinFromServer(latestSpin);
        } else {
            console.log('â³ Aguardando giros do servidor...');
        }
    } catch (error) {
        console.error('Erro ao coletar dados do servidor:', error);
    }
}

// Helper: Converter nÃºmero em cor
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GET COLOR FROM NUMBER - REFATORADO 100%
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function getColorFromNumber(number) {
                // âœ… VALIDAÃ‡ÃƒO DE ENTRADA (silenciosa)
                if (typeof number !== 'number' || isNaN(number) || number === undefined || number === null) {
                    return 'unknown';
                }
                
                // âœ… NORMALIZAR NÃšMERO (caso seja float)
                const normalizedNumber = Math.floor(number);
                
                // âœ… VALIDAR RANGE (0-14)
                if (normalizedNumber < 0 || normalizedNumber > 14) {
                    return 'unknown';
                }
                
                // âœ… DETERMINAR COR
                if (normalizedNumber === 0) {
                    return 'white';
                } else if (normalizedNumber >= 1 && normalizedNumber <= 7) {
                    return 'red';
                } else if (normalizedNumber >= 8 && normalizedNumber <= 14) {
                    return 'black';
                }
                
                // âœ… FALLBACK (nunca deve chegar aqui)
                return 'unknown';
            }

// ğŸ”¥ NÃƒO BLOQUEAR O SINAL (tempo real):
// Tarefas de IO (Telegram, observador, mÃ©tricas) NÃƒO podem travar o pipeline do giro.
function detachPromise(promise, label = 'detached') {
    try {
        Promise.resolve(promise).catch((err) => {
            const msg = err && err.message ? err.message : String(err);
            console.warn(`âš ï¸ [${label}] falhou (detached):`, msg);
        });
    } catch (err) {
        const msg = err && err.message ? err.message : String(err);
        console.warn(`âš ï¸ [${label}] falhou (detached wrapper):`, msg);
    }
}

// Processar novo giro vindo do servidor
async function processNewSpinFromServer(spinData) {
    try {
        const rollNumber = spinData.number;
        const rollColor = spinData.color;
        const latestSpin = {
            created_at: spinData.timestamp || spinData.created_at,
            roll: rollNumber
        };
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // âš¡ PRIORIDADE MÃXIMA: ENVIAR GIRO PARA O UI IMEDIATAMENTE (SEM ESPERAR NADA!)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Adiciona novo giro ao cache ANTES de qualquer operaÃ§Ã£o assÃ­ncrona
        const newGiro = {
            id: spinData.id || `spin_${latestSpin.created_at}`,
                    number: rollNumber,
                    color: rollColor,
            timestamp: latestSpin.created_at,
            created_at: latestSpin.created_at
        };
        
        // Verificar se Ã© realmente um giro novo
        const isNewSpin = cachedHistory.length === 0 || 
                        cachedHistory[0].timestamp !== latestSpin.created_at || 
                        cachedHistory[0].number !== rollNumber;
            
            if (isNewSpin) {
            // ğŸ” DiagnÃ³stico de latÃªncia: quanto tempo depois do timestamp do giro estamos detectando isso?
            // (SÃ³ loga quando passar de 5s para nÃ£o poluir o console)
            try {
                const spinMs = parseSpinTimestamp(latestSpin);
                const nowMs = Date.now();
                if (Number.isFinite(spinMs) && spinMs > 0) {
                    const delta = nowMs - spinMs;
                    if (delta > 5000) {
                        console.warn(`â±ï¸ [LATÃŠNCIA] Novo giro detectado com atraso de ~${Math.round(delta)}ms (ideal: <= 2000ms).`, {
                            number: rollNumber,
                            color: rollColor,
                            spinTimestamp: latestSpin.created_at,
                            now: new Date(nowMs).toISOString()
                        });
                    }
                }
            } catch (_) {}

            console.log('ğŸ¯ NOVO GIRO DETECTADO!', {
                    number: rollNumber,
                    color: rollColor,
                    timestamp: latestSpin.created_at
                });
            
            // âš¡ ATUALIZAR CACHE IMEDIATAMENTE (operaÃ§Ã£o sÃ­ncrona, super rÃ¡pida!)
            cachedHistory.unshift(newGiro);
            if (cachedHistory.length > REALTIME_HISTORY_CAP) {
                cachedHistory.pop(); // manter cap sem custo de slice
            }
            
            console.log(`âš¡ Cache atualizado! ${cachedHistory.length} giros`);
            
            // âš¡âš¡âš¡ ENVIAR PARA O UI IMEDIATAMENTE - SEM ESPERAR NADA! âš¡âš¡âš¡
            // Usar sendMessage sÃ­ncrono + try/catch para mÃ¡xima velocidade
            const spinMessage = {
                type: 'NEW_SPIN',
                data: {
                    lastSpin: { 
                    number: rollNumber,
                    color: rollColor,
                        timestamp: latestSpin.created_at 
                    }
                }
            };
            
            // âœ… ENVIAR PARA O UI IMEDIATAMENTE
            chrome.tabs.query({ url: '*://blaze.com/*' }, (tabs) => {
                if (tabs && tabs.length > 0) {
                    tabs.forEach(tab => {
                        chrome.tabs.sendMessage(tab.id, spinMessage).catch(() => {
                            // Ignorar tabs sem content.js
                        });
                    });
                    console.log(`âš¡ GIRO ENVIADO INSTANTANEAMENTE para ${tabs.length} tab(s)!`);
                } else {
                    // Fallback: tentar enviar para todas as tabs
                    chrome.tabs.query({}, (allTabs) => {
                        if (allTabs && allTabs.length > 0) {
                            allTabs.forEach(tab => {
                                chrome.tabs.sendMessage(tab.id, spinMessage).catch(() => {});
                            });
                        }
                    });
                }
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ“¦ OPERAÃ‡Ã•ES NECESSÃRIAS (UI jÃ¡ foi atualizado instantaneamente acima!)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // âœ… OTIMIZAÃ‡ÃƒO CRÃTICA (Premium + Diamante):
            // VÃ¡rios gets em sequÃªncia somam latÃªncia e podem â€œengasgarâ€ o sinal (especialmente em mobile).
            // Aqui fazemos UMA leitura e UM set em paralelo.
            const storageKeys = ['entriesHistory', RECOVERY_SECURE_HISTORY_KEY, 'analyzerConfig', 'martingaleState', 'analysis'];
            let storageSnapshot = {};
            try {
                const [got] = await Promise.all([
                    chrome.storage.local.get(storageKeys),
                    chrome.storage.local.set({
                        lastSpin: {
                            number: rollNumber,
                            color: rollColor,
                            timestamp: latestSpin.created_at
                        }
                    })
                ]);
                storageSnapshot = got || {};
            } catch (e) {
                console.warn('âš ï¸ Storage batch (get+set) falhou, usando fallback parcial:', e && e.message ? e.message : e);
                // Fallback: ao menos persistir lastSpin; o resto fica com defaults
                try {
                    await chrome.storage.local.set({
                        lastSpin: {
                            number: rollNumber,
                            color: rollColor,
                            timestamp: latestSpin.created_at
                        }
                    });
                } catch (_) {}
                try {
                    storageSnapshot = await chrome.storage.local.get(storageKeys);
                } catch (_) {
                    storageSnapshot = {};
                }
            }

            // entriesHistory + recoverySecureHistory (uma Ãºnica leitura)
            let entriesHistory = Array.isArray(storageSnapshot.entriesHistory) ? storageSnapshot.entriesHistory : [];
            let recoverySecureHistory = Array.isArray(storageSnapshot[RECOVERY_SECURE_HISTORY_KEY]) ? storageSnapshot[RECOVERY_SECURE_HISTORY_KEY] : [];
            
            // âš¡ ATUALIZAR MEMÃ“RIA ATIVA INCREMENTALMENTE (super rÃ¡pido!)
            if (memoriaAtiva.inicializada) {
                const sucesso = atualizarMemoriaIncrementalmente(newGiro);
                if (sucesso) {
                    console.log(`%câš¡ MemÃ³ria Ativa atualizada! (${memoriaAtiva.tempoUltimaAtualizacao.toFixed(2)}ms)`, 'color: #00CED1; font-weight: bold;');
                } else {
                    console.warn('%câš ï¸ Falha ao atualizar MemÃ³ria Ativa!', 'color: #FFA500;');
                }
            } else {
                // âœ… Se modo IA estÃ¡ ativo e memÃ³ria nÃ£o foi inicializada, inicializar agora
                if (analyzerConfig.aiMode && cachedHistory.length >= 60) {
                    console.log('%cğŸ§  Inicializando MemÃ³ria Ativa...', 'color: #00CED1; font-weight: bold;');
                    const sucesso = await inicializarMemoriaAtiva(cachedHistory);
                    if (sucesso) {
                        console.log('%câœ… MemÃ³ria Ativa inicializada!', 'color: #00FF88; font-weight: bold;');
                    } else {
                        console.log('%câš ï¸ Falha ao inicializar MemÃ³ria Ativa', 'color: #FFAA00;');
                    }
                }
            }
            
            // âœ… CARREGAR CONFIGURAÃ‡Ã•ES E ESTADO DO MARTINGALE DO STORAGE
            try {
                // Carregar configuraÃ§Ãµes
                if (storageSnapshot.analyzerConfig) {
                    mergeAnalyzerConfig(storageSnapshot.analyzerConfig);
                    const activeModeKey = getModeKey();
                    const otherModeKey = activeModeKey === 'diamond' ? 'standard' : 'diamond';
                    console.log('âš™ï¸ ConfiguraÃ§Ãµes carregadas:', {
                        aiMode: analyzerConfig.aiMode,
                        n0AllowBlockAll: analyzerConfig.n0AllowBlockAll !== false,
                        martingale: {
                            [activeModeKey]: getMartingaleSettings(activeModeKey),
                            [otherModeKey]: getMartingaleSettings(otherModeKey)
                        }
                    });
                }
                
                // âš ï¸ CRÃTICO: Carregar estado do Martingale do storage
                if (storageSnapshot.martingaleState) {
                    martingaleState = storageSnapshot.martingaleState;
                    console.log('ğŸ”„ Estado do Martingale carregado:', {
                        active: martingaleState.active,
                        stage: martingaleState.stage,
                        entryColor: martingaleState.entryColor,
                        lossCount: martingaleState.lossCount
                    });
                }
            } catch (e) {
                console.warn('âš ï¸ Erro ao carregar configuraÃ§Ãµes/estado, usando padrÃ£o:', e);
            }
            
            console.log('ğŸ” Buscando currentAnalysis de chrome.storage.local...');
                
                // Avaliar recomendaÃ§Ã£o pendente (WIN / G1 / G2)
            const currentAnalysis = storageSnapshot ? storageSnapshot.analysis : null;
            const isHiddenInternal = !!(currentAnalysis && currentAnalysis.hiddenInternal);
            const activeHistory = isHiddenInternal ? recoverySecureHistory : entriesHistory;
            
            console.log('ğŸ“Š Resultado da busca:', { analysis: currentAnalysis ? '[ok]' : null });
            console.log('ğŸ“Š currentAnalysis existe?', currentAnalysis ? 'SIM' : 'NÃƒO');
            
            if (currentAnalysis) {
                console.log('   Cor recomendada:', currentAnalysis.color);
                console.log('   ConfianÃ§a:', currentAnalysis.confidence);
                console.log('   Fase:', currentAnalysis.phase || 'G0');
                console.log('   Timestamp recomendaÃ§Ã£o:', currentAnalysis.createdOnTimestamp);
                console.log('   PredictedFor:', currentAnalysis.predictedFor);
            }
            
            console.log('ğŸ² Giro atual:');
            console.log('   Cor:', rollColor);
            console.log('   NÃºmero:', rollNumber);
            console.log('   Timestamp:', latestSpin.created_at ?? latestSpin.timestamp);
            
                // âœ… Corrigido: algumas anÃ¡lises antigas/alternativas nÃ£o possuem predictedFor='next'
                // (ex.: resultados de performPatternAnalysis). Se createdOnTimestamp existe, tratamos como pendente.
                if (currentAnalysis && currentAnalysis.createdOnTimestamp) {
                const latestSpinMs = parseSpinTimestamp(latestSpin);
                const analysisMs = parseSpinTimestamp({ timestamp: currentAnalysis.createdOnTimestamp, created_at: currentAnalysis.createdOnTimestamp });
                const shouldEvaluate = (Number.isFinite(latestSpinMs) && Number.isFinite(analysisMs))
                    ? (latestSpinMs !== analysisMs)
                    : (String(currentAnalysis.createdOnTimestamp) !== String(latestSpin.created_at ?? latestSpin.timestamp ?? ''));

                console.log('âœ… RecomendaÃ§Ã£o pendente encontrada!');
                console.log('ğŸ” Comparando timestamps (normalizado):');
                console.log('   RecomendaÃ§Ã£o:', currentAnalysis.createdOnTimestamp, '=>', analysisMs);
                console.log('   Giro atual:', (latestSpin.created_at ?? latestSpin.timestamp), '=>', latestSpinMs);
                console.log('   Avaliar agora?', shouldEvaluate);
                
                    // Novo giro chegou para a recomendaÃ§Ã£o pendente
                    if (shouldEvaluate) {
                    console.log('ğŸ¯ AVALIAR RESULTADO!');
                    console.log('   Esperado:', currentAnalysis.color);
                    console.log('   Real:', rollColor);
                    console.log('   Tipo esperado:', typeof currentAnalysis.color);
                    console.log('   Tipo real:', typeof rollColor);
                    console.log('   ComparaÃ§Ã£o exata:', rollColor === currentAnalysis.color);
                    console.log('   ComparaÃ§Ã£o case-insensitive:', rollColor.toLowerCase() === currentAnalysis.color.toLowerCase());
                    
                        // âœ… CORREÃ‡ÃƒO CRÃTICA: ComparaÃ§Ã£o robusta de cores
                        const normalizeSimpleColor = (value) => {
                            const s = String(value || '').toLowerCase().trim();
                            if (!s) return '';
                            if (s.startsWith('r')) return 'red';
                            // "branco" nÃ£o Ã© black
                            if (s.startsWith('b') && s !== 'branco') return 'black';
                            if (s.startsWith('w') || s === 'branco') return 'white';
                            return s;
                        };
                        const expectedColor = normalizeSimpleColor(currentAnalysis.color);
                        const actualColor = normalizeSimpleColor(rollColor);

                        // âœ… ProteÃ§Ã£o no branco: se ativada, WHITE conta como WIN (ciclo nÃ£o Ã© perdido).
                        const whiteProtectedHit = !!analyzerConfig.whiteProtectionAsWin
                            && actualColor === 'white'
                            && (expectedColor === 'red' || expectedColor === 'black');
                        const hit = (expectedColor === actualColor) || whiteProtectedHit;
                    
                    console.log('   ğŸ” VERIFICAÃ‡ÃƒO FINAL DE WIN/LOSS:');
                    console.log('   Esperado (processado):', expectedColor);
                    console.log('   Real (processado):', actualColor);
                    console.log('   SÃ£o iguais?', hit);
                    console.log('   Resultado FINAL:', hit ? 'âœ… WIN!' : 'âŒ LOSS!');
                    
                        if (hit) {
                        console.log('â•‘  âœ… WIN DETECTADO!                                       â•‘');
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // âœ… SISTEMA DE MARTINGALE - LÃ“GICA DE WIN
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            
                            // âœ… VALIDAÃ‡ÃƒO CRÃTICA: Garantir que nÃ£o hÃ¡ processamento duplo
                            console.log('   Martingale ativo:', martingaleState.active);
                            console.log('   EstÃ¡gio atual:', martingaleState.stage);
                            console.log('   AnÃ¡lise fase:', currentAnalysis.phase);
                            
                            // Se jÃ¡ foi processado como WIN, nÃ£o processar novamente
                            if (martingaleState.active && martingaleState.stage !== 'ENTRADA' && currentAnalysis.phase === 'G0') {
                                console.log('âš ï¸ ATENÃ‡ÃƒO: PossÃ­vel processamento duplo detectado!');
                                console.log('   Martingale ativo mas anÃ¡lise Ã© G0 - pode ser WIN jÃ¡ processado');
                                return; // Sair sem processar
                            }
                            
                            // Determinar estÃ¡gio do Martingale CORRETAMENTE
                            // âœ… Verificar PRIMEIRO a fase da anÃ¡lise (G1/G2), depois o estado
                            let martingaleStage = 'ENTRADA';
                            if (currentAnalysis.phase === 'G1') {
                                martingaleStage = 'G1';
                            } else if (currentAnalysis.phase === 'G2') {
                                martingaleStage = 'G2';
                            } else if (martingaleState.active) {
                                martingaleStage = martingaleState.stage;
                            }
                            
                            const patternKey = martingaleState.active ? martingaleState.patternKey : createPatternKey(currentAnalysis);
                            
                            console.log(`ğŸ¯ WIN no estÃ¡gio: ${martingaleStage}`);
                            console.log(`ğŸ”‘ PadrÃ£o: ${patternKey}`);
                            
                            // WIN: registrar entrada com informaÃ§Ãµes de Martingale
                            // âœ… Fix: gravar valores financeiros da entrada no momento (para nÃ£o â€œmudar o passadoâ€ ao alterar config)
                            const cycleAutoBetCfg = martingaleState && martingaleState.active
                                ? ensureMartingaleCycleConfig(snapshotAutoBetConfig(analyzerConfig))
                                : snapshotAutoBetConfig(analyzerConfig);
                            const betColor = currentAnalysis.color;
                            // âœ… UI/HistÃ³rico: manter a confianÃ§a ORIGINAL do sinal de entrada (nÃ£o a confianÃ§a recalculada do GALE)
                            const entryAnalysisForUI = (martingaleState && martingaleState.active && martingaleState.analysisData)
                                ? martingaleState.analysisData
                                : currentAnalysis;
                            const entryConfidenceForUI = (entryAnalysisForUI && typeof entryAnalysisForUI.confidence === 'number' && Number.isFinite(entryAnalysisForUI.confidence))
                                ? entryAnalysisForUI.confidence
                                : ((typeof currentAnalysis.confidence === 'number' && Number.isFinite(currentAnalysis.confidence)) ? currentAnalysis.confidence : 0);
                            const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                            const stakeAmount = calcStakeForStage(martingaleStage, cycleAutoBetCfg);
                            const cycleId = (martingaleState && martingaleState.active && martingaleState.entryTimestamp)
                                ? martingaleState.entryTimestamp
                                : (currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now());
                            const cycleTotalInvested = calcTotalInvestedThroughStage(martingaleStage, cycleAutoBetCfg);
                            const cycleNetProfit = roundMoney((stakeAmount * payoutMultiplier) - cycleTotalInvested);
                            const entrySpinsSnapshot = buildEntrySpinsSnapshot(
                                { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                14
                            );
                            const winEntry = {
                                timestamp: latestSpin.created_at,
                                number: rollNumber,
                                color: rollColor,
                                phase: currentAnalysis.phase || 'G0',
                                result: 'WIN',
                                confidence: entryConfidenceForUI,
                                patternData: {
                                    patternDescription: entryAnalysisForUI ? entryAnalysisForUI.patternDescription : currentAnalysis.patternDescription,
                                    confidence: entryConfidenceForUI,
                                    color: entryAnalysisForUI ? entryAnalysisForUI.color : currentAnalysis.color,
                                    createdOnTimestamp: entryAnalysisForUI ? entryAnalysisForUI.createdOnTimestamp : currentAnalysis.createdOnTimestamp,
                                    // âœ… Snapshot de giros (para o modal "PadrÃ£o da Entrada"): manter 14, igual ao card "Ãšltimos giros"
                                    last5Spins: entrySpinsSnapshot
                                },
                                // âœ… CAMPOS DO MARTINGALE
                                martingaleStage: martingaleStage,  // 'ENTRADA' | 'G1' | 'G2'
                                wonAt: martingaleStage,             // Onde ganhou
                                finalResult: 'WIN',                 // Resultado final do ciclo
                                // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard', // 'diamond' | 'standard'
                                // âœ… NOVO: marcar se este ciclo era SINAL DE ENTRADA
                                isMaster: !!(entryAnalysisForUI && entryAnalysisForUI.masterSignal && entryAnalysisForUI.masterSignal.active),
                                // âœ… NOVO: marcar se este ciclo foi um SINAL DE RECUPERAÃ‡ÃƒO (para exibir na aba RecuperaÃ§Ã£o)
                                recoveryMode: !!(entryAnalysisForUI && entryAnalysisForUI.recoveryMode),
                                // âœ… NOVO (Diamante): qual nÃ­vel "mandou" o sinal (origem)
                                diamondSourceLevel: entryAnalysisForUI && entryAnalysisForUI.diamondSourceLevel ? entryAnalysisForUI.diamondSourceLevel : null,
                                // âœ… FINANCEIRO (fixo no tempo)
                                cycleId,
                                betColor,
                                stakeAmount,
                                baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                payoutMultiplier,
                                cycleTotalInvested,
                                cycleNetProfit
                            };
                            
                            console.log('%câ•‘  ğŸ“ DEBUG COMPLETO: SALVANDO ENTRADA WIN                                    â•‘', 'color: #00FF00; font-weight: bold; font-size: 14px;');
                            console.log('%cğŸ“Š DADOS DA ENTRADA WIN:', 'color: #00FF88; font-weight: bold;');
                            console.log('   â¤ Timestamp:', winEntry.timestamp);
                            console.log('   â¤ NÃºmero:', winEntry.number);
                            console.log('   â¤ Cor:', winEntry.color);
                            console.log('   â¤ Fase:', winEntry.phase);
                            console.log('   â¤ Resultado:', winEntry.result);
                            console.log('   â¤ ConfianÃ§a:', winEntry.confidence + '%');
                            console.log('   â¤ Martingale Stage:', winEntry.martingaleStage);
                            console.log('   â¤ Won At:', winEntry.wonAt);
                            console.log('   â¤ Final Result:', winEntry.finalResult);
                            console.log('%cğŸ“‹ ESTADO DO HISTÃ“RICO ANTES DE ADICIONAR:', 'color: #00FFFF; font-weight: bold;');
                            console.log('   â¤ entriesHistory existe?', !!entriesHistory);
                            console.log('   â¤ entriesHistory.length ANTES:', entriesHistory.length);
                            
                            activeHistory.unshift(winEntry);
                            // âœ… Pedido: nÃ£o limitar histÃ³rico por ciclos (acumular ilimitado)
                            
                            console.log('%câœ… ENTRADA ADICIONADA AO HISTÃ“RICO!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
                            console.log('   â¤ entriesHistory.length DEPOIS:', entriesHistory.length);
                            
                            // âœ… Calcular estatÃ­sticas WIN/LOSS FILTRADAS POR MODO
                            const currentMode = analyzerConfig.aiMode ? 'diamond' : 'standard';
                            const { wins: filteredWins, losses: filteredLosses } = calculateFilteredScore(entriesHistory, currentMode);
                            
                            console.log(`ğŸ“Š Placar total: ${calculateCycleScore(entriesHistory).totalWins} wins / ${calculateCycleScore(entriesHistory).totalLosses} losses`);
                            console.log(`ğŸ“Š Placar ${currentMode}: ${filteredWins} wins / ${filteredLosses} losses`);
                            
                            if (!isHiddenInternal) {
                                // âœ… CRÃTICO: NÃƒO bloquear o prÃ³ximo sinal por IO externo (Telegram/Observer).
                                detachPromise(sendTelegramMartingaleWin(
                                    martingaleStage,
                                    { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                    filteredWins,
                                    filteredLosses,
                                    currentMode,
                                    currentAnalysis.confidence
                                ), 'telegram-martingale-win');
                                
                                detachPromise(registerEntryInObserver(
                                    currentAnalysis.confidence,
                                    'win',
                                    currentAnalysis.createdOnTimestamp,
                                    { type: currentAnalysis.patternType, occurrences: currentAnalysis.occurrences }
                                ), 'observer-register-win');
                            }
                            
                            // âœ… ATUALIZAR HISTÃ“RICO DE CORES QUENTES
                            if (martingaleState.active && (martingaleStage === 'G1' || martingaleStage === 'G2')) {
                                console.log('ğŸ“Š Atualizando histÃ³rico de cores quentes apÃ³s WIN...');
                                
                                // Construir sequÃªncia de cores DOS GIROS (nÃ£o das apostas!)
                                const colorSequence = [];
                                
                                // Adicionar cores dos LOSSes (giros que realmente saÃ­ram)
                                martingaleState.lossColors.forEach(color => {
                                    colorSequence.push({ color });
                                });
                                
                                // Adicionar cor que GANHOU (giro atual)
                                colorSequence.push({ color: rollColor });
                                
                                console.log('   SequÃªncia de cores dos giros:', colorSequence.map(c => c.color).join(' â†’ '));
                                
                                // âœ… NÃ£o bloquear tempo-real com atualizaÃ§Ã£o auxiliar
                                detachPromise(updateHotColorsHistory(patternKey, colorSequence), 'hot-colors-update-win');
                            }

                            // ğŸ’ N4 (Autointeligente): registrar resultado final do CICLO (WIN) para auto-aprendizado
                            try {
                                const learningAnalysis = (martingaleState && martingaleState.active && martingaleState.analysisData)
                                    ? martingaleState.analysisData
                                    : currentAnalysis;
                                await recordN4SelfLearningFromResolvedCycle(learningAnalysis, 'win');
                                // âšª N0 (Detector de Branco): registrar auto-aprendizado quando o N0 foi o sinal final
                                await recordN0SelfLearningFromResolvedCycle(learningAnalysis, 'win');
                                // âšª N0 (Pedido do usuÃ¡rio): apÃ³s WIN no branco, NÃƒO reentrar imediatamente.
                                // Armamos um cooldown dinÃ¢mico (em giros) baseado no gap mediano real do histÃ³rico.
                                try {
                                    if (expectedColor === 'white') {
                                        await armN0PostWinCooldownAfterWhiteWin({
                                            latestSpin,
                                            history: cachedHistory,
                                            lookbackSpins: 3000
                                        });
                                    }
                                } catch (_) {}
                                // ğŸ’ N4 (Autointeligente): auto-ajuste de janela (n4Persistence) quando o desempenho cair
                                try {
                                    if (!isHiddenInternal) {
                                        maybeAutoTuneN4HistoryWindow({ entriesHistory, analysisObj: learningAnalysis }).catch(() => {});
                                    }
                                } catch (_) {}
                            } catch (_) {}
                            
                            // âœ… RESETAR CICLO DE MARTINGALE - CRÃTICO!
                            if (martingaleState.active) {
                                console.log('ğŸ”„ Resetando ciclo de Martingale apÃ³s WIN');
                                console.log('   Estado ANTES do reset:', {
                                    active: martingaleState.active,
                                    stage: martingaleState.stage,
                                    patternKey: martingaleState.patternKey
                                });
                                resetMartingaleState();
                                console.log('   Estado APÃ“S o reset:', {
                                    active: martingaleState.active,
                                    stage: martingaleState.stage,
                                    patternKey: martingaleState.patternKey
                                });
                            }
                            
                            console.log('%cğŸ’¾ SALVANDO NO CHROME.STORAGE.LOCAL...', 'color: #FFD700; font-weight: bold; font-size: 14px;');
                            console.log('   â¤ analysis: null (limpar)');
                            console.log('   â¤ pattern: null (limpar)');
                            console.log('   â¤ lastBet.status: win');
                            console.log('   â¤ entriesHistory.length:', entriesHistory.length);
                            console.log('   â¤ martingaleState.active:', martingaleState.active);
                            console.log('   â¤ rigorLevel: 75 (reset)');
                            
                            const disableRecoveryAfterWin = !!(currentAnalysis && currentAnalysis.recoveryMode);
                            if (disableRecoveryAfterWin) {
                                recoveryModeEnabled = false;
                            }

                            // âœ… Persistir Ãºltimo sinal de recuperaÃ§Ã£o (por modo) para a aba "RecuperaÃ§Ã£o"
                            let lastRecoveryEntryByMode = null;
                            if (!isHiddenInternal && disableRecoveryAfterWin) {
                                try {
                                    const prev = await chrome.storage.local.get([LAST_RECOVERY_ENTRY_BY_MODE_KEY]);
                                    const raw = prev ? prev[LAST_RECOVERY_ENTRY_BY_MODE_KEY] : null;
                                    const map = raw && typeof raw === 'object' ? raw : {};
                                    lastRecoveryEntryByMode = { ...map, [currentMode]: winEntry };
                                } catch (_) {
                                    lastRecoveryEntryByMode = { [currentMode]: winEntry };
                                }
                            }

                            await chrome.storage.local.set({ 
                                analysis: null, 
                                pattern: null,
                                lastBet: { status: 'win', phase: currentAnalysis.phase || 'G0', resolvedAtTimestamp: latestSpin.created_at },
                                // âœ… Marcar fim do ciclo (WIN/RET) para referÃªncia de estado/telemetria
                                lastCycleResolvedSpinId: latestSpin ? (latestSpin.id || null) : null,
                                lastCycleResolvedSpinTimestamp: latestSpin ? (latestSpin.created_at || null) : null,
                                lastCycleResolvedTimestamp: Date.now(),
                                ...(isHiddenInternal ? { [RECOVERY_SECURE_HISTORY_KEY]: recoverySecureHistory } : { entriesHistory }),
                                martingaleState,  // âœ… Salvar estado do Martingale
                                rigorLevel: 75, // RESET: Volta para 75% apÃ³s WIN
                                ...(lastRecoveryEntryByMode ? { [LAST_RECOVERY_ENTRY_BY_MODE_KEY]: lastRecoveryEntryByMode } : {}),
                                ...(disableRecoveryAfterWin ? { [RECOVERY_MODE_KEY]: { enabled: false, updatedAt: Date.now(), lastResult: 'win' } } : {})
                            });
                            
                            if (disableRecoveryAfterWin) {
                                try {
                                    sendMessageToContent('RECOVERY_MODE_UPDATE', { enabled: false, statusText: 'Desativada â€¢ WIN confirmado' });
                                } catch (_) {}
                            }

                            
                            if (!isHiddenInternal || (currentAnalysis && currentAnalysis.recoveryMode)) {
                                sendMessageToContent('CLEAR_ANALYSIS');
                            }
                            
                            // âœ… Enviar atualizaÃ§Ã£o de entradas para UI
                            console.log('%cğŸ“¤ ENVIANDO ENTRIES_UPDATE PARA UI...', 'color: #00D4FF; font-weight: bold; font-size: 14px;');
                            console.log('   â¤ Type: ENTRIES_UPDATE');
                            console.log('   â¤ Total de entradas:', entriesHistory.length);
                            console.log('   â¤ Primeira entrada:', entriesHistory[0] ? {
                                result: entriesHistory[0].result,
                                color: entriesHistory[0].color,
                                number: entriesHistory[0].number,
                                phase: entriesHistory[0].phase
                            } : 'N/A');
                            
                            if (!isHiddenInternal) {
                                const uiUpdateResult = sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                console.log('%cğŸ“¨ Resultado do envio para UI:', uiUpdateResult ? 'color: #00FF00;' : 'color: #FF0000;', uiUpdateResult);
                            }
                            console.log('%câ•‘  âœ… ENTRADA WIN PROCESSADA COMPLETAMENTE!                                   â•‘', 'color: #00FF00; font-weight: bold;');
                        } else {
                            console.log('â•‘  âŒ LOSS DETECTADO!                                      â•‘');
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // âœ… SISTEMA DE MARTINGALE - LÃ“GICA DE LOSS
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            
                            // Determinar estÃ¡gio atual
                            const currentStage = martingaleState.active ? martingaleState.stage : 'ENTRADA';
                            const patternKey = martingaleState.active ? martingaleState.patternKey : createPatternKey(currentAnalysis);
                            
                            console.log(`âŒ LOSS no estÃ¡gio: ${currentStage}`);
                            console.log(`ğŸ”‘ PadrÃ£o: ${patternKey}`);
                            console.log(`ğŸ² Esperado: ${currentAnalysis.color}, Real: ${rollColor}`);
                            
                            // âœ… VERIFICAR SE Ã‰ O ÃšLTIMO GALE (vai virar RED) ou se ainda tem mais Gales
                            // NÃƒO ENVIAR MENSAGEM AQUI - serÃ¡ enviada dentro da lÃ³gica abaixo
                            
                            if (!isHiddenInternal) {
                                // âœ… REGISTRAR NO CALIBRADOR DE PORCENTAGENS
                                await registerEntryInObserver(
                                    currentAnalysis.confidence,
                                    'loss',
                                    currentAnalysis.createdOnTimestamp,
                                    { type: currentAnalysis.patternType, occurrences: currentAnalysis.occurrences }
                                );
                            }
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // NOVA LÃ“GICA DE MARTINGALE - DECIDIR PRÃ“XIMA AÃ‡ÃƒO
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            // âœ… LÃ“GICA DINÃ‚MICA DE MARTINGALE - FUNCIONA PARA QUALQUER QUANTIDADE
                            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            
                            // Determinar o nÃºmero do Gale atual (0=ENTRADA, 1=G1, 2=G2, 3=G3...)
                            let currentGaleNumber = 0;
                            if (currentStage === 'ENTRADA') {
                                currentGaleNumber = 0;
                            } else if (currentStage.startsWith('G')) {
                                currentGaleNumber = parseInt(currentStage.substring(1)) || 0;
                            }
                            
                            const nextGaleNumber = currentGaleNumber + 1;
                            const entryColorForSettings = (martingaleState && martingaleState.active)
                                ? martingaleState.entryColor
                                : currentAnalysis.color;
                            const { maxGales, consecutiveGales } = getMartingaleSettingsForEntryColor(entryColorForSettings);
                            
                            console.log(`â•‘  âŒ LOSS no ${currentStage === 'ENTRADA' ? 'ENTRADA PADRÃƒO' : currentStage}                                  â•‘`);
                            console.log(`â•‘  âš™ï¸  ConfiguraÃ§Ã£o: ${maxGales} Gale${maxGales !== 1 ? 's' : ''} permitido${maxGales !== 1 ? 's' : ''}           â•‘`);
                            console.log(`â•‘  ğŸ“Š Atual: Gale ${currentGaleNumber} (${currentStage})                        â•‘`);
                            console.log(`â•‘  ğŸ¯ PrÃ³ximo: ${nextGaleNumber <= maxGales ? `Tentar G${nextGaleNumber}` : 'RED (limite atingido)'}                  â•‘`);
                            
                            // Verificar se ainda pode tentar mais Gales
                            const canTryNextGale = nextGaleNumber <= maxGales;
                            
                            if (currentStage === 'ENTRADA') {
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // âœ… LOSS NA ENTRADA: Verificar se pode tentar G1
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                
                                if (!canTryNextGale) {
                                    // âŒ SEM GALES: Registrar LOSS direto
                                    console.log('â›” CONFIGURAÃ‡ÃƒO: 0 Gales - Registrando LOSS direto');
                                    
                                    // âœ… Fix financeiro: congelar config e calcular valores do ciclo (RED)
                                    const cycleAutoBetCfg = snapshotAutoBetConfig(analyzerConfig);
                                    const betColor = currentAnalysis.color;
                                    // âœ… UI/HistÃ³rico: manter a confianÃ§a ORIGINAL do sinal de entrada (nÃ£o a confianÃ§a recalculada do GALE)
                                    const entryAnalysisForUI = (martingaleState && martingaleState.active && martingaleState.analysisData)
                                        ? martingaleState.analysisData
                                        : currentAnalysis;
                                    const entryConfidenceForUI = (entryAnalysisForUI && typeof entryAnalysisForUI.confidence === 'number' && Number.isFinite(entryAnalysisForUI.confidence))
                                        ? entryAnalysisForUI.confidence
                                        : ((typeof currentAnalysis.confidence === 'number' && Number.isFinite(currentAnalysis.confidence)) ? currentAnalysis.confidence : 0);
                                    const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                                    const stakeAmount = calcStakeForStage('ENTRADA', cycleAutoBetCfg);
                                    const cycleId = currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now();
                                    const cycleTotalInvested = calcTotalInvestedThroughStage('ENTRADA', cycleAutoBetCfg);
                                    const cycleNetProfit = roundMoney(-cycleTotalInvested);
                                    const entrySpinsSnapshot = buildEntrySpinsSnapshot(
                                        { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                        14
                                    );
                                    
                                    const lossEntry = {
                                        timestamp: latestSpin.created_at,
                                        number: rollNumber,
                                        color: rollColor,
                                        phase: 'G0',
                                        result: 'LOSS',
                                        confidence: entryConfidenceForUI,
                                        patternData: {
                                            patternDescription: entryAnalysisForUI ? entryAnalysisForUI.patternDescription : currentAnalysis.patternDescription,
                                            confidence: entryConfidenceForUI,
                                            color: entryAnalysisForUI ? entryAnalysisForUI.color : currentAnalysis.color,
                                            createdOnTimestamp: entryAnalysisForUI ? entryAnalysisForUI.createdOnTimestamp : currentAnalysis.createdOnTimestamp,
                                            // âœ… Snapshot de giros (para o modal "PadrÃ£o da Entrada"): manter 14, igual ao card "Ãšltimos giros"
                                            last5Spins: entrySpinsSnapshot
                                        },
                                        martingaleStage: 'ENTRADA',
                                        finalResult: 'RED',
                                        // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                        analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard',
                                        // âœ… NOVO: marcar se este ciclo era SINAL DE ENTRADA
                                        isMaster: !!(entryAnalysisForUI && entryAnalysisForUI.masterSignal && entryAnalysisForUI.masterSignal.active),
                                        // âœ… NOVO: marcar se este ciclo foi um SINAL DE RECUPERAÃ‡ÃƒO
                                        recoveryMode: !!(entryAnalysisForUI && entryAnalysisForUI.recoveryMode),
                                        // âœ… NOVO (Diamante): qual nÃ­vel "mandou" o sinal (origem)
                                        diamondSourceLevel: entryAnalysisForUI && entryAnalysisForUI.diamondSourceLevel ? entryAnalysisForUI.diamondSourceLevel : null,
                                        // âœ… FINANCEIRO (fixo no tempo)
                                        cycleId,
                                        betColor,
                                        stakeAmount,
                                        baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                        galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                        payoutMultiplier,
                                        cycleTotalInvested,
                                        cycleNetProfit
                                    };
                                    
                                    console.log('%câ•‘  ğŸ“ DEBUG COMPLETO: SALVANDO ENTRADA LOSS (SEM GALES)                      â•‘', 'color: #FF0000; font-weight: bold; font-size: 14px;');
                                    console.log('%cğŸ“Š DADOS DA ENTRADA LOSS:', 'color: #FF6666; font-weight: bold;');
                                    console.log('   â¤ Timestamp:', lossEntry.timestamp);
                                    console.log('   â¤ NÃºmero:', lossEntry.number);
                                    console.log('   â¤ Cor:', lossEntry.color);
                                    console.log('   â¤ Fase:', lossEntry.phase);
                                    console.log('   â¤ Resultado:', lossEntry.result);
                                    console.log('   â¤ ConfianÃ§a:', lossEntry.confidence + '%');
                                    console.log('   â¤ Martingale Stage:', lossEntry.martingaleStage);
                                    console.log('   â¤ Final Result:', lossEntry.finalResult);
                                    console.log('%cğŸ“‹ ESTADO DO HISTÃ“RICO ANTES DE ADICIONAR:', 'color: #00FFFF; font-weight: bold;');
                                    console.log('   â¤ entriesHistory existe?', !!entriesHistory);
                                    console.log('   â¤ entriesHistory.length ANTES:', entriesHistory.length);
                                    
                                    activeHistory.unshift(lossEntry);
                                    // âœ… Pedido: nÃ£o limitar histÃ³rico por ciclos (acumular ilimitado)
                                    
                                    console.log('%câœ… ENTRADA ADICIONADA AO HISTÃ“RICO!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
                                    console.log('   â¤ entriesHistory.length DEPOIS:', entriesHistory.length);
                                    
                                    // âœ… Calcular estatÃ­sticas WIN/LOSS FILTRADAS POR MODO
                                    const currentMode = analyzerConfig.aiMode ? 'diamond' : 'standard';
                                    const { wins: filteredWins, losses: filteredLosses } = calculateFilteredScore(entriesHistory, currentMode);
                                    
                                    console.log(`ğŸ“Š Placar total: ${calculateCycleScore(entriesHistory).totalWins} wins / ${calculateCycleScore(entriesHistory).totalLosses} losses`);
                                    console.log(`ğŸ“Š Placar ${currentMode}: ${filteredWins} wins / ${filteredLosses} losses`);
                                    
                                    if (!isHiddenInternal) {
                                        // âœ… ENVIAR MENSAGEM DE RED AO TELEGRAM (sem Gales)
                                        console.log('ğŸ“¤ Enviando mensagem de RED ao Telegram (0 Gales configurados)...');
                                        detachPromise(
                                            sendTelegramMartingaleRET(filteredWins, filteredLosses, currentMode, currentAnalysis.confidence),
                                            'telegram-martingale-ret'
                                        );
                                    }

                                    // ğŸ’ N4 (Autointeligente): registrar resultado final do CICLO (LOSS/RED) para auto-aprendizado
                                    try {
                                        await recordN4SelfLearningFromResolvedCycle(currentAnalysis, 'loss');
                                        // âšª N0 (Detector de Branco): registrar auto-aprendizado quando o N0 foi o sinal final
                                        await recordN0SelfLearningFromResolvedCycle(currentAnalysis, 'loss');
                                        // ğŸ’ N4 (Autointeligente): auto-ajuste de janela (n4Persistence) quando o desempenho cair
                                        try {
                                            if (!isHiddenInternal) {
                                                maybeAutoTuneN4HistoryWindow({ entriesHistory, analysisObj: currentAnalysis }).catch(() => {});
                                            }
                                        } catch (_) {}
                                    } catch (_) {}
                                    
                                    resetMartingaleState();
                                    
                                    console.log('%cğŸ’¾ SALVANDO NO CHROME.STORAGE.LOCAL...', 'color: #FFD700; font-weight: bold; font-size: 14px;');
                                    console.log('   â¤ analysis: null (limpar)');
                                    console.log('   â¤ pattern: null (limpar)');
                                    console.log('   â¤ lastBet.status: loss');
                                    console.log('   â¤ entriesHistory.length:', entriesHistory.length);
                                    
                                    // âœ… Persistir Ãºltimo sinal de recuperaÃ§Ã£o (por modo) para a aba "RecuperaÃ§Ã£o"
                                    let lastRecoveryEntryByMode = null;
                                    if (!isHiddenInternal && (currentAnalysis && currentAnalysis.recoveryMode)) {
                                        try {
                                            const prev = await chrome.storage.local.get([LAST_RECOVERY_ENTRY_BY_MODE_KEY]);
                                            const raw = prev ? prev[LAST_RECOVERY_ENTRY_BY_MODE_KEY] : null;
                                            const map = raw && typeof raw === 'object' ? raw : {};
                                            lastRecoveryEntryByMode = { ...map, [currentMode]: lossEntry };
                                        } catch (_) {
                                            lastRecoveryEntryByMode = { [currentMode]: lossEntry };
                                        }
                                    }

                                    await chrome.storage.local.set({ 
                                        analysis: null, 
                                        pattern: null,
                                        lastBet: { status: 'loss', phase: 'G0', resolvedAtTimestamp: latestSpin.created_at },
                                        // âœ… Marcar fim do ciclo (RED) para referÃªncia de estado/telemetria
                                        lastCycleResolvedSpinId: latestSpin ? (latestSpin.id || null) : null,
                                        lastCycleResolvedSpinTimestamp: latestSpin ? (latestSpin.created_at || null) : null,
                                        lastCycleResolvedTimestamp: Date.now(),
                                        ...(isHiddenInternal ? { [RECOVERY_SECURE_HISTORY_KEY]: recoverySecureHistory } : { entriesHistory }),
                                        ...(lastRecoveryEntryByMode ? { [LAST_RECOVERY_ENTRY_BY_MODE_KEY]: lastRecoveryEntryByMode } : {}),
                                        martingaleState
                                    });
                                    
                                    
                                    if (!isHiddenInternal || (currentAnalysis && currentAnalysis.recoveryMode)) {
                                        sendMessageToContent('CLEAR_ANALYSIS');
                                    }
                                    
                                    console.log('%cğŸ“¤ ENVIANDO ENTRIES_UPDATE PARA UI...', 'color: #00D4FF; font-weight: bold; font-size: 14px;');
                                    console.log('   â¤ Type: ENTRIES_UPDATE');
                                    console.log('   â¤ Total de entradas:', entriesHistory.length);
                                    console.log('   â¤ Primeira entrada:', entriesHistory[0] ? {
                                        result: entriesHistory[0].result,
                                        color: entriesHistory[0].color,
                                        number: entriesHistory[0].number,
                                        phase: entriesHistory[0].phase,
                                        finalResult: entriesHistory[0].finalResult
                                    } : 'N/A');
                                    
                                    if (!isHiddenInternal) {
                                        const uiUpdateResult = sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                        console.log('%cğŸ“¨ Resultado do envio para UI:', uiUpdateResult ? 'color: #00FF00;' : 'color: #FF0000;', uiUpdateResult);
                                    }
                                    console.log('%câ•‘  âœ… ENTRADA LOSS PROCESSADA COMPLETAMENTE!                                  â•‘', 'color: #00FF00; font-weight: bold;');
                                    return;
                                }
                                
                                // âœ… TEM GALES: Tentar G1
                                console.log(`ğŸ”„ Tentando G${nextGaleNumber}...`);
                                console.log(`âš™ï¸ Gales consecutivos (atÃ©): ${consecutiveGales}`);
                                
                                if (!isHiddenInternal) {
                                    // âœ… ENVIAR MENSAGEM DE LOSS ENTRADA (vai tentar G1)
                                    detachPromise(
                                        sendTelegramMartingaleLoss(
                                            currentStage,
                                            { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                            currentAnalysis.confidence
                                        ),
                                        'telegram-martingale-loss'
                                    );
                                }
                                
                                // âœ… N4 (Autointeligente): permitir re-anÃ¡lise no Gale (G1) quando estiver rodando "sÃ³ N4"
                                // âšª Branco: NÃƒO mudar cor em gales â€” respeitar configuraÃ§Ã£o exclusiva do Branco.
                                let g1Color = currentAnalysis.color;
                                if (normalizeSimpleBetColor(currentAnalysis.color) !== 'white' && shouldUseN4DynamicGalesForConfig(analyzerConfig)) {
                                    const picked = pickN4DynamicGaleColor({
                                        history: cachedHistory,
                                        config: analyzerConfig,
                                        stageNumber: 1,
                                        maxGales,
                                        forcePick: true
                                    });
                                    if (picked) g1Color = picked;
                                }
                                
                                // âš ï¸ CRÃTICO: Registrar LOSS da ENTRADA antes de tentar G1
                                // âœ… Fix financeiro: congelar config do ciclo na primeira entrada
                                const cycleAutoBetCfg = ensureMartingaleCycleConfig(snapshotAutoBetConfig(analyzerConfig), currentAnalysis.color);
                                const betColor = currentAnalysis.color;
                                const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                                const stakeAmount = calcStakeForStage('ENTRADA', cycleAutoBetCfg);
                                const cycleId = currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now();
                                const entrySpinsSnapshot = buildEntrySpinsSnapshot(
                                    { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                    14
                                );
                                // âœ… UI/HistÃ³rico: manter a confianÃ§a ORIGINAL do sinal de entrada (nÃ£o a confianÃ§a recalculada do GALE)
                                const entryAnalysisForUI = currentAnalysis;
                                const entryConfidenceForUI = (entryAnalysisForUI && typeof entryAnalysisForUI.confidence === 'number' && Number.isFinite(entryAnalysisForUI.confidence))
                                    ? entryAnalysisForUI.confidence
                                    : ((typeof currentAnalysis.confidence === 'number' && Number.isFinite(currentAnalysis.confidence)) ? currentAnalysis.confidence : 0);
                                const entradaLossEntry = {
                            timestamp: latestSpin.created_at,
                            number: rollNumber,
                            color: rollColor,
                                    phase: 'G0',
                            result: 'LOSS',
                            confidence: entryConfidenceForUI,
                            patternData: {
                                patternDescription: currentAnalysis.patternDescription,
                                confidence: entryConfidenceForUI,
                                color: currentAnalysis.color,
                                createdOnTimestamp: currentAnalysis.createdOnTimestamp,
                                // âœ… Snapshot de giros (para o modal "PadrÃ£o da Entrada")
                                last5Spins: entrySpinsSnapshot
                                    },
                                    martingaleStage: 'ENTRADA',
                                    finalResult: null,  // Ainda nÃ£o Ã© final, vai tentar G1
                                    continuingToG1: true,  // Flag indicando que continuarÃ¡
                                    // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                    analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard',
                                    // âœ… NOVO: marcar se este ciclo era SINAL DE ENTRADA
                                    isMaster: !!(currentAnalysis && currentAnalysis.masterSignal && currentAnalysis.masterSignal.active),
                                    // âœ… NOVO (Diamante): qual nÃ­vel "mandou" o sinal (origem)
                                    diamondSourceLevel: currentAnalysis && currentAnalysis.diamondSourceLevel ? currentAnalysis.diamondSourceLevel : null,
                                    // âœ… FINANCEIRO (fixo no tempo)
                                    cycleId,
                                    betColor,
                                    stakeAmount,
                                    baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                    galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                    payoutMultiplier
                                };
                                
                                activeHistory.unshift(entradaLossEntry);
                                // âœ… Pedido: nÃ£o limitar histÃ³rico por ciclos (acumular ilimitado)
                                
                                // Salvar estado do Martingale
                                martingaleState.active = true;
                                martingaleState.stage = 'G1';
                                martingaleState.patternKey = patternKey;
                                martingaleState.entryColor = currentAnalysis.color;
                                martingaleState.currentColor = g1Color;
                                martingaleState.entryColorResult = rollColor;  // âœ… Cor que realmente saiu
                                martingaleState.entryTimestamp = currentAnalysis.createdOnTimestamp;
                                martingaleState.analysisData = currentAnalysis;
                                martingaleState.lossCount = 1;
                                martingaleState.lossColors = [rollColor];  // âœ… Guardar cores dos LOSSes
                                
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // VERIFICAR MODO DE MARTINGALE
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                
                                if (nextGaleNumber <= consecutiveGales) {
                                    // âœ… MODO CONSECUTIVO: Enviar G1 IMEDIATAMENTE no prÃ³ximo giro
                                    console.log('ğŸ¯ MODO CONSECUTIVO: G1 serÃ¡ enviado no PRÃ“XIMO GIRO');
                                    
                                    // Criar anÃ¡lise G1 com timestamp do prÃ³ximo giro
                                    const g1Analysis = {
                                        ...currentAnalysis,
                                        color: g1Color,
                                        phase: 'G1',
                                        predictedFor: 'next',
                                        createdOnTimestamp: latestSpin.created_at  // âœ… Usar giro atual
                                    };
                                    {
                                        const baseConf = Number.isFinite(Number(g1Analysis.confidence)) ? Number(g1Analysis.confidence) : 0;
                                        g1Analysis.confidence = baseConf; // âœ… manter no UI
                                        g1Analysis.galeConfidence = calculateGaleConfidenceValue(baseConf, g1Analysis); // âœ… interno/telegram
                                    }
                                    
                                    await chrome.storage.local.set({
                                        analysis: g1Analysis,
                                        pattern: { description: g1Analysis.patternDescription, confidence: g1Analysis.confidence },
                                        lastBet: { status: 'pending', phase: 'G1', createdOnTimestamp: g1Analysis.createdOnTimestamp },
                                        ...(isHiddenInternal ? { [RECOVERY_SECURE_HISTORY_KEY]: recoverySecureHistory } : { entriesHistory }),
                                        martingaleState
                                    });
                                    
                                    emitAnalysisToContent(g1Analysis, analyzerConfig.aiMode ? 'diamond' : 'standard');
                                    if (!isHiddenInternal) {
                                        sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                    }

                                    // âœ… Telegram com confianÃ§a REAL do G1
                                    if (!isHiddenInternal) {
                                        detachPromise(
                                            sendTelegramMartingaleG1(
                                                g1Color,
                                                (typeof g1Analysis.galeConfidence === 'number' && Number.isFinite(g1Analysis.galeConfidence)) ? g1Analysis.galeConfidence : g1Analysis.confidence,
                                                { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at }
                                            ),
                                            'telegram-martingale-g1'
                                        );
                                    }
                                } else {
                                    // âœ… CorreÃ§Ã£o (pedido do usuÃ¡rio): GALE deve continuar no PRÃ“XIMO GIRO (nÃ£o esperar â€œnovo sinalâ€)
                                    console.log('âœ… GALE AUTOMÃTICO: G1 serÃ¡ enviado no PRÃ“XIMO GIRO');

                                    const g1Analysis = {
                                        ...currentAnalysis,
                                        color: g1Color,
                                        phase: 'G1',
                                        predictedFor: 'next',
                                        createdOnTimestamp: latestSpin.created_at // âœ… usar o giro atual para avaliar no prÃ³ximo
                                    };
                                    {
                                        const baseConf = Number.isFinite(Number(g1Analysis.confidence)) ? Number(g1Analysis.confidence) : 0;
                                        g1Analysis.confidence = baseConf; // âœ… manter no UI
                                        g1Analysis.galeConfidence = calculateGaleConfidenceValue(baseConf, g1Analysis); // âœ… interno/telegram
                                    }

                                    await chrome.storage.local.set({
                                        analysis: g1Analysis,
                                        pattern: { description: g1Analysis.patternDescription, confidence: g1Analysis.confidence },
                                        lastBet: { status: 'pending', phase: 'G1', createdOnTimestamp: g1Analysis.createdOnTimestamp },
                                        ...(isHiddenInternal ? { [RECOVERY_SECURE_HISTORY_KEY]: recoverySecureHistory } : { entriesHistory }),
                                        martingaleState
                                    });

                                    emitAnalysisToContent(g1Analysis, analyzerConfig.aiMode ? 'diamond' : 'standard');
                                    if (!isHiddenInternal) {
                                        sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                    }

                                    // Telegram (manter consistÃªncia com o modo consecutivo)
                                    if (!isHiddenInternal) {
                                        detachPromise(
                                            sendTelegramMartingaleG1(
                                                g1Color,
                                                (typeof g1Analysis.galeConfidence === 'number' && Number.isFinite(g1Analysis.galeConfidence)) ? g1Analysis.galeConfidence : g1Analysis.confidence,
                                                { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at }
                                            ),
                                            'telegram-martingale-g1'
                                        );
                                    }
                                }
                                
                            } else if (currentStage.startsWith('G')) {
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // âœ… LOSS EM QUALQUER GALE (G1, G2, G3... G200)
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                
                                if (!canTryNextGale) {
                                    // âŒ LIMITE ATINGIDO: Registrar RED
                                    console.log(`â›” Limite de Gales atingido (${currentGaleNumber}/${maxGales}) - Registrando RED`);
                                    
                                    // âœ… Fix financeiro: usar config do ciclo (congelada) e calcular net do RED
                                    const cycleAutoBetCfg = ensureMartingaleCycleConfig(snapshotAutoBetConfig(analyzerConfig));
                                    const betColor = (martingaleState && martingaleState.entryColor) ? martingaleState.entryColor : currentAnalysis.color;
                                    const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                                    const stakeAmount = calcStakeForStage(currentStage, cycleAutoBetCfg);
                                    const cycleId = (martingaleState && martingaleState.entryTimestamp)
                                        ? martingaleState.entryTimestamp
                                        : (currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now());
                                    const cycleTotalInvested = calcTotalInvestedThroughStage(currentStage, cycleAutoBetCfg);
                                    const cycleNetProfit = roundMoney(-cycleTotalInvested);
                                    const entrySpinsSnapshot = buildEntrySpinsSnapshot(
                                        { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                        14
                                    );
                                    
                                    // âœ… UI/HistÃ³rico: manter a confianÃ§a ORIGINAL do sinal de entrada (nÃ£o a confianÃ§a recalculada do GALE)
                                    const entryAnalysisForUI = (martingaleState && martingaleState.active && martingaleState.analysisData)
                                        ? martingaleState.analysisData
                                        : currentAnalysis;
                                    const entryConfidenceForUI = (entryAnalysisForUI && typeof entryAnalysisForUI.confidence === 'number' && Number.isFinite(entryAnalysisForUI.confidence))
                                        ? entryAnalysisForUI.confidence
                                        : ((typeof currentAnalysis.confidence === 'number' && Number.isFinite(currentAnalysis.confidence)) ? currentAnalysis.confidence : 0);
                                    const retEntry = {
                                        timestamp: latestSpin.created_at,
                                        number: rollNumber,
                                        color: rollColor,
                                        phase: currentStage,
                                        result: 'LOSS',
                                        confidence: entryConfidenceForUI,
                                        patternData: {
                                            patternDescription: entryAnalysisForUI ? entryAnalysisForUI.patternDescription : currentAnalysis.patternDescription,
                                            confidence: entryConfidenceForUI,
                                            color: entryAnalysisForUI ? entryAnalysisForUI.color : currentAnalysis.color,
                                            createdOnTimestamp: entryAnalysisForUI ? entryAnalysisForUI.createdOnTimestamp : currentAnalysis.createdOnTimestamp,
                                            // âœ… Snapshot de giros (para o modal "PadrÃ£o da Entrada")
                                            last5Spins: entrySpinsSnapshot
                                        },
                                        martingaleStage: currentStage,
                                        finalResult: 'RED',
                                        // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                        analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard',
                                        // âœ… NOVO: marcar se este ciclo era SINAL DE ENTRADA
                                        isMaster: !!(entryAnalysisForUI && entryAnalysisForUI.masterSignal && entryAnalysisForUI.masterSignal.active),
                                        // âœ… NOVO: marcar se este ciclo foi um SINAL DE RECUPERAÃ‡ÃƒO
                                        recoveryMode: !!(entryAnalysisForUI && entryAnalysisForUI.recoveryMode),
                                        // âœ… NOVO (Diamante): qual nÃ­vel "mandou" o sinal (origem)
                                        diamondSourceLevel: entryAnalysisForUI && entryAnalysisForUI.diamondSourceLevel ? entryAnalysisForUI.diamondSourceLevel : null,
                                        // âœ… FINANCEIRO (fixo no tempo)
                                        cycleId,
                                        betColor,
                                        stakeAmount,
                                        baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                        galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                        payoutMultiplier,
                                        cycleTotalInvested,
                                        cycleNetProfit
                                    };
                                    
                                    activeHistory.unshift(retEntry);
                                    // âœ… Pedido: nÃ£o limitar histÃ³rico por ciclos (acumular ilimitado)
                                    
                                    // âœ… Calcular estatÃ­sticas WIN/LOSS FILTRADAS POR MODO
                                    const currentMode = analyzerConfig.aiMode ? 'diamond' : 'standard';
                                    const { wins: filteredWins, losses: filteredLosses } = calculateFilteredScore(entriesHistory, currentMode);
                                    
                                    console.log(`ğŸ“Š Placar total: ${calculateCycleScore(entriesHistory).totalWins} wins / ${calculateCycleScore(entriesHistory).totalLosses} losses`);
                                    console.log(`ğŸ“Š Placar ${currentMode}: ${filteredWins} wins / ${filteredLosses} losses`);
                                    
                                    if (!isHiddenInternal) {
                                        detachPromise(
                                            sendTelegramMartingaleRET(filteredWins, filteredLosses, currentMode, currentAnalysis.confidence),
                                            'telegram-martingale-ret'
                                        );
                                    }
                                    
                                    // âœ… ATUALIZAR HISTÃ“RICO DE CORES QUENTES
                                    const colorSequence = [];
                                    martingaleState.lossColors.forEach(color => {
                                        colorSequence.push({ color });
                                    });
                                    colorSequence.push({ color: rollColor });
                                    detachPromise(updateHotColorsHistory(patternKey, colorSequence), 'hot-colors-update-red');

                                    // ğŸ’ N4 (Autointeligente): registrar resultado final do CICLO (LOSS/RED) para auto-aprendizado
                                    try {
                                        const learningAnalysis = (martingaleState && martingaleState.active && martingaleState.analysisData)
                                            ? martingaleState.analysisData
                                            : currentAnalysis;
                                        await recordN4SelfLearningFromResolvedCycle(learningAnalysis, 'loss');
                                        // âšª N0 (Detector de Branco): registrar auto-aprendizado quando o N0 foi o sinal final
                                        await recordN0SelfLearningFromResolvedCycle(learningAnalysis, 'loss');
                                        // ğŸ’ N4 (Autointeligente): auto-ajuste de janela (n4Persistence) quando o desempenho cair
                                        try {
                                            if (!isHiddenInternal) {
                                                maybeAutoTuneN4HistoryWindow({ entriesHistory, analysisObj: learningAnalysis }).catch(() => {});
                                            }
                                        } catch (_) {}
                                    } catch (_) {}
                                    
                                    resetMartingaleState();

                                    // âœ… Persistir Ãºltimo sinal de recuperaÃ§Ã£o (por modo) para a aba "RecuperaÃ§Ã£o"
                                    let lastRecoveryEntryByMode = null;
                                    if (!isHiddenInternal && (currentAnalysis && currentAnalysis.recoveryMode)) {
                                        try {
                                            const prev = await chrome.storage.local.get([LAST_RECOVERY_ENTRY_BY_MODE_KEY]);
                                            const raw = prev ? prev[LAST_RECOVERY_ENTRY_BY_MODE_KEY] : null;
                                            const map = raw && typeof raw === 'object' ? raw : {};
                                            lastRecoveryEntryByMode = { ...map, [currentMode]: retEntry };
                                        } catch (_) {
                                            lastRecoveryEntryByMode = { [currentMode]: retEntry };
                                        }
                                    }
                                    
                                    await chrome.storage.local.set({ 
                                        analysis: null, 
                                        pattern: null, 
                                        lastBet: { status: 'loss', phase: currentStage, resolvedAtTimestamp: latestSpin.created_at },
                                        // âœ… Marcar fim do ciclo (RED) para referÃªncia de estado/telemetria
                                        lastCycleResolvedSpinId: latestSpin ? (latestSpin.id || null) : null,
                                        lastCycleResolvedSpinTimestamp: latestSpin ? (latestSpin.created_at || null) : null,
                                        lastCycleResolvedTimestamp: Date.now(),
                                        ...(isHiddenInternal ? { [RECOVERY_SECURE_HISTORY_KEY]: recoverySecureHistory } : { entriesHistory }),
                                        ...(lastRecoveryEntryByMode ? { [LAST_RECOVERY_ENTRY_BY_MODE_KEY]: lastRecoveryEntryByMode } : {}),
                                        martingaleState
                                    });
                                    
                                    if (!isHiddenInternal || (currentAnalysis && currentAnalysis.recoveryMode)) {
                                        sendMessageToContent('CLEAR_ANALYSIS');
                                        sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                    }
                                    return;
                                }
                                
                                // âœ… TEM GALES: Tentar prÃ³ximo
                                console.log(`ğŸ”„ Tentando G${nextGaleNumber}...`);
                                console.log(`âš™ï¸ Gales consecutivos (atÃ©): ${consecutiveGales}`);
                                
                                if (!isHiddenInternal) {
                                    // âœ… ENVIAR MENSAGEM DE LOSS (vai tentar prÃ³ximo Gale)
                                    detachPromise(
                                        sendTelegramMartingaleLoss(
                                            currentStage,
                                            { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                            currentAnalysis.confidence
                                        ),
                                        'telegram-martingale-loss'
                                    );
                                }
                                
                                // âœ… N4 (Autointeligente): permitir re-anÃ¡lise no Gale (G2...) quando estiver rodando "sÃ³ N4"
                                console.log(`â•‘  martingaleState.entryColor: ${martingaleState.entryColor}                   â•‘`);
                                console.log(`â•‘  martingaleState.currentColor: ${martingaleState.currentColor || '-'}                   â•‘`);
                                console.log(`â•‘  currentAnalysis.color: ${currentAnalysis.color}                        â•‘`);

                                let nextGaleColor = martingaleState.currentColor || martingaleState.entryColor || currentAnalysis.color;
                                // âšª Branco: NÃƒO mudar cor em gales â€” respeitar configuraÃ§Ã£o exclusiva do Branco.
                                if (normalizeSimpleBetColor(martingaleState.entryColor || currentAnalysis.color) !== 'white' && shouldUseN4DynamicGalesForConfig(analyzerConfig)) {
                                    const picked = pickN4DynamicGaleColor({
                                        history: cachedHistory,
                                        config: analyzerConfig,
                                        stageNumber: nextGaleNumber,
                                        maxGales,
                                        forcePick: true
                                    });
                                    if (picked) nextGaleColor = picked;
                                }
                                
                                console.log(`ğŸ¯ COR CONFIRMADA PARA G${nextGaleNumber}: ${nextGaleColor}`);
                                
                                // âš ï¸ CRÃTICO: Registrar LOSS do Gale atual
                                const entrySpinsSnapshot = buildEntrySpinsSnapshot(
                                    { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                    14
                                );
                                // âœ… UI/HistÃ³rico: manter a confianÃ§a ORIGINAL do sinal de entrada (nÃ£o a confianÃ§a recalculada do GALE)
                                const entryAnalysisForUI = (martingaleState && martingaleState.active && martingaleState.analysisData)
                                    ? martingaleState.analysisData
                                    : currentAnalysis;
                                const entryConfidenceForUI = (entryAnalysisForUI && typeof entryAnalysisForUI.confidence === 'number' && Number.isFinite(entryAnalysisForUI.confidence))
                                    ? entryAnalysisForUI.confidence
                                    : ((typeof currentAnalysis.confidence === 'number' && Number.isFinite(currentAnalysis.confidence)) ? currentAnalysis.confidence : 0);
                                const galeLossEntry = {
                                    timestamp: latestSpin.created_at,
                                    number: rollNumber,
                                    color: rollColor,
                                    phase: currentStage,
                                    result: 'LOSS',
                                    confidence: entryConfidenceForUI,
                                    patternData: {
                                        patternDescription: entryAnalysisForUI ? entryAnalysisForUI.patternDescription : currentAnalysis.patternDescription,
                                        confidence: entryConfidenceForUI,
                                        color: entryAnalysisForUI ? entryAnalysisForUI.color : currentAnalysis.color,
                                        createdOnTimestamp: entryAnalysisForUI ? entryAnalysisForUI.createdOnTimestamp : currentAnalysis.createdOnTimestamp,
                                        // âœ… Snapshot de giros (para o modal "PadrÃ£o da Entrada")
                                        last5Spins: entrySpinsSnapshot
                                    },
                                    martingaleStage: currentStage,
                                    finalResult: null,
                                    [`continuingToG${nextGaleNumber}`]: true,
                                    // âœ… IDENTIFICAR MODO DE ANÃLISE (crÃ­tico para UI filtrar corretamente no grÃ¡fico)
                                    analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard',
                                    // âœ… NOVO: marcar se este ciclo era SINAL DE ENTRADA
                                    isMaster: !!(entryAnalysisForUI && entryAnalysisForUI.masterSignal && entryAnalysisForUI.masterSignal.active)
                                };
                                
                                activeHistory.unshift(galeLossEntry);
                                // âœ… Pedido: nÃ£o limitar histÃ³rico por ciclos (acumular ilimitado)
                                
                                // Atualizar estado do Martingale
                                martingaleState.stage = `G${nextGaleNumber}`;
                                martingaleState.currentColor = nextGaleColor;
                                martingaleState.lossCount = nextGaleNumber;
                                martingaleState.lossColors.push(rollColor);
                                
                                // Verificar modo de Martingale
                                if (nextGaleNumber <= consecutiveGales) {
                                    // âœ… MODO CONSECUTIVO
                                    console.log(`ğŸ¯ MODO CONSECUTIVO: G${nextGaleNumber} serÃ¡ enviado no PRÃ“XIMO GIRO`);
                                    
                                    const nextGaleAnalysis = {
                                        ...currentAnalysis,
                                        color: nextGaleColor,
                                        phase: `G${nextGaleNumber}`,
                                        predictedFor: 'next',
                                        createdOnTimestamp: latestSpin.created_at
                                    };
                                    {
                                        const baseConf = Number.isFinite(Number(nextGaleAnalysis.confidence)) ? Number(nextGaleAnalysis.confidence) : 0;
                                        nextGaleAnalysis.confidence = baseConf; // âœ… manter no UI
                                        nextGaleAnalysis.galeConfidence = calculateGaleConfidenceValue(baseConf, nextGaleAnalysis); // âœ… interno/telegram
                                    }
                                    
                                    await chrome.storage.local.set({
                                        analysis: nextGaleAnalysis,
                                        pattern: { description: nextGaleAnalysis.patternDescription, confidence: nextGaleAnalysis.confidence },
                                        lastBet: { status: 'pending', phase: `G${nextGaleNumber}`, createdOnTimestamp: nextGaleAnalysis.createdOnTimestamp },
                                        ...(isHiddenInternal ? { [RECOVERY_SECURE_HISTORY_KEY]: recoverySecureHistory } : { entriesHistory }),
                                        martingaleState
                                    });
                                    
                                    emitAnalysisToContent(nextGaleAnalysis, analyzerConfig.aiMode ? 'diamond' : 'standard');
                                    if (!isHiddenInternal) {
                                        sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                    }

                                    // âœ… Telegram com confianÃ§a REAL do Gale
                                    if (!isHiddenInternal) {
                                        detachPromise(
                                            sendTelegramMartingaleGale(
                                                nextGaleNumber,
                                                nextGaleColor,
                                                (typeof nextGaleAnalysis.galeConfidence === 'number' && Number.isFinite(nextGaleAnalysis.galeConfidence)) ? nextGaleAnalysis.galeConfidence : nextGaleAnalysis.confidence,
                                                { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at }
                                            ),
                                            'telegram-martingale-gale'
                                        );
                                    }
                                } else {
                                    // âœ… CorreÃ§Ã£o (pedido do usuÃ¡rio): GALE deve continuar no PRÃ“XIMO GIRO (nÃ£o esperar â€œnovo sinalâ€)
                                    console.log(`âœ… GALE AUTOMÃTICO: G${nextGaleNumber} serÃ¡ enviado no PRÃ“XIMO GIRO`);

                                    const nextGaleAnalysis = {
                                        ...currentAnalysis,
                                        color: nextGaleColor,
                                        phase: `G${nextGaleNumber}`,
                                        predictedFor: 'next',
                                        createdOnTimestamp: latestSpin.created_at
                                    };
                                    {
                                        const baseConf = Number.isFinite(Number(nextGaleAnalysis.confidence)) ? Number(nextGaleAnalysis.confidence) : 0;
                                        nextGaleAnalysis.confidence = baseConf; // âœ… manter no UI
                                        nextGaleAnalysis.galeConfidence = calculateGaleConfidenceValue(baseConf, nextGaleAnalysis); // âœ… interno/telegram
                                    }

                                    await chrome.storage.local.set({
                                        analysis: nextGaleAnalysis,
                                        pattern: { description: nextGaleAnalysis.patternDescription, confidence: nextGaleAnalysis.confidence },
                                        lastBet: { status: 'pending', phase: `G${nextGaleNumber}`, createdOnTimestamp: nextGaleAnalysis.createdOnTimestamp },
                                        ...(isHiddenInternal ? { [RECOVERY_SECURE_HISTORY_KEY]: recoverySecureHistory } : { entriesHistory }),
                                        martingaleState
                                    });

                                    emitAnalysisToContent(nextGaleAnalysis, analyzerConfig.aiMode ? 'diamond' : 'standard');
                                    if (!isHiddenInternal) {
                                        sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                    }

                                    if (!isHiddenInternal) {
                                        detachPromise(
                                            sendTelegramMartingaleGale(
                                                nextGaleNumber,
                                                nextGaleColor,
                                                (typeof nextGaleAnalysis.galeConfidence === 'number' && Number.isFinite(nextGaleAnalysis.galeConfidence)) ? nextGaleAnalysis.galeConfidence : nextGaleAnalysis.confidence,
                                                { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at }
                                            ),
                                            'telegram-martingale-gale'
                                        );
                                    }
                                }
                                
                            } else if (false) {
                                // BLOCO ANTIGO DESATIVADO - MANTIDO PARA REFERÃŠNCIA
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // âœ… LOSS NO G1: Verificar modo de Martingale
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                console.log(`âš™ï¸ Gales consecutivos (atÃ©): ${consecutiveGales}`);
                                
                                // âœ… USAR SEMPRE A MESMA COR DA ENTRADA ORIGINAL
                                const g2Color = martingaleState.entryColor;
                                
                                // âš ï¸ CRÃTICO: Registrar LOSS do G1 antes de tentar G2
                                const g1LossEntry = {
                                    timestamp: latestSpin.created_at,
                                    number: rollNumber,
                                    color: rollColor,
                                    phase: 'G1',
                                    result: 'LOSS',
                                    confidence: currentAnalysis.confidence,
                                    patternData: {
                                        patternDescription: currentAnalysis.patternDescription,
                                        confidence: currentAnalysis.confidence,
                                        color: currentAnalysis.color,
                                        createdOnTimestamp: currentAnalysis.createdOnTimestamp
                                    },
                                    martingaleStage: 'G1',
                                    finalResult: null,  // Ainda nÃ£o Ã© final, vai tentar G2
                                    continuingToG2: true,  // Flag indicando que continuarÃ¡
                                    // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                    analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard'
                                };
                                
                                activeHistory.unshift(g1LossEntry);
                                // âœ… Pedido: nÃ£o limitar histÃ³rico por ciclos (acumular ilimitado)
                                
                                // Atualizar estado do Martingale
                                martingaleState.stage = 'G2';
                                martingaleState.lossCount = 2;
                                martingaleState.lossColors.push(rollColor);  // âœ… Adicionar cor do G1 que perdeu
                                
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                // VERIFICAR MODO DE MARTINGALE
                                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                
                                if (consecutiveMartingale) {
                                    // âœ… MODO CONSECUTIVO: Enviar G2 IMEDIATAMENTE no prÃ³ximo giro
                                    console.log('ğŸ¯ MODO CONSECUTIVO: G2 serÃ¡ enviado no PRÃ“XIMO GIRO');
                                    detachPromise(sendTelegramMartingaleG2(g2Color, null), 'telegram-martingale-g2');
                                    
                                    // Criar anÃ¡lise G2 com timestamp do prÃ³ximo giro
                                    const g2Analysis = {
                                        ...currentAnalysis,
                                        color: g2Color,
                                        phase: 'G2',
                                        predictedFor: 'next',
                                        createdOnTimestamp: latestSpin.created_at  // âœ… Usar giro atual
                                    };
                                    g2Analysis.confidence = calculateGaleConfidenceValue(g2Analysis.confidence, g2Analysis);
                                    
                                    await chrome.storage.local.set({
                                        analysis: g2Analysis,
                                        pattern: { description: g2Analysis.patternDescription, confidence: g2Analysis.confidence },
                                        lastBet: { status: 'pending', phase: 'G2', createdOnTimestamp: g2Analysis.createdOnTimestamp },
                                        entriesHistory,
                                        martingaleState
                                    });
                                    
                                    emitAnalysisToContent(g2Analysis, analyzerConfig.aiMode ? 'diamond' : 'standard');
                                } else {
                                    // âŒ MODO PADRÃƒO: Aguardar novo padrÃ£o para enviar G2
                                    console.log('â³ MODO PADRÃƒO: Aguardando novo padrÃ£o para enviar G2...');
                                    
                                    await chrome.storage.local.set({
                                        analysis: null,
                                        pattern: null,
                                        lastBet: { status: 'loss', phase: 'G1', resolvedAtTimestamp: latestSpin.created_at },
                                        ...(isHiddenInternal ? { [RECOVERY_SECURE_HISTORY_KEY]: recoverySecureHistory } : { entriesHistory }),
                                        martingaleState
                                    });
                                    
                                    if (!isHiddenInternal || (currentAnalysis && currentAnalysis.recoveryMode)) {
                                        sendMessageToContent('CLEAR_ANALYSIS');
                                        sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                    }
                                }
                                
                            } else if (currentStage === 'G2') {
                                // âŒ LOSS NO G2: RED (Loss Final)
                                console.log('â›” LOSS no G2 - RED');
                                
                                // âœ… Fix financeiro: usar config do ciclo (congelada) e calcular net do RED
                                const cycleAutoBetCfg = ensureMartingaleCycleConfig(snapshotAutoBetConfig(analyzerConfig));
                                const betColor = (martingaleState && martingaleState.entryColor) ? martingaleState.entryColor : currentAnalysis.color;
                                const payoutMultiplier = getPayoutMultiplierForBetColor(betColor, cycleAutoBetCfg);
                                const stakeAmount = calcStakeForStage('G2', cycleAutoBetCfg);
                                const cycleId = (martingaleState && martingaleState.entryTimestamp)
                                    ? martingaleState.entryTimestamp
                                    : (currentAnalysis.createdOnTimestamp || latestSpin.created_at || Date.now());
                                const cycleTotalInvested = calcTotalInvestedThroughStage('G2', cycleAutoBetCfg);
                                const cycleNetProfit = roundMoney(-cycleTotalInvested);
                                const entrySpinsSnapshot = buildEntrySpinsSnapshot(
                                    { color: rollColor, number: rollNumber, timestamp: latestSpin.created_at },
                                    14
                                );
                                
                                // âœ… UI/HistÃ³rico: manter a confianÃ§a ORIGINAL do sinal de entrada (nÃ£o a confianÃ§a recalculada do GALE)
                                const entryAnalysisForUI = (martingaleState && martingaleState.active && martingaleState.analysisData)
                                    ? martingaleState.analysisData
                                    : currentAnalysis;
                                const entryConfidenceForUI = (entryAnalysisForUI && typeof entryAnalysisForUI.confidence === 'number' && Number.isFinite(entryAnalysisForUI.confidence))
                                    ? entryAnalysisForUI.confidence
                                    : ((typeof currentAnalysis.confidence === 'number' && Number.isFinite(currentAnalysis.confidence)) ? currentAnalysis.confidence : 0);
                                const retEntry = {
                                    timestamp: latestSpin.created_at,
                                    number: rollNumber,
                                    color: rollColor,
                                    phase: 'G2',
                                    result: 'LOSS',
                                    confidence: entryConfidenceForUI,
                                    patternData: {
                                        patternDescription: entryAnalysisForUI ? entryAnalysisForUI.patternDescription : currentAnalysis.patternDescription,
                                        confidence: entryConfidenceForUI,
                                        color: entryAnalysisForUI ? entryAnalysisForUI.color : currentAnalysis.color,
                                        createdOnTimestamp: entryAnalysisForUI ? entryAnalysisForUI.createdOnTimestamp : currentAnalysis.createdOnTimestamp,
                                        // âœ… Snapshot de giros (para o modal "PadrÃ£o da Entrada")
                                        last5Spins: entrySpinsSnapshot
                                    },
                                    martingaleStage: 'G2',
                                    finalResult: 'RED',
                                    // âœ… NOVO: IDENTIFICAR MODO DE ANÃLISE
                                    analysisMode: analyzerConfig.aiMode ? 'diamond' : 'standard',
                                    // âœ… NOVO: marcar se este ciclo era SINAL DE ENTRADA
                                    isMaster: !!(entryAnalysisForUI && entryAnalysisForUI.masterSignal && entryAnalysisForUI.masterSignal.active),
                                    // âœ… NOVO: marcar se este ciclo foi um SINAL DE RECUPERAÃ‡ÃƒO
                                    recoveryMode: !!(entryAnalysisForUI && entryAnalysisForUI.recoveryMode),
                                    // âœ… FINANCEIRO (fixo no tempo)
                                    cycleId,
                                    betColor,
                                    stakeAmount,
                                    baseStakeSnapshot: Number(cycleAutoBetCfg.baseStake) || 0,
                                    galeMultiplierSnapshot: Number(cycleAutoBetCfg.galeMultiplier) || 0,
                                    payoutMultiplier,
                                    cycleTotalInvested,
                                    cycleNetProfit
                                };
                                
                                activeHistory.unshift(retEntry);
                                // âœ… Pedido: nÃ£o limitar histÃ³rico por ciclos (acumular ilimitado)
                                
                                // âœ… Calcular estatÃ­sticas WIN/LOSS FILTRADAS POR MODO
                                const currentMode = analyzerConfig.aiMode ? 'diamond' : 'standard';
                                const { wins: filteredWins, losses: filteredLosses } = calculateFilteredScore(entriesHistory, currentMode);
                                
                                console.log(`ğŸ“Š Placar total: ${calculateCycleScore(entriesHistory).totalWins} wins / ${calculateCycleScore(entriesHistory).totalLosses} losses`);
                                console.log(`ğŸ“Š Placar ${currentMode}: ${filteredWins} wins / ${filteredLosses} losses`);
                                
                                if (!isHiddenInternal) {
                                    detachPromise(
                                        sendTelegramMartingaleRET(filteredWins, filteredLosses, currentMode),
                                        'telegram-martingale-ret'
                                    );
                                }
                                
                                // âœ… ATUALIZAR HISTÃ“RICO DE CORES QUENTES
                                console.log('ğŸ“Š Atualizando histÃ³rico de cores quentes apÃ³s RED...');
                                
                                // Construir sequÃªncia de cores DOS GIROS (nÃ£o das apostas!)
                                const colorSequence = [];
                                
                                // Adicionar cores dos LOSSes (giros que realmente saÃ­ram)
                                martingaleState.lossColors.forEach(color => {
                                    colorSequence.push({ color });
                                });
                                
                                // Adicionar cor do G2 que perdeu (giro atual)
                                colorSequence.push({ color: rollColor });
                                
                                console.log('   SequÃªncia de cores dos giros:', colorSequence.map(c => c.color).join(' â†’ '));
                                detachPromise(updateHotColorsHistory(patternKey, colorSequence), 'hot-colors-update-g2-red');
                                
                                resetMartingaleState();

                                // âœ… Persistir Ãºltimo sinal de recuperaÃ§Ã£o (por modo) para a aba "RecuperaÃ§Ã£o"
                                let lastRecoveryEntryByMode = null;
                                if (!isHiddenInternal && (currentAnalysis && currentAnalysis.recoveryMode)) {
                                    try {
                                        const prev = await chrome.storage.local.get([LAST_RECOVERY_ENTRY_BY_MODE_KEY]);
                                        const raw = prev ? prev[LAST_RECOVERY_ENTRY_BY_MODE_KEY] : null;
                                        const map = raw && typeof raw === 'object' ? raw : {};
                                        lastRecoveryEntryByMode = { ...map, [currentMode]: retEntry };
                                    } catch (_) {
                                        lastRecoveryEntryByMode = { [currentMode]: retEntry };
                                    }
                                }
                                
                                    await chrome.storage.local.set({ 
                                        analysis: null, 
                                        pattern: null, 
                                    lastBet: { status: 'loss', phase: 'G2', resolvedAtTimestamp: latestSpin.created_at },
                                        // âœ… Marcar fim do ciclo (RED) para referÃªncia de estado/telemetria
                                        lastCycleResolvedSpinId: latestSpin ? (latestSpin.id || null) : null,
                                        lastCycleResolvedSpinTimestamp: latestSpin ? (latestSpin.created_at || null) : null,
                                        lastCycleResolvedTimestamp: Date.now(),
                                        ...(isHiddenInternal ? { [RECOVERY_SECURE_HISTORY_KEY]: recoverySecureHistory } : { entriesHistory }),
                                    ...(lastRecoveryEntryByMode ? { [LAST_RECOVERY_ENTRY_BY_MODE_KEY]: lastRecoveryEntryByMode } : {}),
                                    martingaleState
                                    });
                                
                                    if (!isHiddenInternal || (currentAnalysis && currentAnalysis.recoveryMode)) {
                                        sendMessageToContent('CLEAR_ANALYSIS');
                                        sendMessageToContent('ENTRIES_UPDATE', entriesHistory);
                                    }
                            }
                        }
                    }
                } else {
                    console.log('âš ï¸ NÃƒO hÃ¡ recomendaÃ§Ã£o pendente para avaliar');
                    if (!currentAnalysis) {
                        console.log('   Motivo: currentAnalysis nÃ£o existe');
                    } else if (!currentAnalysis.createdOnTimestamp) {
                        console.log('   Motivo: createdOnTimestamp ausente');
                    }
                }
                
                // Notificar content script sobre novo giro (SEMPRE usar cachedHistory - array vÃ¡lido!)
                // âœ… NÃƒO enviar history a cada giro (evita sobrescrever buffer de 10k no content.js e reduz payload)
                sendMessageToContent('NEW_SPIN', { 
                    lastSpin: { number: rollNumber, color: rollColor, timestamp: latestSpin.created_at } 
                });
                
                // âœ… EXECUTAR NOVA ANÃLISE (apÃ³s processar WIN/LOSS)
                // âš ï¸ Importante: NÃƒO gerar novo sinal se ainda existe anÃ¡lise pendente (aguardando resultado).
                // Isso evita sobrescrever G1/G2/RecuperaÃ§Ã£o e elimina â€œsinal normal vazandoâ€ enquanto espera o resultado.
                try {
                    const storedNow = await chrome.storage.local.get(['analysis']);
                    const aNow = storedNow && storedNow.analysis ? storedNow.analysis : null;
                    if (aNow && aNow.createdOnTimestamp) {
                        console.log('â¸ï¸ AnÃ¡lise pendente detectada â€” pulando geraÃ§Ã£o de novo sinal.', {
                            phase: aNow.phase || 'G0',
                            recoveryMode: !!aNow.recoveryMode
                        });
                        return;
                    }
                } catch (_) {}

            console.log('%câ•‘                                                                               â•‘', 'color: #FFD700; font-weight: bold; font-size: 16px; background: #333300; padding: 5px;');
            console.log('%câ•‘                                                                               â•‘', 'color: #FFD700; font-weight: bold; font-size: 16px; background: #333300; padding: 5px;');
            console.log('%câ•‘       ğŸ“Š Giros no histÃ³rico:', 'color: #FFD700; font-weight: bold; background: #333300; padding: 5px;', cachedHistory ? cachedHistory.length : 0);
            console.log('%câ•‘       ğŸ¤– Modo IA ativo:', 'color: #FFD700; font-weight: bold; background: #333300; padding: 5px;', analyzerConfig.aiMode);
            console.log('%câ•‘                                                                               â•‘', 'color: #FFD700; font-weight: bold; font-size: 16px; background: #333300; padding: 5px;');
            
            const __analysisStartMs = Date.now();
            const executed = await runAnalysisIfEnabled(cachedHistory, 'NEW_SPIN');
            if (!executed) {
                return;
            }
            const __analysisElapsedMs = Date.now() - __analysisStartMs;
            if (__analysisElapsedMs > 5000) {
                console.warn(`â±ï¸ [LATÃŠNCIA] AnÃ¡lise levou ~${Math.round(__analysisElapsedMs)}ms (orÃ§amento: 5000ms).`);
            }
            
            console.log('%câœ… runAnalysisController() FINALIZADO!', 'color: #00FF88; font-weight: bold; font-size: 16px; background: #003300; padding: 5px;');
        }
    } catch (error) {
        console.error('Erro ao processar giro do servidor:', error);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… FUNÃ‡ÃƒO PARA CALCULAR PLACAR BASEADO EM CICLOS COMPLETOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calculateCycleScore(entriesHistory) {
    console.log('ğŸ“Š Calculando placar baseado em CICLOS...');
    
    let totalWins = 0;
    let totalLosses = 0;
    
    // Contar apenas entradas com finalResult definido (ciclos completos)
    for (const entry of entriesHistory) {
        if (entry.finalResult === 'WIN') {
            totalWins++;
            console.log(`  âœ… WIN (${entry.martingaleStage || entry.phase})`);
        } else if (entry.finalResult === 'RED' || entry.finalResult === 'RET') {
            totalLosses++;
            console.log(`  âŒ LOSS (${entry.martingaleStage || entry.phase} - NÃ£o pagou)`);
        }
    }
    
    console.log(`ğŸ“Š Placar final: WIN: ${totalWins} | LOSS: ${totalLosses}`);
    return { totalWins, totalLosses };
}

// FunÃ§Ã£o auxiliar para processar giro vindo direto da Blaze (fallback)
function processNewSpin(spinData) {
    return processNewSpinFromServer(spinData);
}

// Tenta carregar os Ãºltimos 10k giros de uma vez do SERVIDOR e popular cache em memÃ³ria
async function initializeHistoryIfNeeded(force = false) {
    if (historyInitialized && !force) return true; // jÃ¡ inicializado nesta sessÃ£o

    try {
        // Buscar giros do SERVIDOR primeiro
        console.log('ğŸ“¥ Buscando histÃ³rico inicial do servidor para cache em memÃ³ria...');
        const serverGiros = await fetchGirosFromAPI(REALTIME_HISTORY_CAP, BOOTSTRAP_HISTORY_TIMEOUT_MS);
        
        if (serverGiros && serverGiros.length > 0) {
            console.log(`âœ… ${serverGiros.length} giros recebidos do servidor!`);
            // âœ… Popular CACHE EM MEMÃ“RIA (nÃ£o salvar em chrome.storage.local)
            cachedHistory = [...serverGiros].slice(0, REALTIME_HISTORY_CAP);
            historyInitialized = true;
            clearHistoryBootstrapRetry();
            console.log(`ğŸ“Š Cache em memÃ³ria inicializado: ${cachedHistory.length} giros`);
            
            // âœ… INICIALIZAR MEMÃ“RIA ATIVA SE MODO IA ESTIVER ATIVO
            if (analyzerConfig.aiMode && !memoriaAtiva.inicializada && cachedHistory.length >= 60) {
                console.log('%cğŸ§  MODO IA ATIVO - Inicializando MemÃ³ria Ativa automaticamente...', 'color: #00CED1; font-weight: bold;');
                const sucesso = await inicializarMemoriaAtiva(cachedHistory);
                if (sucesso) {
                    console.log('%câœ… MemÃ³ria Ativa inicializada com sucesso!', 'color: #00FF88; font-weight: bold;');
                } else {
                    console.log('%câš ï¸ Falha ao inicializar MemÃ³ria Ativa', 'color: #FFAA00; font-weight: bold;');
                }
            }
            
            // âœ… ENVIAR ÃšLTIMO GIRO E HISTÃ“RICO PARA A UI
            const lastSpin = serverGiros[0]; // O mais recente estÃ¡ na posiÃ§Ã£o 0
            if (lastSpin) {
                console.log('ğŸ“¤ Enviando Ãºltimo giro para UI:', lastSpin);
                await chrome.storage.local.set({ lastSpin: lastSpin });
                // âœ… NÃƒO enviar history aqui (ver comentÃ¡rio em syncInitialData)
                sendMessageToContent('NEW_SPIN', { lastSpin: lastSpin });
                console.log('%câœ… UI atualizada com histÃ³rico do servidor (initializeHistoryIfNeeded)', 'color: #00ff00; font-weight: bold;');
            }
            return true;
        }
        
        // Se servidor nÃ£o tiver dados, buscar direto da Blaze (fallback)
        console.log('âš ï¸ Servidor sem dados, buscando direto da Blaze...');
        const endpoints = [
            'https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/2000',
            'https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/300',
            'https://blaze.bet.br/api/singleplayer-originals/originals/roulette_games/recent/100'
        ];
        let combined = [];
        for (const url of endpoints) {
            try {
                const r = await fetch(url);
                if (!r.ok) continue;
                const json = await r.json();
                const arr = Array.isArray(json) ? json : (json?.data || json?.records || json?.items || []);
                if (Array.isArray(arr)) combined = combined.concat(arr);
            } catch(_) { /* tenta prÃ³ximo */ }
        }
        // Remover duplicados por created_at
        const uniqMap = new Map();
        combined.forEach(spin => {
            if (spin && spin.created_at) uniqMap.set(spin.created_at, spin);
        });
        const dataArr = Array.from(uniqMap.values());
        if (Array.isArray(dataArr) && dataArr.length > 0) {
            const sorted = [...dataArr].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            const mapped = sorted.slice(0, 800).map(spin => ({
                id: `spin_${spin.created_at}`,
                number: spin.roll,
                color: getColorFromNumber(spin.roll),
                timestamp: spin.created_at,
                created_at: spin.created_at
            }));
            const last = mapped[0];
            
            // âœ… Popular CACHE EM MEMÃ“RIA (nÃ£o salvar em chrome.storage.local)
            cachedHistory = mapped;
            historyInitialized = true;
            clearHistoryBootstrapRetry();
            
            await chrome.storage.local.set({ lastSpin: last });
            sendMessageToContent('NEW_SPIN', { lastSpin: last });
            console.log(`ğŸ“Š Cache em memÃ³ria inicializado (fallback Blaze): ${mapped.length} giros`);
            return true;
        } else {
            cachedHistory = [];
            historyInitialized = false;
            console.log('âš ï¸ Nenhum giro disponÃ­vel - cache em memÃ³ria vazio');
            scheduleHistoryBootstrapRetry('no_spins_available');
            return false;
        }
    } catch (err) {
        console.warn('NÃ£o foi possÃ­vel carregar giros iniciais. Mantendo coleta incremental.', err);
        cachedHistory = [];
        historyInitialized = false;
        scheduleHistoryBootstrapRetry(err && err.message ? `bootstrap_error:${err.message}` : 'bootstrap_error');
        return false;
    }
    return false;
}

// Analyze patterns in the data - ONLY triggered when new spin detected
async function analyzePatterns(history) {
    console.log('ğŸ” Iniciando anÃ¡lise de padrÃµes...');
    
    // REGRA: MÃ­nimo de 50 giros para comeÃ§ar anÃ¡lises
    if (history.length < 50) {
        console.log('âš ï¸ HistÃ³rico insuficiente para anÃ¡lise:', history.length, '/ 50 giros necessÃ¡rios');
        sendAnalysisStatus(`Coletando dados... ${history.length}/50 giros`);
        return; // Precisa de pelo menos 50 giros para anÃ¡lises confiÃ¡veis
    }
    
    // REGRA: Verificar se nÃ£o estÃ¡ usando o mesmo padrÃ£o da Ãºltima entrada
    const entriesResult = await chrome.storage.local.get(['entriesHistory']);
    const entriesHistory = entriesResult.entriesHistory || [];
    
    if (entriesHistory.length > 0) {
        const lastEntry = entriesHistory[0];
        
        // Verificar se a Ãºltima entrada tem dados de padrÃ£o
        if (lastEntry.patternData && lastEntry.patternData.patternDescription) {
            try {
                // âš ï¸ CRÃTICO: Se for anÃ¡lise IA, patternDescription Ã© texto, nÃ£o JSON
                if (lastEntry.patternData.patternDescription.includes('ğŸ¤– ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL')) {
                    console.log('ğŸ” Ãšltimo padrÃ£o usado: AnÃ¡lise AvanÃ§ada (IA)');
                } else {
                    const lastPatternData = JSON.parse(lastEntry.patternData.patternDescription);
                    console.log('ğŸ” Ãšltimo padrÃ£o usado:', lastPatternData);
                }
                
                // Esta verificaÃ§Ã£o serÃ¡ feita apÃ³s a anÃ¡lise para comparar padrÃµes
                // Por enquanto, continuamos com a anÃ¡lise
            } catch (e) {
                console.log('âš ï¸ Erro ao analisar Ãºltimo padrÃ£o:', e);
            }
        }
    }
    
    try {
        console.log('ğŸš€ Executando anÃ¡lise multidimensional...', '| Rigor:', rigorLogString());
        const analysis = await performPatternAnalysis(history);
        
        if (analysis) {
            // REGRA: Verificar se nÃ£o Ã© o mesmo padrÃ£o da Ãºltima entrada
            let isDuplicatePattern = false;
            
            if (entriesHistory.length > 0) {
                const lastEntry = entriesHistory[0];
                
                if (lastEntry.patternData && lastEntry.patternData.patternDescription) {
                    try {
                        // âš ï¸ CRÃTICO: Se for anÃ¡lise IA, patternDescription Ã© texto, nÃ£o JSON
                        const isLastAI = lastEntry.patternData.patternDescription.includes('ğŸ¤– ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL');
                        const isCurrentAI = analysis.patternDescription.includes('ğŸ¤– ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL');
                        
                        // Se qualquer um for IA, sempre considerar como padrÃ£o diferente
                        if (isLastAI || isCurrentAI) {
                            console.log('âœ… AnÃ¡lise aceita (IA sempre permite novos sinais)');
                            isDuplicatePattern = false;
                        } else {
                            // Ambos sÃ£o anÃ¡lise padrÃ£o, comparar como JSON
                            const lastPatternData = JSON.parse(lastEntry.patternData.patternDescription);
                            const currentPatternData = JSON.parse(analysis.patternDescription);
                            
                            // Comparar caracterÃ­sticas dos padrÃµes
                            isDuplicatePattern = comparePatterns(lastPatternData, currentPatternData);
                            
                            if (isDuplicatePattern) {
                                console.log('âŒ AnÃ¡lise rejeitada: mesmo padrÃ£o da Ãºltima entrada');
                                sendAnalysisStatus('â³ Aguardando padrÃ£o diferente...');
                                return;
                            } else {
                                console.log('âœ… PadrÃ£o diferente detectado, anÃ¡lise aceita');
                            }
                        }
                    } catch (e) {
                        console.log('âš ï¸ Erro ao comparar padrÃµes:', e);
                    }
                }
            }
            
            console.log('âœ… AnÃ¡lise concluÃ­da com sucesso!');

            // ğŸ›Ÿ RecuperaÃ§Ã£o ativa: este sinal entra como "silencioso" (fase 1) por padrÃ£o.
            // `emitAnalysisToContent` decide se vira um sinal de recuperaÃ§Ã£o (recoveryMode=true).
            if (recoveryModeEnabled) {
                try { analysis.hiddenInternal = true; } catch (_) {}
            }

            await chrome.storage.local.set({
                analysis: analysis,
                pattern: {
                    description: analysis.patternDescription,
                    confidence: analysis.confidence
                },
                lastBet: { status: 'pending', phase: analysis.phase || 'G0', createdOnTimestamp: analysis.createdOnTimestamp }
            });
            
            emitAnalysisToContent(analysis, 'standard');
            } else {
            console.log('âŒ Nenhum padrÃ£o vÃ¡lido encontrado na anÃ¡lise');
            // Limpar anÃ¡lise primeiro
            await chrome.storage.local.set({ analysis: null, pattern: null });
            sendMessageToContent('CLEAR_ANALYSIS');
            // Enviar status de aguardando novo giro APÃ“S limpar a anÃ¡lise
            sendAnalysisStatus('â³ Aguardando novo giro...');
        }
    } catch (error) {
        console.error('Erro na anÃ¡lise de padrÃµes:', error);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– SISTEMA DE ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL (IA)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * VARREDURA 1: AnÃ¡lise Macro - Contexto Geral
 * Analisa 2000, 500 e 240 giros para entender:
 * - PadrÃµes gerais da Blaze
 * - ResistÃªncias e quebras
 * - Aleatoriedade
 */
function analyzeMacroContext(history) {
    console.log('ğŸ” VARREDURA 1: AnÃ¡lise Macro (Contexto Geral)');
    
    const results = {
        full: analyzeWindow(history.slice(0, 2000), '2000 giros'),
        recent: analyzeWindow(history.slice(0, 500), '500 giros'),
        immediate: analyzeWindow(history.slice(0, 240), '240 giros')
    };
    
    console.log('âœ… Varredura 1 completa:', results);
    return results;
}

/**
 * AnÃ¡lise de uma janela de giros
 */
function analyzeWindow(window, label) {
    if (!window || window.length === 0) return null;
    
    const colors = window.map(g => g.color);
    const red = colors.filter(c => c === 'red').length;
    const black = colors.filter(c => c === 'black').length;
    const white = colors.filter(c => c === 'white').length;
    
    const total = colors.length;
    const redPct = (red / total) * 100;
    const blackPct = (black / total) * 100;
    const whitePct = (white / total) * 100;
    
    // Detectar resistÃªncias (cor que aparece muito)
    let resistance = null;
    if (redPct > 55) resistance = 'red';
    else if (blackPct > 55) resistance = 'black';
    
    // Detectar quebra de resistÃªncia (mudanÃ§a brusca)
    const last20 = colors.slice(0, 20);
    const last20Red = last20.filter(c => c === 'red').length;
    const last20Black = last20.filter(c => c === 'black').length;
    
    let breakResistance = null;
    if (resistance === 'red' && last20Black > last20Red) breakResistance = 'black';
    else if (resistance === 'black' && last20Red > last20Black) breakResistance = 'red';
    
    // Medir aleatoriedade (quanto mais prÃ³ximo de 50/50, mais aleatÃ³rio)
    const randomness = 100 - Math.abs(redPct - blackPct);
    
    return {
        label,
        total,
        distribution: { red: redPct.toFixed(1), black: blackPct.toFixed(1), white: whitePct.toFixed(1) },
        resistance,
        breakResistance,
        randomness: randomness.toFixed(1)
    };
}

/**
 * VARREDURA 2: AnÃ¡lise Micro - Janelas de 20 giros
 * Divide os Ãºltimos 240 giros em janelas de 20
 * Identifica qual cor tende a sair apÃ³s cada padrÃ£o
 */
function analyzeMicroWindows(history) {
    console.log('ğŸ” VARREDURA 2: AnÃ¡lise Micro (Janelas de 20 giros)');
    
    const last240 = history.slice(0, 240);
    if (last240.length < 240) {
        console.warn('âš ï¸ HistÃ³rico insuficiente para anÃ¡lise micro (precisa 240 giros)');
        return null;
    }
    
    const windows = [];
    const windowSize = 20;
    const numWindows = Math.floor(last240.length / windowSize);
    
    // Dividir em janelas de 20 giros
    for (let i = 0; i < numWindows; i++) {
        const start = i * windowSize;
        const end = start + windowSize;
        const windowGiros = last240.slice(start, end);
        
        // Analisar janela
        const colors = windowGiros.map(g => g.color);
        const pattern = colors.join('-');
        
        // Verificar qual cor veio DEPOIS dessa janela
        const nextGiro = last240[end];
        const nextColor = nextGiro ? nextGiro.color : null;
        
        windows.push({
            index: i + 1,
            giros: `${start + 1}-${end}`,
            pattern,
            colors: {
                red: colors.filter(c => c === 'red').length,
                black: colors.filter(c => c === 'black').length,
                white: colors.filter(c => c === 'white').length
            },
            nextColor
        });
    }
    
    console.log(`âœ… Varredura 2 completa: ${windows.length} janelas analisadas`);
    return windows;
}

/**
 * Combinar resultados das 2 varreduras + padrÃµes salvos
 * Retorna a cor recomendada e confianÃ§a
 */
async function combineAIResults(macroResults, microWindows, savedPatterns) {
    console.log('ğŸ§® Combinando resultados das anÃ¡lises...');
    
    const scores = { red: 0, black: 0, white: 0 };
    
    // 1. PESO DA VARREDURA 1 (Contexto Macro) - 30%
    if (macroResults) {
        const weight = 0.30;
        
        // Quebra de resistÃªncia tem prioridade
        if (macroResults.immediate?.breakResistance) {
            scores[macroResults.immediate.breakResistance] += 30 * weight;
            console.log(`  âœ… Quebra de resistÃªncia detectada: ${macroResults.immediate.breakResistance} (+${30 * weight})`);
        }
        
        // ResistÃªncia tambÃ©m influencia (favor da resistÃªncia)
        if (macroResults.recent?.resistance) {
            scores[macroResults.recent.resistance] += 15 * weight;
        }
    }
    
    // 2. PESO DA VARREDURA 2 (Janelas de 20) - 50% (MAIOR PESO)
    if (microWindows && microWindows.length > 0) {
        const weight = 0.50;
        
        // Analisar Ãºltimos 20 giros (janela mais recente)
        const lastWindow = microWindows[0];
        
        // Contar qual cor apareceu DEPOIS de janelas similares
        const colorAfterPatterns = {};
        microWindows.forEach(w => {
            if (w.nextColor) {
                colorAfterPatterns[w.nextColor] = (colorAfterPatterns[w.nextColor] || 0) + 1;
            }
        });
        
        // Dar pontos baseado na frequÃªncia
        const total = Object.values(colorAfterPatterns).reduce((a, b) => a + b, 0);
        Object.keys(colorAfterPatterns).forEach(color => {
            const frequency = (colorAfterPatterns[color] / total) * 100;
            scores[color] += frequency * weight;
            console.log(`  âœ… Janelas de 20: ${color} aparece ${frequency.toFixed(1)}% (+${(frequency * weight).toFixed(1)})`);
        });
    }
    
    // 3. PESO DOS PADRÃ•ES SALVOS - 20%
    if (savedPatterns && savedPatterns.length > 0) {
        const weight = 0.20;
        
        // Pegar padrÃ£o com maior confianÃ§a
        const bestPattern = savedPatterns.reduce((best, p) => 
            p.confidence > (best?.confidence || 0) ? p : best
        , null);
        
        if (bestPattern) {
            scores[bestPattern.color] += bestPattern.confidence * weight;
            console.log(`  âœ… Melhor padrÃ£o salvo: ${bestPattern.color} (${bestPattern.confidence}%) (+${(bestPattern.confidence * weight).toFixed(1)})`);
        }
    }
    
    // Encontrar cor com maior score
    const bestColor = Object.keys(scores).reduce((a, b) => scores[a] > scores[b] ? a : b);
    const confidence = Math.min(95, Math.max(45, scores[bestColor]));
    
    console.log('ğŸ“Š Scores finais:', scores);
    console.log(`ğŸ¯ RecomendaÃ§Ã£o IA: ${bestColor} (${confidence.toFixed(1)}%)`);
    
    // âœ… VALIDAR CONFIANÃ‡A MÃNIMA (configurada pelo usuÃ¡rio) - MODO IA
    const minConfidence = analyzerConfig.minPercentage || 60; // Porcentagem mÃ­nima configurada para o modo IA
    if (confidence < minConfidence) {
        console.log(`âš ï¸ ConfianÃ§a ${confidence.toFixed(1)}% estÃ¡ abaixo do mÃ­nimo configurado (${minConfidence}%)`);
        console.log('âŒ AnÃ¡lise IA rejeitada por nÃ£o atingir confianÃ§a mÃ­nima');
        return null; // NÃ£o retorna anÃ¡lise
    }
    console.log(`âœ… ConfianÃ§a ${confidence.toFixed(1)}% atende ao mÃ­nimo (${minConfidence}%)`);
    
    // âœ… CRIAR RESUMOS DETALHADOS PARA O USUÃRIO
    let macroSummary = '';
    if (macroResults) {
        const parts = [];
        if (macroResults.immediate?.breakResistance) {
            parts.push(`âœ… Quebra de resistÃªncia detectada em ${macroResults.immediate.breakResistance}`);
        }
        if (macroResults.recent?.resistance) {
            parts.push(`ğŸ“Š ResistÃªncia atual: ${macroResults.recent.resistance}`);
        }
        if (macroResults.immediate?.randomness) {
            const randomPct = parseFloat(macroResults.immediate.randomness);
            if (randomPct > 90) parts.push('âš ï¸ Alto grau de aleatoriedade detectado');
            else if (randomPct < 70) parts.push('âœ… PadrÃµes consistentes identificados');
        }
        macroSummary = parts.length > 0 ? parts.join('\n   ') : 'âœ… AnÃ¡lise de tendÃªncias concluÃ­da';
    }
    
    let microSummary = '';
    if (microWindows && microWindows.length > 0) {
        const colorCounts = {};
        microWindows.forEach(w => {
            if (w.nextColor) {
                colorCounts[w.nextColor] = (colorCounts[w.nextColor] || 0) + 1;
            }
        });
        const topColor = Object.keys(colorCounts).reduce((a, b) => colorCounts[a] > colorCounts[b] ? a : b, null);
        if (topColor) {
            const freq = ((colorCounts[topColor] / microWindows.length) * 100).toFixed(0);
            microSummary = `âœ… ${topColor} aparece em ${freq}% dos padrÃµes similares`;
        } else {
            microSummary = 'âœ… PadrÃµes recentes mapeados';
        }
    }
    
    let patternSummary = 'âœ… Base de dados consultada';
    if (savedPatterns && savedPatterns.length > 0) {
        const bestPattern = savedPatterns.reduce((best, p) => 
            p.confidence > (best?.confidence || 0) ? p : best
        , null);
        if (bestPattern) {
            patternSummary = `âœ… Melhor padrÃ£o: ${bestPattern.color} (${bestPattern.confidence}% confianÃ§a)`;
        }
    } else {
        patternSummary = 'âš ï¸ Nenhum padrÃ£o salvo encontrado';
    }
    
    // Criar raciocÃ­nio baseado na pontuaÃ§Ã£o
    let reasoning = '';
    const diff = scores[bestColor] - Math.max(...Object.keys(scores).filter(c => c !== bestColor).map(c => scores[c]));
    if (diff > 20) {
        reasoning = `âœ… IA identificou forte tendÃªncia para ${bestColor} com ${diff.toFixed(1)} pontos de vantagem sobre outras cores.`;
    } else if (diff > 10) {
        reasoning = `âœ… IA recomenda ${bestColor} com vantagem moderada de ${diff.toFixed(1)} pontos.`;
    } else {
        reasoning = `âš ï¸ IA recomenda ${bestColor} com pequena vantagem de ${diff.toFixed(1)} pontos. Entrada de risco moderado.`;
    }
    
    return {
        color: bestColor,
        confidence: parseFloat(confidence.toFixed(1)),
        scores,
        macroSummary,
        microSummary,
        patternSummary,
        reasoning
    };
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ” DETECTOR DE PADRÃ•ES NO HISTÃ“RICO (ANÃLISE ESTATÃSTICA REAL)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * Esta funÃ§Ã£o analisa TODO o histÃ³rico e detecta padrÃµes especÃ­ficos:
 * - AlternÃ¢ncia simples (P-V-P-V)
 * - AlternÃ¢ncia dupla (P-P-V-V)
 * - AlternÃ¢ncia tripla (P-P-P-V-V-V)
 * - SequÃªncias longas (6+ mesma cor)
 * 
 * Para cada padrÃ£o, conta O QUE VEIO DEPOIS (estatÃ­stica REAL)
 */
function detectPatternsInHistory(history) {
    console.log('%câ•‘  ğŸ” DETECTANDO PADRÃ•ES NO HISTÃ“RICO                      â•‘', 'color: #00BFFF; font-weight: bold;');
    console.log('%c   HistÃ³rico recebido: ' + history.length + ' giros', 'color: #00BFFF;');
    
    // âœ… VALIDAÃ‡ÃƒO: Verificar se histÃ³rico Ã© vÃ¡lido
    if (!history || !Array.isArray(history) || history.length === 0) {
        console.warn('%câš ï¸ HistÃ³rico invÃ¡lido ou vazio!', 'color: #FFAA00; font-weight: bold;');
        return [];
    }
    
    const patterns = {
        // AlternÃ¢ncia simples: P-V-P-V-P-V
        alternanciaSimples: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // AlternÃ¢ncia dupla: P-P-V-V-P-P-V-V
        alternanciaDupla: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // AlternÃ¢ncia tripla: P-P-P-V-V-V-P-P-P
        alternanciaTripla: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // SequÃªncia longa de vermelhos (6+)
        sequenciaVermelho6Plus: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // SequÃªncia longa de pretos (6+)
        sequenciaPreto6Plus: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 },
        
        // SequÃªncia longa de mesma cor (4-5)
        sequenciaMesmaCor4a5: { count: 0, afterRed: 0, afterBlack: 0, afterWhite: 0 }
    };
    
    // Simplificar cores (ignorar white temporariamente para padrÃµes)
    const simplifiedHistory = history.map(spin => {
        if (spin.color === 'white') return 'W';
        return spin.color === 'red' ? 'R' : 'B';
    });
    
    // Analisar histÃ³rico (deixar espaÃ§o para o "prÃ³ximo giro")
    for (let i = 0; i < history.length - 1; i++) {
        const next = history[i]; // O giro que VEIO DEPOIS do padrÃ£o
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALTERNÃ‚NCIA SIMPLES: R-B-R-B-R-B (mÃ­nimo 6 giros)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 6 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 7).join('');
            
            // PadrÃ£o: R-B-R-B-R-B ou B-R-B-R-B-R
            if (seq === 'RBRBRB' || seq === 'BRBRBR') {
                // ğŸ”¥ VALIDAR COR DE DISPARO: Cor antes do padrÃ£o DEVE ser diferente da primeira cor
                const colorBefore = simplifiedHistory[i + 7]; // Cor imediatamente antes do padrÃ£o
                const firstPatternColor = seq[0]; // Primeira cor do padrÃ£o (R ou B)
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = normalizeColorName(firstPatternColor === 'R' ? 'red' : 'black');
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) {
                        continue; // Sem trigger vÃ¡lida
                    }
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.alternanciaSimples.count++;
                if (next.color === 'red') patterns.alternanciaSimples.afterRed++;
                else if (next.color === 'black') patterns.alternanciaSimples.afterBlack++;
                else patterns.alternanciaSimples.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALTERNÃ‚NCIA DUPLA: R-R-B-B-R-R-B-B (mÃ­nimo 8 giros)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 8 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 9).join('');
            
            // PadrÃ£o: R-R-B-B-R-R-B-B ou B-B-R-R-B-B-R-R
            if (seq === 'RRBBRRBB' || seq === 'BBRRBBRR') {
                // ğŸ”¥ VALIDAR COR DE DISPARO
                const colorBefore = simplifiedHistory[i + 9];
                const firstPatternColor = seq[0];
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = normalizeColorName(firstPatternColor === 'R' ? 'red' : 'black');
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.alternanciaDupla.count++;
                if (next.color === 'red') patterns.alternanciaDupla.afterRed++;
                else if (next.color === 'black') patterns.alternanciaDupla.afterBlack++;
                else patterns.alternanciaDupla.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALTERNÃ‚NCIA TRIPLA: R-R-R-B-B-B-R-R-R (mÃ­nimo 9 giros)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 9 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 10).join('');
            
            // PadrÃ£o: R-R-R-B-B-B-R-R-R ou B-B-B-R-R-R-B-B-B
            if (seq === 'RRRBBBRRR' || seq === 'BBBRRRBBB') {
                // ğŸ”¥ VALIDAR COR DE DISPARO
                const colorBefore = simplifiedHistory[i + 10];
                const firstPatternColor = seq[0];
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = normalizeColorName(firstPatternColor === 'R' ? 'red' : 'black');
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.alternanciaTripla.count++;
                if (next.color === 'red') patterns.alternanciaTripla.afterRed++;
                else if (next.color === 'black') patterns.alternanciaTripla.afterBlack++;
                else patterns.alternanciaTripla.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SEQUÃŠNCIA DE VERMELHO 6+ (ignorando brancos)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 6 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 7).filter(c => c !== 'W').join('');
            
            if (seq === 'RRRRRR') {
                // ğŸ”¥ VALIDAR COR DE DISPARO (ignorando brancos)
                let colorBeforeIndex = i + 7;
                let colorBefore = simplifiedHistory[colorBeforeIndex];
                // Pular brancos para encontrar a cor de disparo real
                while (colorBefore === 'W' && colorBeforeIndex < simplifiedHistory.length) {
                    colorBeforeIndex++;
                    colorBefore = simplifiedHistory[colorBeforeIndex];
                }
                const firstPatternColor = 'R'; // Sempre vermelho neste padrÃ£o
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = 'red';
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.sequenciaVermelho6Plus.count++;
                if (next.color === 'red') patterns.sequenciaVermelho6Plus.afterRed++;
                else if (next.color === 'black') patterns.sequenciaVermelho6Plus.afterBlack++;
                else patterns.sequenciaVermelho6Plus.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SEQUÃŠNCIA DE PRETO 6+ (ignorando brancos)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 6 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 7).filter(c => c !== 'W').join('');
            
            if (seq === 'BBBBBB') {
                // ğŸ”¥ VALIDAR COR DE DISPARO (ignorando brancos)
                let colorBeforeIndex = i + 7;
                let colorBefore = simplifiedHistory[colorBeforeIndex];
                // Pular brancos para encontrar a cor de disparo real
                while (colorBefore === 'W' && colorBeforeIndex < simplifiedHistory.length) {
                    colorBeforeIndex++;
                    colorBefore = simplifiedHistory[colorBeforeIndex];
                }
                const firstPatternColor = 'B'; // Sempre preto neste padrÃ£o
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = 'black';
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.sequenciaPreto6Plus.count++;
                if (next.color === 'red') patterns.sequenciaPreto6Plus.afterRed++;
                else if (next.color === 'black') patterns.sequenciaPreto6Plus.afterBlack++;
                else patterns.sequenciaPreto6Plus.afterWhite++;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SEQUÃŠNCIA MESMA COR 4-5 (mais comum, mais dados)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (i + 5 < history.length) {
            const seq = simplifiedHistory.slice(i + 1, i + 6).filter(c => c !== 'W').join('');
            
            if (seq === 'RRRRR' || seq === 'BBBBB' || seq === 'RRRR' || seq === 'BBBB') {
                // ğŸ”¥ VALIDAR COR DE DISPARO (ignorando brancos)
                let colorBeforeIndex = i + 6;
                let colorBefore = simplifiedHistory[colorBeforeIndex];
                // Pular brancos para encontrar a cor de disparo real
                while (colorBefore === 'W' && colorBeforeIndex < simplifiedHistory.length) {
                    colorBeforeIndex++;
                    colorBefore = simplifiedHistory[colorBeforeIndex];
                }
                const firstPatternColor = seq[0]; // R ou B (primeira cor do padrÃ£o)
                const triggerColorNormalized = normalizeColorName(
                    colorBefore === 'R' ? 'red' :
                    colorBefore === 'B' ? 'black' :
                    colorBefore === 'W' ? 'white' : null
                );
                const firstColorNormalized = normalizeColorName(firstPatternColor === 'R' ? 'red' : 'black');
                
                if (!triggerColorNormalized) {
                    if (analyzerConfig.requireTrigger) continue;
                } else if (!validateDisparoColor(firstColorNormalized, triggerColorNormalized).valid) {
                    continue;
                }
                
                patterns.sequenciaMesmaCor4a5.count++;
                if (next.color === 'red') patterns.sequenciaMesmaCor4a5.afterRed++;
                else if (next.color === 'black') patterns.sequenciaMesmaCor4a5.afterBlack++;
                else patterns.sequenciaMesmaCor4a5.afterWhite++;
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CALCULAR PORCENTAGENS E MONTAR RELATÃ“RIO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const report = [];
    
    for (const [patternName, data] of Object.entries(patterns)) {
        if (data.count > 0) {
            const total = data.afterRed + data.afterBlack + data.afterWhite;
            const redPercent = ((data.afterRed / total) * 100).toFixed(1);
            const blackPercent = ((data.afterBlack / total) * 100).toFixed(1);
            const whitePercent = ((data.afterWhite / total) * 100).toFixed(1);
            
            // Nome legÃ­vel do padrÃ£o
            let readableName = '';
            switch(patternName) {
                case 'alternanciaSimples':
                    readableName = 'AlternÃ¢ncia Simples (P-V-P-V-P-V)';
                    break;
                case 'alternanciaDupla':
                    readableName = 'AlternÃ¢ncia Dupla (P-P-V-V-P-P-V-V)';
                    break;
                case 'alternanciaTripla':
                    readableName = 'AlternÃ¢ncia Tripla (P-P-P-V-V-V-P-P-P)';
                    break;
                case 'sequenciaVermelho6Plus':
                    readableName = 'SequÃªncia de 6+ Vermelhos';
                    break;
                case 'sequenciaPreto6Plus':
                    readableName = 'SequÃªncia de 6+ Pretos';
                    break;
                case 'sequenciaMesmaCor4a5':
                    readableName = 'SequÃªncia de 4-5 Mesma Cor';
                    break;
            }
            
            report.push({
                name: readableName,
                pattern: patternName,
                occurrences: data.count,
                afterRed: data.afterRed,
                afterBlack: data.afterBlack,
                afterWhite: data.afterWhite,
                redPercent: parseFloat(redPercent),
                blackPercent: parseFloat(blackPercent),
                whitePercent: parseFloat(whitePercent)
            });
        }
    }
    
    // Ordenar por nÃºmero de ocorrÃªncias (mais confiÃ¡vel primeiro)
    report.sort((a, b) => b.occurrences - a.occurrences);
    
    // Exibir relatÃ³rio no console
    console.log('%cğŸ“Š RELATÃ“RIO DE PADRÃ•ES DETECTADOS:', 'color: #00BFFF; font-weight: bold; font-size: 14px;');
    
    if (report.length === 0) {
        console.log('%câš ï¸ Nenhum padrÃ£o claro detectado no histÃ³rico', 'color: #FFAA00;');
        console.log('%c   Isso Ã© NORMAL se o histÃ³rico for muito aleatÃ³rio', 'color: #FFAA00;');
        console.log('%c   A IA vai analisar de forma livre.', 'color: #FFAA00;');
    } else {
        report.forEach((p, index) => {
            console.log(`%c${index + 1}. ${p.name}`, 'color: #00FF88; font-weight: bold;');
            console.log(`   OcorrÃªncias: ${p.occurrences} vezes`);
            console.log(`   ApÃ³s esse padrÃ£o:`);
            console.log(`   %câ†’ VERMELHO: ${p.afterRed} vezes (${p.redPercent}%)`, 'color: #FF0000; font-weight: bold;');
            console.log(`   %câ†’ PRETO: ${p.afterBlack} vezes (${p.blackPercent}%)`, 'color: #FFFFFF; font-weight: bold;');
            console.log(`   %câ†’ BRANCO: ${p.afterWhite} vezes (${p.whitePercent}%)`, 'color: #00FF00; font-weight: bold;');
        });
    }
    
    console.log('%câœ… DetecÃ§Ã£o de padrÃµes concluÃ­da! Retornando ' + report.length + ' padrÃµes', 'color: #00BFFF; font-weight: bold;');
    
    return report;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ SISTEMA DE ANÃLISE AVANÃ‡ADA POR PADRÃ•ES (100% JavaScript - SEM IA)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * ARMAZENAMENTO DE SINAIS ENVIADOS (para auto-aprendizado)
 * Persiste em chrome.storage.local
 */
let signalsHistory = {
    signals: [],              // Todos os sinais enviados
    patternStats: {},         // EstatÃ­sticas por tipo de padrÃ£o
    contextStats: {},         // EstatÃ­sticas por contexto
    blockedPatterns: {},      // ğŸš« PadrÃµes bloqueados temporariamente {patternKey: {until: timestamp, reason: string}}
    // âšª N0 (Detector de Branco): auto-aprendizado por contexto + aÃ§Ã£o (block_all/soft_block)
    // Objetivo: permitir que o N0 "aprenda" o que funciona no histÃ³rico da conta e ajuste o bloqueio dinamicamente.
    n0SelfLearning: {
        version: 1,
        stats: {},            // { [key]: { total, wins, losses, recent: boolean[], lastTs } }
        maxRecent: 40,        // janela de recÃªncia por key
        maxKeys: 600,         // limite de chaves (evita crescer infinito)
        minSamples: 8,        // mÃ­nimo de ciclos para ativar bloqueio/boost
        // Fatores relativos ao baseline de branco (ex.: baseline ~6.7%):
        // - badFactor 0.8 => bloqueia se performance <= baseline*0.8 (pior que aleatÃ³rio)
        // - goodFactor 1.8 => considera "bom" se performance >= baseline*1.8 (lift forte)
        badFactor: 0.8,
        goodFactor: 1.8,
        lastUpdated: null
    },
    // âšª N0 (Detector de Branco): guard rails operacionais (ex.: cooldown pÃ³s-WIN)
    n0Guard: {
        version: 1,
        lastWhiteWinSpinId: null,     // spin.id (preferido) ou timestamp (fallback)
        lastWhiteWinTimestamp: null,  // created_at/timestamp do giro que confirmou o WIN
        lastWhiteWinAtMs: null,       // ms parseado (quando disponÃ­vel)
        cooldownSpins: 0,             // quantos giros bloquear apÃ³s WIN no branco
        setAtMs: null,                // quando o cooldown foi armado
        budgetSnapshot: null          // snapshot do budget por hora (para sobreviver reinÃ­cio do SW)
    },
    // ğŸ’ N4 (Autointeligente): auto-aprendizado por "tipo de sinal" do prÃ³prio N4 (contexto n-gram + cor + setup)
    n4SelfLearning: {
        version: 2,
        stats: {},            // { [key]: { total, wins, losses, recent: boolean[], lastTs } }
        maxRecent: 30,        // janela de recÃªncia por key
        maxKeys: 400,         // limite de chaves (evita crescer infinito)
        minSamples: 8,        // mÃ­nimo de ciclos para ativar bloqueio/boost
        badWinRate: 0.45,     // abaixo disso -> bloquear tipo
        goodWinRate: 0.60,    // acima disso -> liberar com boost (mais permissivo)
        lastUpdated: null
    },
    // ğŸ’ N4 (Autointeligente): auto-ajuste do tamanho do histÃ³rico (janela) quando o desempenho cair
    n4AutoTune: {
        enabled: true,
        targetWinRate: 0.90,     // alvo mÃ­nimo (ciclos) para manter o N4 â€œsaudÃ¡velâ€
        minCycles: 20,           // amostra mÃ­nima para disparar ajuste
        cooldownMs: 10 * 60 * 1000, // nÃ£o ajustar em loop (10min)
        // bateria: avalia algumas janelas candidatas em cima do histÃ³rico recente
        lookbackSpins: 5000,
        stride: 2,
        maxSignalsToScore: 200,
        minSignalsToAccept: 25,
        lastRunAt: null,
        lastFrom: null,
        lastTo: null,
        lastWinRate: null
    },
    consecutiveLosses: 0,     // ğŸ“‰ Contador de losses consecutivos GLOBAL
    recentPerformance: [],    // ğŸ“Š Ãšltimos 20 sinais (para ajuste dinÃ¢mico de minPercentage)
    lastUpdated: null
};

/**
 * Inicializar histÃ³rico de sinais do storage
 */
async function initializeSignalsHistory() {
    try {
        const result = await chrome.storage.local.get('signalsHistory');
        if (result.signalsHistory) {
            signalsHistory = result.signalsHistory;
            
            // âœ… Garantir que TODOS os campos existam (migraÃ§Ã£o + seguranÃ§a)
            if (!signalsHistory.signals || !Array.isArray(signalsHistory.signals)) signalsHistory.signals = [];
            if (!signalsHistory.patternStats) signalsHistory.patternStats = {};
            if (!signalsHistory.contextStats) signalsHistory.contextStats = {};
            if (!signalsHistory.blockedPatterns) signalsHistory.blockedPatterns = {};
            if (!signalsHistory.n0SelfLearning || typeof signalsHistory.n0SelfLearning !== 'object') {
                signalsHistory.n0SelfLearning = {
                    version: 1,
                    stats: {},
                    maxRecent: 40,
                    maxKeys: 600,
                    minSamples: 8,
                    badFactor: 0.8,
                    goodFactor: 1.8,
                    lastUpdated: null
                };
            }
            // âœ… N0 guard rails (cooldown pÃ³s-WIN etc.)
            if (!signalsHistory.n0Guard || typeof signalsHistory.n0Guard !== 'object') {
                signalsHistory.n0Guard = {
                    version: 1,
                    lastWhiteWinSpinId: null,
                    lastWhiteWinTimestamp: null,
                    lastWhiteWinAtMs: null,
                    cooldownSpins: 0,
                    setAtMs: null,
                    budgetSnapshot: null
                };
            } else {
                const g = signalsHistory.n0Guard;
                const ver = Math.max(1, Math.floor(Number(g.version) || 1));
                g.version = ver;
                if (g.lastWhiteWinSpinId === undefined) g.lastWhiteWinSpinId = null;
                if (g.lastWhiteWinTimestamp === undefined) g.lastWhiteWinTimestamp = null;
                if (g.lastWhiteWinAtMs === undefined) g.lastWhiteWinAtMs = null;
                if (!Number.isFinite(Number(g.cooldownSpins))) g.cooldownSpins = 0;
                if (!Number.isFinite(Number(g.setAtMs))) g.setAtMs = null;
                if (g.budgetSnapshot === undefined) g.budgetSnapshot = null;
            }
            // âœ… N0 budget: restaurar snapshot quando possÃ­vel (evita spam se o SW reiniciar no meio da hora)
            try {
                const snap = signalsHistory.n0Guard && typeof signalsHistory.n0Guard === 'object'
                    ? signalsHistory.n0Guard.budgetSnapshot
                    : null;
                if (snap && typeof snap === 'object' && n0WhiteBudgetState && typeof n0WhiteBudgetState === 'object') {
                    const now = Date.now();
                    const currentHourKey = buildHourKeyLocal(now);
                    const hourKey = snap.hourKey != null ? String(snap.hourKey) : null;
                    if (hourKey && hourKey === currentHourKey) {
                        const target = Number.isFinite(Number(snap.target)) ? Math.floor(Number(snap.target)) : null;
                        const used = Number.isFinite(Number(snap.used)) ? Math.floor(Number(snap.used)) : null;
                        n0WhiteBudgetState = {
                            ...n0WhiteBudgetState,
                            hourKey,
                            target: (target != null) ? Math.max(N0_WHITE_SIGNAL_TARGET_MIN, Math.min(N0_WHITE_SIGNAL_TARGET_MAX, target)) : n0WhiteBudgetState.target,
                            used: (used != null) ? Math.max(0, used) : n0WhiteBudgetState.used,
                            lastUpdateMs: Number.isFinite(Number(snap.lastUpdateMs)) ? Number(snap.lastUpdateMs) : (n0WhiteBudgetState.lastUpdateMs || now)
                        };
                    }
                }
            } catch (_) {}
            if (!signalsHistory.n4SelfLearning || typeof signalsHistory.n4SelfLearning !== 'object') {
                signalsHistory.n4SelfLearning = {
                    version: 2,
                    stats: {},
                    maxRecent: 30,
                    maxKeys: 400,
                    minSamples: 8,
                    badWinRate: 0.45,
                    goodWinRate: 0.60,
                    lastUpdated: null
                };
            }
            // âœ… N4 auto-tune: garantir defaults (sem sobrescrever ajustes do usuÃ¡rio)
            if (!signalsHistory.n4AutoTune || typeof signalsHistory.n4AutoTune !== 'object') {
                signalsHistory.n4AutoTune = {
                    enabled: true,
                    targetWinRate: 0.90,
                    minCycles: 20,
                    cooldownMs: 10 * 60 * 1000,
                    lookbackSpins: 5000,
                    stride: 2,
                    maxSignalsToScore: 200,
                    minSignalsToAccept: 25,
                    lastRunAt: null,
                    lastFrom: null,
                    lastTo: null,
                    lastWinRate: null
                };
            } else {
                const at = signalsHistory.n4AutoTune;
                if (at.enabled === undefined) at.enabled = true;
                if (!Number.isFinite(Number(at.targetWinRate))) at.targetWinRate = 0.90;
                if (!Number.isFinite(Number(at.minCycles))) at.minCycles = 20;
                if (!Number.isFinite(Number(at.cooldownMs))) at.cooldownMs = 10 * 60 * 1000;
                if (!Number.isFinite(Number(at.lookbackSpins))) at.lookbackSpins = 5000;
                if (!Number.isFinite(Number(at.stride))) at.stride = 2;
                if (!Number.isFinite(Number(at.maxSignalsToScore))) at.maxSignalsToScore = 200;
                if (!Number.isFinite(Number(at.minSignalsToAccept))) at.minSignalsToAccept = 25;
                if (at.lastRunAt === undefined) at.lastRunAt = null;
                if (at.lastFrom === undefined) at.lastFrom = null;
                if (at.lastTo === undefined) at.lastTo = null;
                if (at.lastWinRate === undefined) at.lastWinRate = null;
            }
            if (!signalsHistory.n4SelfLearning.stats || typeof signalsHistory.n4SelfLearning.stats !== 'object') {
                signalsHistory.n4SelfLearning.stats = {};
            }
            if (!signalsHistory.n0SelfLearning.stats || typeof signalsHistory.n0SelfLearning.stats !== 'object') {
                signalsHistory.n0SelfLearning.stats = {};
            }
            if (!Number.isFinite(Number(signalsHistory.n0SelfLearning.maxRecent))) signalsHistory.n0SelfLearning.maxRecent = 40;
            if (!Number.isFinite(Number(signalsHistory.n0SelfLearning.maxKeys))) signalsHistory.n0SelfLearning.maxKeys = 600;
            if (!Number.isFinite(Number(signalsHistory.n0SelfLearning.minSamples))) signalsHistory.n0SelfLearning.minSamples = 8;
            if (!Number.isFinite(Number(signalsHistory.n0SelfLearning.badFactor))) signalsHistory.n0SelfLearning.badFactor = 0.8;
            if (!Number.isFinite(Number(signalsHistory.n0SelfLearning.goodFactor))) signalsHistory.n0SelfLearning.goodFactor = 1.8;
            if (!Number.isFinite(Number(signalsHistory.n4SelfLearning.maxRecent))) signalsHistory.n4SelfLearning.maxRecent = 30;
            if (!Number.isFinite(Number(signalsHistory.n4SelfLearning.maxKeys))) signalsHistory.n4SelfLearning.maxKeys = 400;
            if (!Number.isFinite(Number(signalsHistory.n4SelfLearning.minSamples))) signalsHistory.n4SelfLearning.minSamples = 8;
            if (!Number.isFinite(Number(signalsHistory.n4SelfLearning.badWinRate))) signalsHistory.n4SelfLearning.badWinRate = 0.45;
            if (!Number.isFinite(Number(signalsHistory.n4SelfLearning.goodWinRate))) signalsHistory.n4SelfLearning.goodWinRate = 0.60;
            // âœ… MigraÃ§Ã£o leve: se ainda estiver em versÃ£o antiga, apenas marcar versÃ£o (sem sobrescrever ajustes do usuÃ¡rio).
            const n4Ver = Math.max(1, Math.floor(Number(signalsHistory.n4SelfLearning.version) || 1));
            if (n4Ver < 2) {
                signalsHistory.n4SelfLearning.version = 2;
            }
            if (signalsHistory.consecutiveLosses === undefined) signalsHistory.consecutiveLosses = 0;
            if (!signalsHistory.recentPerformance || !Array.isArray(signalsHistory.recentPerformance)) signalsHistory.recentPerformance = [];
            
            console.log(`%câœ… HistÃ³rico de sinais carregado: ${signalsHistory.signals.length} sinais`, 'color: #00FF88;');
            console.log(`%c   ğŸ“‰ Losses consecutivos: ${signalsHistory.consecutiveLosses}`, 'color: #FFA500;');
        } else {
            // Se nÃ£o tem nada no storage, garantir estrutura padrÃ£o
            console.log('%câš ï¸ Nenhum histÃ³rico encontrado - inicializando estrutura padrÃ£o', 'color: #FFA500;');
        }
    } catch (error) {
        console.error('%câŒ Erro ao carregar histÃ³rico de sinais:', 'color: #FF0000;', error);
        // Em caso de erro, garantir estrutura padrÃ£o
        signalsHistory = {
            signals: [],
            patternStats: {},
            contextStats: {},
            blockedPatterns: {},
            n0SelfLearning: {
                version: 1,
                stats: {},
                maxRecent: 40,
                maxKeys: 600,
                minSamples: 8,
                badFactor: 0.8,
                goodFactor: 1.8,
                lastUpdated: null
            },
            n0Guard: {
                version: 1,
                lastWhiteWinSpinId: null,
                lastWhiteWinTimestamp: null,
                lastWhiteWinAtMs: null,
                cooldownSpins: 0,
                setAtMs: null,
                budgetSnapshot: null
            },
            n4SelfLearning: {
                version: 2,
                stats: {},
                maxRecent: 30,
                maxKeys: 400,
                minSamples: 8,
                badWinRate: 0.45,
                goodWinRate: 0.60,
                lastUpdated: null
            },
            consecutiveLosses: 0,
            recentPerformance: [],
            lastUpdated: null
        };
    }
}

/**
 * Salvar histÃ³rico de sinais no storage
 */
async function saveSignalsHistory() {
    try {
        signalsHistory.lastUpdated = Date.now();
        await chrome.storage.local.set({ signalsHistory });
    } catch (error) {
        console.error('%câŒ Erro ao salvar histÃ³rico de sinais:', 'color: #FF0000;', error);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âšª N0 (Detector de Branco): auto-aprendizado por contexto + aÃ§Ã£o
// - Aprende apenas quando o N0 realmente gerou o sinal final (WHITE).
// - Usa baseline de branco para decidir o que Ã© "bom/ruim" (evento raro).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildN0LearningContextKey({ windowChars, windowNumbers, dominantNonWhite, maxTail = 12 }) {
    try {
        const w = Array.isArray(windowChars) ? windowChars : [];
        if (!w.length) return '';
        const nums = Array.isArray(windowNumbers) ? windowNumbers : null;

        const limit = Math.max(6, Math.min(30, Math.floor(Number(maxTail) || 12)));
        const tailRaw = w.slice(-limit);
        const lastWInTail = tailRaw.lastIndexOf('W');
        const tail = lastWInTail >= 0 ? tailRaw.slice(lastWInTail) : tailRaw;

        const lastWFull = w.lastIndexOf('W');
        const gap = lastWFull >= 0 ? (w.length - 1 - lastWFull) : w.length;
        const gapBucket = bucketGapForN0(gap);

        const dom = dominantNonWhite ? String(dominantNonWhite).toLowerCase().trim() : '';
        const domTag = (dom === 'red' || dom === 'black') ? dom : '';

        const tailNum = getTailNonWhiteNumberFromWindow(w, nums);
        const numTag = (tailNum != null) ? `|num=${tailNum}` : '';

        const br = computeBreakAfterStreak(w);
        const breakTag = (br && br.broke)
            ? `|br=${bucketRunLenForN0(br.prevRunLen || 0)}:${br.from || '-'}>${br.to || '-'}`
            : '';

        return `tail=${tail.join('')}|gap=${gapBucket}` + (domTag ? `|dom=${domTag}` : '') + numTag + breakTag;
    } catch (_) {
        return '';
    }
}

function buildN0SelfLearningKey(ctxKey, action, cfg) {
    try {
        const ctx = String(ctxKey || '').trim().toUpperCase();
        const act = String(action || '').toLowerCase().trim();
        const fam = cfg && cfg.family ? String(cfg.family).toLowerCase().trim() : 'unknown';
        if (!ctx) return null;
        if (!(act === 'block_all' || act === 'soft_block')) return null;
        if (!fam) return null;
        return `N0|ctx=${ctx}|act=${act}|fam=${fam}`;
    } catch (_) {
        return null;
    }
}

function getN0SelfLearningStatsForKey(key) {
    try {
        const store = signalsHistory && signalsHistory.n0SelfLearning ? signalsHistory.n0SelfLearning : null;
        const map = store && store.stats ? store.stats : null;
        if (!map || !key) return null;
        const row = map[key];
        if (!row || typeof row !== 'object') return null;
        const total = Math.max(0, Math.floor(Number(row.total) || 0));
        const wins = Math.max(0, Math.floor(Number(row.wins) || 0));
        const losses = Math.max(0, Math.floor(Number(row.losses) || 0));
        const recent = Array.isArray(row.recent) ? row.recent : [];
        const recentN = recent.length;
        const recentWins = recent.filter(Boolean).length;
        const recentWinRate = recentN > 0 ? (recentWins / recentN) : null;
        const totalWinRate = total > 0 ? (wins / total) : null;
        return { total, wins, losses, recentN, recentWins, recentWinRate, totalWinRate, lastTs: row.lastTs || null };
    } catch (_) {
        return null;
    }
}

function pruneN0SelfLearningIfNeeded() {
    try {
        if (!signalsHistory || !signalsHistory.n0SelfLearning || !signalsHistory.n0SelfLearning.stats) return;
        const store = signalsHistory.n0SelfLearning;
        const maxKeys = Math.max(50, Math.min(3000, Math.floor(Number(store.maxKeys) || 600)));
        const keys = Object.keys(store.stats || {});
        if (keys.length <= maxKeys) return;
        const ranked = keys.map(k => ({ k, ts: Number(store.stats[k]?.lastTs) || 0 }))
            .sort((a, b) => a.ts - b.ts);
        const toRemove = ranked.slice(0, Math.max(0, keys.length - maxKeys));
        toRemove.forEach(({ k }) => { try { delete store.stats[k]; } catch (_) {} });
    } catch (_) {}
}

async function recordN0SelfLearningFromResolvedCycle(analysisObj, outcome) {
    try {
        // âœ… Se o N0 estiver com modelo congelado, nÃ£o alterar o auto-aprendizado (mantÃ©m comportamento fixo)
        try {
            if (analyzerConfig && analyzerConfig.n0FrozenEnabled) return false;
        } catch (_) {}

        const analysis = analysisObj && typeof analysisObj === 'object' ? analysisObj : null;
        if (!analysis) return false;
        // âœ… Aprender apenas de sinais "visÃ­veis" (nÃ£o contam ciclos silenciosos da RecuperaÃ§Ã£o).
        const isHiddenInternal = !!analysis.hiddenInternal;
        const isRecoveryVisible = !!analysis.recoveryMode;
        if (isHiddenInternal && !isRecoveryVisible) return false;

        const n0 = analysis.diamondN0 && typeof analysis.diamondN0 === 'object' ? analysis.diamondN0 : null;
        if (!n0) return false;
        const usedInFinal = !!n0.usedInFinal;
        if (!usedInFinal) return false;
        const key = typeof n0.key === 'string' ? n0.key : null;
        if (!key) return false;

        const isWin = String(outcome || '').toLowerCase().trim() === 'win';
        const isLoss = String(outcome || '').toLowerCase().trim() === 'loss';
        if (!isWin && !isLoss) return false;

        if (!signalsHistory.n0SelfLearning || typeof signalsHistory.n0SelfLearning !== 'object') {
            signalsHistory.n0SelfLearning = {
                version: 1,
                stats: {},
                maxRecent: 40,
                maxKeys: 600,
                minSamples: 8,
                badFactor: 0.8,
                goodFactor: 1.8,
                lastUpdated: null
            };
        }
        if (!signalsHistory.n0SelfLearning.stats || typeof signalsHistory.n0SelfLearning.stats !== 'object') {
            signalsHistory.n0SelfLearning.stats = {};
        }

        const store = signalsHistory.n0SelfLearning;
        const maxRecent = Math.max(10, Math.min(300, Math.floor(Number(store.maxRecent) || 40)));
        const now = Date.now();
        const row = store.stats[key] && typeof store.stats[key] === 'object'
            ? store.stats[key]
            : { total: 0, wins: 0, losses: 0, recent: [], lastTs: 0 };

        row.total = Math.max(0, Math.floor(Number(row.total) || 0)) + 1;
        row.wins = Math.max(0, Math.floor(Number(row.wins) || 0)) + (isWin ? 1 : 0);
        row.losses = Math.max(0, Math.floor(Number(row.losses) || 0)) + (isLoss ? 1 : 0);
        row.recent = Array.isArray(row.recent) ? row.recent.slice(-maxRecent + 1) : [];
        row.recent.push(!!isWin);
        row.lastTs = now;

        store.stats[key] = row;
        store.lastUpdated = now;
        pruneN0SelfLearningIfNeeded();

        await saveSignalsHistory();
        return true;
    } catch (e) {
        console.warn('âš ï¸ Falha ao registrar auto-aprendizado do N0:', e);
        return false;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’ N4 (Autointeligente): auto-aprendizado por tipo de sinal
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildN4SelfLearningKey(ctxKey, tok, stepsToWin, intensity) {
    try {
        const ctx = String(ctxKey || '').trim().toUpperCase();
        const t = String(tok || '').trim().toUpperCase();
        const steps = Math.max(1, Math.min(3, Math.floor(Number(stepsToWin) || 1)));
        const mode = (intensity === 'conservative') ? 'conservative' : 'aggressive';
        if (!ctx) return null;
        if (!(t === 'R' || t === 'B' || t === 'W')) return null;
        // âœ… Separar aprendizado por polÃ­tica de Gale:
        // - dyn: N4-only com gales dinÃ¢micos (muda cor em G1/G2)
        // - fix: consenso multi-nÃ­veis (a cor do ciclo Ã© fixa)
        // Default = dyn (compat), com fallback automÃ¡tico para a chave legada sem "|pol=".
        const pol = (arguments.length >= 5 && (arguments[4] === false || String(arguments[4]).toLowerCase().includes('fix')))
            ? 'fix'
            : 'dyn';
        return `N4|ctx=${ctx}|tok=${t}|steps=${steps}|int=${mode}|pol=${pol}`;
    } catch (_) {
        return null;
    }
}

function getN4SelfLearningStatsForKey(key) {
    try {
        const store = signalsHistory && signalsHistory.n4SelfLearning ? signalsHistory.n4SelfLearning : null;
        const map = store && store.stats ? store.stats : null;
        if (!map || !key) return null;
        let row = map[key];
        // âœ… Fallback: chave legada (sem "|pol=") â€” mantÃ©m compatibilidade com dados jÃ¡ coletados.
        if ((!row || typeof row !== 'object') && typeof key === 'string' && key.includes('|pol=')) {
            try {
                const legacyKey = key.replace(/\|pol=(dyn|fix)\b/i, '');
                row = map[legacyKey];
            } catch (_) {}
        }
        if (!row || typeof row !== 'object') return null;
        const total = Math.max(0, Math.floor(Number(row.total) || 0));
        const wins = Math.max(0, Math.floor(Number(row.wins) || 0));
        const losses = Math.max(0, Math.floor(Number(row.losses) || 0));
        const recent = Array.isArray(row.recent) ? row.recent : [];
        const recentN = recent.length;
        const recentWins = recent.filter(Boolean).length;
        const recentWinRate = recentN > 0 ? (recentWins / recentN) : null;
        const totalWinRate = total > 0 ? (wins / total) : null;
        return { total, wins, losses, recentN, recentWins, recentWinRate, totalWinRate, lastTs: row.lastTs || null };
    } catch (_) {
        return null;
    }
}

function pruneN4SelfLearningIfNeeded() {
    try {
        if (!signalsHistory || !signalsHistory.n4SelfLearning || !signalsHistory.n4SelfLearning.stats) return;
        const store = signalsHistory.n4SelfLearning;
        const maxKeys = Math.max(50, Math.min(2000, Math.floor(Number(store.maxKeys) || 400)));
        const keys = Object.keys(store.stats || {});
        if (keys.length <= maxKeys) return;
        // remover os mais antigos (por lastTs)
        const ranked = keys.map(k => ({ k, ts: Number(store.stats[k]?.lastTs) || 0 }))
            .sort((a, b) => a.ts - b.ts);
        const toRemove = ranked.slice(0, Math.max(0, keys.length - maxKeys));
        toRemove.forEach(({ k }) => { try { delete store.stats[k]; } catch (_) {} });
    } catch (_) {}
}

async function recordN4SelfLearningFromResolvedCycle(analysisObj, outcome) {
    try {
        const analysis = analysisObj && typeof analysisObj === 'object' ? analysisObj : null;
        if (!analysis) return false;
        // âœ… Aprender apenas de sinais "visÃ­veis" (nÃ£o contam ciclos silenciosos da RecuperaÃ§Ã£o).
        // ExceÃ§Ã£o: se for recoveryMode=true (sinal seguro), ele Ã© visÃ­vel na aba RecuperaÃ§Ã£o.
        const isHiddenInternal = !!analysis.hiddenInternal;
        const isRecoveryVisible = !!analysis.recoveryMode;
        if (isHiddenInternal && !isRecoveryVisible) return false;
        const n4 = analysis.diamondN4 && typeof analysis.diamondN4 === 'object' ? analysis.diamondN4 : null;
        if (!n4) return false;
        const usedInFinal = !!n4.usedInFinal;
        if (!usedInFinal) return false;
        const key = typeof n4.key === 'string' ? n4.key : null;
        if (!key) return false;
        const isWin = String(outcome || '').toLowerCase().trim() === 'win';
        const isLoss = String(outcome || '').toLowerCase().trim() === 'loss';
        if (!isWin && !isLoss) return false;

        if (!signalsHistory.n4SelfLearning || typeof signalsHistory.n4SelfLearning !== 'object') {
            signalsHistory.n4SelfLearning = {
                version: 2,
                stats: {},
                maxRecent: 30,
                maxKeys: 400,
                minSamples: 8,
                badWinRate: 0.45,
                goodWinRate: 0.60,
                lastUpdated: null
            };
        }
        if (!signalsHistory.n4SelfLearning.stats || typeof signalsHistory.n4SelfLearning.stats !== 'object') {
            signalsHistory.n4SelfLearning.stats = {};
        }

        const store = signalsHistory.n4SelfLearning;
        const maxRecent = Math.max(10, Math.min(200, Math.floor(Number(store.maxRecent) || 30)));
        const now = Date.now();
        const row = store.stats[key] && typeof store.stats[key] === 'object'
            ? store.stats[key]
            : { total: 0, wins: 0, losses: 0, recent: [], lastTs: 0 };

        row.total = Math.max(0, Math.floor(Number(row.total) || 0)) + 1;
        row.wins = Math.max(0, Math.floor(Number(row.wins) || 0)) + (isWin ? 1 : 0);
        row.losses = Math.max(0, Math.floor(Number(row.losses) || 0)) + (isLoss ? 1 : 0);
        row.recent = Array.isArray(row.recent) ? row.recent.slice(-maxRecent + 1) : [];
        row.recent.push(!!isWin);
        row.lastTs = now;

        store.stats[key] = row;
        store.lastUpdated = now;

        pruneN4SelfLearningIfNeeded();

        await saveSignalsHistory();
        return true;
    } catch (e) {
        console.warn('âš ï¸ Falha ao registrar auto-aprendizado do N4:', e);
        return false;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’ N4 (Autointeligente): auto-ajuste da janela (n4Persistence)
// - Quando o desempenho recente do N4 cair abaixo do alvo, roda uma â€œbateriaâ€
//   rÃ¡pida de janelas candidatas e aplica a melhor.
// - Projetado para ser leve e com cooldown (evita â€œchacoalharâ€ config).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let n4AutoTuneInProgress = false;

function normalizeSimpleColorN4(value) {
    const s = String(value || '').toLowerCase().trim();
    if (!s) return '';
    if (s.startsWith('r')) return 'red';
    if (s.startsWith('b') && s !== 'branco') return 'black';
    if (s.startsWith('w') || s === 'branco') return 'white';
    if (s === 'vermelho') return 'red';
    if (s === 'preto') return 'black';
    return s;
}

function getDiamondSourceIdFromEntry(entry) {
    try {
        const src = (entry && entry.diamondSourceLevel)
            || (entry && entry.patternData && entry.patternData.diamondSourceLevel)
            || null;
        const id = src && src.id ? String(src.id) : null;
        return id;
    } catch (_) {
        return null;
    }
}

function computeRecentCycleWinRateForSource(entriesHistoryRaw, sourceId, maxCycles = 30) {
    try {
        const entries = Array.isArray(entriesHistoryRaw) ? entriesHistoryRaw : [];
        const finals = filterFinalEntries(entries);
        const want = String(sourceId || '').toUpperCase().trim();
        let wins = 0;
        let losses = 0;
        for (const e of finals) {
            if (!e || typeof e !== 'object') continue;
            if (String(e.analysisMode || '').toLowerCase().trim() !== 'diamond') continue;
            const srcId = getDiamondSourceIdFromEntry(e);
            if (!srcId || String(srcId).toUpperCase().trim() !== want) continue;
            const res = String(e.result || '').toUpperCase().trim();
            if (res === 'WIN') wins++;
            else if (res === 'LOSS') losses++;
            if ((wins + losses) >= Math.max(1, Math.floor(Number(maxCycles) || 30))) break;
        }
        const total = wins + losses;
        const winRate = total ? (wins / total) : 0;
        return { wins, losses, total, winRate };
    } catch (_) {
        return { wins: 0, losses: 0, total: 0, winRate: 0 };
    }
}

function clampN4WindowSize(raw) {
    const n = Math.floor(Number(raw));
    if (!Number.isFinite(n)) return 2000;
    // âœ… abaixo de 80 o N4 vira â€œNULOâ€ na prÃ¡tica (tokens insuficientes)
    return Math.max(80, Math.min(10000, n));
}

function buildN4WindowCandidates(currentWindow, maxCandidates = 7) {
    const cur = clampN4WindowSize(currentWindow);
    const base = [250, 500, 800, 1200, 1600, 2000, 2500, 3000, 4000].map(clampN4WindowSize);
    const scaled = [
        Math.round(cur * 0.50),
        Math.round(cur * 0.75),
        cur,
        Math.round(cur * 1.25),
        Math.round(cur * 1.50)
    ].map(clampN4WindowSize);

    const uniq = Array.from(new Set([...base, ...scaled].map(clampN4WindowSize)));
    const must = new Set([clampN4WindowSize(cur), clampN4WindowSize(2000)]);
    const rest = uniq
        .filter(v => !must.has(v))
        .sort((a, b) => Math.abs(a - cur) - Math.abs(b - cur));

    const take = Math.max(3, Math.min(12, Math.floor(Number(maxCandidates) || 7)));
    const chosen = [...Array.from(must), ...rest.slice(0, Math.max(0, take - must.size))];
    return chosen.sort((a, b) => a - b);
}

function evaluateN4WindowOnCachedHistory({ historyMostRecentFirst, windowSize, config, autoTuneCfg }) {
    const history = Array.isArray(historyMostRecentFirst) ? historyMostRecentFirst : [];
    const cfg = config && typeof config === 'object' ? config : {};
    const tune = autoTuneCfg && typeof autoTuneCfg === 'object' ? autoTuneCfg : {};

    const { maxGales: maxGalesRaw } = getMartingaleSettings('diamond', cfg);
    const maxGales = Math.max(0, Math.min(2, Math.floor(Number(maxGalesRaw) || 0)));
    // âœ… Intensidade removida (por enquanto): travar sempre em "aggressive"
    const signalIntensity = 'aggressive';
    const whiteProtectionAsWin = !!cfg.whiteProtectionAsWin;
    const dynamicGales = shouldUseN4DynamicGalesForConfig(cfg);

    const lookbackSpins = Math.max(200, Math.min(10000, Math.floor(Number(tune.lookbackSpins) || 5000)));
    const stride = Math.max(1, Math.min(20, Math.floor(Number(tune.stride) || 2)));
    const maxSignalsToScore = Math.max(30, Math.min(1000, Math.floor(Number(tune.maxSignalsToScore) || 200)));

    const maxIndex = Math.min(lookbackSpins, history.length - 1 - maxGales);
    let wins = 0;
    let losses = 0;
    let entryWins = 0;
    let entryLosses = 0;
    let abstained = 0;

    const compareHit = (expectedColor, actualColor) => {
        const exp = normalizeSimpleColorN4(expectedColor);
        const act = normalizeSimpleColorN4(actualColor);
        if (!exp || !act) return false;
        if (exp === act) return true;
        if (whiteProtectionAsWin && act === 'white' && (exp === 'red' || exp === 'black')) return true;
        return false;
    };

    // k = offset do "Ãºltimo giro disponÃ­vel" no passado (history[k] Ã© o mais recente daquele momento)
    // prÃ³ximo giro (resultado da entrada) estÃ¡ em history[k-1]
    for (let k = (maxGales + 1); k <= maxIndex; k += stride) {
        const histSlice = history.slice(k, k + Math.max(80, Math.min(windowSize, 10000)));
        const n4 = analyzeAutointeligente(histSlice, {
            historySize: windowSize,
            maxGales,
            signalIntensity,
            whiteProtectionAsWin,
            dynamicGales,
            n4SelfLearning: signalsHistory && signalsHistory.n4SelfLearning ? signalsHistory.n4SelfLearning : null
        });

        const entryColor = n4 && n4.color ? normalizeSimpleColorN4(n4.color) : null;
        if (!entryColor) {
            abstained++;
            continue;
        }

        // 1) Entrada
        const entrySpin = history[k - 1];
        const entryHit = compareHit(entryColor, entrySpin && entrySpin.color);
        if (entryHit) {
            wins++;
            entryWins++;
        } else {
            entryLosses++;
            // 2) G1/G2 (se houver)
            let cycleWon = false;
            for (let stage = 1; stage <= maxGales; stage++) {
                const spin = history[k - 1 - stage];
                if (!spin) break;

                let expected = entryColor;
                if (dynamicGales) {
                    const startIndex = k - stage; // inclui o LOSS anterior como "mais recente"
                    const histForGale = history.slice(startIndex, startIndex + Math.max(80, Math.min(windowSize, 10000)));
                    const picked = pickN4DynamicGaleColor({
                        history: histForGale,
                        config: cfg,
                        stageNumber: stage,
                        maxGales,
                        forcePick: true
                    });
                    if (picked) expected = normalizeSimpleColorN4(picked);
                }

                if (compareHit(expected, spin.color)) {
                    cycleWon = true;
                    break;
                }
            }

            if (cycleWon) wins++;
            else losses++;
        }

        if ((wins + losses) >= maxSignalsToScore) break;
    }

    const totalCycles = wins + losses;
    const winRate = totalCycles ? wins / totalCycles : 0;
    const entryTotal = entryWins + entryLosses;
    const entryWinRate = entryTotal ? entryWins / entryTotal : 0;

    return {
        windowSize: clampN4WindowSize(windowSize),
        wins,
        losses,
        totalCycles,
        winRate,
        entryWins,
        entryLosses,
        entryTotal,
        entryWinRate,
        abstained
    };
}

async function maybeAutoTuneN4HistoryWindow({ entriesHistory, analysisObj } = {}) {
    try {
        if (n4AutoTuneInProgress) return;
        if (!analyzerConfig || !analyzerConfig.aiMode) return;
        if (!isDiamondLevelEnabled('N4', analyzerConfig)) return;
        if (!signalsHistory || !signalsHistory.n4AutoTune || signalsHistory.n4AutoTune.enabled === false) return;

        // Se o ciclo resolvido NÃƒO veio do N4, nÃ£o disparar bateria aqui (reduz custo/ruÃ­do).
        try {
            const srcId = analysisObj && analysisObj.diamondSourceLevel && analysisObj.diamondSourceLevel.id
                ? String(analysisObj.diamondSourceLevel.id).toUpperCase().trim()
                : null;
            if (srcId && srcId !== 'N4') return;
        } catch (_) {}

        const tune = signalsHistory.n4AutoTune;
        const now = Date.now();
        const lastRunAt = Number.isFinite(Number(tune.lastRunAt)) ? Number(tune.lastRunAt) : 0;
        const cooldownMs = Math.max(60 * 1000, Math.min(60 * 60 * 1000, Math.floor(Number(tune.cooldownMs) || (10 * 60 * 1000))));
        if (lastRunAt && (now - lastRunAt) < cooldownMs) return;

        const srcPerf = computeRecentCycleWinRateForSource(entriesHistory, 'N4', Math.max(10, Math.min(200, Math.floor(Number(tune.minCycles) || 20))));
        if (srcPerf.total < Math.max(5, Math.floor(Number(tune.minCycles) || 20))) return;

        const target = Math.max(0.5, Math.min(0.99, Number(tune.targetWinRate) || 0.90));
        if (srcPerf.winRate >= target) return;

        // Precisa de histÃ³rico em memÃ³ria para testar janelas
        const history = Array.isArray(cachedHistory) ? cachedHistory : [];
        if (history.length < 200) return;

        n4AutoTuneInProgress = true;

        const currentWindow = clampN4WindowSize(getDiamondWindow('n4Persistence', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence));
        const candidates = buildN4WindowCandidates(currentWindow, 7);

        // Avaliar baseline (janela atual) + candidatos
        const candidateCfgBase = analyzerConfig;
        const results = [];
        for (const w of candidates) {
            const candidateCfg = {
                ...(candidateCfgBase || {}),
                aiMode: true,
                diamondLevelWindows: {
                    ...((candidateCfgBase && candidateCfgBase.diamondLevelWindows) || {}),
                    n4Persistence: w
                }
            };
            const r = evaluateN4WindowOnCachedHistory({
                historyMostRecentFirst: history,
                windowSize: w,
                config: candidateCfg,
                autoTuneCfg: tune
            });
            results.push(r);
            // micro-yield para nÃ£o travar o background (loop rÃ¡pido)
            await new Promise(res => setTimeout(res, 0));
        }

        const minSignals = Math.max(5, Math.min(300, Math.floor(Number(tune.minSignalsToAccept) || 25)));
        const eligible = results.filter(r => (r.totalCycles || 0) >= minSignals);
        if (!eligible.length) return;

        const baseline = eligible.find(r => r.windowSize === currentWindow) || null;
        const baselineWR = baseline ? baseline.winRate : 0;

        eligible.sort((a, b) => {
            if ((b.winRate || 0) !== (a.winRate || 0)) return (b.winRate || 0) - (a.winRate || 0);
            if ((b.totalCycles || 0) !== (a.totalCycles || 0)) return (b.totalCycles || 0) - (a.totalCycles || 0);
            // menor distÃ¢ncia da janela atual (evita chacoalhar)
            return Math.abs((a.windowSize || 0) - currentWindow) - Math.abs((b.windowSize || 0) - currentWindow);
        });

        const best = eligible[0];
        if (!best || !Number.isFinite(Number(best.windowSize))) return;

        const improvement = (best.winRate || 0) - (baselineWR || 0);
        const bestBeatsTarget = (best.winRate || 0) >= target;
        const shouldApply = (best.windowSize !== currentWindow) && (bestBeatsTarget || improvement >= 0.02);
        if (!shouldApply) return;

        // Aplicar no analyzerConfig persistido
        const stored = await chrome.storage.local.get(['analyzerConfig']);
        const baseStored = stored && stored.analyzerConfig && typeof stored.analyzerConfig === 'object' ? stored.analyzerConfig : (analyzerConfig || {});
        const updated = {
            ...baseStored,
            diamondLevelWindows: {
                ...(baseStored.diamondLevelWindows || {}),
                n4Persistence: best.windowSize
            },
            _clientUpdatedAt: Date.now()
        };

        await chrome.storage.local.set({ analyzerConfig: updated });

        // Persistir telemetria do auto-tune (para debug / transparÃªncia futura)
        try {
            tune.lastRunAt = now;
            tune.lastFrom = currentWindow;
            tune.lastTo = best.windowSize;
            tune.lastWinRate = Number.isFinite(Number(best.winRate)) ? Number(best.winRate) : null;
            signalsHistory.n4AutoTune = tune;
            await saveSignalsHistory();
        } catch (_) {}

        console.log(`ğŸ’ N4 AutoTune: janela ${currentWindow} â†’ ${best.windowSize} | winrate ${(baselineWR * 100).toFixed(1)}% â†’ ${(best.winRate * 100).toFixed(1)}% (amostra ${best.totalCycles})`);
    } catch (e) {
        console.warn('âš ï¸ N4 AutoTune: falha ao ajustar janela:', e);
    } finally {
        n4AutoTuneInProgress = false;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ SISTEMA DE PADRÃ•ES CUSTOMIZADOS (NÃVEL DIAMANTE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let customPatternsCache = []; // Cache dos padrÃµes customizados

/**
 * Carregar padrÃµes customizados do storage
 */
async function loadCustomPatterns() {
    customPatternsCache = [];
        
    
    try {
        await chrome.storage.local.remove('customPatterns');
        console.log('%c   â¤ Dados antigos removidos do storage (customPatterns)', 'color: #666; font-style: italic;');
    } catch (error) {
        console.warn('âš ï¸ NÃ£o foi possÃ­vel limpar customPatterns do storage:', error);
    }
    
    console.log('%câ•‘  ğŸ¯ PADRÃ•ES CUSTOMIZADOS DESATIVADOS (MODO DIAMANTE)     â•‘', 'color: #666; font-weight: bold;');
    console.log('%c   â¤ AnÃ¡lise focada apenas na Zona Segura automÃ¡tica', 'color: #666; font-style: italic;');
        
        return customPatternsCache;
}

/**
 * Buscar padrÃ£o customizado no histÃ³rico
 */
function findCustomPatternInHistory(customPattern, history) {
    console.log(`%cğŸ” Buscando padrÃ£o customizado: ${customPattern.name}`, 'color: #00d4ff; font-weight: bold;');
    console.log('   SequÃªncia:', customPattern.sequence.join(' â†’ '));
    console.log('   Cor anterior:', customPattern.beforeColor);
    console.log('   âšª WHITE serÃ¡ IGNORADO na busca');
    
    const colors = history.map(spin => spin.color);
    const patternLength = customPattern.sequence.length;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”¥ NOVA LÃ“GICA: Agrupar por trigger
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const matchesByTrigger = new Map(); // Chave: trigger normalizada
    
    // Buscar no histÃ³rico (pegando mais giros para compensar possÃ­veis whites)
    const extraForWhites = 5;
    for (let i = 0; i <= colors.length - patternLength - extraForWhites; i++) {
        // Pegar slice maior para compensar whites
        const sliceRaw = colors.slice(i, i + patternLength + extraForWhites);
        
        // âœ… FILTRAR WHITE antes de comparar
        const sliceFiltered = sliceRaw.filter(c => c !== 'white');
        const slice = sliceFiltered.slice(0, patternLength);
        
        // Verificar se temos giros suficientes apÃ³s filtrar white
        if (slice.length < patternLength) {
            continue; // NÃ£o hÃ¡ giros suficientes
        }
        
        // Verificar se a sequÃªncia bate (SEM WHITE)
        const isMatch = slice.every((color, index) => color === customPattern.sequence[index]);
        
        if (isMatch) {
            // Verificar cor anterior (se especificada)
            const colorBefore = (i + patternLength < colors.length) ? colors[i + patternLength] : null;
            
            // ğŸ”¥ VALIDAÃ‡ÃƒO CRÃTICA: Cor de disparo DEVE ser DIFERENTE da primeira cor do padrÃ£o
            const firstPatternColor = customPattern.sequence[0];
            const colorBeforeNormalized = normalizeColorName(colorBefore);
            const firstPatternColorNormalized = normalizeColorName(firstPatternColor);
            
            if (colorBeforeNormalized && !validateDisparoColor(firstPatternColorNormalized, colorBeforeNormalized).valid) {
                // âŒ OCORRÃŠNCIA INVÃLIDA: trigger invÃ¡lida
                continue;
            }
            
            // âœ… Validar cor anterior com as novas opÃ§Ãµes
            let isBeforeColorValid = false;
            if (customPattern.beforeColor === 'red-white') {
                isBeforeColorValid = (colorBefore === 'red' || colorBefore === 'white');
            } else if (customPattern.beforeColor === 'black-white') {
                isBeforeColorValid = (colorBefore === 'black' || colorBefore === 'white');
            } else {
                // Retrocompatibilidade com modelos antigos
                isBeforeColorValid = (customPattern.beforeColor === 'any' || colorBefore === customPattern.beforeColor);
            }
            
            if (isBeforeColorValid) {
                // âœ… PADRÃƒO ENCONTRADO!
                const whatCameNext = (i > 0) ? colors[i - 1] : null;
                
                if (whatCameNext && whatCameNext !== 'white') {
                    // âœ… Agrupar por trigger
                    const triggerKey = colorBeforeNormalized || 'unknown';
                    if (!matchesByTrigger.has(triggerKey)) {
                        matchesByTrigger.set(triggerKey, []);
                    }
                    
                    matchesByTrigger.get(triggerKey).push({
                        index: i,
                        colorBefore: colorBefore,
                        whatCameNext: whatCameNext
                    });
                }
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âœ… SELECIONAR APENAS O GRUPO COM TRIGGER MAIS FREQUENTE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let bestTrigger = null;
    let bestMatches = [];
    
    for (const [trigger, matches] of matchesByTrigger.entries()) {
        if (matches.length > bestMatches.length) {
            bestTrigger = trigger;
            bestMatches = matches;
        }
    }
    
    if (matchesByTrigger.size > 1) {
        console.log(`   âš ï¸ Encontradas ocorrÃªncias com ${matchesByTrigger.size} triggers diferentes!`);
        for (const [trigger, matches] of matchesByTrigger.entries()) {
            console.log(`      - Trigger ${trigger}: ${matches.length} ocorrÃªncia(s)`);
        }
        console.log(`   âœ… Selecionado trigger mais frequente: ${bestTrigger} (${bestMatches.length} ocorrÃªncias)`);
    }
    
    console.log(`   âœ… ${bestMatches.length} ocorrÃªncia(s) VÃLIDA(s) com trigger consistente`);
    
    return bestMatches;
}

/**
 * Analisar padrÃ£o customizado e calcular estatÃ­sticas
 */
function analyzeCustomPatternStatistics(matches) {
    if (matches.length === 0) {
        return null;
    }
    
    // Contar o que veio depois
    const nextColorCount = {
        red: 0,
        black: 0,
        white: 0
    };
    
    matches.forEach(match => {
        if (match.whatCameNext) {
            nextColorCount[match.whatCameNext]++;
        }
    });
    
    const total = matches.length;
    const stats = {
        occurrences: total,
        nextColor: {
            red: nextColorCount.red,
            black: nextColorCount.black,
            white: nextColorCount.white,
            redPercent: Math.round((nextColorCount.red / total) * 100),
            blackPercent: Math.round((nextColorCount.black / total) * 100),
            whitePercent: Math.round((nextColorCount.white / total) * 100)
        }
    };
    
    console.log(`%cğŸ“Š ESTATÃSTICAS DO PADRÃƒO CUSTOMIZADO:`, 'color: #00ff88; font-weight: bold;');
    console.log(`   Total de ocorrÃªncias: ${total}`);
    console.log(`   PrÃ³xima cor:`);
    console.log(`   ğŸ”´ Vermelho: ${stats.nextColor.redPercent}% (${nextColorCount.red}x)`);
    console.log(`   âš« Preto: ${stats.nextColor.blackPercent}% (${nextColorCount.black}x)`);
    console.log(`   âšª Branco: ${stats.nextColor.whitePercent}% (${nextColorCount.white}x)`);
    
    return stats;
}

/**
 * Verificar se o padrÃ£o atual bate com algum padrÃ£o customizado
 */
async function checkForCustomPatterns(history) {
    // âš ï¸ Funcionalidade desativada: padrÃµes customizados foram removidos do sistema.
    return null;
    // âœ… SEMPRE recarregar do storage para pegar mudanÃ§as mais recentes
    console.log('%cğŸ”„ Recarregando padrÃµes customizados do storage...', 'color: #00d4ff; font-weight: bold;');
    await loadCustomPatterns();
    
    if (customPatternsCache.length === 0) {
        console.log('%câ•‘  âš ï¸ NENHUM PADRÃƒO CUSTOMIZADO ENCONTRADO                 â•‘', 'color: #FFA500; font-weight: bold;');
        console.log('%c   â¤ Storage foi verificado e estÃ¡ vazio', 'color: #FFA500;');
        console.log('%c   â¤ Nenhum sinal de padrÃ£o customizado serÃ¡ gerado', 'color: #FFA500;');
        return null;
    }
    
    console.log('%câœ… PadrÃµes customizados carregados do storage!', 'color: #00FF88; font-weight: bold;');
    console.log(`%c   Total: ${customPatternsCache.length} padrÃ£o(Ãµes)`, 'color: #00FF88;');
    
    console.log(`ğŸ“Š Total de padrÃµes carregados no cache: ${customPatternsCache.length}`);
    
    const colors = history.map(spin => spin.color);
    
    // Mostrar em ordem cronolÃ³gica (do mais antigo para o mais recente)
    const last15Reversed = colors.slice(0, 15).reverse();
    const last15Display = last15Reversed.map(c => c === 'red' ? 'ğŸ”´' : c === 'black' ? 'âš«' : 'âšª').join(' â†’ ');
    
    console.log('%cğŸ“œ ÃšLTIMOS 15 GIROS DO HISTÃ“RICO (ordem cronolÃ³gica):', 'color: #00d4ff; font-weight: bold;');
    console.log(`%c   â†‘ PASSADO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PRESENTE â†‘`, 'color: #888; font-style: italic;');
    console.log(`%c   ${last15Display}`, 'color: #FFD700; font-weight: bold;');
    console.log(`%c   ${last15Reversed.join(' â†’ ')}`, 'color: #888;');
    
    let patternIndex = 0;
    // Verificar cada padrÃ£o customizado
    for (const customPattern of customPatternsCache) {
        patternIndex++;
        console.log(`%cğŸ” PADRÃƒO #${patternIndex}: "${customPattern.name}"`, 'color: #00d4ff; font-weight: bold;');
        console.log(`   Status: ${customPattern.active ? 'âœ… ATIVO' : 'âŒ INATIVO'}`);
        console.log(`%c   ğŸ“‹ SEQUÃŠNCIA CONFIGURADA (ordem cronolÃ³gica):`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c      [ANTERIOR] â†’ [1Âº] â†’ [2Âº] â†’ [3Âº] â†’ ... â†’ [ÃšLTIMO/ATUAL]`, 'color: #888; font-style: italic;');
        
        // Construir visualizaÃ§Ã£o com cor anterior
        const beforeColorDisplay = customPattern.beforeColor === 'red-white' ? 'ğŸ”´/âšª' :
                                    customPattern.beforeColor === 'black-white' ? 'âš«/âšª' :
                                    customPattern.beforeColor === 'red' ? 'ğŸ”´' :
                                    customPattern.beforeColor === 'black' ? 'âš«' :
                                    customPattern.beforeColor === 'white' ? 'âšª' : 'â“';
        
        const sequenceDisplay = customPattern.sequence.map((c, idx) => {
            const symbol = c === 'red' ? 'ğŸ”´' : c === 'black' ? 'âš«' : 'âšª';
            return `[${idx + 1}Âº: ${symbol}]`;
        }).join(' â†’ ');
        
        console.log(`%c      ${beforeColorDisplay} (anterior) â†’ ${sequenceDisplay}`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c      â†‘ PASSADO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PRESENTE â†‘`, 'color: #888;');
        
        if (!customPattern.active) {
            console.log(`%c   â­ï¸ PULANDO: PadrÃ£o estÃ¡ INATIVO`, 'color: #888;');
            continue;
        }
        
        const patternLength = customPattern.sequence.length;
        
        // HistÃ³rico vem do MAIS RECENTE para o MAIS ANTIGO
        // Mas padrÃ£o Ã© configurado na ordem cronolÃ³gica (do mais antigo para o mais recente)
        // EntÃ£o precisamos REVERTER a sequÃªncia atual para comparar!
        
        // âœ… PEGAR MAIS GIROS PARA COMPENSAR POSSÃVEIS WHITES
        const extraForWhites = 5; // Pegar 5 giros extras para compensar whites
        const currentSequenceRaw = colors.slice(0, patternLength + extraForWhites);
        const currentSequenceReversed = [...currentSequenceRaw].reverse(); // âœ… INVERTER para ordem cronolÃ³gica
        
        // âœ… REMOVER WHITES (branco nÃ£o conta para padrÃµes)
        console.log(`%c   ğŸ” FILTRANDO GIROS (removendo WHITE):`, 'color: #FFD700; font-weight: bold;');
        console.log(`      SequÃªncia bruta: [${currentSequenceReversed.join(' â†’ ')}]`);
        
        const currentSequenceFiltered = currentSequenceReversed.filter(c => c !== 'white');
        const currentSequence = currentSequenceFiltered.slice(0, patternLength); // Pegar apenas o tamanho do padrÃ£o
        
        console.log(`      ApÃ³s remover WHITE: [${currentSequenceFiltered.join(' â†’ ')}]`);
        console.log(`      Comparando primeiros ${patternLength} giros: [${currentSequence.join(' â†’ ')}]`);
        
        console.log(`%c   ğŸ“‹ COMPARANDO SEQUÃŠNCIAS (ordem cronolÃ³gica, SEM WHITE):`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c      ğŸ“ IMPORTANTE: WHITE Ã© IGNORADO na comparaÃ§Ã£o!`, 'color: #FFD700; font-weight: bold;');
        console.log(`      ğŸ¯ Esperado: [${customPattern.sequence.join(' â†’ ')}]`);
        console.log(`      ğŸ“Š Atual:    [${currentSequence.join(' â†’ ')}]`);
        console.log(`      ğŸ“ Tamanho:  ${patternLength} giros (sem contar WHITE)`);
        
        // Comparar posiÃ§Ã£o por posiÃ§Ã£o (agora ambos estÃ£o em ordem cronolÃ³gica)
        let matchDetails = [];
        for (let i = 0; i < patternLength; i++) {
            const match = (currentSequence[i] === customPattern.sequence[i]);
            matchDetails.push({
                position: i + 1,
                expected: customPattern.sequence[i],
                actual: currentSequence[i] || 'N/A',
                match: match
            });
        }
        
        console.log('%c      COMPARAÃ‡ÃƒO DETALHADA (posiÃ§Ã£o por posiÃ§Ã£o):', 'color: #FFD700;');
        matchDetails.forEach(detail => {
            const status = detail.match ? 'âœ…' : 'âŒ';
            const color = detail.match ? '#00FF88' : '#FF6666';
            const expectedSymbol = detail.expected === 'red' ? 'ğŸ”´' : detail.expected === 'black' ? 'âš«' : 'âšª';
            const actualSymbol = detail.actual === 'red' ? 'ğŸ”´' : detail.actual === 'black' ? 'âš«' : detail.actual === 'white' ? 'âšª' : 'â“';
            console.log(`%c      ${status} ${detail.position}Âº giro: esperado ${expectedSymbol} (${detail.expected}) | real ${actualSymbol} (${detail.actual})`, `color: ${color};`);
        });
        
        const isCurrentMatch = matchDetails.every(d => d.match);
        console.log(`%c   ${isCurrentMatch ? 'âœ… SEQUÃŠNCIA BATE PERFEITAMENTE!' : 'âŒ SequÃªncia NÃƒO bate'}`, `color: ${isCurrentMatch ? '#00FF88' : '#FF6666'}; font-weight: bold;`);
        
        if (isCurrentMatch) {
            // Verificar cor anterior (se especificada)
            // Lembrar: colors[patternLength] Ã© a cor que veio ANTES da sequÃªncia (no histÃ³rico invertido)
            const colorBefore = (patternLength < colors.length) ? colors[patternLength] : null;
            const colorBeforeSymbol = colorBefore === 'red' ? 'ğŸ”´' : colorBefore === 'black' ? 'âš«' : colorBefore === 'white' ? 'âšª' : 'â“';
            
            console.log(`\n   ğŸ” VALIDANDO COR ANTERIOR (que veio ANTES da sequÃªncia):`);
            
            const beforeColorExpected = customPattern.beforeColor === 'red-white' ? 'ğŸ”´/âšª (vermelho OU branco)' :
                                       customPattern.beforeColor === 'black-white' ? 'âš«/âšª (preto OU branco)' :
                                       customPattern.beforeColor === 'red' ? 'ğŸ”´ (vermelho)' :
                                       customPattern.beforeColor === 'black' ? 'âš« (preto)' :
                                       customPattern.beforeColor === 'white' ? 'âšª (branco)' :
                                       customPattern.beforeColor === 'any' ? 'â“ (qualquer)' : customPattern.beforeColor;
            
            console.log(`      Esperado: ${beforeColorExpected}`);
            console.log(`      Real: ${colorBeforeSymbol} (${colorBefore || 'N/A'})`);
            
            // ğŸ”¥ VALIDAÃ‡ÃƒO CRÃTICA: Cor de disparo DEVE ser DIFERENTE da primeira cor do padrÃ£o
            const firstPatternColor = customPattern.sequence[0];
            const colorBeforeNormalized = normalizeColorName(colorBefore);
            const firstPatternColorNormalized = normalizeColorName(firstPatternColor);
            const disparoValidation = validateDisparoColor(firstPatternColorNormalized, colorBeforeNormalized);
            
            if (colorBeforeNormalized && !disparoValidation.valid) {
                console.log(`%c   âŒ PADRÃƒO REJEITADO: Cor de disparo (${colorBeforeSymbol}) IGUAL Ã  primeira cor do padrÃ£o!`, 'color: #FF6666; font-weight: bold;');
                console.log(`%c      Isso corrompe o padrÃ£o! Se padrÃ£o Ã© ${firstPatternColor.toUpperCase()} e disparo tambÃ©m Ã© ${colorBefore.toUpperCase()}, o padrÃ£o fica diferente!`, 'color: #FF6666;');
                console.log(`%c      ValidaÃ§Ã£o: ${disparoValidation.reason}`, 'color: #FF6666;');
                continue; // âŒ PULAR este padrÃ£o
            }
            
            // âœ… Validar cor anterior com as novas opÃ§Ãµes
            let isBeforeColorValid = false;
            if (customPattern.beforeColor === 'red-white') {
                isBeforeColorValid = (colorBefore === 'red' || colorBefore === 'white');
                console.log(`      ${isBeforeColorValid ? 'âœ…' : 'âŒ'} ${colorBefore} Ã© vermelho OU branco? ${isBeforeColorValid ? 'SIM' : 'NÃƒO'}`);
            } else if (customPattern.beforeColor === 'black-white') {
                isBeforeColorValid = (colorBefore === 'black' || colorBefore === 'white');
                console.log(`      ${isBeforeColorValid ? 'âœ…' : 'âŒ'} ${colorBefore} Ã© preto OU branco? ${isBeforeColorValid ? 'SIM' : 'NÃƒO'}`);
            } else {
                // Retrocompatibilidade com modelos antigos
                isBeforeColorValid = (customPattern.beforeColor === 'any' || colorBefore === customPattern.beforeColor);
                console.log(`      ${isBeforeColorValid ? 'âœ…' : 'âŒ'} ${colorBefore} Ã© ${customPattern.beforeColor}? ${isBeforeColorValid ? 'SIM' : 'NÃƒO'}`);
            }
            
            if (isBeforeColorValid) {
                console.log(`%câœ… PADRÃƒO CUSTOMIZADO ATIVO DETECTADO!`, 'color: #00ff88; font-weight: bold;');
                console.log(`   Nome: ${customPattern.name}`);
                console.log(`   SequÃªncia: ${customPattern.sequence.join(' â†’ ')}`);
                console.log(`   Cor anterior esperada: ${customPattern.beforeColor}`);
                console.log(`   Cor anterior real: ${colorBefore || 'N/A'}`);
                
                // Buscar no histÃ³rico o que geralmente vem depois
                const matches = findCustomPatternInHistory(customPattern, history);
                const stats = analyzeCustomPatternStatistics(matches);
                
                console.log('%câ•‘  ğŸ“Š ANÃLISE SIMPLES DO PADRÃƒO                            â•‘', 'color: #FFD700; font-weight: bold;');
                
                // âœ… LÃ“GICA SIMPLES: Encontrou pelo menos 1x? Recomenda a cor com maior %
                if (stats && stats.occurrences >= 1) {
                    console.log(`ğŸ“ˆ Total de ocorrÃªncias encontradas: ${stats.occurrences}`);
                    console.log(`ğŸ”´ Vermelho veio depois: ${stats.nextColor.redPercent}%`);
                    console.log(`âš« Preto veio depois: ${stats.nextColor.blackPercent}%`);
                    console.log(`âšª Branco veio depois: ${stats.nextColor.whitePercent}%`);
                    
                    // Determinar cor com maior frequÃªncia (SIMPLES!)
                    const redPercent = stats.nextColor.redPercent;
                    const blackPercent = stats.nextColor.blackPercent;
                    const recommendedColor = redPercent > blackPercent ? 'red' : 'black';
                    const confidence = Math.max(redPercent, blackPercent);
                    
                    console.log(`%câœ… PADRÃƒO CUSTOMIZADO APROVADO!`, 'color: #00FF88; font-weight: bold; font-size: 14px;');
                    console.log(`%cğŸ¯ COR RECOMENDADA: ${recommendedColor === 'red' ? 'ğŸ”´ VERMELHO' : 'âš« PRETO'}`, 'color: #00FF88; font-weight: bold;');
                    console.log(`%cğŸ“Š ConfianÃ§a: ${confidence}%`, 'color: #00FF88; font-weight: bold;');
                    
                    return {
                        pattern: customPattern,
                        stats: stats,
                        recommendedColor: recommendedColor,
                        confidence: confidence,
                        reasoning: `PadrÃ£o customizado "${customPattern.name}" detectado! ` +
                                  `Sistema encontrou ${stats.occurrences} ocorrÃªncia(s) no histÃ³rico. ` +
                                  `A cor ${recommendedColor === 'red' ? 'ğŸ”´ VERMELHA' : 'âš« PRETA'} veio depois em ${confidence}% dos casos.`
                    };
                } else {
                    // PadrÃ£o nunca apareceu no histÃ³rico
                    console.log(`%câš ï¸ ATENÃ‡ÃƒO! PadrÃ£o NUNCA apareceu no histÃ³rico`, 'color: #FFA500; font-weight: bold; font-size: 14px;');
                    console.log(`%c   PadrÃ£o detectado: "${customPattern.name}"`, 'color: #FFA500;');
                    console.log(`%c   Sem dados histÃ³ricos para anÃ¡lise`, 'color: #FFA500;');
                    // Continuar verificando prÃ³ximo padrÃ£o
                }
            } else {
                console.log(`\n   âŒ COR ANTERIOR NÃƒO VÃLIDA!`);
                console.log(`      Esperado: ${customPattern.beforeColor}`);
                console.log(`      Recebido: ${colorBefore}`);
                console.log(`      Este padrÃ£o NÃƒO serÃ¡ usado!\n`);
            }
        }
    }
    
    console.log('\nğŸ“Š Resultado final: Nenhum padrÃ£o customizado vÃ¡lido encontrado no momento');
    return null;
}

// Listener para atualizaÃ§Ã£o de padrÃµes customizados
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.type === 'CUSTOM_PATTERNS_UPDATED') {
        console.log('%câ•‘  ğŸ”„ PADRÃ•ES CUSTOMIZADOS ATUALIZADOS!                    â•‘', 'color: #00FF88; font-weight: bold;');
        
        const oldCache = [...customPatternsCache];
        customPatternsCache = request.data || [];
        
        console.log(`ğŸ“Š PadrÃµes no cache ANTIGO: ${oldCache.length}`);
        if (oldCache.length > 0) {
            oldCache.forEach((p, idx) => {
                console.log(`   ${idx + 1}. "${p.name}" (ID: ${p.id})`);
            });
        }
        
        console.log(`ğŸ“Š PadrÃµes no cache NOVO: ${customPatternsCache.length}`);
        if (customPatternsCache.length > 0) {
            customPatternsCache.forEach((p, idx) => {
                console.log(`   ${idx + 1}. "${p.name}" (ID: ${p.id})`);
            });
        }
        
        // Detectar padrÃµes REMOVIDOS
        const removedPatterns = oldCache.filter(old => !customPatternsCache.find(p => p.id === old.id));
        if (removedPatterns.length > 0) {
            console.log('%cğŸ—‘ï¸ PADRÃ•ES REMOVIDOS:', 'color: #FF6666; font-weight: bold;');
            removedPatterns.forEach(p => {
                console.log(`   âœ• "${p.name}" (ID: ${p.id}) | SequÃªncia: ${p.sequence.join(' â†’ ')}`);
            });
        }
        
        // Detectar padrÃµes NOVOS
        const newPatterns = customPatternsCache.filter(p => !oldCache.find(old => old.id === p.id));
        if (newPatterns.length > 0) {
            console.log('%câœ¨ PADRÃ•ES NOVOS:', 'color: #00FF88; font-weight: bold;');
            newPatterns.forEach(p => {
                console.log(`   + "${p.name}" (ID: ${p.id}) | SequÃªncia: ${p.sequence.join(' â†’ ')}`);
            });
        }
        
        // Detectar padrÃµes EDITADOS
        const editedPatterns = customPatternsCache.filter(p => {
            const old = oldCache.find(old => old.id === p.id);
            return old && (old.name !== p.name || 
                          JSON.stringify(old.sequence) !== JSON.stringify(p.sequence) ||
                          old.beforeColor !== p.beforeColor);
        });
        if (editedPatterns.length > 0) {
            console.log('%câœï¸ PADRÃ•ES EDITADOS:', 'color: #FFD700; font-weight: bold;');
            editedPatterns.forEach(p => {
                console.log(`   âœï¸ "${p.name}" (ID: ${p.id})`);
            });
        }
        
        console.log('%câœ… CACHE ATUALIZADO - PrÃ³ximo sinal usarÃ¡ os padrÃµes mais recentes!', 'color: #00FF88; font-weight: bold;');
        console.log('%câš ï¸ IMPORTANTE: PadrÃµes removidos NÃƒO gerarÃ£o mais sinais!', 'color: #FFD700; font-weight: bold;');
        
        sendResponse({ success: true });
        return true;
    }
});

/**
 * DETECTAR TODOS OS TIPOS DE PADRÃ•ES VARIADOS
 * Cria exemplos de alternÃ¢ncia simples, dupla, tripla, sequÃªncias, etc.
 */
function detectAllPatternTypes(history) {
    const patterns = [];
    
    if (history.length < 2) return patterns;
    
    // Converter histÃ³rico para array de cores simples
    const colors = history.map(spin => spin.color);
    
    console.log('%cğŸ” DETECTANDO TODOS OS PADRÃ•ES POSSÃVEIS', 'color: #00BFFF; font-weight: bold;');
    
    // 1. ALTERNÃ‚NCIA SIMPLES (V-P-V-P...)
    console.log('%cğŸ“Š Buscando: AlternÃ¢ncia Simples (tamanhos 2-20)', 'color: #00FF88;');
    for (let size = 2; size <= Math.min(20, colors.length); size += 2) {
        for (let i = 0; i <= colors.length - size; i++) {
            const sequence = colors.slice(i, i + size);
            const isAlternating = checkAlternatingPattern(sequence, 1);
            
            if (isAlternating && !sequence.includes('white')) {
                // âœ… CORREÃ‡ÃƒO CRÃTICA: Array[0]=recente, [1]=antigo
                // O que veio DEPOIS Ã© [i-1] (mais recente), nÃ£o [i+size] (mais antigo)!
                if (i > 0) { // Precisa ter um giro seguinte
                    const whatCameNext = colors[i - 1]; // âœ… Giro SEGUINTE
                    const contextBefore = (i + size < colors.length - 4) ? colors.slice(i + size, i + size + 4).join('-') : 'inicio';
                    patterns.push({
                        type: 'alternancia_simples',
                        size: size,
                        sequence: sequence.join('-'),
                        index: i,
                        whatCameNext: whatCameNext,
                        contextBefore: contextBefore
                    });
                }
            }
        }
    }
    
    // 2. ALTERNÃ‚NCIA DUPLA (V-V-P-P-V-V...)
    console.log('%cğŸ“Š Buscando: AlternÃ¢ncia Dupla (tamanhos 4-20)', 'color: #00FF88;');
    for (let size = 4; size <= Math.min(20, colors.length); size += 4) {
        for (let i = 0; i <= colors.length - size; i++) {
            const sequence = colors.slice(i, i + size);
            const isAlternating = checkAlternatingPattern(sequence, 2);
            
            if (isAlternating && !sequence.includes('white')) {
                // âœ… CORREÃ‡ÃƒO: O que veio DEPOIS Ã© [i-1], nÃ£o [i+size]
                if (i > 0) {
                    const whatCameNext = colors[i - 1]; // âœ… Giro SEGUINTE
                    const contextBefore = (i + size < colors.length - 4) ? colors.slice(i + size, i + size + 4).join('-') : 'inicio';
                    patterns.push({
                        type: 'alternancia_dupla',
                        size: size,
                        sequence: sequence.join('-'),
                        index: i,
                        whatCameNext: whatCameNext,
                        contextBefore: contextBefore
                    });
                }
            }
        }
    }
    
    // 3. ALTERNÃ‚NCIA TRIPLA (V-V-V-P-P-P...)
    console.log('%cğŸ“Š Buscando: AlternÃ¢ncia Tripla (tamanhos 6-18)', 'color: #00FF88;');
    for (let size = 6; size <= Math.min(18, colors.length); size += 6) {
        for (let i = 0; i <= colors.length - size; i++) {
            const sequence = colors.slice(i, i + size);
            const isAlternating = checkAlternatingPattern(sequence, 3);
            
            if (isAlternating && !sequence.includes('white')) {
                // âœ… CORREÃ‡ÃƒO: O que veio DEPOIS Ã© [i-1], nÃ£o [i+size]
                if (i > 0) {
                    const whatCameNext = colors[i - 1]; // âœ… Giro SEGUINTE
                    const contextBefore = (i + size < colors.length - 4) ? colors.slice(i + size, i + size + 4).join('-') : 'inicio';
                    patterns.push({
                        type: 'alternancia_tripla',
                        size: size,
                        sequence: sequence.join('-'),
                        index: i,
                        whatCameNext: whatCameNext,
                        contextBefore: contextBefore
                    });
                }
            }
        }
    }
    
    // 4. SEQUÃŠNCIAS (mesma cor consecutiva)
    console.log('%cğŸ“Š Buscando: SequÃªncias (tamanhos 2-15)', 'color: #00FF88;');
    for (let size = 2; size <= Math.min(15, colors.length); size++) {
        for (let i = 0; i <= colors.length - size; i++) {
            const sequence = colors.slice(i, i + size);
            const firstColor = sequence[0];
            const isSequence = sequence.every(c => c === firstColor) && firstColor !== 'white';
            
            if (isSequence) {
                // âœ… CORREÃ‡ÃƒO: O que veio DEPOIS Ã© [i-1], nÃ£o [i+size]
                if (i > 0) {
                    const whatCameNext = colors[i - 1]; // âœ… Giro SEGUINTE
                    const contextBefore = (i + size < colors.length - 4) ? colors.slice(i + size, i + size + 4).join('-') : 'inicio';
                    patterns.push({
                        type: 'sequencia_' + firstColor,
                        size: size,
                        sequence: sequence.join('-'),
                        index: i,
                        whatCameNext: whatCameNext,
                        contextBefore: contextBefore
                    });
                }
            }
        }
    }
    
    console.log('%câœ… Total de padrÃµes detectados: ' + patterns.length, 'color: #00BFFF; font-weight: bold;');
    
    return patterns;
}

/**
 * Verificar se uma sequÃªncia segue um padrÃ£o de alternÃ¢ncia
 * @param {Array} sequence - Array de cores
 * @param {Number} groupSize - Tamanho do grupo (1=simples, 2=dupla, 3=tripla)
 */
function checkAlternatingPattern(sequence, groupSize) {
    if (sequence.length < groupSize * 2) return false;
    
    for (let i = 0; i < sequence.length; i++) {
        const groupIndex = Math.floor(i / groupSize);
        const expectedColor = groupIndex % 2 === 0 ? sequence[0] : (sequence[0] === 'red' ? 'black' : 'red');
        
        if (sequence[i] !== expectedColor) {
            return false;
        }
    }
    
    return true;
}

/**
 * âœ¨ DETECTAR PADRÃ•ES IRREGULARES/CUSTOMIZADOS
 * Exemplos:
 * - P-V-V-V-P â†’ PadrÃ£o 1-3-1 (1 preto, 3 vermelhos, repete)
 * - B-P-P-V-P-P â†’ PadrÃ£o com branco (B/V-P-P repete)
 * - V-V-P-V-V-P â†’ PadrÃ£o 2-1-2 (2 vermelhos, 1 preto, repete)
 */
function detectIrregularPattern(colors) {
    console.log('%cğŸ” Buscando padrÃµes irregulares nos Ãºltimos 10 giros...', 'color: #FF00FF;');
    
    // Ignorar brancos para simplificar anÃ¡lise inicial
    const nonWhite = colors.filter(c => c !== 'white');
    
    // Tentar detectar ciclos de tamanhos diferentes (2-6 giros por ciclo)
    for (let cycleSize = 2; cycleSize <= 6; cycleSize++) {
        // Precisa de pelo menos 2 ciclos completos para confirmar padrÃ£o
        const minGiros = cycleSize * 2;
        if (nonWhite.length < minGiros) continue;
        
        const cycle1 = nonWhite.slice(0, cycleSize);
        const cycle2 = nonWhite.slice(cycleSize, cycleSize * 2);
        
        // Verificar se os dois ciclos sÃ£o idÃªnticos
        const isSameCycle = cycle1.every((color, i) => color === cycle2[i]);
        
        if (isSameCycle) {
            // Encontrou padrÃ£o irregular repetido!
            const patternStr = cycle1.map(c => c === 'red' ? 'V' : 'P').join('-');
            
            console.log(`%c   âœ… PadrÃ£o irregular detectado: ${patternStr}`, 'color: #FF00FF; font-weight: bold;');
            console.log(`%c      Ciclo se repete a cada ${cycleSize} giros`, 'color: #FF00FF;');
            
            return {
                type: 'irregular_pattern',
                size: cycleSize * 2,
                sequence: cycle1.join('-'),
                name: `PadrÃ£o Irregular (${patternStr} repetido)`,
                cycleSize: cycleSize,
                contextBefore: colors.slice(cycleSize * 2, cycleSize * 2 + 4).join('-')
            };
        }
    }
    
    // Tentar detectar padrÃµes com branco incluÃ­do
    if (colors.includes('white')) {
        for (let cycleSize = 2; cycleSize <= 6; cycleSize++) {
            const minGiros = cycleSize * 2;
            if (colors.length < minGiros) continue;
            
            const cycle1 = colors.slice(0, cycleSize);
            const cycle2 = colors.slice(cycleSize, cycleSize * 2);
            
            const isSameCycle = cycle1.every((color, i) => color === cycle2[i]);
            
            if (isSameCycle) {
                const patternStr = cycle1.map(c => c === 'red' ? 'V' : c === 'black' ? 'P' : 'B').join('-');
                
                console.log(`%c   âœ… PadrÃ£o irregular COM BRANCO: ${patternStr}`, 'color: #FF00FF; font-weight: bold;');
                
                return {
                    type: 'irregular_pattern_with_white',
                    size: cycleSize * 2,
                    sequence: cycle1.join('-'),
                    name: `PadrÃ£o com Branco (${patternStr} repetido)`,
                    cycleSize: cycleSize,
                    contextBefore: colors.slice(cycleSize * 2, cycleSize * 2 + 4).join('-')
                };
            }
        }
    }
    
    console.log('%c   âŒ Nenhum padrÃ£o irregular encontrado', 'color: #FF00FF;');
    return null;
}

/**
 * ğŸ” VALIDADOR RIGOROSO DE PADRÃƒO
 * Verifica se o padrÃ£o detectado estÃ¡ REALMENTE correto
 * Analisa o contexto completo antes e depois do padrÃ£o
 */
function validatePatternDetection(colors, patternStartIndex, patternSize, patternType, groupSize, patternName) {
    const patternSequence = colors.slice(patternStartIndex, patternStartIndex + patternSize);
    
    console.log('%cğŸ” VALIDADOR RIGOROSO DE PADRÃƒO', 'color: #FF1493; font-weight: bold; font-size: 14px;');
    console.log(`%cğŸ“‹ PadrÃ£o detectado: ${patternName}`, 'color: #FF69B4; font-weight: bold;');
    console.log(`%c   Tipo: ${patternType}`, 'color: #FF69B4;');
    console.log(`%c   Tamanho: ${patternSize} giros`, 'color: #FF69B4;');
    console.log(`%c   SequÃªncia: ${patternSequence.map(c => c === 'red' ? 'V' : c === 'black' ? 'P' : 'B').join('-')}`, 'color: #FF69B4;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 1: MOSTRAR CONTEXTO COMPLETO (10 giros)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const contextSize = Math.min(10, colors.length);
    const contextColors = colors.slice(0, contextSize).map((c, i) => {
        const symbol = c === 'red' ? 'V' : c === 'black' ? 'P' : 'B';
        if (i >= patternStartIndex && i < patternStartIndex + patternSize) {
            return `[${symbol}]`; // Marcar padrÃ£o com colchetes
        }
        return symbol;
    }).join('-');
    
    console.log(`%cğŸ“Š CONTEXTO COMPLETO (Ãºltimos ${contextSize} giros):`, 'color: #00CED1; font-weight: bold;');
    console.log(`%c   ${contextColors}`, 'color: #00CED1;');
    console.log(`%c   (PadrÃ£o marcado com [ ])`, 'color: #888;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 2: ANÃLISE DO CONTEXTO ANTERIOR (O que veio ANTES)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const contextBefore = [];
    for (let i = patternStartIndex + patternSize; i < Math.min(patternStartIndex + patternSize + 5, colors.length); i++) {
        if (colors[i] && colors[i] !== 'white') {
            contextBefore.push(colors[i]);
        }
    }
    
    if (contextBefore.length > 0) {
        console.log(`%cğŸ”™ CONTEXTO ANTERIOR (antes do padrÃ£o):`, 'color: #FFA500; font-weight: bold;');
        console.log(`%c   Giros anteriores: ${contextBefore.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #FFA500;');
        
        // VALIDAÃ‡ÃƒO CRÃTICA: Se Ã© alternÃ¢ncia, verificar se nÃ£o Ã© sequÃªncia quebrando
        if (patternType.includes('alternancia')) {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LÃ“GICA CORRETA: Pegar os ÃšLTIMOS N giros do padrÃ£o (onde N = groupSize)
            // e ver se essa cor continua ANTES do padrÃ£o
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Para alternÃ¢ncia DUPLA P-P-V-V:
            // - Ãšltimos 2 giros (groupSize=2): P-P (posiÃ§Ãµes 2,3 do padrÃ£o)
            // - Se antes veio mais P, entÃ£o P-P faz parte de P-P-P!
            // - REJEITAR!
            
            // Pegar os Ãºltimos N giros do padrÃ£o
            const lastGroupColors = patternSequence.slice(patternSize - groupSize, patternSize);
            const lastGroupColor = lastGroupColors[0]; // Cor do Ãºltimo grupo
            
            console.log(`%c      Cor: ${lastGroupColor === 'red' ? 'VERMELHO' : 'PRETO'}`, 'color: #FFA500;');
            
            // Verificar se essa mesma cor continua ANTES do padrÃ£o
            if (contextBefore.length > 0 && contextBefore[0] === lastGroupColor) {
                console.log('%c   âŒ ERRO DETECTADO: PadrÃ£o INCORRETO!', 'color: #FF0000; font-weight: bold;');
                console.log(`%c   Motivo: A cor ${lastGroupColor === 'red' ? 'VERMELHO' : 'PRETO'} continua ANTES do padrÃ£o!`, 'color: #FF0000;');
                console.log(`%c   O Ãºltimo grupo (${lastGroupColors.map(c => c === 'red' ? 'V' : 'P').join('-')}) faz parte de uma SEQUÃŠNCIA maior!`, 'color: #FF0000;');
                console.log(`%c   Isso NÃƒO Ã© ${patternName}! Ã‰ uma SEQUÃŠNCIA quebrando!`, 'color: #FF0000; font-weight: bold;');
                return { valid: false, reason: `Ãšltimo grupo do padrÃ£o (${lastGroupColor === 'red' ? 'V' : 'P'}) continua antes - Ã© sequÃªncia quebrando!` };
            }
            
            // VALIDAÃ‡ÃƒO ADICIONAL: Verificar os PRIMEIROS N giros do padrÃ£o tambÃ©m
            const firstGroupColors = patternSequence.slice(0, groupSize);
            const firstGroupColor = firstGroupColors[0];
            
            console.log(`%c      Cor: ${firstGroupColor === 'red' ? 'VERMELHO' : 'PRETO'}`, 'color: #FFA500;');
            
            // Verificar quantas vezes essa cor aparece ANTES do padrÃ£o
            let sameColorCountBefore = 0;
            for (let i = 0; i < contextBefore.length; i++) {
                if (contextBefore[i] === lastGroupColor) {
                    sameColorCountBefore++;
                } else {
                    break;
                }
            }
            
            if (sameColorCountBefore > 0) {
                console.log('%c   âŒ ERRO DETECTADO: PadrÃ£o INCORRETO!', 'color: #FF0000; font-weight: bold;');
                console.log(`%c   Motivo: ${sameColorCountBefore} cor(es) ${lastGroupColor === 'red' ? 'VERMELHO' : 'PRETO'} continuam antes!`, 'color: #FF0000;');
                console.log(`%c   Isso cria uma sequÃªncia de ${sameColorCountBefore + groupSize} cores iguais!`, 'color: #FF0000;');
                console.log(`%c   Isso NÃƒO Ã© ${patternName}! Ã‰ uma SEQUÃŠNCIA quebrando!`, 'color: #FF0000; font-weight: bold;');
                return { valid: false, reason: `${sameColorCountBefore} cor(es) continuam antes - sequÃªncia de ${sameColorCountBefore + groupSize} total!` };
            } else {
                console.log(`%c   âœ… OK: NÃ£o hÃ¡ continuaÃ§Ã£o da cor antes do padrÃ£o`, 'color: #00FF00;');
            }
        }
        
        // VALIDAÃ‡ÃƒO: Se Ã© sequÃªncia, nÃ£o pode ter a mesma cor logo antes
        if (patternType.includes('sequencia')) {
            const firstColor = getInitialPatternColor(patternSequence);
            if (contextBefore[0] === firstColor) {
                console.log('%c   âŒ ERRO DETECTADO: PadrÃ£o INCORRETO!', 'color: #FF0000; font-weight: bold;');
                console.log(`%c   Motivo: SequÃªncia continua ANTES do padrÃ£o detectado`, 'color: #FF0000;');
                console.log(`%c   Isso nÃ£o Ã© uma nova sequÃªncia, Ã© continuaÃ§Ã£o!`, 'color: #FF0000; font-weight: bold;');
                return { valid: false, reason: 'SequÃªncia continua antes do padrÃ£o' };
            } else {
                console.log(`%c   âœ… OK: Cor anterior (${contextBefore[0] === 'red' ? 'V' : 'P'}) Ã© diferente da sequÃªncia (${firstColor === 'red' ? 'V' : 'P'})`, 'color: #00FF00;');
            }
        }
        
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 3: ANÃLISE DO CONTEXTO POSTERIOR (O que veio DEPOIS)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (patternStartIndex >= 1) {
        const contextAfter = [];
        for (let i = patternStartIndex - 1; i >= Math.max(0, patternStartIndex - 5); i--) {
            if (colors[i] && colors[i] !== 'white') {
                contextAfter.push(colors[i]);
            }
        }
        
        if (contextAfter.length > 0) {
            console.log(`%cğŸ”œ CONTEXTO POSTERIOR (depois do padrÃ£o):`, 'color: #9370DB; font-weight: bold;');
            console.log(`%c   Giros seguintes: ${contextAfter.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #9370DB;');
            
            const nextColor = contextAfter[0];
            const lastColorOfPattern = patternSequence[patternSize - 1];
            
            // VALIDAÃ‡ÃƒO: Ãšltimo giro do padrÃ£o nÃ£o pode continuar depois
            if (nextColor === lastColorOfPattern) {
                console.log('%c   âŒ ERRO DETECTADO: PadrÃ£o INCORRETO!', 'color: #FF0000; font-weight: bold;');
                console.log(`%c   Motivo: Ãšltimo giro do padrÃ£o (${lastColorOfPattern === 'red' ? 'V' : 'P'}) continua depois`, 'color: #FF0000;');
                console.log(`%c   O padrÃ£o detectado faz parte de um padrÃ£o MAIOR!`, 'color: #FF0000; font-weight: bold;');
                return { valid: false, reason: 'Ãšltimo giro do padrÃ£o continua depois (padrÃ£o maior)' };
            } else {
                console.log(`%c   âœ… OK: PrÃ³ximo giro (${nextColor === 'red' ? 'V' : 'P'}) quebra o padrÃ£o`, 'color: #00FF00;');
            }
            
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONCLUSÃƒO: PADRÃƒO VÃLIDO!
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%câœ… PADRÃƒO VALIDADO COM SUCESSO!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
    console.log('%c   Todas as verificaÃ§Ãµes passaram!', 'color: #00FF88;');
    console.log('%c   O padrÃ£o estÃ¡ LIMPO e CORRETO!', 'color: #00FF88;');
    
    return { valid: true, reason: 'PadrÃ£o validado com sucesso' };
}

/**
 * âœ… VALIDAÃ‡ÃƒO CRÃTICA: Verificar se o padrÃ£o estÃ¡ "limpo"
 * Um padrÃ£o sÃ³ Ã© vÃ¡lido se:
 * 1. O giro ANTERIOR (antes do primeiro giro do padrÃ£o) quebra o padrÃ£o
 * 2. O giro POSTERIOR (depois do Ãºltimo giro do padrÃ£o) tambÃ©m quebra
 * 
 * Exemplo CORRETO:
 * Giros: P-V-P-V (posiÃ§Ãµes 3,2,1,0)
 * PadrÃ£o: V-P (posiÃ§Ãµes 1,0)
 * - Giro anterior (2): V (se continuasse: V-V-P = nÃ£o Ã© alternÃ¢ncia) âœ…
 * - Giro posterior (3): P (se continuasse: V-P-P = nÃ£o Ã© alternÃ¢ncia) âœ…
 * 
 * Exemplo ERRADO:
 * Giros: P-P-V-P (posiÃ§Ãµes 3,2,1,0)
 * PadrÃ£o: V-P (posiÃ§Ãµes 1,0)
 * - Giro anterior (2): P âœ… OK
 * - Giro posterior (3): P âŒ ERRO! O P do giro 1 faz parte de sequÃªncia P-P
 */
function isPatternClean(colors, patternStartIndex, patternSize, patternType, groupSize) {
    const patternSequence = colors.slice(patternStartIndex, patternStartIndex + patternSize);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VERIFICAÃ‡ÃƒO 1: Giro ANTERIOR ao padrÃ£o (apÃ³s o Ãºltimo giro)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const previousColorIndex = patternStartIndex + patternSize;
    const previousColor = colors[previousColorIndex];
    
    if (previousColor) {
        // Para alternÃ¢ncias, verificar se o giro anterior quebraria o padrÃ£o
        if (patternType.includes('alternancia')) {
            const firstColor = getInitialPatternColor(patternSequence);
			if (!firstColor) return false;
            const groupIndex = Math.floor(patternSize / groupSize);
            const expectedColor = groupIndex % 2 === 0 ? firstColor : (firstColor === 'red' ? 'black' : 'red');
            
            if (previousColor === expectedColor) {
                return false; // âŒ PadrÃ£o continua antes
            }
        }
        
        // Para sequÃªncias, verificar se o giro anterior Ã© diferente
        if (patternType.includes('sequencia')) {
            const firstColor = getInitialPatternColor(patternSequence);
			if (!firstColor) return false;
            if (previousColor === firstColor) {
                return false; // âŒ SequÃªncia continua antes
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VERIFICAÃ‡ÃƒO 2: Giro POSTERIOR ao padrÃ£o (depois do primeiro giro)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âš ï¸ CRÃTICO: Para alternÃ¢ncias e sequÃªncias de 2+ giros
    if (patternSize >= 2 && patternStartIndex >= 1) {
        const nextColorIndex = patternStartIndex - 1; // Giro DEPOIS do padrÃ£o (mais recente)
        const nextColor = colors[nextColorIndex];
        
        if (nextColor && nextColor !== 'white') {
            const lastColorOfPattern = patternSequence[patternSize - 1];
            
            // Para alternÃ¢ncias, o Ãºltimo giro do padrÃ£o NÃƒO pode continuar depois
            if (patternType.includes('alternancia')) {
                // Se o Ãºltimo giro do padrÃ£o for P, e o prÃ³ximo tambÃ©m for P,
                // significa que o P do padrÃ£o faz parte de uma sequÃªncia maior
                if (nextColor === lastColorOfPattern) {
                    return false; // âŒ Ãšltimo giro do padrÃ£o continua depois
                }
            }
            
            // Para sequÃªncias, verificar se continua depois
            if (patternType.includes('sequencia')) {
                if (nextColor === lastColorOfPattern) {
                    return false; // âŒ SequÃªncia continua depois
                }
            }
        }
    }
    
    return true; // âœ… PadrÃ£o estÃ¡ limpo dos dois lados
}

/**
 * BUSCAR PADRÃƒO ATIVO NOS ÃšLTIMOS 20 GIROS
 * Identifica qual padrÃ£o estÃ¡ acontecendo AGORA (comeÃ§ando do giro 1)
 */
function findActivePattern(last20Spins) {
    const colors = last20Spins.map(spin => spin.color);
    
    console.log('%cğŸ¯ IDENTIFICANDO PADRÃƒO ATIVO (comeÃ§ando do giro 1)', 'color: #FFD700; font-weight: bold;');
    
    console.log('%cÃšltimos 20 giros:', 'color: #FFD700;');
    last20Spins.slice(0, 10).forEach((spin, index) => {
        console.log(`  ${index + 1}. ${spin.color} (${spin.roll})`);
    });
    console.log('  ... (+ 10 giros mais antigos)');
    
    // Tentar detectar padrÃµes do MAIOR para o MENOR
    // ComeÃ§ar sempre do giro 1 (mais recente)
    
    let bestPattern = null;
    let bestSize = 0;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ TAMANHOS MÃNIMOS PARA PADRÃ•ES CONFIÃVEIS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ CALIBRAÃ‡Ã•ES BASEADAS EM 10.000 GIROS REAIS DA BLAZE
    // Data: 31/10/2025 - 03/11/2025 | AnÃ¡lise cientÃ­fica correta
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // âœ… CORRIGIDO: MÃ­nimos mais inteligentes para detecÃ§Ã£o precoce
    const MIN_ALTERNANCIA_TRIPLA = 8;  // 2 ciclos + 2 giros (P-P-P-V-V-V-P-P) â†’ prÃ³ximo: P
    const MIN_ALTERNANCIA_DUPLA = 6;   // 3 ciclos completos (P-P-V-V-P-P) â†’ prÃ³ximo: V
    const MIN_ALTERNANCIA_SIMPLES = 4; // 2 ciclos completos (P-V-P-V) â†’ prÃ³ximo: P
    const MIN_SEQUENCIA = 3;           // 3 da mesma cor (P-P-P) â†’ detecta tendÃªncia
    
    // ğŸ”¥ DADOS REAIS: Pontos de quebra crÃ­ticos (>60% probabilidade)
    const QUEBRA_CRITICA_RED_5 = 5;    // âœ… Vermelho 5: 62.4% quebra (83/133)
    const QUEBRA_CRITICA_RED_8 = 8;    // âœ… Vermelho 8: 66.7% quebra (8/12)
    const QUEBRA_CRITICA_BLACK_7 = 7;  // âœ… Preto 7: 76.0% quebra (19/25) â¬…ï¸ FORTE!
    const MAX_SEQUENCIA_HISTORICO = 11; // âœ… MÃ¡ximo visto: 11 (1x cada cor em 10k)
    
    // ğŸ“Š DISTRIBUIÃ‡ÃƒO REAL (QUASE 50/50!)
    const REAL_RED_PERCENT = 46.77;    // âœ… Vermelho: 4677/10000
    const REAL_BLACK_PERCENT = 46.87;  // âœ… Preto: 4687/10000 (apenas 0.1% a mais!)
    const REAL_WHITE_PERCENT = 6.36;   // âœ… Branco: 636/10000 (1 a cada 15.7)
    
    console.log('%câš™ï¸ TAMANHOS MÃNIMOS PARA PADRÃ•ES:', 'color: #FFD700; font-weight: bold;');
    console.log(`%c   AlternÃ¢ncia Tripla: ${MIN_ALTERNANCIA_TRIPLA}+ giros (ex: P-P-P-V-V-V-P-P)`, 'color: #FFD700;');
    console.log(`%c   AlternÃ¢ncia Dupla: ${MIN_ALTERNANCIA_DUPLA}+ giros (ex: P-P-V-V-P-P)`, 'color: #FFD700;');
    console.log(`%c   AlternÃ¢ncia Simples: ${MIN_ALTERNANCIA_SIMPLES}+ giros (ex: P-V-P-V)`, 'color: #FFD700;');
    console.log(`%c   SequÃªncia: ${MIN_SEQUENCIA}+ giros (ex: P-P-P)`, 'color: #FFD700;');
    
    // Tentar alternÃ¢ncia tripla (8, 9, 12, 15, 18)
    // âœ… ComeÃ§a em 18 e vai descendo atÃ© o mÃ­nimo (8)
    for (let size = 18; size >= MIN_ALTERNANCIA_TRIPLA; size -= 3) {
        if (size > colors.length) continue;
        const sequence = colors.slice(0, size);
        if (checkAlternatingPattern(sequence, 3) && !sequence.includes('white')) {
            const patternName = `AlternÃ¢ncia Tripla de ${size} giros`;
            // ğŸ” VALIDAÃ‡ÃƒO RIGOROSA: Verificar se o padrÃ£o estÃ¡ REALMENTE correto
            const validation = validatePatternDetection(colors, 0, size, 'alternancia_tripla', 3, patternName);
            if (validation.valid) {
                bestPattern = {
                    type: 'alternancia_tripla',
                    size: size,
                    sequence: sequence.join('-'),
                    name: patternName
                };
                bestSize = size;
                break;
            } else {
                console.log(`%câŒ PadrÃ£o "${patternName}" rejeitado: ${validation.reason}`, 'color: #FF0000; font-weight: bold;');
            }
        }
    }
    
    // Tentar alternÃ¢ncia dupla (6, 10, 14, 18) - incremento de 4
    // âœ… MÃ­nimo reduzido para 6 giros (P-P-V-V-P-P)
    if (!bestPattern || bestSize < MIN_ALTERNANCIA_DUPLA) {
        for (let size = 20; size >= MIN_ALTERNANCIA_DUPLA; size -= 4) {
            if (size > colors.length) continue;
            const sequence = colors.slice(0, size);
            if (checkAlternatingPattern(sequence, 2) && !sequence.includes('white')) {
                const patternName = `AlternÃ¢ncia Dupla de ${size} giros`;
                // ğŸ” VALIDAÃ‡ÃƒO RIGOROSA: Verificar se o padrÃ£o estÃ¡ REALMENTE correto
                const validation = validatePatternDetection(colors, 0, size, 'alternancia_dupla', 2, patternName);
                if (validation.valid) {
                    bestPattern = {
                        type: 'alternancia_dupla',
                        size: size,
                        sequence: sequence.join('-'),
                        name: patternName
                    };
                    bestSize = size;
                    break;
                } else {
                    console.log(`%câŒ PadrÃ£o "${patternName}" rejeitado: ${validation.reason}`, 'color: #FF0000; font-weight: bold;');
                }
            }
        }
    }
    
    // Tentar alternÃ¢ncia simples (4, 6, 8, 10, 12, 14, 16, 18, 20)
    // âœ… MÃ­nimo reduzido para 4 giros (P-V-P-V) - jÃ¡ dÃ¡ para prever!
    if (!bestPattern || bestSize < MIN_ALTERNANCIA_SIMPLES) {
        for (let size = 20; size >= MIN_ALTERNANCIA_SIMPLES; size -= 2) {
            if (size > colors.length) continue;
            const sequence = colors.slice(0, size);
            if (checkAlternatingPattern(sequence, 1) && !sequence.includes('white')) {
                const patternName = `AlternÃ¢ncia Simples de ${size} giros`;
                // ğŸ” VALIDAÃ‡ÃƒO RIGOROSA: Verificar se o padrÃ£o estÃ¡ REALMENTE correto
                const validation = validatePatternDetection(colors, 0, size, 'alternancia_simples', 1, patternName);
                if (validation.valid) {
                    bestPattern = {
                        type: 'alternancia_simples',
                        size: size,
                        sequence: sequence.join('-'),
                        name: patternName
                    };
                    bestSize = size;
                    break;
                } else {
                    console.log(`%câŒ PadrÃ£o "${patternName}" rejeitado: ${validation.reason}`, 'color: #FF0000; font-weight: bold;');
                }
            }
        }
    }
    
    // Tentar sequÃªncias (mesma cor) - MÃNIMO 4 GIROS
    if (!bestPattern || bestSize < MIN_SEQUENCIA) {
        for (let size = 15; size >= MIN_SEQUENCIA; size--) {
            if (size > colors.length) continue;
            const sequence = colors.slice(0, size);
            const firstColor = sequence[0];
            if (sequence.every(c => c === firstColor) && firstColor !== 'white') {
                const patternName = `SequÃªncia de ${size} ${firstColor === 'red' ? 'Vermelhos' : 'Pretos'}`;
                // ğŸ” VALIDAÃ‡ÃƒO RIGOROSA: Verificar se o padrÃ£o estÃ¡ REALMENTE correto
                const validation = validatePatternDetection(colors, 0, size, 'sequencia_' + firstColor, 1, patternName);
                if (validation.valid) {
                    bestPattern = {
                        type: 'sequencia_' + firstColor,
                        size: size,
                        sequence: sequence.join('-'),
                        name: patternName
                    };
                    bestSize = size;
                    break;
                } else {
                    console.log(`%câŒ PadrÃ£o "${patternName}" rejeitado: ${validation.reason}`, 'color: #FF0000; font-weight: bold;');
                }
            }
        }
    }
    
    if (bestPattern) {
        console.log('%câœ… PADRÃƒO ATIVO ENCONTRADO:', 'color: #00FF00; font-weight: bold;');
        console.log(`%c   ${bestPattern.name}`, 'color: #00FF88; font-weight: bold;');
        console.log(`%c   SequÃªncia: ${bestPattern.sequence}`, 'color: #00FF88;');
        
        // Adicionar contexto (o que veio antes)
        const contextStart = bestSize;
        const contextEnd = Math.min(contextStart + 4, colors.length);
        bestPattern.contextBefore = colors.slice(contextStart, contextEnd).join('-');
        
        return bestPattern;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” SE NÃƒO ENCONTROU PADRÃƒO FIXO, TENTAR PADRÃ•ES IRREGULARES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%câš ï¸ Nenhum padrÃ£o fixo detectado', 'color: #FFAA00; font-weight: bold;');
    console.log('%cğŸ” Tentando detectar PADRÃ•ES IRREGULARES...', 'color: #FF00FF; font-weight: bold;');
    
    const irregularPattern = detectIrregularPattern(colors);
    if (irregularPattern) {
        console.log(`%câœ… PADRÃƒO IRREGULAR DETECTADO:`, 'color: #FF00FF; font-weight: bold;');
        console.log(`%c   ${irregularPattern.name}`, 'color: #FF00FF; font-weight: bold;');
        console.log(`%c   SequÃªncia: ${irregularPattern.sequence}`, 'color: #FF00FF;');
        return irregularPattern;
    }
    
    console.log('%cğŸ” Tentando anÃ¡lise por SIMILARIDADE...', 'color: #00CED1; font-weight: bold;');
    
    const similarityPattern = findPatternBySimilarity(last20Spins);
    
    // âœ… GARANTIA: similarityPattern SEMPRE retorna algo (nunca null)
    if (similarityPattern) {
        const levelText = similarityPattern.level ? ` (NÃ­vel ${similarityPattern.level})` : '';
        console.log(`%câœ… PADRÃƒO POR SIMILARIDADE ENCONTRADO${levelText}:`, 'color: #00FF00; font-weight: bold;');
        console.log(`%c   ${similarityPattern.name}`, 'color: #00FF88; font-weight: bold;');
        console.log(`%c   SequÃªncia: ${similarityPattern.sequence}`, 'color: #00FF88;');
        
        if (similarityPattern.forced) {
            console.log('%c   âš ï¸ AnÃ¡lise forÃ§ada (sem padrÃ£o forte detectado)', 'color: #FFA500;');
        }
        if (similarityPattern.minimal) {
            console.log('%c   âš ï¸ AnÃ¡lise mÃ­nima (confianÃ§a serÃ¡ reduzida)', 'color: #FFA500;');
        }
        
        return similarityPattern;
    }
    
    // âŒ ISSO NUNCA DEVE ACONTECER! (fallback extremo)
    console.error('%câŒ ERRO CRÃTICO: Similaridade retornou null!', 'color: #FF0000; font-weight: bold;');
    console.error('%c   Isso nÃ£o deveria acontecer. Sistema tem bug!', 'color: #FF0000;');
    
    return null;
}

/**
 * ğŸ” BUSCAR PADRÃƒO POR SIMILARIDADE
 * Quando nÃ£o hÃ¡ padrÃ£o fixo, buscar situaÃ§Ãµes similares no histÃ³rico
 */
function findPatternBySimilarity(last20Spins) {
    const colors = last20Spins.map(spin => spin.color);
    
    console.log('%cğŸ” ANÃLISE POR SIMILARIDADE (Busca Inteligente)', 'color: #00CED1; font-weight: bold;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 1: DETECTAR SEQUÃŠNCIAS RECENTES (mesmo que curtas)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Contar quantas cores iguais no inÃ­cio (giros 1, 2, 3...)
    let currentStreak = 1;
    const firstColor = colors[0];
    
    for (let i = 1; i < Math.min(10, colors.length); i++) {
        if (colors[i] === firstColor && colors[i] !== 'white') {
            currentStreak++;
        } else {
            break;
        }
    }
    
    console.log(`%cğŸ“Š SITUAÃ‡ÃƒO ATUAL:`, 'color: #00CED1; font-weight: bold;');
    console.log(`%c   Cor mais recente: ${firstColor === 'red' ? 'VERMELHO' : firstColor === 'black' ? 'PRETO' : 'BRANCO'}`, 'color: #00CED1;');
    console.log(`%c   SequÃªncia atual: ${currentStreak} giro(s) da mesma cor`, 'color: #00CED1;');
    
    // ğŸ¯ NÃVEL 1: SequÃªncias de 4+ giros (MÃNIMO ACEITÃVEL)
    if (currentStreak >= 4 && firstColor !== 'white') {
        console.log(`%cğŸ¯ NÃVEL 1: Detectado ${currentStreak} ${firstColor === 'red' ? 'VERMELHOS' : 'PRETOS'} seguidos!`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c   Vamos buscar no histÃ³rico: o que acontece apÃ³s ${currentStreak} cores iguais?`, 'color: #FFD700;');
        
        const sequence = colors.slice(0, currentStreak);
        return {
            type: 'sequencia_' + firstColor,
            size: currentStreak,
            sequence: sequence.join('-'),
            name: `SequÃªncia de ${currentStreak} ${firstColor === 'red' ? 'Vermelhos' : 'Pretos'}`,
            contextBefore: colors.slice(currentStreak, Math.min(currentStreak + 4, colors.length)).join('-'),
            isSimilarity: true,
            level: 1
        };
    }
    
    // âŒ NÃVEL 2 REMOVIDO: 2-3 giros NÃƒO sÃ£o suficientes para anÃ¡lise!
    // 2 pretos ou 2 vermelhos saem O TEMPO TODO no jogo!
    // NÃ£o dÃ¡ para fazer previsÃ£o com isso!
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ETAPA 2: DETECTAR ALTERNÃ‚NCIAS IMPERFEITAS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Contar alternÃ¢ncias nos primeiros 6-8 giros (mesmo com branco no meio)
    let alternations = 0;
    let lastNonWhite = null;
    
    for (let i = 0; i < Math.min(8, colors.length); i++) {
        if (colors[i] !== 'white') {
            if (lastNonWhite && colors[i] !== lastNonWhite) {
                alternations++;
            }
            lastNonWhite = colors[i];
        }
    }
    
    console.log(`%cğŸ”„ ALTERNÃ‚NCIAS DETECTADAS: ${alternations}`, 'color: #9370DB;');
    
    // âœ… NÃVEL 3 REATIVADO: AlternÃ¢ncias sÃ£o ÃšTEIS!
    // Com 10 mil giros de dados, mesmo padrÃµes comuns tÃªm estatÃ­stica vÃ¡lida!
    
    if (alternations >= 3) {
        console.log(`%cğŸ¯ NÃVEL 3: Comportamento de ALTERNÃ‚NCIA (${alternations} mudanÃ§as)!`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c   Vamos buscar no histÃ³rico: padrÃµes de alternÃ¢ncia similares`, 'color: #FFD700;');
        
        const nonWhiteSequence = colors.filter(c => c !== 'white').slice(0, 6);
        
        return {
            type: 'alternancia_simples',
            size: nonWhiteSequence.length,
            sequence: nonWhiteSequence.join('-'),
            name: `AlternÃ¢ncia com ${alternations} mudanÃ§as (${nonWhiteSequence.length} giros)`,
            contextBefore: colors.slice(6, 10).join('-'),
            isSimilarity: true,
            level: 3
        };
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ NÃVEL 4: ANÃLISE DOS ÃšLTIMOS 5-7 GIROS (PADRÃ•ES ESPECÃFICOS)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    console.log('%cğŸ¯ NÃVEL 4: Analisando Ãºltimos 5-7 giros', 'color: #FF6B35; font-weight: bold;');
    console.log('%c   Buscando padrÃµes ESPECÃFICOS (nÃ£o genÃ©ricos)', 'color: #FF6B35;');
    
    // Pegar os Ãºltimos 5-7 giros (ignorando brancos)
    const last7NonWhite = colors.filter(c => c !== 'white').slice(0, 7);
    
    if (last7NonWhite.length >= 5) {
        console.log(`%c   SequÃªncia dos Ãºltimos ${last7NonWhite.length} giros (sem branco):`, 'color: #FF6B35;');
        console.log(`%c   ${last7NonWhite.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #FF6B35;');
        
        const firstColor = last7NonWhite[0];
        let patternType = 'sequencia_mixed';
        let patternName = '';
        
        // Verificar se Ã© sequÃªncia da mesma cor (5+ iguais)
        if (last7NonWhite.every(c => c === firstColor)) {
            patternType = 'sequencia_' + firstColor;
            patternName = `SequÃªncia de ${last7NonWhite.length} ${firstColor === 'red' ? 'Vermelhos' : 'Pretos'}`;
            console.log(`%c   âœ… PADRÃƒO ESPECÃFICO: ${patternName}`, 'color: #00FF00; font-weight: bold;');
        } else {
            // Verificar alternÃ¢ncia dupla (PP-VV-PP ou VV-PP-VV)
            let isAlternanceDupla = true;
            for (let i = 0; i < last7NonWhite.length - 1; i += 2) {
                if (i + 1 < last7NonWhite.length) {
                    if (last7NonWhite[i] !== last7NonWhite[i + 1]) {
                        isAlternanceDupla = false;
                        break;
                    }
                }
            }
            
            if (isAlternanceDupla && last7NonWhite.length >= 6) {
                patternType = 'alternancia_dupla';
                patternName = `AlternÃ¢ncia Dupla de ${last7NonWhite.length} giros`;
                console.log(`%c   âœ… PADRÃƒO ESPECÃFICO: ${patternName}`, 'color: #00FF00; font-weight: bold;');
            } else {
                // NÃ£o Ã© um padrÃ£o especÃ­fico suficiente - rejeitar
                console.log(`%c   âŒ NÃƒO Ã© padrÃ£o especÃ­fico (nem sequÃªncia nem alternÃ¢ncia dupla)`, 'color: #FF6B35;');
                console.log(`%c   Pulando para NÃ­vel 5 (fallback)...`, 'color: #FF6B35;');
                // NÃ£o retornar nada - deixar cair no NÃ­vel 5
            }
        }
        
        // Se encontrou padrÃ£o especÃ­fico, retornar
        if (patternName) {
            console.log(`%c   Buscando no histÃ³rico: o que veio apÃ³s ${patternName}?`, 'color: #FFD700;');
            
            return {
                type: patternType,
                size: last7NonWhite.length,
                sequence: last7NonWhite.join('-'),
                name: patternName,
                contextBefore: colors.slice(7, 11).join('-'),
                isSimilarity: true,
                level: 4
            };
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ NÃVEL 5: FALLBACK - SEMPRE ENCONTRA ALGO (mÃ­nimo 3 giros)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    console.log('%cğŸ¯ NÃVEL 5: FALLBACK - AnÃ¡lise dos Ãºltimos 3-5 giros disponÃ­veis', 'color: #FFA500; font-weight: bold;');
    console.log('%c   Garantindo que SEMPRE haja uma anÃ¡lise baseada em histÃ³rico', 'color: #FFA500;');
    
    // Pegar os Ãºltimos 3-5 giros nÃ£o-brancos (SEMPRE terÃ¡ ao menos 1)
    const last5NonWhite = colors.filter(c => c !== 'white').slice(0, 5);
    
    if (last5NonWhite.length >= 3) {
        console.log(`%c   âœ… Usando Ãºltimos ${last5NonWhite.length} giros para anÃ¡lise`, 'color: #FFA500;');
        console.log(`%c   SequÃªncia: ${last5NonWhite.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #FFA500;');
        
        const firstColor = last5NonWhite[0];
        let patternType = 'sequencia_mixed';
        
        // Verificar se Ã© sequÃªncia da mesma cor
        if (last5NonWhite.every(c => c === firstColor)) {
            patternType = 'sequencia_' + firstColor;
        } else {
            patternType = 'alternancia_simples';
        }
        
        return {
            type: patternType,
            size: last5NonWhite.length,
            sequence: last5NonWhite.join('-'),
            name: `AnÃ¡lise Fallback (${last5NonWhite.length} giros)`,
            contextBefore: colors.slice(5, 9).join('-'),
            isSimilarity: true,
            level: 5,
            forced: true,
            minimal: true // Indica anÃ¡lise mÃ­nima - aplica penalidade
        };
    }
    
    // âš ï¸ ÃšLTIMO RECURSO: Pegar ao menos os Ãºltimos 2 giros
    if (last5NonWhite.length >= 2) {
        console.log(`%c   âš ï¸ MÃNIMO: Usando Ãºltimos ${last5NonWhite.length} giros`, 'color: #FF6B35;');
        console.log(`%c   SequÃªncia: ${last5NonWhite.map(c => c === 'red' ? 'V' : 'P').join('-')}`, 'color: #FF6B35;');
        
        const firstColor = last5NonWhite[0];
        
        return {
            type: 'sequencia_mixed',
            size: last5NonWhite.length,
            sequence: last5NonWhite.join('-'),
            name: `AnÃ¡lise MÃ­nima (${last5NonWhite.length} giros)`,
            contextBefore: colors.slice(2, 6).join('-'),
            isSimilarity: true,
            level: 5,
            forced: true,
            minimal: true
        };
    }
    
    // ğŸš¨ SITUAÃ‡ÃƒO EXTREMA: NÃ£o hÃ¡ giros suficientes (muito raro)
    // âœ… MAS MESMO ASSIM, NUNCA RETORNAR NULL!
    console.log('%cğŸš¨ SITUAÃ‡ÃƒO EXTREMA: Menos de 2 giros vÃ¡lidos!', 'color: #FF0000; font-weight: bold;');
    console.log('%c   Isso Ã© MUITO raro - pode ser inÃ­cio do jogo', 'color: #FF0000;');
    console.log('%c   Usando o ÃšLTIMO giro como base...', 'color: #FFAA00;');
    
    const lastColor = last20NonWhite[0] || 'red';
    
    return {
        type: 'sequencia_mixed',
        size: 1,
        sequence: lastColor,
        name: 'AnÃ¡lise Ultra-MÃ­nima (1 giro)',
        contextBefore: '',
        isSimilarity: true,
        level: 5,
        forced: true,
        minimal: true,
        emergency: true
    };
}

/**
 * BUSCAR TODAS AS OCORRÃŠNCIAS DE UM PADRÃƒO NO HISTÃ“RICO
 * Retorna distribuiÃ§Ã£o completa (quantas vezes parou em cada tamanho)
 */
function searchPatternInHistory(activePattern, allPatterns, history) {
    console.log('%cğŸ“š BUSCANDO PADRÃƒO NO HISTÃ“RICO', 'color: #00CED1; font-weight: bold;');
    
    // Buscar todas as ocorrÃªncias do mesmo TIPO de padrÃ£o
    const sameTypePatterns = allPatterns.filter(p => p.type === activePattern.type);
    
    console.log(`%cPadrÃ£o buscado: ${activePattern.name}`, 'color: #00CED1;');
    console.log(`%cOcorrÃªncias encontradas: ${sameTypePatterns.length}`, 'color: #00CED1;');
    
    if (sameTypePatterns.length === 0) {
        console.log('%câš ï¸ Nenhuma ocorrÃªncia EXATA deste padrÃ£o no histÃ³rico', 'color: #FFAA00;');
        console.log('%c   Mas com 10k giros, SEMPRE hÃ¡ padrÃµes similares!', 'color: #00FFFF;');
        console.log('%c   Usando estatÃ­sticas GERAIS do tipo de padrÃ£o...', 'color: #00FFFF;');
        
        // âœ… FALLBACK: Usar estatÃ­sticas gerais para este TIPO de padrÃ£o
        // Mesmo sem ocorrÃªncias exatas, temos dados histÃ³ricos!
        return {
            occurrences: 1,
            avgSize: activePattern.size,
            mostCommonSize: activePattern.size,
            nextColor: {
                red: 1,
                black: 1,
                white: 0,
                redPercent: 50,
                blackPercent: 50,
                whitePercent: 0
            },
            confidence: 50,
            isFallback: true
        };
    }
    
    // âœ… NOVA FILOSOFIA: QUANTO MAIS OCORRÃŠNCIAS, MELHOR!
    // Com 10 mil giros, temos dados estatÃ­sticos sÃ³lidos para QUALQUER padrÃ£o!
    // NÃ£o rejeitar mais padrÃµes "genÃ©ricos" - eles sÃ£o ÃšTEIS porque tÃªm muitos dados!
    
    console.log(`%câœ… ANÃLISE ESTATÃSTICA: ${sameTypePatterns.length} ocorrÃªncias encontradas`, 'color: #00FF00; font-weight: bold;');
    console.log(`%c   Representa ${((sameTypePatterns.length / history.length) * 100).toFixed(1)}% do histÃ³rico total`, 'color: #00FF88;');
    
    if (sameTypePatterns.length >= 50) {
        console.log('%c   ğŸ¯ EXCELENTE! Muitos dados = EstatÃ­stica CONFIÃVEL!', 'color: #00FF00; font-weight: bold;');
    } else if (sameTypePatterns.length >= 20) {
        console.log('%c   âœ… BOM: Dados suficientes para anÃ¡lise estatÃ­stica', 'color: #00FF88;');
    } else if (sameTypePatterns.length >= 5) {
        console.log('%c   âš ï¸ ACEITÃVEL: Poucos dados, mas utilizÃ¡vel', 'color: #FFAA00;');
    } else {
        console.log('%c   âš ï¸ MUITO POUCO: Menos de 5 ocorrÃªncias - confianÃ§a baixa', 'color: #FF6B35;');
    }
    
    // Calcular distribuiÃ§Ã£o de tamanhos
    const distribution = {};
    const nextColorStats = { red: 0, black: 0, white: 0 };
    
    sameTypePatterns.forEach(pattern => {
        // Contar tamanho
        if (!distribution[pattern.size]) {
            distribution[pattern.size] = 0;
        }
        distribution[pattern.size]++;
        
        // Contar cor que veio depois
        if (pattern.whatCameNext) {
            nextColorStats[pattern.whatCameNext]++;
        }
    });
    
    console.log('%cğŸ“Š DISTRIBUIÃ‡ÃƒO DE TAMANHOS:', 'color: #00CED1; font-weight: bold;');
    Object.keys(distribution).sort((a, b) => distribution[b] - distribution[a]).forEach(size => {
        const count = distribution[size];
        const percent = ((count / sameTypePatterns.length) * 100).toFixed(1);
        console.log(`   ${size} giros: ${count} vezes (${percent}%)`);
    });
    
    const totalNext = nextColorStats.red + nextColorStats.black + nextColorStats.white;
    const redPercent = ((nextColorStats.red / totalNext) * 100).toFixed(1);
    const blackPercent = ((nextColorStats.black / totalNext) * 100).toFixed(1);
    const whitePercent = ((nextColorStats.white / totalNext) * 100).toFixed(1);
    
    console.log('%cğŸ¯ COR QUE VEIO DEPOIS:', 'color: #00CED1; font-weight: bold;');
    console.log(`   %cVERMELHO: ${nextColorStats.red} vezes (${redPercent}%)`, 'color: #FF0000; font-weight: bold;');
    console.log(`   %cPRETO: ${nextColorStats.black} vezes (${blackPercent}%)`, 'color: #FFFFFF; font-weight: bold;');
    console.log(`   %cBRANCO: ${nextColorStats.white} vezes (${whitePercent}%)`, 'color: #00FF00; font-weight: bold;');
    
    // Encontrar tamanho mais comum
    const mostCommonSize = Object.keys(distribution).sort((a, b) => distribution[b] - distribution[a])[0];
    const avgSize = sameTypePatterns.reduce((sum, p) => sum + p.size, 0) / sameTypePatterns.length;
    
    return {
        occurrences: sameTypePatterns.length,
        distribution: distribution,
        mostCommonSize: parseInt(mostCommonSize),
        averageSize: avgSize.toFixed(1),
        nextColor: {
            red: nextColorStats.red,
            black: nextColorStats.black,
            white: nextColorStats.white,
            redPercent: parseFloat(redPercent),
            blackPercent: parseFloat(blackPercent),
            whitePercent: parseFloat(whitePercent)
        }
    };
}

/**
 * VERIFICAR ACERTOS DOS SINAIS ANTERIORES
 * Atualiza estatÃ­sticas quando um novo giro acontece
 */
async function checkPreviousSignalAccuracy(newSpin) {
    // âœ… VERIFICAÃ‡ÃƒO DE SEGURANÃ‡A: signalsHistory pode estar undefined
    if (!signalsHistory || !signalsHistory.signals || signalsHistory.signals.length === 0) {
        console.log('âš ï¸ signalsHistory nÃ£o inicializado ou vazio - pulando verificaÃ§Ã£o');
        return;
    }
    
    // Pegar Ãºltimo sinal enviado que ainda nÃ£o foi verificado
    const lastSignal = signalsHistory.signals[signalsHistory.signals.length - 1];
    
    if (lastSignal.verified) return; // JÃ¡ foi verificado
    
    
    const colorThatCame = newSpin.color;
    const colorRecommended = lastSignal.colorRecommended;
    const hit = colorThatCame === colorRecommended;
    
    console.log(`%cSinal anterior recomendou: ${colorRecommended.toUpperCase()}`, 'color: #FF69B4;');
    console.log(`%cCor que saiu: ${colorThatCame.toUpperCase()}`, 'color: #FF69B4;');
    console.log(`%cResultado: ${hit ? 'âœ… ACERTOU!' : 'âŒ ERROU'}`, hit ? 'color: #00FF00; font-weight: bold;' : 'color: #FF0000; font-weight: bold;');
    
    // Atualizar sinal
    lastSignal.colorThatCame = colorThatCame;
    lastSignal.hit = hit;
    lastSignal.verified = true;
    
    // ğŸ”¥ ATUALIZAR CONTROLE DE ALTERNÃ‚NCIA (SE ATIVO)
    if (alternanceEntryControl.active && lastSignal.patternType === 'nivel-diamante') {
        console.log('%cğŸ”„ Atualizando controle de alternÃ¢ncia...', 'color: #8E44AD; font-weight: bold;');
        console.log(`   Resultado: ${hit ? 'WIN' : 'LOSS'}`);
        console.log(`   Entrada atual: ${alternanceEntryControl.entryCount}/2`);
        
        alternanceEntryControl.lastResult = hit ? 'win' : 'loss';
        
        if (hit) {
            alternanceEntryControl.totalWins++;
            console.log(`%c   âœ… WIN registrado! Total: ${alternanceEntryControl.totalWins}W / ${alternanceEntryControl.totalLosses}L`, 'color: #00FF88; font-weight: bold;');
        } else {
            alternanceEntryControl.totalLosses++;
            console.log(`%c   âŒ LOSS registrado! Total: ${alternanceEntryControl.totalWins}W / ${alternanceEntryControl.totalLosses}L`, 'color: #FF6666; font-weight: bold;');
            
            // ğŸ”¥ Se LOSS na 1Âª entrada ou se jÃ¡ fez 2 entradas â†’ RESETAR controle
            if (alternanceEntryControl.entryCount <= 1 || alternanceEntryControl.entryCount >= 2) {
                console.log('%c   ğŸ”„ RESETANDO controle de alternÃ¢ncia', 'color: #FFAA00; font-weight: bold;');
                alternanceEntryControl.active = false;
                alternanceEntryControl.patternSignature = null;
                alternanceEntryControl.entryColor = null;
                alternanceEntryControl.entryCount = 0;
                alternanceEntryControl.lastResult = null;
                alternanceEntryControl.lastEntryTimestamp = null;
            }
        }
        
        // Se fez 2 entradas e teve WIN, resetar tambÃ©m
        if (hit && alternanceEntryControl.entryCount >= 2) {
            console.log('%c   âœ… 2 entradas completas! RESETANDO controle de alternÃ¢ncia', 'color: #00FF88; font-weight: bold;');
            alternanceEntryControl.active = false;
            alternanceEntryControl.patternSignature = null;
            alternanceEntryControl.entryColor = null;
            alternanceEntryControl.entryCount = 0;
            alternanceEntryControl.lastResult = null;
            alternanceEntryControl.lastEntryTimestamp = null;
        }
    }
    
    // Atualizar estatÃ­sticas por padrÃ£o
    const patternKey = `${lastSignal.patternType}_${lastSignal.patternSize}`;
    if (!signalsHistory.patternStats[patternKey]) {
        signalsHistory.patternStats[patternKey] = {
            total: 0,
            hits: 0,
            misses: 0,
            hitRate: 0
        };
    }
    
    signalsHistory.patternStats[patternKey].total++;
    if (hit) {
        signalsHistory.patternStats[patternKey].hits++;
    } else {
        signalsHistory.patternStats[patternKey].misses++;
    }
    signalsHistory.patternStats[patternKey].hitRate = 
        (signalsHistory.patternStats[patternKey].hits / signalsHistory.patternStats[patternKey].total * 100).toFixed(1);
    
    // Atualizar estatÃ­sticas por contexto
    const contextKey = `${lastSignal.patternType}_${lastSignal.contextBefore}`;
    if (!signalsHistory.contextStats[contextKey]) {
        signalsHistory.contextStats[contextKey] = {
            total: 0,
            hits: 0,
            hitRate: 0
        };
    }
    
    signalsHistory.contextStats[contextKey].total++;
    if (hit) {
        signalsHistory.contextStats[contextKey].hits++;
    }
    signalsHistory.contextStats[contextKey].hitRate = 
        (signalsHistory.contextStats[contextKey].hits / signalsHistory.contextStats[contextKey].total * 100).toFixed(1);
    
    console.log(`%cğŸ“Š EstatÃ­sticas do padrÃ£o "${lastSignal.patternName}":`, 'color: #FF69B4; font-weight: bold;');
    console.log(`   Total de sinais: ${signalsHistory.patternStats[patternKey].total}`);
    console.log(`   Acertos: ${signalsHistory.patternStats[patternKey].hits}`);
    console.log(`   Erros: ${signalsHistory.patternStats[patternKey].misses}`);
    console.log(`   %cTaxa de acerto: ${signalsHistory.patternStats[patternKey].hitRate}%`, 'color: #FFD700; font-weight: bold;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š RASTREAMENTO DE LOSSES CONSECUTIVOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Atualizar contador de losses consecutivos
    if (hit) {
        signalsHistory.consecutiveLosses = 0; // âœ… Resetar ao acertar
        console.log('%câœ… LOSS CONSECUTIVOS RESETADO!', 'color: #00FF00; font-weight: bold;');
    } else {
        signalsHistory.consecutiveLosses++; // âŒ Incrementar ao errar
        console.log(`%câš ï¸ LOSS CONSECUTIVOS: ${signalsHistory.consecutiveLosses}`, 'color: #FF0000; font-weight: bold;');
        
        // ğŸš¨ ALERTA: Se chegou a 2 losses consecutivos
        if (signalsHistory.consecutiveLosses >= 2) {
            console.log('%câš ï¸âš ï¸âš ï¸ ATENÃ‡ÃƒO: 2+ LOSSES CONSECUTIVOS! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; background: #FFFF00;');
            console.log('%c   Sistema vai AUMENTAR o mÃ­nimo para proteger o usuÃ¡rio!', 'color: #FF6B6B; font-weight: bold;');
        }
    }
    
    // Atualizar performance recente (Ãºltimos 20 sinais)
    signalsHistory.recentPerformance.push({
        timestamp: Date.now(),
        hit: hit,
        patternKey: patternKey
    });
    
    // Manter apenas os Ãºltimos 20
    if (signalsHistory.recentPerformance.length > 20) {
        signalsHistory.recentPerformance = signalsHistory.recentPerformance.slice(-20);
    }
    
    // Calcular taxa de acerto recente (Ãºltimos 20 sinais)
    const recentHits = signalsHistory.recentPerformance.filter(s => s.hit).length;
    const recentTotal = signalsHistory.recentPerformance.length;
    const recentHitRate = recentTotal > 0 ? ((recentHits / recentTotal) * 100).toFixed(1) : 0;
    
    console.log(`%cğŸ“Š PERFORMANCE RECENTE (Ãºltimos ${recentTotal} sinais):`, 'color: #00CED1; font-weight: bold;');
    console.log(`   Acertos: ${recentHits}/${recentTotal} (${recentHitRate}%)`);
    
    // ğŸš¨ ALERTA: Se performance recente < 50%, avisar!
    if (recentTotal >= 10 && parseFloat(recentHitRate) < 50) {
        console.log('%câš ï¸âš ï¸âš ï¸ ALERTA: PERFORMANCE RECENTE MUITO BAIXA! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #FFFF00;');
        console.log(`%c   Taxa de acerto: ${recentHitRate}% (mÃ­nimo recomendado: 55%)`, 'color: #FF0000; font-weight: bold;');
        console.log('%c   AÃ‡ÃƒO: Sistema irÃ¡ AUMENTAR o mÃ­nimo exigido automaticamente!', 'color: #FFA500; font-weight: bold;');
    }
    
    // Salvar
    await saveSignalsHistory();
}

/**
 * âœ… CALCULAR AJUSTE DE CONFIANÃ‡A BASEADO EM PERFORMANCE
 * Ajuste PROPORCIONAL baseado na diferenÃ§a entre performance real e esperada
 */
function calculateConfidenceAdjustment(patternType, patternSize, contextBefore) {
    const patternKey = `${patternType}_${patternSize}`;
    const contextKey = `${patternType}_${contextBefore}`;
    
    let adjustment = 0;
    let reasons = [];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AJUSTE 1: Baseado na performance do padrÃ£o
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (signalsHistory.patternStats[patternKey]) {
        const stats = signalsHistory.patternStats[patternKey];
        const hitRate = parseFloat(stats.hitRate);
        
        if (stats.total >= 3) { // MÃ­nimo 3 sinais para ter significÃ¢ncia estatÃ­stica
            // FÃ“RMULA: Ajuste = (Taxa Real - 50%) Ã— Peso
            // 50% = Expectativa neutra (como jogar moeda)
            // Se taxa > 50% = padrÃ£o bom (ajuste positivo)
            // Se taxa < 50% = padrÃ£o ruim (ajuste negativo)
            
            const expectedRate = 50; // 50% = neutro (chance aleatÃ³ria)
            const difference = hitRate - expectedRate;
            
            // Peso baseado na quantidade de amostras (mais amostras = mais confiÃ¡vel)
            let sampleWeight = 1.0;
            if (stats.total >= 10) sampleWeight = 1.5; // 10+ amostras = peso maior
            if (stats.total >= 20) sampleWeight = 2.0; // 20+ amostras = peso ainda maior
            
            // Ajuste proporcional com limite
            const calculatedAdjustment = (difference * 0.4 * sampleWeight); // 0.4 = fator de escala
            adjustment += Math.max(-25, Math.min(20, calculatedAdjustment)); // Limita entre -25% e +20%
            
            const sign = calculatedAdjustment >= 0 ? '+' : '';
            reasons.push(`PadrÃ£o: ${hitRate}% de acerto (${stats.hits}/${stats.total}) | Ajuste: ${sign}${adjustment.toFixed(1)}%`);
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AJUSTE 2: Baseado no contexto especÃ­fico
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (signalsHistory.contextStats[contextKey]) {
        const stats = signalsHistory.contextStats[contextKey];
        const hitRate = parseFloat(stats.hitRate);
        
        if (stats.total >= 2) { // MÃ­nimo 2 sinais
            // FÃ“RMULA: Ajuste = (Taxa Real - 50%) Ã— 0.3
            const expectedRate = 50;
            const difference = hitRate - expectedRate;
            const contextAdjustment = Math.max(-15, Math.min(15, difference * 0.3));
            
            adjustment += contextAdjustment;
            
            if (Math.abs(contextAdjustment) > 0.5) {
                const sign = contextAdjustment >= 0 ? '+' : '';
                reasons.push(`Contexto: ${hitRate}% de acerto (${stats.hits}/${stats.total}) | Ajuste: ${sign}${contextAdjustment.toFixed(1)}%`);
            }
        }
    }
    
    return { adjustment, reasons };
}

/**
 * âœ… ANÃLISE DE "TEMPERATURA" DOS ÃšLTIMOS 20 GIROS
 * Detecta se a Blaze estÃ¡ "quente" (sequÃªncias longas) ou "fria" (quebrando rÃ¡pido)
 */
function analyzeLast20Temperature(last20Spins, activePattern) {
    // âœ… Constantes baseadas em 10.000 giros reais da Blaze
    const MAX_SEQUENCIA_HISTORICO = 11; // âœ… MÃ¡ximo visto: 11 (1x cada cor em 10k)
    
    const colors = last20Spins.map(s => s.color);
    
    console.log('%cğŸŒ¡ï¸ ANÃLISE DE TEMPERATURA DOS ÃšLTIMOS 20 GIROS', 'color: #FF6B35; font-weight: bold;');
    
    // Detectar todas as sequÃªncias e alternÃ¢ncias nos Ãºltimos 20 giros
    let sequencesFound = [];
    let i = 0;
    
    while (i < colors.length) {
        const currentColor = colors[i];
        if (currentColor === 'white') {
            i++;
            continue;
        }
        
        // Contar sequÃªncia da mesma cor
        let seqLength = 1;
        while (i + seqLength < colors.length && colors[i + seqLength] === currentColor) {
            seqLength++;
        }
        
        sequencesFound.push({
            type: seqLength >= 2 ? 'sequencia' : 'single',
            color: currentColor,
            length: seqLength,
            position: i
        });
        
        i += seqLength;
    }
    
    // Calcular estatÃ­sticas
    const totalSequences = sequencesFound.filter(s => s.type === 'sequencia').length;
    const longSequences = sequencesFound.filter(s => s.length >= 4).length; // 4+ mesma cor
    const veryLongSequences = sequencesFound.filter(s => s.length >= 6).length; // 6+ mesma cor
    
    // Detectar se estÃ¡ em modo "alternÃ¢ncia rÃ¡pida" ou "sequÃªncias longas"
    let avgSequenceLength = 0;
    if (sequencesFound.length > 0) {
        avgSequenceLength = sequencesFound.reduce((sum, s) => sum + s.length, 0) / sequencesFound.length;
    }
    
    console.log('%cğŸ“Š ESTATÃSTICAS DOS ÃšLTIMOS 20 GIROS:', 'color: #FF6B35; font-weight: bold;');
    console.log(`   Total de sequÃªncias: ${totalSequences}`);
    console.log(`   SequÃªncias longas (4+): ${longSequences}`);
    console.log(`   SequÃªncias muito longas (6+): ${veryLongSequences}`);
    console.log(`   Tamanho mÃ©dio: ${avgSequenceLength.toFixed(1)} giros`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âœ… DETERMINAR TEMPERATURA COM CÃLCULOS FUNDAMENTADOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let temperature = 'NEUTRA';
    let adjustment = 0;
    let reasoning = '';
    
    // FÃ“RMULA: Intensidade de SequÃªncias = (Soma dos tamanhos das sequÃªncias longas) / 20 giros
    // Quanto maior a intensidade, mais "quente" estÃ¡ a Blaze
    const longSequencesIntensity = sequencesFound
        .filter(s => s.length >= 3)
        .reduce((sum, s) => sum + s.length, 0) / 20;
    
    // FÃ“RMULA: Score de Temperatura = (MÃ©dia Ã— 10) + (SequÃªncias longas Ã— 5) + (Intensidade Ã— 20)
    const temperatureScore = (avgSequenceLength * 10) + (longSequences * 5) + (longSequencesIntensity * 20);
    
    console.log(`%cğŸŒ¡ï¸ CÃLCULOS DE TEMPERATURA:`, 'color: #FF6B35; font-weight: bold;');
    console.log(`   Intensidade de sequÃªncias: ${(longSequencesIntensity * 100).toFixed(1)}%`);
    console.log(`   Score de temperatura: ${temperatureScore.toFixed(1)}`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CLASSIFICAÃ‡ÃƒO DE TEMPERATURA (baseada no score)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // TEMPERATURA QUENTE: Score >= 45 (muitas sequÃªncias longas)
    if (temperatureScore >= 45) {
        temperature = 'QUENTE ğŸ”¥';
        
        // FÃ“RMULA: Ajuste para sequÃªncias = Score Ã— 0.3 (mÃ¡ximo +20%)
        // FÃ“RMULA: Ajuste para alternÃ¢ncias = -Score Ã— 0.2 (penaliza alternÃ¢ncias)
        if (activePattern.type.includes('sequencia')) {
            adjustment = Math.min(20, temperatureScore * 0.3);
            reasoning = `Blaze QUENTE (score: ${temperatureScore.toFixed(0)}). SequÃªncias tendem a continuar. (+${adjustment.toFixed(1)}%)`;
        } else {
            adjustment = Math.max(-10, -(temperatureScore - 45) * 0.2);
            reasoning = `Blaze QUENTE mas padrÃ£o Ã© alternÃ¢ncia. Pode estar mudando. (${adjustment.toFixed(1)}%)`;
        }
    }
    // TEMPERATURA FRIA: Score <= 20 (poucas ou nenhuma sequÃªncia)
    else if (temperatureScore <= 20) {
        temperature = 'FRIA â„ï¸';
        
        // FÃ“RMULA: Ajuste para sequÃªncias = -(20 - Score) Ã— 0.7 (penaliza sequÃªncias)
        // FÃ“RMULA: Ajuste para alternÃ¢ncias = (20 - Score) Ã— 0.5 (favorece alternÃ¢ncias)
        if (activePattern.type.includes('sequencia')) {
            adjustment = -((20 - temperatureScore) * 0.7);
            adjustment = Math.max(-20, adjustment);
            reasoning = `Blaze FRIA (score: ${temperatureScore.toFixed(0)}). SequÃªncias quebram rÃ¡pido. (${adjustment.toFixed(1)}%)`;
        } else {
            adjustment = (20 - temperatureScore) * 0.5;
            adjustment = Math.min(15, adjustment);
            reasoning = `Blaze FRIA (score: ${temperatureScore.toFixed(0)}). AlternÃ¢ncias se mantÃªm fortes. (+${adjustment.toFixed(1)}%)`;
        }
    }
    // TEMPERATURA MÃ‰DIA: Score entre 21-44 (comportamento misto)
    else {
        temperature = 'MÃ‰DIA ğŸŒ¤ï¸';
        
        // FÃ“RMULA: Ajuste suave proporcional Ã  proximidade dos extremos
        // Score prÃ³ximo de 45 = leve bÃ´nus para sequÃªncias
        // Score prÃ³ximo de 20 = leve bÃ´nus para alternÃ¢ncias
        
        if (activePattern.type.includes('sequencia')) {
            // Quanto mais prÃ³ximo de 45, mais positivo (0 a +8%)
            adjustment = ((temperatureScore - 20) / 25) * 8;
            adjustment = Math.max(-5, Math.min(8, adjustment));
            reasoning = `Blaze MÃ‰DIA (score: ${temperatureScore.toFixed(0)}). Comportamento misto. (${adjustment >= 0 ? '+' : ''}${adjustment.toFixed(1)}%)`;
        } else {
            // Quanto mais prÃ³ximo de 20, mais positivo para alternÃ¢ncias (0 a +5%)
            adjustment = ((44 - temperatureScore) / 24) * 5;
            adjustment = Math.max(-3, Math.min(5, adjustment));
            reasoning = `Blaze MÃ‰DIA (score: ${temperatureScore.toFixed(0)}). AlternÃ¢ncia moderada. (${adjustment >= 0 ? '+' : ''}${adjustment.toFixed(1)}%)`;
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ ANÃLISE DE QUEBRAS (O que o usuÃ¡rio pediu!)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Se o padrÃ£o ativo Ã© uma sequÃªncia, verificar se sequÃªncias similares quebraram recentemente
    if (activePattern.type.includes('sequencia') && activePattern.size >= 3) {
        console.log('%cğŸ” ANÃLISE DE QUEBRAS (contexto dos Ãºltimos 20 giros):', 'color: #FFD700; font-weight: bold;');
        
        const patternColor = activePattern.sequence.split('-')[0];
        const patternSize = activePattern.size;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¯ PRIORIDADE 1: VERIFICAÃ‡ÃƒO GLOBAL (10.000 GIROS REAIS)
        // AnÃ¡lise cientÃ­fica CORRETA baseada em probabilidades reais
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        console.log(`%c   PadrÃ£o atual: ${patternSize} ${patternColor === 'red' ? 'VERMELHOS' : 'PRETOS'}`, 'color: #FFD700;');
        
        // ğŸ¯ LÃ“GICA INTELIGENTE: Cada cor tem seus pontos crÃ­ticos DIFERENTES!
        
        // â•â•â• VERMELHO â•â•â•
        if (patternColor === 'red') {
            if (patternSize >= MAX_SEQUENCIA_HISTORICO) {
                // 11+ vermelhos: Nunca visto ir alÃ©m disso! (Apenas log informativo)
                console.log(`%cğŸš¨ MÃXIMO HISTÃ“RICO ATINGIDO! (${patternSize} vermelhos)`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
                console.log(`%c   ğŸ“Š Em 10.000 giros, NUNCA passou de ${MAX_SEQUENCIA_HISTORICO}!`, 'color: #FF0000; font-weight: bold;');
                console.log(`%c   â„¹ï¸ Probabilidade de quebra MUITO ALTA`, 'color: #FFA500;');
                reasoning += ` | ğŸš¨ MÃ¡ximo histÃ³rico (${MAX_SEQUENCIA_HISTORICO}) atingido`;
            }
            else if (patternSize >= 7) {
                // 7+ vermelhos: Log informativo apenas
                console.log(`%cğŸ”¥ SEQUÃŠNCIA LONGA! (${patternSize} vermelhos)`, 'color: #FF4500; font-weight: bold;');
                console.log(`%c   ğŸ“Š SequÃªncia considerÃ¡vel detectada`, 'color: #FF4500;');
                console.log(`%c   â„¹ï¸ HistÃ³rico indica probabilidade de quebra`, 'color: #FFA500;');
                reasoning += ` | ğŸ”¥ Vermelho ${patternSize}: SequÃªncia longa`;
            }
            // âœ… REMOVIDAS: TODAS as penalizaÃ§Ãµes artificiais!
            // Os dados histÃ³ricos jÃ¡ incluem as probabilidades de quebra!
        }
        // â•â•â• PRETO â•â•â•
        else if (patternColor === 'black') {
            if (patternSize >= MAX_SEQUENCIA_HISTORICO) {
                // 11+ pretos: Nunca visto ir alÃ©m disso! (Apenas log informativo)
                console.log(`%cğŸš¨ MÃXIMO HISTÃ“RICO ATINGIDO! (${patternSize} pretos)`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
                console.log(`%c   ğŸ“Š Em 10.000 giros, NUNCA passou de ${MAX_SEQUENCIA_HISTORICO}!`, 'color: #FF0000; font-weight: bold;');
                console.log(`%c   â„¹ï¸ Probabilidade de quebra MUITO ALTA`, 'color: #FFA500;');
                reasoning += ` | ğŸš¨ MÃ¡ximo histÃ³rico (${MAX_SEQUENCIA_HISTORICO}) atingido`;
            }
            else if (patternSize >= 7) {
                // 7+ pretos: Log informativo apenas
                console.log(`%cğŸ”¥ SEQUÃŠNCIA LONGA! (${patternSize} pretos)`, 'color: #FF0000; font-weight: bold;');
                console.log(`%c   ğŸ“Š SequÃªncia considerÃ¡vel detectada (76.0% quebra real em 7+)`, 'color: #FF0000;');
                console.log(`%c   â„¹ï¸ HistÃ³rico indica probabilidade de quebra`, 'color: #FFA500;');
                reasoning += ` | ğŸ”¥ Preto ${patternSize}: SequÃªncia longa`;
            }
            // âœ… REMOVIDAS: TODAS as penalizaÃ§Ãµes artificiais!
            // Os dados histÃ³ricos jÃ¡ incluem as probabilidades de quebra!
        }
        
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¯ PRIORIDADE 2: ANÃLISE DOS ÃšLTIMOS 20 GIROS (contexto recente)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Buscar sequÃªncias da mesma cor nos Ãºltimos 20 giros
        const similarSequences = sequencesFound.filter(s => 
            s.color === patternColor && s.length >= 3
        );
        
        console.log(`%c   SequÃªncias similares nos Ãºltimos 20: ${similarSequences.length}`, 'color: #FFD700;');
        
        if (similarSequences.length > 0) {
            // Verificar o tamanho mÃ¡ximo que chegou
            const maxLength = Math.max(...similarSequences.map(s => s.length));
            const avgLength = similarSequences.reduce((sum, s) => sum + s.length, 0) / similarSequences.length;
            
            console.log(`%c   Tamanho mÃ¡ximo alcanÃ§ado: ${maxLength} giros`, 'color: #FFD700;');
            console.log(`%c   Tamanho mÃ©dio: ${avgLength.toFixed(1)} giros`, 'color: #FFD700;');
            
            // ğŸ¯ LÃ“GICA INTELIGENTE DO USUÃRIO:
            // Se jÃ¡ estamos no giro X e nenhuma sequÃªncia recente passou de X,
            // MUITO PROVÃVEL que vai quebrar!
            
            // â„¹ï¸ AnÃ¡lise informativa apenas - SEM penalizaÃ§Ãµes artificiais
            if (patternSize >= maxLength) {
                console.log(`%câš ï¸ ALERTA: PadrÃ£o atual (${patternSize}) jÃ¡ atingiu o mÃ¡ximo recente (${maxLength})!`, 'color: #FF0000; font-weight: bold;');
                console.log(`%c   â„¹ï¸ Probabilidade de QUEBRA pode ser alta`, 'color: #FFA500;');
                console.log(`%c   ğŸ“Š HistÃ³rico jÃ¡ reflete esta probabilidade`, 'color: #00FF88;');
                reasoning += ` | PadrÃ£o atingiu mÃ¡ximo recente (${maxLength})`;
            } else if (patternSize >= avgLength) {
                console.log(`%câš ï¸ PadrÃ£o atual (${patternSize}) estÃ¡ acima da mÃ©dia recente (${avgLength.toFixed(1)})`, 'color: #FFA500; font-weight: bold;');
                console.log(`%c   â„¹ï¸ SequÃªncia acima do normal nos Ãºltimos 20 giros`, 'color: #FFA500;');
                reasoning += ` | Acima da mÃ©dia recente (${avgLength.toFixed(1)})`;
            } else {
                console.log(`%câœ… PadrÃ£o atual (${patternSize}) estÃ¡ abaixo do mÃ¡ximo (${maxLength}) e mÃ©dia (${avgLength.toFixed(1)})`, 'color: #00FF00;');
                console.log(`%c   âœ… Ainda hÃ¡ espaÃ§o para crescer!`, 'color: #00FF88;');
            }
            // âœ… REMOVIDAS: TODAS as penalizaÃ§Ãµes artificiais (-15%, -10%)
            // Os dados histÃ³ricos jÃ¡ incluem essas probabilidades!
        } else {
            console.log(`%c   â„¹ï¸ Nenhuma sequÃªncia similar encontrada nos Ãºltimos 20 giros`, 'color: #888;');
            console.log(`%c   NÃ£o hÃ¡ dados recentes para comparaÃ§Ã£o`, 'color: #888;');
        }
        
    }
    
    console.log(`%cğŸŒ¡ï¸  TEMPERATURA: ${temperature}`, 'color: #FF6B35; font-weight: bold; font-size: 14px;');
    console.log(`%c   ${reasoning}`, 'color: #FF8C00;');
    
    // âœ… CALCULAR COR DOMINANTE NOS ÃšLTIMOS 20 GIROS
    let colorCounts = { red: 0, black: 0, white: 0 };
    last20Spins.forEach(spin => {
        colorCounts[spin.color]++;
    });
    
    const total20 = last20Spins.length;
    const colorPercents = {
        red: ((colorCounts.red / total20) * 100).toFixed(1),
        black: ((colorCounts.black / total20) * 100).toFixed(1),
        white: ((colorCounts.white / total20) * 100).toFixed(1)
    };
    
    // Encontrar cor dominante
    let dominantColor = 'red';
    let dominantCount = colorCounts.red;
    let dominantPercent = parseFloat(colorPercents.red);
    
    if (colorCounts.black > dominantCount) {
        dominantColor = 'black';
        dominantCount = colorCounts.black;
        dominantPercent = parseFloat(colorPercents.black);
    }
    if (colorCounts.white > dominantCount) {
        dominantColor = 'white';
        dominantCount = colorCounts.white;
        dominantPercent = parseFloat(colorPercents.white);
    }
    
    // Considerar "dominante" se for >=55% (11+ em 20 giros)
    const hasDominantColor = dominantPercent >= 55;
    
    return {
        temperature,
        adjustment,
        reasoning,
        stats: {
            totalSequences,
            longSequences,
            veryLongSequences,
            avgSequenceLength
        },
        // âœ… InformaÃ§Ãµes de cor dominante
        colorCounts,
        colorPercents,
        dominantColor,
        dominantCount,
        dominantPercent,
        hasDominantColor
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  FUNÃ‡Ã•ES DE MEMÃ“RIA ATIVA - SISTEMA INCREMENTAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function getMemoriaAtivaHistoryCap() {
    // MantÃ©m o comportamento histÃ³rico (2000) como mÃ­nimo seguro,
    // mas permite crescer atÃ© 10k quando o usuÃ¡rio ajustar N0 (diamondLevelWindows.n0History).
    try {
        const windows = analyzerConfig && analyzerConfig.diamondLevelWindows ? analyzerConfig.diamondLevelWindows : {};
        const raw = Number(windows.n0History);
        const desired = Number.isFinite(raw) && raw > 0 ? Math.floor(raw) : 2000;
        const minSafe = 2000;
        return clampInt(Math.max(minSafe, desired), minSafe, REALTIME_HISTORY_CAP);
    } catch (_) {
        return Math.min(2000, REALTIME_HISTORY_CAP);
    }
}

/**
 * ğŸ”§ INICIALIZAR MEMÃ“RIA ATIVA
 * Analisa todo o histÃ³rico UMA VEZ e armazena em memÃ³ria
 * Deve ser chamado apenas na primeira vez ou apÃ³s reset
 */
async function inicializarMemoriaAtiva(history) {
    // âš ï¸ Evitar inicializaÃ§Ãµes simultÃ¢neas
    if (memoriaAtivaInicializando) {
        console.log('%câ³ MemÃ³ria Ativa jÃ¡ estÃ¡ sendo inicializada...', 'color: #FFA500;');
        return false;
    }
    
    memoriaAtivaInicializando = true;
    const inicio = performance.now();
    
    console.log('%câ•‘  ğŸ§  INICIALIZANDO MEMÃ“RIA ATIVA                          â•‘', 'color: #00CED1; font-weight: bold; font-size: 14px;');
    
    try {
        // âœ… FAST INIT (crÃ­tico para tempo-real):
        // Antigamente esta rotina fazia varreduras pesadas (detectAllPatternTypes + estatÃ­sticas globais),
        // o que podia bloquear o event-loop e atrasar o envio do sinal.
        // Para tempo-real, basta ter cache + distribuiÃ§Ã£o + padrÃ£o atual (Ãºltimos 20).

        // 1. COPIAR HISTÃ“RICO
        console.log('%cğŸ“Š ETAPA 1/3: Copiando histÃ³rico...', 'color: #00CED1; font-weight: bold;');
        const cap = getMemoriaAtivaHistoryCap();
        memoriaAtiva.giros = [...history].slice(0, cap);
        memoriaAtiva.ultimos20 = memoriaAtiva.giros.slice(0, 20);
        memoriaAtiva.estatisticas.totalGiros = memoriaAtiva.giros.length;
        console.log(`%c   âœ… ${memoriaAtiva.giros.length} giros copiados`, 'color: #00FF88;');
        
        // 2. CALCULAR DISTRIBUIÃ‡ÃƒO
        console.log('%cğŸ“Š ETAPA 2/3: Calculando distribuiÃ§Ã£o de cores...', 'color: #00CED1; font-weight: bold;');
        const distribuicao = { red: 0, black: 0, white: 0 };
        for (const giro of memoriaAtiva.giros) {
            if (giro.color) {
                distribuicao[giro.color]++;
            }
        }
        const total = memoriaAtiva.giros.length;
        memoriaAtiva.estatisticas.distribuicao = {
            red: { count: distribuicao.red, percent: (distribuicao.red / total) * 100 },
            black: { count: distribuicao.black, percent: (distribuicao.black / total) * 100 },
            white: { count: distribuicao.white, percent: (distribuicao.white / total) * 100 }
        };
        console.log(`%c   ğŸ”´ Vermelho: ${distribuicao.red} (${memoriaAtiva.estatisticas.distribuicao.red.percent.toFixed(2)}%)`, 'color: #FF6B6B;');
        console.log(`%c   âš« Preto: ${distribuicao.black} (${memoriaAtiva.estatisticas.distribuicao.black.percent.toFixed(2)}%)`, 'color: #888;');
        console.log(`%c   âšª Branco: ${distribuicao.white} (${memoriaAtiva.estatisticas.distribuicao.white.percent.toFixed(2)}%)`, 'color: #FFF;');
        
        // 3. PADRÃƒO ATUAL (Ãºltimos 20) + placeholders (evita undefined e mantÃ©m telemetria ok)
        console.log('%cğŸ” ETAPA 3/3: Preparando snapshot rÃ¡pido...', 'color: #00CED1; font-weight: bold;');
        try {
            memoriaAtiva.padraoAtual = findActivePattern(memoriaAtiva.ultimos20);
        } catch (_) {
            memoriaAtiva.padraoAtual = null;
        }
        memoriaAtiva.padroesDetectados = {
            alternanciaSimples: [],
            alternanciasDupla: [],
            alternanciasTripla: [],
            sequenciasRed: [],
            sequenciasBlack: []
        };
        memoriaAtiva.estatisticas.porPadrao = {};
        
        // 5. MARCAR COMO INICIALIZADA
        memoriaAtiva.inicializada = true;
        memoriaAtiva.ultimaAtualizacao = new Date();
        memoriaAtiva.tempoInicializacao = performance.now() - inicio;
        memoriaAtiva.totalAtualizacoes = 0;
        
        console.log('%câ•‘  âœ… MEMÃ“RIA ATIVA INICIALIZADA COM SUCESSO!              â•‘', 'color: #00FF00; font-weight: bold; font-size: 14px;');
        console.log(`%câ•‘  â±ï¸  Tempo: ${memoriaAtiva.tempoInicializacao.toFixed(2)}ms                                    â•‘`, 'color: #00FF88;');
        console.log(`%câ•‘  ğŸ“Š Giros: ${memoriaAtiva.giros.length}                                          â•‘`, 'color: #00FF88;');
        
        memoriaAtivaInicializando = false;
        return true;
        
    } catch (error) {
        console.error('%câŒ ERRO ao inicializar memÃ³ria ativa:', 'color: #FF0000; font-weight: bold;');
        console.error(error);
        memoriaAtivaInicializando = false;
        memoriaAtiva.inicializada = false;
        return false;
    }
}

/**
 * âš¡ ATUALIZAR MEMÃ“RIA INCREMENTALMENTE
 * Adiciona novo giro e atualiza apenas o necessÃ¡rio (RÃPIDO!)
 */
function atualizarMemoriaIncrementalmente(novoGiro) {
    if (!memoriaAtiva.inicializada) {
        console.warn('%câš ï¸ MemÃ³ria Ativa nÃ£o inicializada! NÃ£o Ã© possÃ­vel atualizar.', 'color: #FFA500;');
        return false;
    }
    
    const inicio = performance.now();
    
    try {
        // 1. ADICIONAR NOVO GIRO NO INÃCIO
        memoriaAtiva.giros.unshift(novoGiro);
        
        // 2. REMOVER O MAIS ANTIGO (manter cap dinÃ¢mico)
        const cap = getMemoriaAtivaHistoryCap();
        if (memoriaAtiva.giros.length > cap) {
            const removido = memoriaAtiva.giros.pop();
            
            // Atualizar distribuiÃ§Ã£o (decrementar cor removida)
            if (removido && removido.color) {
                memoriaAtiva.estatisticas.distribuicao[removido.color].count--;
            }
        }
        
        // 3. ATUALIZAR DISTRIBUIÃ‡ÃƒO (incrementar nova cor)
        if (novoGiro.color) {
            memoriaAtiva.estatisticas.distribuicao[novoGiro.color].count++;
        }
        
        // Recalcular percentuais
        const total = memoriaAtiva.giros.length;
        for (const cor of ['red', 'black', 'white']) {
            memoriaAtiva.estatisticas.distribuicao[cor].percent = 
                (memoriaAtiva.estatisticas.distribuicao[cor].count / total) * 100;
        }
        
        // 4. ATUALIZAR ÃšLTIMOS 20
        memoriaAtiva.ultimos20 = memoriaAtiva.giros.slice(0, 20);
        
        // 5. DETECTAR NOVO PADRÃƒO ATIVO (apenas nos Ãºltimos 20)
        // Isso Ã© rÃ¡pido porque sÃ³ analisa 20 giros!
        memoriaAtiva.padraoAtual = findActivePattern(memoriaAtiva.ultimos20);
        
        // 6. ATUALIZAR MÃ‰TRICAS
        memoriaAtiva.ultimaAtualizacao = new Date();
        memoriaAtiva.tempoUltimaAtualizacao = performance.now() - inicio;
        memoriaAtiva.totalAtualizacoes++;
        
        // âœ… Log resumido (apenas se demorar muito)
        if (memoriaAtiva.tempoUltimaAtualizacao > 50) {
            console.log(`%câš¡ MemÃ³ria atualizada em ${memoriaAtiva.tempoUltimaAtualizacao.toFixed(2)}ms`, 'color: #FFD700;');
        }
        
        return true;
        
    } catch (error) {
        console.error('%câŒ ERRO ao atualizar memÃ³ria incrementalmente:', 'color: #FF0000; font-weight: bold;');
        console.error(error);
        return false;
    }
}

/**
 * ğŸ” VALIDAR MEMÃ“RIA ATIVA
 * Verifica integridade e sincronizaÃ§Ã£o com cachedHistory
 */
function validarMemoriaAtiva() {
    if (!memoriaAtiva.inicializada) {
        return { valida: false, motivo: 'NÃ£o inicializada' };
    }
    
    // Verificar se tem giros
    if (memoriaAtiva.giros.length === 0) {
        return { valida: false, motivo: 'Sem giros na memÃ³ria' };
    }
    
    // Verificar sincronizaÃ§Ã£o com cachedHistory
    if (cachedHistory.length > 0 && memoriaAtiva.giros.length > 0) {
        const ultimoGiroMemoria = memoriaAtiva.giros[0];
        const ultimoGiroCache = cachedHistory[0];
        
        if (ultimoGiroMemoria.number !== ultimoGiroCache.number || 
            ultimoGiroMemoria.color !== ultimoGiroCache.color) {
            return { 
                valida: false, 
                motivo: 'Dessincronizado com cachedHistory',
                detalhes: {
                    memoria: ultimoGiroMemoria,
                    cache: ultimoGiroCache
                }
            };
        }
    }
    
    // Verificar se estatÃ­sticas fazem sentido
    const totalDist = memoriaAtiva.estatisticas.distribuicao.red.count +
                      memoriaAtiva.estatisticas.distribuicao.black.count +
                      memoriaAtiva.estatisticas.distribuicao.white.count;
    
    if (totalDist !== memoriaAtiva.giros.length) {
        return { 
            valida: false, 
            motivo: 'DistribuiÃ§Ã£o inconsistente',
            detalhes: {
                totalDistribuicao: totalDist,
                totalGiros: memoriaAtiva.giros.length
            }
        };
    }
    
    return { valida: true };
}

/**
 * ğŸ”„ RESETAR MEMÃ“RIA ATIVA
 * Limpa tudo e forÃ§a reinicializaÃ§Ã£o
 */
function resetarMemoriaAtiva() {
    console.log('%cğŸ”„ Resetando MemÃ³ria Ativa...', 'color: #FFA500; font-weight: bold;');
    
    memoriaAtiva = {
        inicializada: false,
        ultimaAtualizacao: null,
        versao: memoriaAtiva.versao + 1,
        giros: [],
        ultimos20: [],
        padroesDetectados: {
            alternanciaSimples: [],
            alternanciasDupla: [],
            alternanciasTripla: [],
            sequenciasRed: [],
            sequenciasBlack: []
        },
        estatisticas: {
            totalGiros: 0,
            distribuicao: {
                red: { count: 0, percent: 0 },
                black: { count: 0, percent: 0 },
                white: { count: 0, percent: 0 }
            },
            porPadrao: {}
        },
        padraoAtual: null,
        tempoInicializacao: 0,
        tempoUltimaAtualizacao: 0,
        totalAtualizacoes: 0
    };
    
    memoriaAtivaInicializando = false;
    
    console.log('%câœ… MemÃ³ria Ativa resetada!', 'color: #00FF88;');
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * ğŸ§  ANÃLISE CONTEXTUAL INTELIGENTE - SISTEMA DE GRADIENTE
 * Analisa os ÃšLTIMOS 20 GIROS com peso gradual (mais recente = mais importante)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
function analyzeCurrentContext(last20Spins, activePattern) {
    const colors = last20Spins.map(s => s.color);
    const nonWhite = colors.filter(c => c !== 'white');
    
    let description = '';
    let insight = '';
    
    console.log('%câ•‘  ğŸŒ¡ï¸ ANÃLISE CONTEXTUAL COM GRADIENTE QUENTE/FRIO         â•‘', 'color: #00FFFF; font-weight: bold;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸŒ¡ï¸ GRADIENTE DE TEMPERATURA (20 giros)
    // Giro 20 (antigo) = FRIO (peso 1.0x)
    // Giro 1 (recente) = FERVENDO (peso 3.0x)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const last20NonWhite = nonWhite.slice(0, Math.min(20, nonWhite.length));
    
    console.log(`%cğŸ“Š Analisando ${last20NonWhite.length} giros (ignorando brancos)`, 'color: #00FFFF;');
    console.log(`%c   Do mais antigo (FRIO) ao mais recente (QUENTE)`, 'color: #00FFFF;');
    
    // Mostrar sequÃªncia completa com gradiente visual
    let gradientDisplay = '';
    for (let i = last20NonWhite.length - 1; i >= 0; i--) {
        const color = last20NonWhite[i];
        const position = last20NonWhite.length - i;
        const colorSymbol = color === 'red' ? 'V' : 'P';
        
        // Gradiente de cor no console
        let tempEmoji = '';
        if (position <= 5) {
            tempEmoji = 'ğŸ§Š'; // Muito frio (giros antigos)
        } else if (position <= 10) {
            tempEmoji = 'â„ï¸'; // Frio
        } else if (position <= 15) {
            tempEmoji = 'ğŸŒ¡ï¸'; // Morno
        } else {
            tempEmoji = 'ğŸ”¥'; // Quente (giros recentes)
        }
        
        gradientDisplay += `${tempEmoji}${colorSymbol} `;
    }
    
    console.log(`%cğŸŒ¡ï¸ Gradiente: ${gradientDisplay}`, 'color: #00FFFF;');
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” ANÃLISE 1: SEQUÃŠNCIA ATUAL (Ãºltimos giros mais recentes)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const firstColor = last20NonWhite[0];
    let currentSequenceLength = 1;
    
    for (let i = 1; i < last20NonWhite.length; i++) {
        if (last20NonWhite[i] === firstColor) {
            currentSequenceLength++;
        } else {
            break;
        }
    }
    
    console.log(`%cğŸ”¥ ANÃLISE DA SEQUÃŠNCIA ATUAL (giros mais recentes):`, 'color: #FFD700; font-weight: bold;');
    console.log(`%c   Cor atual: ${firstColor === 'red' ? 'VERMELHO' : 'PRETO'}`, 'color: #FFD700;');
    console.log(`%c   SequÃªncia: ${currentSequenceLength} giros consecutivos`, 'color: #FFD700;');
    
    if (currentSequenceLength >= 7) {
        const colorName = firstColor === 'red' ? 'VERMELHOS' : 'PRETOS';
        description = `ğŸ”¥ SEQUÃŠNCIA MUITO LONGA! ${currentSequenceLength} ${colorName} consecutivos. `;
        insight = `ATENÃ‡ÃƒO: SequÃªncia de ${currentSequenceLength} giros estÃ¡ MUITO longa! Probabilidade de quebra ALTA.`;
        console.log(`%c   âš ï¸ SEQUÃŠNCIA MUITO LONGA! Risco de quebra ALTO!`, 'color: #FF0000; font-weight: bold;');
    } else if (currentSequenceLength >= 5) {
        const colorName = firstColor === 'red' ? 'VERMELHOS' : 'PRETOS';
        description = `ğŸ“Š SequÃªncia de ${currentSequenceLength} ${colorName}. `;
        insight = `SequÃªncia moderada (${currentSequenceLength} giros). Pode continuar ou quebrar.`;
        console.log(`%c   âœ… SequÃªncia moderada`, 'color: #FFAA00;');
    } else if (currentSequenceLength >= 3) {
        const colorName = firstColor === 'red' ? 'vermelhos' : 'pretos';
        description = `ğŸ“ˆ SequÃªncia curta de ${currentSequenceLength} ${colorName}. `;
        insight = `SequÃªncia ainda curta (${currentSequenceLength} giros).`;
        console.log(`%c   â„¹ï¸ SequÃªncia curta`, 'color: #00FF88;');
    } else {
        console.log(`%c   â„¹ï¸ Sem sequÃªncia clara (apenas ${currentSequenceLength} giro)`, 'color: #00FF88;');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” ANÃLISE 2: COMPORTAMENTO NOS ÃšLTIMOS 20 GIROS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    console.log(`%cğŸ”„ ANÃLISE GERAL DOS 20 GIROS:`, 'color: #9370DB; font-weight: bold;');
    
    const redCount = last20NonWhite.filter(c => c === 'red').length;
    const blackCount = last20NonWhite.filter(c => c === 'black').length;
    const total = last20NonWhite.length;
    
    console.log(`%c   VERMELHO: ${redCount} giros (${((redCount/total)*100).toFixed(1)}%)`, 'color: #FF0000;');
    console.log(`%c   PRETO: ${blackCount} giros (${((blackCount/total)*100).toFixed(1)}%)`, 'color: #FFFFFF;');
    
    // Detectar alternÃ¢ncia nos Ãºltimos 10 giros (zona quente)
    const last10 = last20NonWhite.slice(0, 10);
    let alternations = 0;
    for (let i = 0; i < last10.length - 1; i++) {
        if (last10[i] !== last10[i + 1]) {
            alternations++;
        }
    }
    
    console.log(`%c   MudanÃ§as de cor (Ãºltimos 10): ${alternations}`, 'color: #9370DB;');
    
    if (alternations >= 7) {
        description += `ğŸ”„ ALTERNÃ‚NCIA MUITO ATIVA nos Ãºltimos 10 giros (${alternations} mudanÃ§as). `;
        insight = `Forte padrÃ£o de alternÃ¢ncia. Cores trocando frequentemente.`;
        console.log(`%c   âœ… ALTERNÃ‚NCIA MUITO ATIVA!`, 'color: #00FF00; font-weight: bold;');
    } else if (alternations >= 5) {
        description += `ğŸ”„ AlternÃ¢ncia moderada (${alternations} mudanÃ§as em 10 giros). `;
        insight = `PadrÃ£o de alternÃ¢ncia presente.`;
        console.log(`%c   â„¹ï¸ AlternÃ¢ncia moderada`, 'color: #00FF88;');
    } else {
        console.log(`%c   â„¹ï¸ Pouca alternÃ¢ncia (${alternations} mudanÃ§as)`, 'color: #FFAA00;');
    }
    
    // âš ï¸ NÃƒO RECOMENDAR BASEADO EM DOMINÃ‚NCIA DE COR!
    // A recomendaÃ§Ã£o vem do PADRÃƒO e do HISTÃ“RICO, nÃ£o da quantidade!
    // Apenas DESCREVER o contexto atual para o usuÃ¡rio entender
    if (currentSequenceLength < 3 && alternations < 5) {
        if (redCount > blackCount + 3) {
            description = `ğŸ“Š Contexto: ${redCount} vermelhos vs ${blackCount} pretos nos Ãºltimos 20 giros. `;
            insight = `Vermelho apareceu mais recentemente. A decisÃ£o virÃ¡ do padrÃ£o detectado e do histÃ³rico.`;
            console.log(`%c   ğŸ“Š Contexto: Vermelho mais frequente (${redCount} vs ${blackCount})`, 'color: #00FFFF;');
            console.log(`%c   âš ï¸ MAS: DecisÃ£o baseada no PADRÃƒO e HISTÃ“RICO, nÃ£o na quantidade!`, 'color: #FFAA00; font-weight: bold;');
        } else if (blackCount > redCount + 3) {
            description = `ğŸ“Š Contexto: ${blackCount} pretos vs ${redCount} vermelhos nos Ãºltimos 20 giros. `;
            insight = `Preto apareceu mais recentemente. A decisÃ£o virÃ¡ do padrÃ£o detectado e do histÃ³rico.`;
            console.log(`%c   ğŸ“Š Contexto: Preto mais frequente (${blackCount} vs ${redCount})`, 'color: #00FFFF;');
            console.log(`%c   âš ï¸ MAS: DecisÃ£o baseada no PADRÃƒO e HISTÃ“RICO, nÃ£o na quantidade!`, 'color: #FFAA00; font-weight: bold;');
        } else {
            description = `ğŸ“Š Contexto: Equilibrado nos Ãºltimos 20 giros (V:${redCount} vs P:${blackCount}). `;
            insight = `DistribuiÃ§Ã£o equilibrada. A decisÃ£o virÃ¡ do padrÃ£o detectado e do histÃ³rico.`;
            console.log(`%c   ğŸ“Š Contexto: Jogo equilibrado (${redCount} vs ${blackCount})`, 'color: #00FFFF;');
        }
    }
    
    
    return {
        description: description,
        insight: insight,
        currentSequenceLength: currentSequenceLength,
        alternations: alternations,
        redDominance: redCount,
        blackDominance: blackCount
    };
}

/**
 * FUNÃ‡ÃƒO AUXILIAR: Buscar sequÃªncia de 10 giros no histÃ³rico
 * Retorna a cor que mais saiu apÃ³s essa sequÃªncia
 * @param {Array} targetSequence - SequÃªncia de 10 giros a buscar
 * @param {Array} searchHistory - HistÃ³rico onde buscar
 * @param {number} spinsToAnalyze - Quantos giros analisar apÃ³s encontrar a sequÃªncia
 * @returns {Object} - {color, confidence, occurrences, similarity}
 */
function buscarSequenciaNoHistorico(targetSequence, searchHistory, spinsToAnalyze = 100) {
    console.log(`%cğŸ“Š PARÃ‚METROS DA BUSCA:`, 'color: #00D4FF; font-weight: bold;');
    console.log(`   â¤ Tamanho do histÃ³rico de busca: ${searchHistory.length} giros`);
    console.log(`   â¤ Tamanho da sequÃªncia alvo: ${targetSequence.length} giros`);
    console.log(`   â¤ Giros para analisar apÃ³s match: ${spinsToAnalyze}`);
    
    // Extrair apenas as cores da sequÃªncia alvo
    const targetColors = targetSequence.map(spin => spin.color);
    
    console.log('%cğŸ¯ SEQUÃŠNCIA ALVO (Ãšltimos 10 giros):', 'color: #FFD700; font-weight: bold;');
    for (let i = 0; i < targetSequence.length; i++) {
        const spin = targetSequence[i];
        const colorEmoji = spin.color === 'red' ? 'ğŸ”´' : spin.color === 'black' ? 'âš«' : 'âšª';
        console.log(`   ${i + 1}. ${colorEmoji} ${spin.color.toUpperCase()} (#${spin.number || '?'})`);
    }
    console.log(`   â†’ PadrÃ£o: ${targetColors.map(c => c === 'red' ? 'ğŸ”´' : c === 'black' ? 'âš«' : 'âšª').join(' ')}`);
    
    let exactMatches = [];
    let similarMatches = []; // Matches com 60%+ de similaridade
    let highMatches = [];    // Matches com 80%+ de similaridade
    
    console.log('%cğŸ” INICIANDO VARREDURA DO HISTÃ“RICO...', 'color: #00D4FF; font-weight: bold;');
    console.log(`   Analisando ${searchHistory.length - spinsToAnalyze - 10} posiÃ§Ãµes no histÃ³rico`);
    
    // Buscar no histÃ³rico (comeÃ§ando do Ã­ndice 10, pois precisamos de 10 giros anteriores)
    for (let i = 10; i < searchHistory.length - spinsToAnalyze; i++) {
        const historySlice = searchHistory.slice(i - 10, i).map(spin => spin.color);
        
        // Calcular similaridade
        let matchCount = 0;
        for (let j = 0; j < 10; j++) {
            if (historySlice[j] === targetColors[j]) {
                matchCount++;
            }
        }
        
        const similarity = (matchCount / 10) * 100;
        
        if (similarity === 100) {
            // Match exato!
            exactMatches.push(i);
            console.log(`%c   âœ… MATCH EXATO encontrado na posiÃ§Ã£o ${i}! (100% similaridade)`, 'color: #00FF00; font-weight: bold;');
        } else if (similarity >= 80) {
            // Match com 80%+ de similaridade
            highMatches.push({ index: i, similarity: similarity });
            console.log(`%c   â­ MATCH ALTO encontrado na posiÃ§Ã£o ${i} (${similarity}% similaridade)`, 'color: #FFD700;');
        } else if (similarity >= 60) {
            // Match com 60%+ de similaridade
            similarMatches.push({ index: i, similarity: similarity });
        }
    }
    
    console.log('%cğŸ“Š RESULTADO DA VARREDURA:', 'color: #00FF88; font-weight: bold; font-size: 14px;');
    console.log(`%c   âœ… Matches EXATOS (100%): ${exactMatches.length}`, exactMatches.length > 0 ? 'color: #00FF00; font-weight: bold;' : 'color: #FF6666;');
    console.log(`%c   â­ Matches ALTOS (80-99%): ${highMatches.length}`, highMatches.length > 0 ? 'color: #FFD700; font-weight: bold;' : 'color: #FF6666;');
    console.log(`%c   âš¡ Matches SIMILARES (60-79%): ${similarMatches.length}`, similarMatches.length > 0 ? 'color: #00FF88;' : 'color: #FF6666;');
    console.log(`%c   ğŸ“Š TOTAL de matches com 60%+: ${exactMatches.length + highMatches.length + similarMatches.length}`, 'color: #00D4FF; font-weight: bold;');
    
    // Analisar o que veio DEPOIS dessas ocorrÃªncias
    let nextColorCounts = { red: 0, black: 0, white: 0 };
    let totalOccurrences = 0;
    let avgSimilarity = 0;
    let matchesUsed = [];
    
    console.log('%cğŸ¯ ANALISANDO O QUE VEIO DEPOIS DOS MATCHES...', 'color: #FFD700; font-weight: bold;');
    
    if (exactMatches.length > 0) {
        // PRIORIDADE 1: Usar matches exatos (100%)
        console.log(`%c   âœ… USANDO ${exactMatches.length} MATCH(ES) EXATO(S) (100% similaridade)`, 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
        exactMatches.forEach((matchIndex, idx) => {
            console.log(`%c   ğŸ“ Match ${idx + 1}/${exactMatches.length} (posiÃ§Ã£o ${matchIndex})`, 'color: #00FF88;');
            
            // Analisar os prÃ³ximos X giros apÃ³s o match
            const nextSpins = searchHistory.slice(matchIndex, matchIndex + spinsToAnalyze);
            console.log(`      â¤ Analisando ${nextSpins.length} giros apÃ³s este match`);
            
            let localCounts = { red: 0, black: 0, white: 0 };
            nextSpins.forEach(spin => {
                if (spin.color in nextColorCounts) {
                    nextColorCounts[spin.color]++;
                    localCounts[spin.color]++;
                }
            });
            
            console.log(`      â¤ DistribuiÃ§Ã£o: ğŸ”´ ${localCounts.red} | âš« ${localCounts.black} | âšª ${localCounts.white}`);
        });
        
        totalOccurrences = exactMatches.length;
        avgSimilarity = 100;
        matchesUsed = exactMatches.map(i => ({ index: i, similarity: 100 }));
        
        console.log(`%c   âœ… TOTAL DE OCORRÃŠNCIAS EXATAS: ${totalOccurrences}`, 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
    } else if (highMatches.length > 0) {
        // PRIORIDADE 2: Usar matches altos (80-99%)
        console.log(`%c   â­ USANDO ${highMatches.length} MATCH(ES) DE ALTA SIMILARIDADE (80-99%)`, 'color: #FFD700; font-weight: bold; font-size: 14px;');
        
        highMatches.forEach((match, idx) => {
            console.log(`%c   ğŸ“ Match ${idx + 1}/${highMatches.length} (posiÃ§Ã£o ${match.index}, ${match.similarity}% similar)`, 'color: #FFD700;');
            
            const nextSpins = searchHistory.slice(match.index, match.index + spinsToAnalyze);
            console.log(`      â¤ Analisando ${nextSpins.length} giros apÃ³s este match`);
            
            let localCounts = { red: 0, black: 0, white: 0 };
            nextSpins.forEach(spin => {
                if (spin.color in nextColorCounts) {
                    nextColorCounts[spin.color]++;
                    localCounts[spin.color]++;
                }
            });
            
            console.log(`      â¤ DistribuiÃ§Ã£o: ğŸ”´ ${localCounts.red} | âš« ${localCounts.black} | âšª ${localCounts.white}`);
        });
        
        totalOccurrences = highMatches.length;
        avgSimilarity = Math.round(highMatches.reduce((sum, m) => sum + m.similarity, 0) / highMatches.length);
        matchesUsed = highMatches;
        
        console.log(`%c   â­ TOTAL DE OCORRÃŠNCIAS DE ALTA SIMILARIDADE: ${totalOccurrences}`, 'color: #FFD700; font-weight: bold; font-size: 14px;');
        console.log(`%c   ğŸ“Š Similaridade mÃ©dia: ${avgSimilarity}%`, 'color: #FFD700; font-weight: bold;');
        
    } else if (similarMatches.length > 0) {
        // PRIORIDADE 3: Usar matches similares (60-79%)
        console.log(`%c   âš¡ USANDO ${similarMatches.length} MATCH(ES) DE MÃ‰DIA SIMILARIDADE (60-79%)`, 'color: #00FF88; font-weight: bold; font-size: 14px;');
        
        // Usar no mÃ¡ximo os 10 melhores matches similares (para nÃ£o poluir demais)
        const topSimilarMatches = similarMatches
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, 10);
        
        console.log(`%c   ğŸ“Š Usando os ${topSimilarMatches.length} melhores matches (dos ${similarMatches.length} encontrados)`, 'color: #00FF88;');
        
        topSimilarMatches.forEach((match, idx) => {
            console.log(`%c   ğŸ“ Match ${idx + 1}/${topSimilarMatches.length} (posiÃ§Ã£o ${match.index}, ${match.similarity}% similar)`, 'color: #00FF88;');
            
            const nextSpins = searchHistory.slice(match.index, match.index + spinsToAnalyze);
            
            let localCounts = { red: 0, black: 0, white: 0 };
            nextSpins.forEach(spin => {
                if (spin.color in nextColorCounts) {
                    nextColorCounts[spin.color]++;
                    localCounts[spin.color]++;
                }
            });
            
            if (idx < 3) { // Mostrar detalhes sÃ³ dos 3 primeiros
                console.log(`      â¤ Analisando ${nextSpins.length} giros apÃ³s este match`);
                console.log(`      â¤ DistribuiÃ§Ã£o: ğŸ”´ ${localCounts.red} | âš« ${localCounts.black} | âšª ${localCounts.white}`);
            }
        });
        
        totalOccurrences = topSimilarMatches.length;
        avgSimilarity = Math.round(topSimilarMatches.reduce((sum, m) => sum + m.similarity, 0) / topSimilarMatches.length);
        matchesUsed = topSimilarMatches;
        
        console.log(`%c   âš¡ TOTAL DE OCORRÃŠNCIAS SIMILARES USADAS: ${totalOccurrences}`, 'color: #00FF88; font-weight: bold; font-size: 14px;');
        console.log(`%c   ğŸ“Š Similaridade mÃ©dia: ${avgSimilarity}%`, 'color: #00FF88; font-weight: bold;');
        
    } else {
        // âŒ NENHUM MATCH ENCONTRADO â†’ REJEITAR SINAL!
        console.log(`%c   âŒâŒâŒ NENHUM MATCH ENCONTRADO! âŒâŒâŒ`, 'color: #FF0000; font-weight: bold; font-size: 16px;');
        console.log(`%c   â¤ O padrÃ£o dos Ãºltimos 10 giros NUNCA apareceu no histÃ³rico!`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ Sem dados histÃ³ricos para basear a previsÃ£o!`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   ğŸš« DECISÃƒO: REJEITAR SINAL!`, 'color: #FF0000; font-weight: bold; font-size: 16px;');
        console.log(`%c   â¤ NÃƒO vamos usar "frequÃªncia geral" (isso nÃ£o funciona!)`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ SÃ³ enviamos sinal quando encontramos PADRÃƒO REAL no histÃ³rico!`, 'color: #00FF88; font-weight: bold;');
        
        totalOccurrences = 0;
        avgSimilarity = 0;
        
        // âœ… NÃƒO PREENCHER nextColorCounts - deixar zerado!
        // Isso farÃ¡ com que a confianÃ§a seja 0% e o sinal seja rejeitado
    }
    
    // Determinar cor recomendada baseada na distribuiÃ§Ã£o
    console.log('%cğŸ“Š CALCULANDO COR RECOMENDADA...', 'color: #FFD700; font-weight: bold;');
    console.log(`%c   DistribuiÃ§Ã£o total apÃ³s todos os matches:`, 'color: #00D4FF; font-weight: bold;');
    console.log(`%c      ğŸ”´ VERMELHO: ${nextColorCounts.red} giros`, 'color: #FF0000; font-weight: bold;');
    console.log(`%c      âš« PRETO: ${nextColorCounts.black} giros`, 'color: #FFFFFF; font-weight: bold;');
    console.log(`%c      âšª BRANCO: ${nextColorCounts.white} giros`, 'color: #00FF00;');
    
    let recommendedColor = 'red';
    let maxCount = nextColorCounts.red;
    
    if (nextColorCounts.black > maxCount) {
        recommendedColor = 'black';
        maxCount = nextColorCounts.black;
    }
    
    console.log(`%c   ğŸ¯ Cor com MAIOR frequÃªncia: ${recommendedColor.toUpperCase()} (${maxCount} giros)`, 
        `color: ${recommendedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 14px;`);
    
    // Calcular confianÃ§a baseada na distribuiÃ§Ã£o
    const totalColors = nextColorCounts.red + nextColorCounts.black + nextColorCounts.white;
    let confidence = totalColors > 0 ? Math.round((maxCount / totalColors) * 100) : 50;
    
    console.log(`%c   ğŸ“ˆ CÃ¡lculo de confianÃ§a:`, 'color: #00D4FF; font-weight: bold;');
    console.log(`%c      Total de giros analisados: ${totalColors}`, 'color: #00D4FF;');
    console.log(`%c      FrequÃªncia da cor vencedora: ${maxCount}/${totalColors}`, 'color: #00D4FF;');
    console.log(`%c      ConfianÃ§a inicial: ${confidence}%`, 'color: #00D4FF; font-weight: bold;');
    
    // âœ… NÃƒO AJUSTAR CONFIANÃ‡A AQUI - jÃ¡ serÃ¡ ajustada para 0% na validaÃ§Ã£o abaixo
    
    // âœ… VALIDAÃ‡ÃƒO RIGOROSA: ALERTAR SE POUCOS MATCHES
    console.log('%cğŸ” VALIDAÃ‡ÃƒO DE QUALIDADE DA ANÃLISE:', 'color: #FFD700; font-weight: bold;');
    
    const MIN_OCCURRENCES_WARNING = 5;
    const MIN_OCCURRENCES_CRITICAL = 2;
    
    if (totalOccurrences === 0) {
        console.log(`%c   âŒâŒâŒ CRÃTICO: NENHUM MATCH ENCONTRADO! âŒâŒâŒ`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
        console.log(`%c   â¤ O padrÃ£o dos Ãºltimos 10 giros NUNCA apareceu no histÃ³rico`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ SEM PADRÃƒO REAL â†’ CONFIANÃ‡A = 0%`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
        console.log(`%c   â¤ ESTE SINAL SERÃ REJEITADO!`, 'color: #FF0000; font-weight: bold; font-size: 14px;');
        
        // âœ… FORÃ‡AR CONFIANÃ‡A = 0% PARA GARANTIR REJEIÃ‡ÃƒO
        confidence = 0;
    } else if (totalOccurrences < MIN_OCCURRENCES_CRITICAL) {
        console.log(`%c   âš ï¸ ALERTA: MUITO POUCOS MATCHES!`, 'color: #FF6666; font-weight: bold; font-size: 14px;');
        console.log(`%c   â¤ Matches encontrados: ${totalOccurrences}`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ Recomendado: pelo menos ${MIN_OCCURRENCES_WARNING}+ matches`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c   â¤ Base estatÃ­stica MUITO FRACA!`, 'color: #FF0000; font-weight: bold;');
        
        const oldConfidence = confidence;
        confidence = Math.min(confidence, 45);
        console.log(`%c   âš ï¸ PENALIDADE: ConfianÃ§a limitada a ${confidence}% (era ${oldConfidence}%)`, 'color: #FFA500; font-weight: bold;');
    } else if (totalOccurrences < MIN_OCCURRENCES_WARNING) {
        console.log(`%c   âš ï¸ ATENÃ‡ÃƒO: Poucos matches encontrados`, 'color: #FFA500; font-weight: bold;');
        console.log(`%c   â¤ Matches encontrados: ${totalOccurrences}`, 'color: #FFA500;');
        console.log(`%c   â¤ Recomendado: pelo menos ${MIN_OCCURRENCES_WARNING}+ matches`, 'color: #FFA500;');
        console.log(`%c   â¤ Base estatÃ­stica razoÃ¡vel, mas nÃ£o ideal`, 'color: #FFA500;');
        
        const oldConfidence = confidence;
        confidence = Math.min(confidence, 50);
        console.log(`%c   âš ï¸ ConfianÃ§a limitada a ${confidence}% (era ${oldConfidence}%)`, 'color: #FFA500;');
    } else {
        console.log(`%c   âœ… Base estatÃ­stica SÃ“LIDA!`, 'color: #00FF00; font-weight: bold; font-size: 14px;');
        console.log(`%c   â¤ Matches encontrados: ${totalOccurrences}`, 'color: #00FF88; font-weight: bold;');
        console.log(`%c   â¤ Similaridade mÃ©dia: ${avgSimilarity}%`, 'color: #00FF88; font-weight: bold;');
        console.log(`%c   â¤ AnÃ¡lise baseada em dados REAIS do histÃ³rico!`, 'color: #00FF00; font-weight: bold;');
    }
    
    console.log('%cğŸ RESULTADO FINAL DA BUSCA:', 'color: #00FF00; font-weight: bold; font-size: 16px;');
    console.log(`%c   ğŸ¯ Cor recomendada: ${recommendedColor.toUpperCase()}`, `color: ${recommendedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 16px;`);
    console.log(`%c   ğŸ“Š ConfianÃ§a: ${confidence}%`, 'color: #FFD700; font-weight: bold; font-size: 16px;');
    console.log(`%c   ğŸ”¢ OcorrÃªncias do padrÃ£o: ${totalOccurrences}x`, 'color: #00FF88; font-weight: bold; font-size: 16px;');
    console.log(`%c   ğŸ“ˆ Similaridade mÃ©dia: ${avgSimilarity}%`, 'color: #00FF88; font-weight: bold; font-size: 16px;');
    
    const result = {
        color: recommendedColor,
        confidence: confidence,
        occurrences: totalOccurrences,
        similarity: avgSimilarity,
        distribution: nextColorCounts,
        // Dados extras para debug
        matchesBreakdown: {
            exact: exactMatches.length,
            high: highMatches.length,
            similar: similarMatches.length,
            used: matchesUsed.length
        }
    };
    
    console.log('%cğŸ“¦ Objeto retornado:', 'color: #00FFFF; font-weight: bold;');
    console.log(result);
    
    return result;
}

/**
 * ğŸ§  FASE 4 (NOVA): ValidaÃ§Ã£o de Viabilidade de SequÃªncia
 * Analisa se a sequÃªncia sugerida Ã© viÃ¡vel baseado no histÃ³rico recente
 */
function analyzeSequenceViability(history, suggestedColor) {
    console.log('%cğŸ§  Analisando viabilidade da sequÃªncia...', 'color: #9C27B0; font-weight: bold;');
    console.log(`%c   â¤ Cor sugerida pelas fases anteriores: ${suggestedColor.toUpperCase()}`, `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    
    // Detectar sequÃªncia atual (quantas cores consecutivas da mesma cor)
    let currentSequence = [];
    let currentColor = null;
    
    // ğŸ” MOSTRAR OS ÃšLTIMOS 10 GIROS PARA DEBUG
    console.log('%c   ğŸ“Š Ãšltimos 10 giros (para debug):', 'color: #9C27B0;');
    const last10 = history.slice(0, 10);
    let debugString = '';
    for (let i = 0; i < last10.length; i++) {
        const spin = last10[i];
        const colorSymbol = spin.color === 'red' ? 'ğŸ”´' : (spin.color === 'black' ? 'âš«' : 'âšª');
        const number = spin.number !== undefined ? spin.number : spin.roll;
        debugString += `${colorSymbol}${number} `;
    }
    console.log(`%c      ${debugString}`, 'color: #9C27B0;');
    
    for (let i = 0; i < history.length; i++) {
        const spin = history[i];
        
        // Brancos QUEBRAM a sequÃªncia!
        if (spin.color === 'white') {
            break;
        }
        
        if (currentColor === null) {
            currentColor = spin.color;
            currentSequence.push(spin);
        } else if (spin.color === currentColor) {
            currentSequence.push(spin);
        } else {
            break; // Quebrou a sequÃªncia (cor diferente)
        }
    }
    
    const currentSequenceLength = currentSequence.length;
    const currentSequenceColor = currentColor;
    
    console.log(`%c   ğŸ¯ SequÃªncia atual detectada: ${currentSequenceLength} ${currentSequenceColor?.toUpperCase() || 'NENHUMA'}(s) CONSECUTIVO(S)`, 
        `color: ${currentSequenceColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 14px;`);
    console.log(`%c   ğŸ” Detalhes da sequÃªncia:`, 'color: #9C27B0;');
    currentSequence.forEach((spin, idx) => {
        const number = spin.number !== undefined ? spin.number : spin.roll;
        console.log(`%c      ${idx + 1}Âº: ${spin.color.toUpperCase()} (${number})`, `color: ${spin.color === 'red' ? '#FF0000' : '#FFFFFF'};`);
    });
    
    // Se sinal sugere a MESMA cor da sequÃªncia atual, significa que quer CONTINUAR a sequÃªncia
    const isExtendingSequence = (currentSequenceColor === suggestedColor);
    
    console.log(`%c   ğŸ¤” Sinal sugere CONTINUAR a sequÃªncia? ${isExtendingSequence ? 'SIM âš ï¸' : 'NÃƒO âœ…'}`, 'color: #9C27B0; font-weight: bold;');
    
    if (!isExtendingSequence) {
        console.log('%c   âœ… Sinal sugere QUEBRA de sequÃªncia (inverter cor)', 'color: #00FF88; font-weight: bold;');
        console.log('%c   ğŸ“Œ NÃ£o precisa validar resistÃªncia (jÃ¡ estÃ¡ invertendo)', 'color: #00FF88;');
        return {
            shouldInvert: false,
            reason: 'Sinal jÃ¡ sugere inversÃ£o de cor',
            maxHistorical: 0,
            currentLength: currentSequenceLength,
            isViable: true
        };
    }
    
    // Sinal quer CONTINUAR a sequÃªncia (ex: 3 pretos â†’ sugerir 4Âº preto)
    const targetSequenceLength = currentSequenceLength + 1;
    console.log(`%c   âš ï¸ âš ï¸ âš ï¸ ATENÃ‡ÃƒO! Sinal quer CONTINUAR a sequÃªncia! âš ï¸ âš ï¸ âš ï¸`, 'color: #FF0000; font-weight: bold; font-size: 14px; background: #FFFF00;');
    console.log(`%c   â¤ SequÃªncia ATUAL: ${currentSequenceLength} ${suggestedColor.toUpperCase()}(s) consecutivo(s)`, `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    console.log(`%c   â¤ Sinal pede: ${targetSequenceLength}Âº ${suggestedColor.toUpperCase()} (${targetSequenceLength} consecutivos!)`, `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    
    // Buscar no histÃ³rico: qual foi a MAIOR sequÃªncia dessa cor nos Ãºltimos giros?
    const analysisWindow = Math.min(history.length, 500); // Analisar atÃ© 500 giros
    console.log(`%c   ğŸ” Buscando no histÃ³rico dos Ãºltimos ${analysisWindow} giros...`, 'color: #9C27B0; font-weight: bold;');
    console.log(`%c   ğŸ” Pergunta: JÃ ACONTECEU ${targetSequenceLength}+ ${suggestedColor.toUpperCase()}(s) consecutivos antes?`, 'color: #9C27B0; font-weight: bold;');
    
    let maxConsecutive = 0;
    let resistances = []; // Armazenar todas as resistÃªncias encontradas
    let currentStreak = 0;
    let lastColor = null;
    let streakStartGiro = 0;
    
    for (let i = 0; i < analysisWindow; i++) {
        const spin = history[i];
        
        if (spin.color === suggestedColor) {
            if (lastColor !== suggestedColor) {
                currentStreak = 1;
                streakStartGiro = i;
            } else {
                currentStreak++;
            }
            
            if (currentStreak > maxConsecutive) {
                maxConsecutive = currentStreak;
            }
            
            lastColor = suggestedColor;
        } else {
            // Cor diferente (black, white, ou outra) QUEBRA a sequÃªncia!
            if (currentStreak >= currentSequenceLength && currentStreak < targetSequenceLength) {
                resistances.push({
                    length: currentStreak,
                    startGiro: streakStartGiro,
                    girosAgo: i
                });
            }
            currentStreak = 0;
            lastColor = spin.color;
        }
    }
    
    console.log(`%c   ğŸ“Š RESULTADO DA BUSCA HISTÃ“RICA:`, 'color: #9C27B0; font-weight: bold; font-size: 13px;');
    console.log(`%c      â¤ MÃ¡ximo de ${suggestedColor.toUpperCase()}(s) consecutivos jÃ¡ encontrado: ${maxConsecutive}`, 
        `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    console.log(`%c      â¤ Sinal quer: ${targetSequenceLength} ${suggestedColor.toUpperCase()}(s) consecutivos`, 
        `color: ${suggestedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
    
    // DECISÃƒO: A sequÃªncia sugerida Ã© viÃ¡vel?
    if (targetSequenceLength > maxConsecutive) {
        // NUNCA aconteceu uma sequÃªncia tÃ£o grande!
        console.log('%c   âŒâŒâŒ DECISÃƒO: SEQUÃŠNCIA INVIÃVEL! âŒâŒâŒ', 'color: #FFFFFF; font-weight: bold; font-size: 14px; background: #FF0000;');
        console.log('%c   ğŸ“Œ NUNCA aconteceu no histÃ³rico analisado!', 'color: #FF0000; font-weight: bold;');
        console.log(`%c      â¤ MÃ¡ximo histÃ³rico: ${maxConsecutive} ${suggestedColor.toUpperCase()}(s)`, 'color: #FF6666; font-weight: bold;');
        console.log(`%c      â¤ Sinal pede: ${targetSequenceLength} ${suggestedColor.toUpperCase()}(s)`, 'color: #FF6666; font-weight: bold;');
        console.log('%c   ğŸš« AÃ‡ÃƒO: CANCELAR SINAL (NÃƒO INVERTER)!', 'color: #FFFF00; font-weight: bold; font-size: 14px; background: #FF0000;');
        console.log('%c   ğŸ’¡ Seria burrice apostar em algo que NUNCA aconteceu!', 'color: #FF6666; font-weight: bold;');
        
        return {
            shouldInvert: false,  // âœ… NÃƒO inverte
            shouldReject: true,   // âœ… NOVO: Flag para rejeitar o sinal
            reason: `SequÃªncia NUNCA aconteceu - mÃ¡ximo histÃ³rico: ${maxConsecutive}, sinal pede: ${targetSequenceLength}`,
            maxHistorical: maxConsecutive,
            currentLength: currentSequenceLength,
            isViable: false
        };
    }
    
    // SequÃªncia JÃ aconteceu no passado - mas QUANDO foi a Ãºltima vez?
    // Buscar quando foi a ÃšLTIMA ocorrÃªncia de uma sequÃªncia >= targetSequenceLength
    let lastOccurrenceGirosAgo = null;
    let tempStreak = 0;
    let tempLastColor = null;
    
    for (let i = 0; i < analysisWindow; i++) {
        const spin = history[i];
        
        if (spin.color === suggestedColor) {
            if (tempLastColor !== suggestedColor) {
                tempStreak = 1;
            } else {
                tempStreak++;
            }
            
            // Se atingiu ou ultrapassou o tamanho alvo, registrar
            if (tempStreak >= targetSequenceLength && lastOccurrenceGirosAgo === null) {
                lastOccurrenceGirosAgo = i;
            }
            
            tempLastColor = suggestedColor;
        } else {
            // Qualquer cor diferente QUEBRA a sequÃªncia!
            tempStreak = 0;
            tempLastColor = spin.color;
        }
    }
    
    
    if (lastOccurrenceGirosAgo === null) {
        // NUNCA aconteceu essa sequÃªncia!
        console.log('%c   âŒ NUNCA aconteceu sequÃªncia de ' + targetSequenceLength + '+ ' + suggestedColor.toUpperCase() + '(s) no histÃ³rico!', 'color: #FF0000; font-weight: bold;');
        console.log('%c   ğŸ’¡ DecisÃ£o: CANCELAR sinal (padrÃ£o inexistente)', 'color: #FFD700; font-weight: bold;');
        
        return {
            shouldInvert: false,  // âœ… NÃƒO inverte
            shouldReject: true,   // âœ… REJEITA
            reason: `NUNCA aconteceu ${targetSequenceLength}+ ${suggestedColor}(s) nos Ãºltimos ${analysisWindow} giros`,
            maxHistorical: maxConsecutive,
            currentLength: currentSequenceLength,
            isViable: false
        };
    }
    
    // Encontrou! Agora decidir baseado em QUANDO foi
    console.log(`%c   ğŸ•’ Ãšltima sequÃªncia de ${targetSequenceLength}+ ${suggestedColor.toUpperCase()}(s): hÃ¡ ${lastOccurrenceGirosAgo} giros atrÃ¡s`, 'color: #9C27B0; font-weight: bold;');
    
    // âœ… OPÃ‡ÃƒO 1: Aconteceu nos Ãºltimos 20 giros (RECENTE - padrÃ£o ATIVO)
    if (lastOccurrenceGirosAgo < 20) {
        console.log('%c   âœ… OPÃ‡ÃƒO 1: Aconteceu RECENTEMENTE (< 20 giros)', 'color: #00FF00; font-weight: bold; font-size: 14px;');
        console.log('%c      PadrÃ£o estÃ¡ ATIVO! Pode acontecer de novo!', 'color: #00FF88;');
        console.log('%c   ğŸ’¡ DecisÃ£o: MANTER sinal original', 'color: #FFD700; font-weight: bold;');
        
        return {
            shouldInvert: false,
            reason: `SequÃªncia aconteceu recentemente (hÃ¡ ${lastOccurrenceGirosAgo} giros) - padrÃ£o ativo`,
            maxHistorical: maxConsecutive,
            currentLength: currentSequenceLength,
            isViable: true
        };
    }
    
    // âš ï¸ OPÃ‡ÃƒO 2: Aconteceu entre 20-50 giros (ZONA CINZENTA - analisar mais)
    if (lastOccurrenceGirosAgo >= 20 && lastOccurrenceGirosAgo <= 50) {
        console.log('%c   âš ï¸ OPÃ‡ÃƒO 2: Aconteceu na ZONA CINZENTA (20-50 giros)', 'color: #FFA500; font-weight: bold; font-size: 14px;');
        console.log('%c      Analisando mais profundamente...', 'color: #FFAA00;');
        
        // Buscar TODAS as ocorrÃªncias dessa sequÃªncia
        let allOccurrences = [];
        tempStreak = 0;
        tempLastColor = null;
        
        for (let i = 0; i < analysisWindow; i++) {
            const spin = history[i];
            
            if (spin.color === suggestedColor) {
                if (tempLastColor !== suggestedColor) {
                    tempStreak = 1;
                } else {
                    tempStreak++;
                }
                
                if (tempStreak >= targetSequenceLength) {
                    if (allOccurrences.length === 0 || allOccurrences[allOccurrences.length - 1] !== i) {
                        allOccurrences.push(i);
                    }
                }
                
                tempLastColor = suggestedColor;
            } else {
                // Qualquer cor diferente QUEBRA a sequÃªncia!
                tempStreak = 0;
                tempLastColor = spin.color;
            }
        }
        
        console.log(`%c      ğŸ“Š Total de ocorrÃªncias encontradas: ${allOccurrences.length}`, 'color: #FFAA00;');
        
        if (allOccurrences.length >= 2) {
            // Calcular intervalo mÃ©dio entre ocorrÃªncias
            let intervals = [];
            for (let i = 1; i < allOccurrences.length; i++) {
                intervals.push(allOccurrences[i] - allOccurrences[i - 1]);
            }
            const avgInterval = intervals.reduce((sum, val) => sum + val, 0) / intervals.length;
            
            console.log(`%c      ğŸ“ˆ Intervalo mÃ©dio entre ocorrÃªncias: ${Math.round(avgInterval)} giros`, 'color: #FFAA00;');
            
            // Se o intervalo atual estÃ¡ ABAIXO da mÃ©dia, pode quebrar em breve
            if (lastOccurrenceGirosAgo < avgInterval * 0.8) {
                console.log('%c      âœ… Intervalo atual < 80% da mÃ©dia â†’ PODE QUEBRAR!', 'color: #00FF88; font-weight: bold;');
                console.log('%c   ğŸ’¡ DecisÃ£o: MANTER sinal', 'color: #FFD700; font-weight: bold;');
                
                return {
                    shouldInvert: false,
                    reason: `Intervalo atual (${lastOccurrenceGirosAgo}) < mÃ©dia histÃ³rica (${Math.round(avgInterval)}) - pode quebrar`,
                    maxHistorical: maxConsecutive,
                    currentLength: currentSequenceLength,
                    isViable: true
                };
            } else {
                console.log('%c      âŒ Intervalo atual > 80% da mÃ©dia â†’ AINDA CEDO!', 'color: #FF6666; font-weight: bold;');
                console.log('%c   ğŸ’¡ DecisÃ£o: CANCELAR sinal (ainda cedo)', 'color: #FFD700; font-weight: bold;');
                
                return {
                    shouldInvert: false,  // âœ… NÃƒO inverte
                    shouldReject: true,   // âœ… REJEITA
                    reason: `Intervalo atual (${lastOccurrenceGirosAgo}) > mÃ©dia histÃ³rica (${Math.round(avgInterval)}) - ainda cedo`,
                    maxHistorical: maxConsecutive,
                    currentLength: currentSequenceLength,
                    isViable: false
                };
            }
        } else {
            // SÃ³ aconteceu 1 vez no histÃ³rico - muito raro!
            console.log('%c      âš ï¸ Apenas 1 ocorrÃªncia no histÃ³rico â†’ RARO!', 'color: #FFA500; font-weight: bold;');
            console.log('%c   ğŸ’¡ DecisÃ£o: CANCELAR sinal (evento raro)', 'color: #FFD700; font-weight: bold;');
            
            return {
                shouldInvert: false,  // âœ… NÃƒO inverte
                shouldReject: true,   // âœ… REJEITA
                reason: `Apenas 1 ocorrÃªncia nos Ãºltimos ${analysisWindow} giros - evento raro`,
                maxHistorical: maxConsecutive,
                currentLength: currentSequenceLength,
                isViable: false
            };
        }
    }
    
    // âŒ OPÃ‡ÃƒO 3: Aconteceu hÃ¡ MAIS de 50 giros (MUITO TEMPO - resistÃªncia forte)
    console.log('%c   âŒ OPÃ‡ÃƒO 3: Aconteceu hÃ¡ MUITO TEMPO (> 50 giros)', 'color: #FF0000; font-weight: bold; font-size: 14px;');
    console.log('%c      Faz muito tempo! ResistÃªncia forte!', 'color: #FF6666;');
    console.log('%c   ğŸ’¡ DecisÃ£o: CANCELAR sinal (faz muito tempo)', 'color: #FFD700; font-weight: bold;');
    
    return {
        shouldInvert: false,  // âœ… NÃƒO inverte
        shouldReject: true,   // âœ… REJEITA
        reason: `Ãšltima ocorrÃªncia hÃ¡ ${lastOccurrenceGirosAgo} giros - resistÃªncia forte (> 50 giros)`,
        maxHistorical: maxConsecutive,
        currentLength: currentSequenceLength,
        isViable: false
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ FUNÃ‡Ã•ES AUXILIARES PARA SISTEMA DE 5 NÃVEIS - MODO DIAMANTE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Identifica se Ã© Giro 1 ou Giro 2 baseado no timestamp
 * Cada minuto tem 2 giros (aproximadamente a cada 30 segundos)
 */
function identifySpinPosition(timestamp) {
    const date = new Date(timestamp);
    const seconds = date.getSeconds();
    
    // Giro 1: segundos 0-29
    // Giro 2: segundos 30-59
    return seconds < 30 ? 1 : 2;
}

function normalizeSpinColorValue(input) {
    if (input == null) return null;
    const color = typeof input === 'string' ? input : input.color;
    if (!color) return null;
    const normalized = String(color).toLowerCase();
    if (normalized === 'red' || normalized === 'black' || normalized === 'white') {
        return normalized;
    }
    return null;
}

function toColorEmoji(color) {
    switch (color) {
        case 'red':
            return 'ğŸ”´';
        case 'black':
            return 'âš«';
        case 'white':
            return 'âšª';
        default:
            return 'â”';
    }
}

function formatNgramWindowDisplay(windowSequence = []) {
    if (!Array.isArray(windowSequence) || windowSequence.length === 0) {
        return 'N/A';
    }
    return windowSequence.map(toColorEmoji).join(' â†’ ');
}

function summarizeNgramCounts(counts = {}) {
    const summary = Object.entries(counts)
        .filter(([, value]) => Number(value) > 0)
        .map(([color, value]) => `${toColorEmoji(color)} ${color.toUpperCase()} (${value})`);
    return summary.length > 0 ? summary.join(' | ') : 'Nenhuma ocorrÃªncia registrada';
}

function computeNgramStats(sequence, targetWindow, length) {
    if (!Array.isArray(sequence) || !Array.isArray(targetWindow)) {
        return { total: 0, counts: {} };
    }
    if (sequence.length <= length || targetWindow.length !== length) {
        return { total: 0, counts: {} };
    }
    let total = 0;
    const counts = { red: 0, black: 0, white: 0 };
    for (let i = 0; i + length < sequence.length; i++) {
        let matches = true;
        for (let j = 0; j < length; j++) {
            if (sequence[i + j] !== targetWindow[j]) {
                matches = false;
                break;
            }
        }
        if (!matches) continue;
        const nextColor = sequence[i + length];
        if (!nextColor) continue;
        if (!counts[nextColor]) {
            counts[nextColor] = 0;
        }
        counts[nextColor] += 1;
        total += 1;
    }
    return { total, counts };
}

/**
 * NÃVEL 1: AnÃ¡lise de Cor Dominante
 * Analisa os Ãºltimos 15 giros e retorna a cor que mais saiu
 */
function analyzeDominantColor(history) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #9C27B0; font-weight: bold;');
    console.log('%câ”‚ ğŸ” NÃVEL 1: ANÃLISE DE COR DOMINANTE (15 GIROS)       â”‚', 'color: #9C27B0; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #9C27B0; font-weight: bold;');
    
    const last15 = history.slice(0, Math.min(15, history.length));
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${history.length}`);
    console.log(`   ğŸ“Š Analisando Ãºltimos: ${last15.length} giros`);
    
    let counts = { red: 0, black: 0, white: 0 };
    last15.forEach(spin => {
        if (spin.color in counts) {
            counts[spin.color]++;
        }
    });
    
    console.log(`   ğŸ”´ Vermelhos: ${counts.red} (${(counts.red / last15.length * 100).toFixed(1)}%)`);
    console.log(`   âš« Pretos: ${counts.black} (${(counts.black / last15.length * 100).toFixed(1)}%)`);
    console.log(`   âšª Brancos: ${counts.white} (${(counts.white / last15.length * 100).toFixed(1)}%)`);
    
    // Determinar cor dominante (ignorar branco)
    const dominantColor = counts.red > counts.black ? 'red' : 'black';
    console.log(`   ğŸ—³ï¸ VOTA: ${dominantColor.toUpperCase()} (cor dominante)`);
    
    return {
        color: dominantColor,
        counts: counts,
        total: last15.length,
        percentage: {
            red: (counts.red / last15.length * 100).toFixed(1),
            black: (counts.black / last15.length * 100).toFixed(1),
            white: (counts.white / last15.length * 100).toFixed(1)
        }
    };
}

/**
 * NÃVEL 2: AnÃ¡lise de PosiÃ§Ã£o do Giro
 * Analisa qual cor mais saiu na posiÃ§Ã£o especÃ­fica (Giro 1 ou Giro 2)
 * targetPosition: 1 ou 2 (qual giro queremos analisar)
 */
function analyzeSpinPosition(history, targetPosition) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #00D4FF; font-weight: bold;');
    console.log(`%câ”‚ ğŸ” NÃVEL 2: POSIÃ‡ÃƒO DO GIRO (GIRO ${targetPosition})                  â”‚`, 'color: #00D4FF; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #00D4FF; font-weight: bold;');
    
    const last30 = history.slice(0, Math.min(30, history.length));
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${history.length}`);
    console.log(`   ğŸ“Š Analisando Ãºltimos: ${last30.length} giros`);
    console.log(`   ğŸ¯ Filtrando apenas: Giro ${targetPosition} de cada minuto`);
    
    let counts = { red: 0, black: 0, white: 0 };
    let analyzed = 0;
    
    last30.forEach(spin => {
        if (!spin.timestamp) return;
        
        const position = identifySpinPosition(spin.timestamp);
        if (position === targetPosition) {
            if (spin.color in counts) {
                counts[spin.color]++;
                analyzed++;
            }
        }
    });
    
    console.log(`   ğŸ“Š Total de Giro ${targetPosition} encontrados: ${analyzed}`);
    console.log(`   ğŸ”´ Vermelhos: ${counts.red} (${analyzed > 0 ? (counts.red / analyzed * 100).toFixed(1) : '0.0'}%)`);
    console.log(`   âš« Pretos: ${counts.black} (${analyzed > 0 ? (counts.black / analyzed * 100).toFixed(1) : '0.0'}%)`);
    console.log(`   âšª Brancos: ${counts.white} (${analyzed > 0 ? (counts.white / analyzed * 100).toFixed(1) : '0.0'}%)`);
    
    // Determinar cor dominante nessa posiÃ§Ã£o (ignorar branco)
    const dominantColor = counts.red > counts.black ? 'red' : 'black';
    console.log(`   ğŸ—³ï¸ VOTA: ${dominantColor.toUpperCase()} (mais frequente no Giro ${targetPosition})`);
    
    return {
        color: dominantColor,
        counts: counts,
        analyzed: analyzed,
        percentage: analyzed > 0 ? {
            red: (counts.red / analyzed * 100).toFixed(1),
            black: (counts.black / analyzed * 100).toFixed(1),
            white: (counts.white / analyzed * 100).toFixed(1)
        } : { red: '0.0', black: '0.0', white: '0.0' }
    };
}

/**
 * NÃVEL 3: AnÃ¡lise de Soma dos Minutos
 * Analisa minutos com mesmo final (ex: :11, :21, :31, :41, :51)
 * Faz duas contas: 1) Cor dominante no minuto, 2) Cor dominante na posiÃ§Ã£o do giro
 */
function analyzeMinuteSum(history, currentMinute, targetPosition) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #FF6B35; font-weight: bold;');
    console.log(`%câ”‚ ğŸ” NÃVEL 3: SOMA DOS MINUTOS (X${currentMinute % 10})                  â”‚`, 'color: #FF6B35; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #FF6B35; font-weight: bold;');
    
    const last30 = history.slice(0, Math.min(30, history.length));
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${history.length}`);
    console.log(`   ğŸ“Š Analisando Ãºltimos: ${last30.length} giros`);
    console.log(`   ğŸ• Filtrando minutos terminados em: ${currentMinute % 10} (:${currentMinute % 10}, :1${currentMinute % 10}, :2${currentMinute % 10}...)`);
    console.log(`   ğŸ¯ Giro alvo: Giro ${targetPosition}`);
    
    // Primeira conta: Qual cor domina no minuto especÃ­fico
    let minuteCounts = { red: 0, black: 0, white: 0 };
    
    // Segunda conta: Qual cor domina na posiÃ§Ã£o do giro desse minuto
    let positionCounts = { red: 0, black: 0, white: 0 };
    
    last30.forEach(spin => {
        if (!spin.timestamp) return;
        
        const date = new Date(spin.timestamp);
        const minute = date.getMinutes();
        const minuteDigit = minute % 10; // Pegar Ãºltimo dÃ­gito
        
        if (minuteDigit === (currentMinute % 10)) {
            // Conta 1: Cor no minuto
            if (spin.color in minuteCounts) {
                minuteCounts[spin.color]++;
            }
            
            // Conta 2: Cor na posiÃ§Ã£o especÃ­fica desse minuto
            const position = identifySpinPosition(spin.timestamp);
            if (position === targetPosition && spin.color in positionCounts) {
                positionCounts[spin.color]++;
            }
        }
    });
    
    console.log(`   ğŸ“Š CONTA 1 - Cor dominante no minuto X${currentMinute % 10}:`);
    console.log(`      ğŸ”´ Vermelhos: ${minuteCounts.red} | âš« Pretos: ${minuteCounts.black} | âšª Brancos: ${minuteCounts.white}`);
    
    console.log(`   ğŸ“Š CONTA 2 - Cor dominante no Giro ${targetPosition} do minuto X${currentMinute % 10}:`);
    console.log(`      ğŸ”´ Vermelhos: ${positionCounts.red} | âš« Pretos: ${positionCounts.black} | âšª Brancos: ${positionCounts.white}`);
    
    // Determinar vencedores
    const minuteWinner = minuteCounts.red > minuteCounts.black ? 'red' : 'black';
    const positionWinner = positionCounts.red > positionCounts.black ? 'red' : 'black';
    
    console.log(`   ğŸ† Vencedor Conta 1: ${minuteWinner.toUpperCase()}`);
    console.log(`   ğŸ† Vencedor Conta 2: ${positionWinner.toUpperCase()}`);
    
    // Voto final: se ambos concordam, usar consenso. Se divergem, usar primeira conta
    const finalVote = minuteWinner === positionWinner ? minuteWinner : minuteWinner;
    
    if (minuteWinner === positionWinner) {
        console.log(`   âœ… CONSENSO! Ambas as contas concordam`);
    } else {
        console.log(`   âš ï¸ DIVERGÃŠNCIA! Usando Conta 1 (desempate)`);
    }
    console.log(`   ğŸ—³ï¸ VOTA: ${finalVote.toUpperCase()}`);
    
    return {
        color: finalVote,
        minuteCounts: minuteCounts,
        positionCounts: positionCounts,
        minuteWinner: minuteWinner,
        positionWinner: positionWinner,
        consensus: minuteWinner === positionWinner
    };
}

/**
 * NÃVEL 2 (novo): Ritmo AutÃ´nomo (duplas e sequÃªncia)
 * O usuÃ¡rio define uma janela base W e o N2 ajusta automaticamente para encolher/expandir,
 * validando pelo histÃ³rico (ocorrÃªncias) e reiniciando apÃ³s BRANCO.
 */
function analyzeMomentum(history) {
    // âœ… NOVO N2 (final): janela base Ãºnica W (usuÃ¡rio) + liberdade do cÃ³digo para encolher/expandir
    // Config: n2Recent = W (janela base)
    const baseW = Math.max(6, Math.min(200, getDiamondWindow('n2Recent', 10)));

    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #00AAFF; font-weight: bold;');
    console.log(`%câ”‚ ğŸ” N2: RITMO AUTÃ”NOMO (DUPLAS/SEQUÃŠNCIA) â€¢ W=${baseW} â”‚`, 'color: #00AAFF; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #00AAFF; font-weight: bold;');
    
    return analyzeMomentumWithSizes(history, baseW, 0);
}

function analyzeMomentumWithSizes(history, recentSize, previousSize) {
    // âœ… NOVO N2 (ritmo autÃ´nomo): recentSize = W (janela base); previousSize ignorado
    const clampIntLocal = (n, min, max) => {
        const v = Math.floor(Number(n));
        if (!Number.isFinite(v)) return min;
        return Math.max(min, Math.min(max, v));
    };
    const clamp01Local = (v) => Math.max(0, Math.min(1, Number(v) || 0));
    const opp = (c) => c === 'red' ? 'black' : c === 'black' ? 'red' : null;

    const W = clampIntLocal(recentSize, 6, 200);
    const available = Array.isArray(history) ? history.length : 0;

    const currentColor = normalizeSpinColorValue(Array.isArray(history) ? history[0] : null);
    if (currentColor !== 'red' && currentColor !== 'black') {
        return {
            color: null,
            momentum: { red: '0.0', black: '0.0' },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'ultimo_nao_rb',
            details: 'NULO â€¢ Ãºltimo giro nÃ£o Ã© vermelho/preto'
        };
    }

    if (available < 6) {
        return {
            color: null,
            momentum: { red: '0.0', black: '0.0' },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'historico_insuficiente',
            details: `NULO â€¢ histÃ³rico insuficiente (${available}/6)`
        };
    }

    // Base histÃ³rica (para ocorrÃªncias): maior que W, mas com limite para performance
    const historyCap = Math.min(
        available,
        Math.max(120, Math.min(800, Math.floor(W * 30)))
    );
    const baseSpins = history.slice(0, historyCap).reverse(); // antigo -> recente
    const baseSeq = baseSpins.map(spin => normalizeSpinColorValue(spin)); // red/black/white/null

    const buildRuns = (seqChron) => {
        const by = { red: [], black: [] };
        let cur = null;
        let len = 0;
        for (const c of seqChron) {
            if (c !== 'red' && c !== 'black') {
                if (cur) {
                    by[cur].push(len);
                    cur = null;
                    len = 0;
                }
                continue; // branco quebra
            }
            if (c === cur) {
                len += 1;
    } else {
                if (cur) by[cur].push(len);
                cur = c;
                len = 1;
            }
        }
        if (cur) by[cur].push(len);
        return by;
    };

    const percentile = (arr, p) => {
        const list = Array.isArray(arr) ? arr.slice().filter(n => Number.isFinite(Number(n)) && Number(n) > 0).map(n => Number(n)) : [];
        if (list.length === 0) return 0;
        list.sort((a, b) => a - b);
        const idx = Math.max(0, Math.min(list.length - 1, Math.floor((list.length - 1) * p)));
        return list[idx];
    };

    const baseRunsBy = buildRuns(baseSeq);

    const evalWindow = (w) => {
        const windowSpins = history.slice(0, w).reverse(); // antigo -> recente
        const seq = windowSpins.map(spin => normalizeSpinColorValue(spin)); // red/black/white/null

        const minConfirm = Math.max(6, Math.floor(W * 0.6));

        // âœ… Regra principal do N2 (como vocÃª descreveu):
        // A cor-alvo sÃ³ Ã© vÃ¡lida se, desde o Ãºltimo "singleton" (run=1) COMPLETO dela,
        // ela NÃƒO tiver mais aparecido sozinha (apenas em duplas+). Se sair sÃ³, reinicia dali.
        const findLastSingletonBreak = (seqArr, targetColor) => {
            let cur = null;
            let len = 0;
            let start = 0;
            let lastBreakAt = -1;
            for (let i = 0; i < seqArr.length; i++) {
                const c = seqArr[i];
                const isRB = (c === 'red' || c === 'black');
                if (isRB) {
                    if (c === cur) {
                        len += 1;
                    } else {
                        // fechar run anterior
                        if (cur === targetColor && len === 1) {
                            lastBreakAt = start; // singleton confirmado (porque mudou)
                        }
                        cur = c;
                        len = 1;
                        start = i;
                    }
                } else {
                    // fechar run anterior (branco/preenchimento tambÃ©m confirma a quebra se a run era singleton)
                    if (cur === targetColor && len === 1) {
                        lastBreakAt = start;
                    }
                    cur = null;
                    len = 0;
                    start = i + 1;
                }
            }
            // NÃ£o marcar o Ãºltimo run (mais recente) como quebra: ele ainda estÃ¡ "em andamento"
            return lastBreakAt;
        };

        const pairRate = (lens) => {
            const n = lens.length;
            if (!n) return 0;
            const pairs = lens.filter(v => v >= 2).length;
            return pairs / n;
        };
        const maxLen = (lens) => lens.length ? Math.max(...lens) : 0;
        const singleRate = (lens) => {
            const n = lens.length;
            if (!n) return 0;
            const singles = lens.filter(v => v === 1).length;
            return singles / n;
        };
        const meanLen = (lens) => lens.length ? (lens.reduce((a, b) => a + b, 0) / lens.length) : 0;

        const buildCandidate = (targetColor) => {
            const lastBreakAt = findLastSingletonBreak(seq, targetColor);
            const segment = lastBreakAt >= 0 ? seq.slice(lastBreakAt + 1) : seq;
            const segLen = segment.filter(c => c === 'red' || c === 'black').length;
            if (segLen < minConfirm) return null;

            const runsBy = buildRuns(segment);
            const targetRuns = runsBy[targetColor] || [];
            const other = opp(targetColor);
            const otherRuns = other ? (runsBy[other] || []) : [];

            const rRuns = runsBy.red || [];
            const bRuns = runsBy.black || [];
            const totalRuns = rRuns.length + bRuns.length;
            if (totalRuns < 4) return null;
            if (rRuns.length < 1 || bRuns.length < 1) return null;

            // âœ… â€œNunca sai sÃ³â€: todas as runs COMPLETAS da cor-alvo devem ser >= 2.
            // A Ãºltima run (mais recente) pode estar "em andamento" e pode ser 1 (vamos apostar no 2Âº),
            // mas somente depois de existir "prova suficiente" (ver regra abaixo).
            const isCurrentTarget = currentColor === targetColor;
            const completedTargetRuns = isCurrentTarget ? targetRuns.slice(0, -1) : targetRuns.slice(0);
            if (completedTargetRuns.length === 0) return null; // sem evidÃªncia do padrÃ£o na janela atual
            if (completedTargetRuns.some(v => v < 2)) return null; // houve singleton => deveria ter resetado, logo invÃ¡lido

            // AmeaÃ§a: outra cor com 3+ seguidos derruba totalmente (vocÃª pediu)
            const otherMax = maxLen(otherRuns);
            if (otherMax >= 3) return null;

            const otherSingles = singleRate(otherRuns);
            const completedMean = meanLen(completedTargetRuns);
            const redPair = pairRate(rRuns);
            const blackPair = pairRate(bRuns);

            // Score: quanto mais a outra cor aparece "picada" (singles) e quanto mais a cor-alvo tem runs longas,
            // maior a confianÃ§a do regime "duplas+".
            const evidence = Math.min(1, completedTargetRuns.length / 6);
            const score = clamp01Local(
                (otherSingles * 0.45 + Math.min(1, completedMean / 6) * 0.35 + evidence * 0.20)
            );

            return {
                windowSize: w,
                score,
                target: targetColor,
                other,
                redPair,
                blackPair,
                otherMax,
                totalRuns,
                targetRuns,
                completedTargetRuns,
                segmentLen: segLen,
                lastBreakAt
            };
        };

        const redC = buildCandidate('red');
        const blackC = buildCandidate('black');
        if (!redC && !blackC) return null;
        if (redC && !blackC) return redC;
        if (!redC && blackC) return blackC;
        // desempate: maior score; se empatar, mais prÃ³ximo do W
        if (Math.abs((redC.score || 0) - (blackC.score || 0)) > 1e-9) {
            return (redC.score > blackC.score) ? redC : blackC;
        }
        const dr = Math.abs(redC.windowSize - W);
        const db = Math.abs(blackC.windowSize - W);
        return dr <= db ? redC : blackC;
    };

    // Faixa de busca dinÃ¢mica ao redor de W (sem travar em 6..14)
    const span = Math.max(6, Math.floor(W * 0.55));
    let wMin = Math.max(6, W - span);
    let wMax = Math.min(Math.min(200, available), W + span);
    if (wMax < wMin) { wMin = Math.max(6, Math.min(W, available)); wMax = wMin; }

    const base = W;
    let best = null;
    for (let w = wMin; w <= wMax; w++) {
        const c = evalWindow(w);
        if (!c) continue;
        if (!best) {
            best = c;
            continue;
        }
        if (c.score > best.score + 1e-9) best = c;
        else if (Math.abs(c.score - best.score) <= 1e-9) {
            // tie-break: mais prÃ³ximo do "meio" e mais recente (janela menor)
            const dc = Math.abs(c.windowSize - base);
            const db = Math.abs(best.windowSize - base);
            if (dc < db) best = c;
            else if (dc === db && c.windowSize < best.windowSize) best = c;
        }
    }

    if (!best) {
    return {
            color: null,
            momentum: { red: '0.0', black: '0.0' },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'sem_ritmo',
            details: `NULO â€¢ sem ritmo vÃ¡lido (W=${W} â€¢ busca ${wMin}-${wMax})`
        };
    }

    // tamanho da sequÃªncia atual (sem atravessar branco)
    let currentRunLen = 0;
    for (let i = 0; i < Math.min(best.windowSize, history.length); i++) {
        const c = normalizeSpinColorValue(history[i]);
        if (c !== currentColor) break;
        currentRunLen++;
    }

    // O N2 sÃ³ aposta na cor-alvo quando ela aparece (aposta Ã©: "vai repetir")
    if (currentColor !== best.target) {
        const details = `NULO â€¢ aguardando ${best.target.toUpperCase()} â€¢ W=${W} â€¢ jan ${best.windowSize}`;
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'aguardando_cor_alvo',
            details
        };
    }

    // âœ… REGRA NOVA (pedido): sÃ³ entrar depois de ter "provas" suficientes de que a cor NÃƒO sai sozinha.
    // Prova = ocorrÃªncia de uma run COMPLETA >= 2. A run atual conta como prova sÃ³ quando jÃ¡ estÃ¡ em 2+.
    const completedProofs = Array.isArray(best.completedTargetRuns)
        ? best.completedTargetRuns.filter(v => Number(v) >= 2).length
        : 0;
    const currentProof = (currentRunLen >= 2) ? 1 : 0;
    const proofsTotal = completedProofs + currentProof;
    const PROOFS_REQUIRED = 2;
    if (proofsTotal < PROOFS_REQUIRED) {
        const details = `NULO â€¢ poucas provas (${proofsTotal}/${PROOFS_REQUIRED}) â€¢ run ${currentRunLen} â€¢ W=${W} â€¢ jan ${best.windowSize}`;
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'poucas_provas_duplas',
            details
        };
    }

    // âœ… REGRA NOVA (pedido): se o regime histÃ³rico mostra sequÃªncias longas (4+),
    // nÃ£o entrar no "2Âº" (run=1â†’2). Esperar a dupla se formar e entrar no 3Âº (run>=2).
    const maxCompleted = Array.isArray(best.completedTargetRuns) && best.completedTargetRuns.length
        ? Math.max(...best.completedTargetRuns.map(v => Number(v) || 0))
        : 0;
    const longRegime = maxCompleted >= 4;
    if (longRegime && currentRunLen < 2) {
        const details = `NULO â€¢ regime longo (mÃ¡x ${maxCompleted}) â€¢ aguarde dupla â€¢ run ${currentRunLen} â€¢ W=${W} â€¢ jan ${best.windowSize}`;
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'regime_longo_aguarda_dupla',
            details
        };
    }

    // NÃ£o entrar no "topo" da sequÃªncia: usa p80 para limitar
    // Anti-topo: baseado no "regime atual" (janela apÃ³s reset). Evita apostar em 2â†’3 quando o regime Ã© sÃ³ duplas.
    const topoRuns = Array.isArray(best.completedTargetRuns) ? best.completedTargetRuns.slice() : [];
    // incluir a run atual como evidÃªncia de regime (se jÃ¡ estÃ¡ em 2+)
    if (currentColor === best.target && currentRunLen >= 2) topoRuns.push(currentRunLen);
    const p90Seg = Math.max(1, percentile(topoRuns, 0.9) || 1);
    const maxEnterLen = Math.max(1, p90Seg - 1);
    if (currentRunLen > maxEnterLen) {
        const details = `NULO â€¢ topo seq (${currentRunLen}>${maxEnterLen}) â€¢ W=${W} â€¢ jan ${best.windowSize}`;
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'topo_sequencia',
            details
        };
    }

    // Prob. empÃ­rica de continuar 1 passo: combina base histÃ³rica + janela recente (com suavizaÃ§Ã£o)
    const atRiskRecent = best.targetRuns.filter(len => len >= currentRunLen).length;
    const contRecent = best.targetRuns.filter(len => len >= (currentRunLen + 1)).length;

    // âœ… base histÃ³rica para p(continuar): usar runs da cor-alvo na BASE (Ãºltimos historyCap giros)
    const targetBaseRuns = best.target === 'red'
        ? (baseRunsBy.red || [])
        : (baseRunsBy.black || []);
    const atRiskBase = targetBaseRuns.filter(len => len >= currentRunLen).length;
    const contBase = targetBaseRuns.filter(len => len >= (currentRunLen + 1)).length;

    // Cap base para nÃ£o esmagar o "momento" atual (mantÃ©m o nÃ­vel adaptativo)
    const capBase = 20;
    const atRiskBaseC = Math.min(capBase, atRiskBase);
    const contBaseC = Math.min(atRiskBaseC, contBase);

    const atRisk = atRiskBaseC + atRiskRecent;
    const cont = contBaseC + contRecent;

    if (atRisk < 4) {
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'poucas_ocorrencias',
            details: `NULO â€¢ poucas ocorrÃªncias (n=${atRisk}) â€¢ W=${W} â€¢ jan ${best.windowSize}`
        };
    }
    const pContinue = (cont + 1) / (atRisk + 2); // suavizaÃ§Ã£o

    // Quanto mais avanÃ§ado na sequÃªncia, mais rigoroso (mas o histÃ³rico dita se vale)
    const threshold = currentRunLen <= 1 ? 0.6 : (currentRunLen === 2 ? 0.68 : 0.74);
    if (pContinue < threshold) {
        return {
            color: null,
            momentum: { red: (best.redPair * 100).toFixed(1), black: (best.blackPair * 100).toFixed(1) },
            trending: 'neutral',
            confidence: 0,
            confidencePct: 0,
            reason: 'pcontinue_baixo',
            details: `NULO â€¢ pCont ${(pContinue * 100).toFixed(0)}% < ${(threshold * 100).toFixed(0)}% â€¢ run ${currentRunLen} â€¢ W=${W}`
        };
    }

    // confianÃ§a: mistura forÃ§a do padrÃ£o + prob. de continuar + amostra
    const contConf = clamp01Local((pContinue - threshold) / Math.max(0.05, 1 - threshold));
    const pairDiff = Math.abs(best.redPair - best.blackPair);
    const pairConf = clamp01Local((Math.max(best.redPair, best.blackPair) - 0.55) / 0.45);
    const diffConf = clamp01Local(pairDiff / 0.5);
    const nConf = clamp01Local(best.totalRuns / 12);
    let confidence = clamp01Local(contConf * 0.45 + pairConf * 0.25 + diffConf * 0.20 + nConf * 0.10);
    confidence = clamp01Local(confidence * (0.9 + best.score * 0.2));

    const details =
        `Alvo ${best.target.toUpperCase()} â€¢ W=${W} â€¢ jan ${best.windowSize} â€¢ seg ${best.segmentLen} â€¢ provas ${proofsTotal}/${PROOFS_REQUIRED} â€¢ ` +
        `P2+ R ${(best.redPair * 100).toFixed(0)}% â€¢ B ${(best.blackPair * 100).toFixed(0)}% â€¢ ` +
        `run ${currentRunLen}â†’${currentRunLen + 1} (${(pContinue * 100).toFixed(0)}%)`;

    return {
        color: best.target,
        momentum: {
            red: (best.redPair * 100).toFixed(1),
            black: (best.blackPair * 100).toFixed(1)
        },
        trending: best.target === 'red' ? 'paired_red' : 'paired_black',
        confidence: Number(confidence.toFixed(3)),
        confidencePct: Math.round(confidence * 100),
        reason: 'ok',
        details
    };
}

/**
 * NÃVEL 5 (novo): Ritmo por Giro e Minuto
 * Mede a cor dominante para o prÃ³ximo giro (1 ou 2) dentro do minuto alvo
 * Examina atÃ© windowSize ocorrÃªncias recentes com mesmo minuto e posiÃ§Ã£o
 */
function analyzeMinuteSpinBias(history, targetMinute, targetPosition, windowSize = 60) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #1ABC9C; font-weight: bold;');
    console.log(`%câ”‚ ğŸ” NÃVEL 5: RITMO POR GIRO (min:${String(targetMinute).padStart(2, '0')} â€¢ giro ${targetPosition}) â”‚`, 'color: #1ABC9C; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #1ABC9C; font-weight: bold;');
    
    // windowSize aqui representa "quantas ocorrÃªncias do mesmo minuto/posiÃ§Ã£o" vamos coletar (nÃ£o giros totais)
    const MAX_WINDOW = Math.max(10, Math.min(200, windowSize));
    const counts = { red: 0, black: 0, white: 0, other: 0 };
    const samples = [];
    
    for (let i = 0; i < history.length && samples.length < MAX_WINDOW; i++) {
        const spin = history[i];
        if (!spin || !spin.timestamp) continue;
        
        const pos = identifySpinPosition(spin.timestamp);
        if (pos !== targetPosition) continue;
        
        const date = new Date(spin.timestamp);
        if (date.getMinutes() !== targetMinute) continue;
        
        const c = spin && spin.color ? String(spin.color).toLowerCase() : '';
        if (c === 'red') counts.red++;
        else if (c === 'black') counts.black++;
        else if (c === 'white') counts.white++;
        else counts.other++;
        samples.push({
            color: spin.color,
            number: spin.number,
            timestamp: date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        });
    }
    
    const totalSamples = samples.length;
    const effectiveSamples = counts.red + counts.black;
    
    console.log(`   ğŸ“Š Amostras encontradas: ${totalSamples} (mÃ¡x ${MAX_WINDOW})`);
    console.log(`      ğŸ”´ Vermelhos: ${counts.red}`);
    console.log(`      âš« Pretos: ${counts.black}`);
    console.log(`      âšª Brancos: ${counts.white}`);
    if (counts.other) console.log(`      â“ Outros: ${counts.other}`);
    
    if (totalSamples === 0 || effectiveSamples <= 0) {
        console.log('   âŒ Dados insuficientes para este minuto/giro');
        return {
            color: null,
            confidence: 0,
            dominantPercent: 0,
            totalSamples,
            effectiveSamples,
            reason: 'no_data',
            details: 'Sem dados suficientes para este minuto/giro'
        };
    }
    
    // âœ… Regras de seguranÃ§a (mas ajustadas para janelas pequenas):
    // Aqui o usuÃ¡rio escolhe "quantas ocorrÃªncias" vamos coletar (ex.: 20).
    // EntÃ£o o rigor deve ser compatÃ­vel com N pequeno.
    const MAX_WHITE_RATIO = 0.25; // se muitos brancos, a amostra fica enviesada

    // âœ… Rigor pedido: detectar viÃ©s pequeno (â‰ˆ 6â€“7pp) sem exigir 67% (17pp).
    // edge = |p - 0.5|. Ex.: 56.5% vs 43.5% => edge=6.5pp
    const MIN_EDGE = 0.065;

    // âœ… Amostra mÃ­nima proporcional ao window escolhido (evita exigir 18 quando window=20)
    const MIN_EFFECTIVE_SAMPLES = Math.max(8, Math.min(30, Math.floor(MAX_WINDOW * 0.5)));

    // z-score mÃ­nimo bem mais baixo (compatÃ­vel com N pequeno).
    // ObservaÃ§Ã£o: isto NÃƒO garante que seja "estatisticamente forte"; apenas evita votar com ruÃ­do total.
    const Z_THRESHOLD = 0.6;

    const whiteRatio = totalSamples > 0 ? (counts.white / totalSamples) : 0;
    if (effectiveSamples < MIN_EFFECTIVE_SAMPLES) {
        return {
            color: null,
            confidence: 0,
            dominantPercent: effectiveSamples > 0 ? (Math.max(counts.red, counts.black) / effectiveSamples) : 0,
            totalSamples,
            effectiveSamples,
            reason: 'low_samples',
            details: `NULO â€¢ poucas amostras Ãºteis (${effectiveSamples}/${MIN_EFFECTIVE_SAMPLES})`
        };
    }
    if (whiteRatio > MAX_WHITE_RATIO) {
        return {
            color: null,
            confidence: 0,
            dominantPercent: Math.max(counts.red, counts.black) / effectiveSamples,
            totalSamples,
            effectiveSamples,
            reason: 'too_many_whites',
            details: `NULO â€¢ muitos brancos (${Math.round(whiteRatio * 100)}%)`
        };
    }

    // Empate => NULO (remove viÃ©s)
    if (counts.red === counts.black) {
        return {
            color: null,
            confidence: 0,
            dominantPercent: 0.5,
            totalSamples,
            effectiveSamples,
            reason: 'tie',
            details: `NULO â€¢ empate (${counts.red}/${counts.black})`
        };
    }

    const dominantColor = counts.red > counts.black ? 'red' : 'black';
    const dominantCount = Math.max(counts.red, counts.black);
    const dominantPercent = dominantCount / Math.max(1, effectiveSamples);
    const edge = Math.abs(dominantPercent - 0.5);

    // z-score para diferenÃ§a de proporÃ§Ãµes contra 50/50 (sem odds, sÃ³ histÃ³rico)
    const z = (dominantPercent - 0.5) / Math.sqrt(0.25 / Math.max(1, effectiveSamples));
    const zAbs = Math.abs(z);

    if (edge < MIN_EDGE) {
        return {
            color: null,
            confidence: 0,
            dominantPercent,
            totalSamples,
            effectiveSamples,
            reason: 'edge_low',
            details: `NULO â€¢ viÃ©s < ${Math.round(MIN_EDGE * 100)}pp (${Math.round(edge * 100)}pp)`
        };
    }
    if (zAbs < Z_THRESHOLD) {
        return {
            color: null,
            confidence: 0,
            dominantPercent,
            totalSamples,
            effectiveSamples,
            reason: 'z_low',
            details: `NULO â€¢ z ${zAbs.toFixed(2)} < ${Z_THRESHOLD}`
        };
    }

    // ConfianÃ§a: combina dominÃ¢ncia com significÃ¢ncia + fator de amostra
    const zConf = Math.max(0, Math.min(1, (zAbs - Z_THRESHOLD) / (2.5 - Z_THRESHOLD)));
    const edgeConf = Math.max(0, Math.min(1, (edge - MIN_EDGE) / (0.25 - MIN_EDGE))); // 25pp jÃ¡ seria extremo
    const sampleConf = Math.max(0, Math.min(1, effectiveSamples / 60));
    const confidence = Math.max(0, Math.min(1, zConf * 0.35 + edgeConf * 0.45 + sampleConf * 0.20));

    const dominantPercentFormatted = (dominantPercent * 100).toFixed(1);
    console.log(`   ğŸ† Cor dominante: ${dominantColor.toUpperCase()} (${dominantPercentFormatted}%)`);
    console.log(`   ğŸ—³ï¸ ConfianÃ§a final: ${(confidence * 100).toFixed(0)}% (viÃ©s ${Math.round(edge * 100)}pp â€¢ z ${zAbs.toFixed(2)} â€¢ n=${effectiveSamples})`);
    
    return {
        color: dominantColor,
        confidence,
        dominantPercent,
        totalSamples,
        effectiveSamples,
        zScore: Number(z.toFixed(3)),
        reason: 'ok',
        details: `${dominantPercentFormatted}% ${dominantColor === 'red' ? 'vermelho' : 'preto'} â€¢ viÃ©s ${Math.round(edge * 100)}pp â€¢ z ${zAbs.toFixed(2)} â€¢ n=${effectiveSamples}`
    };
}

function analyzeHistoricalRetracement(history, windowSize = 80, intensity = 'aggressive') {
    const windowCap = Math.max(30, Math.min(200, Number(windowSize) || 80));
    const rawWindow = Array.isArray(history) ? history.slice(0, Math.min(windowCap, history.length)) : [];

    // âš ï¸ CorreÃ§Ã£o crÃ­tica: branco NÃƒO pode ser "ignorado" aqui.
    // Se filtrarmos branco fora, a sequÃªncia pode "atravessar" branco e virar falsa.
    const norm = rawWindow.map(spin => normalizeSpinColorValue(spin)); // red/black/white/null
    const rb = norm.filter(c => c === 'red' || c === 'black');
    const whiteCount = norm.filter(c => c === 'white').length;
    const total = norm.filter(c => c === 'red' || c === 'black' || c === 'white').length;
    const whiteRatio = total > 0 ? (whiteCount / total) : 0;

    const MIN_EFFECTIVE = 30;
    const MAX_WHITE_RATIO = 0.18;
    if (rb.length < MIN_EFFECTIVE) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            ratio: 0,
            reason: 'amostra_insuficiente',
            details: `NULO â€¢ amostra Ãºtil ${rb.length}/${MIN_EFFECTIVE}`
        };
    }
    if (whiteRatio > MAX_WHITE_RATIO) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            ratio: 0,
            reason: 'muito_branco',
            details: `NULO â€¢ muitos brancos (${Math.round(whiteRatio * 100)}%)`
        };
    }

    const first = norm[0];
    if (first !== 'red' && first !== 'black') {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            ratio: 0,
            reason: 'ultimo_nao_rb',
            details: 'NULO â€¢ Ãºltimo giro nÃ£o Ã© vermelho/preto'
        };
    }

    const currentColor = first;
    let currentStreak = 0;
    for (let i = 0; i < norm.length; i++) {
        const c = norm[i];
        if (c === currentColor) currentStreak++;
        else break; // QUALQUER outra cor (inclui branco) quebra
    }

    // Mapear runs dentro da janela (branco quebra)
    const runsByColor = { red: [], black: [] };
    for (let i = 0; i < norm.length;) {
        const c = norm[i];
        if (c !== 'red' && c !== 'black') {
            i++;
            continue;
        }
        let j = i + 1;
        while (j < norm.length && norm[j] === c) j++;
        runsByColor[c].push(j - i);
        i = j;
    }

    const runs = runsByColor[currentColor] || [];
    const maxStreakFound = runs.length > 0 ? Math.max(...runs) : currentStreak;
    const historicalMax = Math.max(1, maxStreakFound);
    const ratioPct = Math.min(100, Math.round((currentStreak / historicalMax) * 100));

    // Probabilidade empÃ­rica de continuar 1 passo (sem olhar futuro, sÃ³ runs histÃ³ricos da janela)
    const MIN_AT_RISK = 5;
    const atRisk = runs.filter(len => len >= currentStreak).length;
    const cont = runs.filter(len => len >= (currentStreak + 1)).length;
    const pContinue = atRisk > 0 ? (cont / atRisk) : 0;

    if (atRisk < MIN_AT_RISK) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            ratio: ratioPct,
            reason: 'poucas_ocorrencias',
            details: `NULO â€¢ poucas ocorrÃªncias (${atRisk}/${MIN_AT_RISK}) â€¢ seq ${currentStreak}/${historicalMax}`
        };
    }

    const thresholds = {
        aggressive: { inversion: 70, minDelta: 0.28, z: 2.33 },
        conservative: { inversion: 85, minDelta: 0.35, z: 2.58 }
    };
    const t = thresholds[intensity] || thresholds.aggressive;

    let color = null;
    let strength = 0;
    let status = 'âš–ï¸ Neutra';
    let reason = 'neutral';

    // Regra 1: reversÃ£o sÃ³ faz sentido com sequÃªncia mÃ­nima
    const MIN_STREAK_REV = 3;
    const MIN_STREAK_CONT = 2;

    // z-score contra 50/50 da "continuaÃ§Ã£o" (aproximaÃ§Ã£o binomial) para evitar ruÃ­do
    const pHat = pContinue;
    const se = Math.sqrt(Math.max(0, 0.25 / Math.max(1, atRisk)));
    const z = se > 0 ? (pHat - 0.5) / se : 0;
    const zAbs = Math.abs(z);

    if (currentStreak >= MIN_STREAK_REV && ratioPct >= t.inversion && pContinue <= (0.5 - t.minDelta) && zAbs >= t.z) {
        color = currentColor === 'red' ? 'black' : 'red';
        const edge = Math.min(1, ((0.5 - t.minDelta) - pContinue) / 0.5);
        const prox = Math.min(1, (ratioPct - t.inversion) / (100 - t.inversion));
        strength = clamp01(edge * 0.65 + prox * 0.35);
        status = 'ğŸ”„ ReversÃ£o provÃ¡vel';
        reason = 'reversion';
    } else if (currentStreak >= MIN_STREAK_CONT && ratioPct <= 40 && pContinue >= (0.5 + t.minDelta) && zAbs >= t.z) {
        color = currentColor;
        const edge = Math.min(1, (pContinue - (0.5 + t.minDelta)) / 0.5);
        const room = Math.min(1, (40 - ratioPct) / 40);
        strength = clamp01(edge * 0.7 + room * 0.3);
        status = 'âœ… ContinuaÃ§Ã£o';
        reason = 'continuation';
    } else {
        status = 'âš–ï¸ Zona neutra';
        reason = 'neutral_thresholds';
    }

    const details = color
        ? `${status} â€¢ seq ${currentStreak}/${historicalMax} (${ratioPct}%) â€¢ pCont ${(pContinue * 100).toFixed(0)}% (${cont}/${atRisk}) â€¢ z ${zAbs.toFixed(2)}`
        : `NULO â€¢ ${status} â€¢ seq ${currentStreak}/${historicalMax} (${ratioPct}%) â€¢ pCont ${(pContinue * 100).toFixed(0)}% (${cont}/${atRisk})`;

    return {
        color,
        strength,
        status,
        ratio: ratioPct,
        reason,
        details
    };
}

function analyzeBayesianCalibration(history, baseWindow = 100, priorConfig = { red: 1, black: 1, white: 0.5 }, nullDiff = 0.08) {
    const sanitizedBase = Math.max(20, Math.min(500, Number(baseWindow) || 100));
    const windowSize = Math.min(history.length, sanitizedBase);
    const windowSpins = history.slice(0, windowSize);

    const counts = { red: 0, black: 0, white: 0 };
    windowSpins.forEach(spin => {
        if (spin && typeof spin.color === 'string' && Object.prototype.hasOwnProperty.call(counts, spin.color)) {
            counts[spin.color]++;
        }
    });

    const totalSamples = counts.red + counts.black + counts.white;
    const coverage = Math.min(1, totalSamples / Math.max(1, sanitizedBase));

    const prior = {
        red: Math.max(0.01, Number(priorConfig.red) || 1),
        black: Math.max(0.01, Number(priorConfig.black) || 1),
        white: Math.max(0.01, Number(priorConfig.white) || Math.max(0.01, (Number(priorConfig.red) || 1) * 0.5))
    };

    const posterior = {
        red: prior.red + counts.red,
        black: prior.black + counts.black,
        white: prior.white + counts.white
    };
    const posteriorTotal = posterior.red + posterior.black + posterior.white;

    const probabilities = {
        red: posteriorTotal > 0 ? posterior.red / posteriorTotal : 1 / 3,
        black: posteriorTotal > 0 ? posterior.black / posteriorTotal : 1 / 3,
        white: posteriorTotal > 0 ? posterior.white / posteriorTotal : 1 / 3
    };

    const sorted = Object.entries(probabilities).sort(([, a], [, b]) => b - a);
    const [topColor, topProb] = sorted[0] || ['red', 1 / 3];
    const [, secondProb] = sorted[1] || ['black', 1 / 3];
    const gap = topProb - secondProb;
    const effectiveThreshold = Math.max(0.01, Number(nullDiff) || 0.08);
    const normalizedGap = Math.min(1, gap / effectiveThreshold);
    const strength = coverage * normalizedGap;
    const shouldStayNeutral = gap < effectiveThreshold || coverage < 0.3;
    const selectedColor = shouldStayNeutral ? null : topColor;

    const maxProb = Math.max(probabilities.red, probabilities.black, probabilities.white, 0.0001);
    const adjustments = {};
    ['red', 'black', 'white'].forEach(color => {
        const ratio = maxProb > 0 ? probabilities[color] / maxProb : 1;
        let factor = (ratio * coverage) + (1 - coverage);
        if (color === topColor) {
            factor = Math.min(1.05, factor + Math.min(0.05, gap * 0.25));
        }
        factor = Math.max(0.35, Math.min(1.05, factor));
        adjustments[color] = factor;
    });

    const toPct = value => `${(value * 100).toFixed(1)}%`;
    const diffPct = (gap * 100).toFixed(1);
    const detailsParts = [
        `ğŸ”´ ${toPct(probabilities.red)}`,
        `âš« ${toPct(probabilities.black)}`,
        `âšª ${toPct(probabilities.white)}`,
        `Î” ${diffPct}%`,
        `jan ${totalSamples}/${sanitizedBase}`
    ];

    if (shouldStayNeutral) {
        detailsParts.push(`nulo < ${(effectiveThreshold * 100).toFixed(0)}%`);
    } else {
        detailsParts.push(`lider ${topColor.toUpperCase()}`);
    }

    return {
        color: selectedColor,
        probabilities,
        strength,
        gap,
        coverage,
        adjustments,
        details: detailsParts.join(' â€¢ '),
        totalSamples,
        baseWindow: sanitizedBase,
        threshold: effectiveThreshold,
        nullVote: shouldStayNeutral
    };
}

function analyzeGlobalContinuity(signalData, decisionWindow = 20, historyLimit = 100, intensity = 'aggressive') {
    if (!signalData || !Array.isArray(signalData.signals) || signalData.signals.length === 0) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            details: 'Sem decisÃµes registradas'
        };
    }

    const relevantSignals = signalData.signals
        .slice(-Math.max(decisionWindow, Math.min(800, Number(historyLimit) || 100)))
        .filter(sig => sig && typeof sig.hit === 'boolean' && (sig.colorRecommended === 'red' || sig.colorRecommended === 'black'));

    const minBase = Math.max(12, Math.min(decisionWindow, 25));
    if (relevantSignals.length < minBase) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            details: `HistÃ³rico de decisÃµes insuficiente (${relevantSignals.length}/${minBase})`
        };
    }

    const windowSignals = relevantSignals.slice(-decisionWindow);
    const colorStats = {
        red: { attempts: 0, hits: 0 },
        black: { attempts: 0, hits: 0 }
    };

    windowSignals.forEach(sig => {
        const color = sig.colorRecommended;
        if (!colorStats[color]) return;
        colorStats[color].attempts++;
        if (sig.hit) colorStats[color].hits++;
    });

    const totalAttempts = windowSignals.length;
    const totalHits = windowSignals.filter(sig => sig.hit).length;
    const overallRate = totalAttempts > 0 ? (totalHits / totalAttempts) * 100 : 0;

    const thresholds = {
        aggressive: { high: 55, low: 40 },
        conservative: { high: 65, low: 50 }
    };
    const { high } = thresholds[intensity] || thresholds.aggressive;

    // âœ… Se a taxa geral estÃ¡ baixa, esse nÃ­vel NÃƒO deve "forÃ§ar" voto (evita ruÃ­do)
    if (overallRate < high) {
        return {
            color: null,
            strength: 0,
            status: 'âš ï¸ Instabilidade',
            reason: 'overall_low',
            details: `NULO â€¢ taxa geral ${overallRate.toFixed(1)}% < ${high}% â€¢ n=${totalAttempts}`
        };
    }

    const rAtt = colorStats.red.attempts;
    const bAtt = colorStats.black.attempts;
    const rHit = colorStats.red.hits;
    const bHit = colorStats.black.hits;

    // âœ… Para comparar cores, precisamos de amostra mÃ­nima em AMBAS.
    const MIN_PER_COLOR = 6;
    if (rAtt < MIN_PER_COLOR || bAtt < MIN_PER_COLOR) {
        return {
            color: null,
            strength: 0,
            status: 'âŒ Nulo',
            reason: 'per_color_low',
            details: `NULO â€¢ poucas amostras por cor (R ${rAtt}/${MIN_PER_COLOR} â€¢ B ${bAtt}/${MIN_PER_COLOR})`
        };
    }

    const pR = rAtt > 0 ? rHit / rAtt : 0;
    const pB = bAtt > 0 ? bHit / bAtt : 0;
    const delta = pR - pB;
    const deltaAbs = Math.abs(delta);

    // CritÃ©rio de rigor: diferenÃ§a mÃ­nima (15-20pp) + significÃ¢ncia
    const MIN_DELTA = intensity === 'conservative' ? 0.20 : 0.15;
    const Z_THRESHOLD = intensity === 'conservative' ? 2.58 : 2.33;

    if (deltaAbs < MIN_DELTA) {
        return {
            color: null,
            strength: 0,
            status: 'âš–ï¸ Neutra',
            reason: 'delta_low',
            details: `NULO â€¢ Î” ${(deltaAbs * 100).toFixed(0)}pp < ${(MIN_DELTA * 100).toFixed(0)}pp â€¢ R ${(pR * 100).toFixed(0)}% â€¢ B ${(pB * 100).toFixed(0)}%`
        };
    }

    const pooled = (rHit + bHit) / Math.max(1, rAtt + bAtt);
    const se = Math.sqrt(Math.max(0, pooled * (1 - pooled)) * (1 / rAtt + 1 / bAtt));
    const z = se > 0 ? delta / se : 0;
    const zAbs = Math.abs(z);
    if (zAbs < Z_THRESHOLD) {
        return {
            color: null,
            strength: 0,
            status: 'âš–ï¸ Neutra',
            reason: 'z_low',
            details: `NULO â€¢ z ${zAbs.toFixed(2)} < ${Z_THRESHOLD} â€¢ Î” ${(deltaAbs * 100).toFixed(0)}pp`
        };
    }

    const voteColor = delta > 0 ? 'red' : 'black';
    const zConf = Math.max(0, Math.min(1, (zAbs - Z_THRESHOLD) / (4 - Z_THRESHOLD)));
    const dConf = Math.max(0, Math.min(1, (deltaAbs - MIN_DELTA) / (0.45 - MIN_DELTA)));
    const nConf = Math.max(0, Math.min(1, totalAttempts / 40));
    const strength = clamp01(zConf * 0.55 + dConf * 0.35 + nConf * 0.10);
    const status = strength >= 0.85 ? 'ğŸ”¥ Alta confianÃ§a' : 'âœ… Continuidade';

    const details = `${status} â€¢ Î” ${(delta * 100).toFixed(0)}pp â€¢ z ${zAbs.toFixed(2)} â€¢ geral ${overallRate.toFixed(1)}% â€¢ R ${rHit}/${rAtt} â€¢ B ${bHit}/${bAtt}`;

    return {
        color: voteColor,
        strength,
        status,
        reason: 'ok',
        details
    };
}

/**
 * NÃVEL 6: Barreira/Freio - Valida se a sequÃªncia Ã© viÃ¡vel historicamente
 * Usa somente os Ãºltimos 50 giros para garantir proteÃ§Ã£o recente
 */
function validateSequenceBarrier(history, predictedColor, configuredSize, alternanceInfo = null) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #FF0000; font-weight: bold;');
    console.log('%câ”‚ ğŸ” NÃVEL 6: BARREIRA (FREIO DE SEGURANÃ‡A)             â”‚', 'color: #FF0000; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #FF0000; font-weight: bold;');
    
    const barrierWindowConfigured = Math.max(1, configuredSize || 50);
    const effectiveWindow = Math.min(barrierWindowConfigured, history.length);
    const last = history.slice(0, effectiveWindow);
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${history.length}`);
    console.log(`   ğŸ“Š HistÃ³rico configurado: ${configuredSize} giros`);
    console.log(`   ğŸ“Š Janela da barreira: ${barrierWindowConfigured} giros`);
    console.log(`   ğŸ“Š Analisando Ãºltimos: ${last.length} giros`);
    console.log(`   ğŸ¯ Cor prevista pelos outros nÃ­veis: ${predictedColor.toUpperCase()}`);
    
    // Contar quantos da cor prevista jÃ¡ saÃ­ram consecutivamente
    // âš ï¸ IMPORTANTE: BRANCO QUEBRA A SEQUÃŠNCIA!
    let currentStreak = 0;
    for (let i = 0; i < last.length; i++) {
        if (last[i].color === predictedColor) {
            currentStreak++;
        } else {
            // âœ… QUALQUER outra cor (incluindo BRANCO) quebra a sequÃªncia!
            break;
        }
    }
    
    console.log(`   ğŸ“Š SequÃªncia atual de ${predictedColor.toUpperCase()}: ${currentStreak} giro(s)`);
    
    // Verificar se sequÃªncia de (currentStreak + 1) jÃ¡ aconteceu
    const targetStreak = currentStreak + 1;
    console.log(`   ğŸ¯ Se entrar agora, teremos: ${targetStreak} ${predictedColor.toUpperCase()} consecutivos`);
    
    let maxStreakFound = 0;
    let streakCount = 0;
    let currentColor = null;
    
    for (let i = 0; i < last.length; i++) {
        if (last[i].color === predictedColor) {
            if (currentColor === predictedColor) {
                streakCount++;
            } else {
                streakCount = 1;
                currentColor = predictedColor;
            }
            maxStreakFound = Math.max(maxStreakFound, streakCount);
        } else {
            // âœ… QUALQUER outra cor (incluindo BRANCO) quebra a sequÃªncia!
            currentColor = last[i].color;
            streakCount = 1;
        }
    }
    
    console.log(`   ğŸ“Š Maior sequÃªncia de ${predictedColor.toUpperCase()} encontrada: ${maxStreakFound} giro(s)`);
    
    let allowed = targetStreak <= maxStreakFound;
    let gapRuleBlocked = false;
    const safetyGapRequired = targetStreak >= 4;

    // âœ… Ajuste para WHITE:
    // - Se estamos tentando apenas "1 WHITE" (targetStreak=1), nÃ£o faz sentido bloquear sÃ³ porque a janela recente
    //   nÃ£o teve WHITE (maxStreakFound=0). WHITE Ã© raro e o N4 pode votar nele mesmo assim.
    if (!allowed && predictedColor === 'white' && targetStreak === 1) {
        allowed = true;
    }

    // âœ… NOVA REGRA (pedido): acima de 4, exigir sempre "folga" de 1 no mÃ¡ximo histÃ³rico.
    // - alvo 1..3 pode encostar no mÃ¡ximo (alvo == mÃ¡x)
    // - alvo >=4 NÃƒO pode encostar: precisa alvo <= (mÃ¡x - 1)
    if (allowed && safetyGapRequired) {
        const gap = maxStreakFound - targetStreak; // 0 = encosta, 1+ = tem folga
        if (gap < 1) {
            allowed = false;
            gapRuleBlocked = true;
        }
    }

    let alternanceBlocked = false;
    let reasonText;
    if (allowed) {
        reasonText = (predictedColor === 'white' && targetStreak === 1 && maxStreakFound === 0)
            ? `âœ… SequÃªncia de 1 ${predictedColor} permitida (sem precedente na janela)`
            : `âœ… SequÃªncia de ${targetStreak} ${predictedColor} jÃ¡ aconteceu`;
    } else if (gapRuleBlocked) {
        reasonText = `âŒ SeguranÃ§a: alvo ${targetStreak} encosta no mÃ¡ximo histÃ³rico (${maxStreakFound}). Exigir folga mÃ­nima de 1 para alvo â‰¥ 4.`;
    } else {
        reasonText = `âŒ SequÃªncia de ${targetStreak} ${predictedColor} NUNCA aconteceu (mÃ¡x: ${maxStreakFound})`;
    }
    
    if (allowed) {
        console.log(`   âœ… APROVADO! SequÃªncia de ${targetStreak} Ã© historicamente viÃ¡vel`);
        console.log(`   ğŸš¦ Sinal LIBERADO para prosseguir`);
    } else {
        console.log(`   âŒ BLOQUEADO! SequÃªncia de ${targetStreak} NUNCA aconteceu antes (mÃ¡x: ${maxStreakFound})`);
        console.log(`   ğŸ›‘ Sinal BLOQUEADO por seguranÃ§a (sem precedente histÃ³rico)`);
    }
    
    if (alternanceInfo && alternanceInfo.override) {
        const targetRuns = alternanceInfo.targetRuns || 0;
        const maxRuns = alternanceInfo.maxRuns || 0;
        if (maxRuns && targetRuns && targetRuns > maxRuns) {
            console.log(`   âŒ BLOQUEADO! AlternÃ¢ncia excede histÃ³rico (${targetRuns} blocos > ${maxRuns})`);
            allowed = false;
            alternanceBlocked = true;
            reasonText = `âŒ AlternÃ¢ncia excede histÃ³rico (${targetRuns} > ${maxRuns})`;
        } else {
            console.log(`   âœ… AlternÃ¢ncia dentro do histÃ³rico (${targetRuns}/${maxRuns || 'âˆ'})`);
        }
    }
    
    return {
        allowed,
        currentStreak: currentStreak,
        targetStreak: targetStreak,
        maxStreakFound: maxStreakFound,
        reason: reasonText,
        alternanceBlocked,
        gapRuleBlocked,
        safetyGapRequired
    };
}

/**
 * NÃVEL 3: AlternÃ¢ncia (REAL) â€” simples/dupla/tripla
 *
 * DefiniÃ§Ã£o (sem branco):
 * - Simples:   P-V-P-V-...
 * - Dupla:     P-P-V-V-P-P-...
 * - Tripla:    P-P-P-V-V-V-P-P-P-...
 *
 * Regras:
 * - Branco SEMPRE quebra a alternÃ¢ncia (nÃ£o Ã© vÃ¡lido)
 * - O tamanho (L) Ã© em "blocos" (runs), nÃ£o em giros:
 *   - Simples (g=1):  L blocos = L giros
 *   - Dupla   (g=2):  L blocos = 2L giros
 *   - Tripla  (g=3):  L blocos = 3L giros
 *
 * Config (simplificado â€” pedido do usuÃ¡rio):
 * - historySize: profundidade do histÃ³rico (giros) usado para buscar ocorrÃªncias
 * - minOccurrences: mÃ­nimo de ocorrÃªncias do padrÃ£o no histÃ³rico
 * - baseThreshold: rigor do N3 â€” probabilidade mÃ­nima (prÃ³ximo giro) para o N3 votar
 * - allowBackoff: se true, tenta padrÃµes menores (menos blocos) quando faltarem ocorrÃªncias
 * - ignoreWhite: se true, nunca votar WHITE (mesmo que seja a cor mais provÃ¡vel apÃ³s o padrÃ£o)
 */
function analyzeAlternancePattern(history, options = {}) {
    logSection('[N3] AlternÃ¢ncia (simples/dupla/tripla)');

    const defaultSettings = {
        historySize: 2000,
        baseThreshold: 0.60,
        minOccurrences: 3,
        allowBackoff: false,
        ignoreWhite: false
    };

    const settings = {
        historySize: Number(options.historySize) > 0 ? Number(options.historySize) : defaultSettings.historySize,
        baseThreshold: (typeof options.baseThreshold === 'number')
            ? options.baseThreshold
            : (typeof options.threshold === 'number' ? options.threshold : defaultSettings.baseThreshold),
        minOccurrences: Number(options.minOccurrences) > 0 ? Number(options.minOccurrences) : defaultSettings.minOccurrences,
        allowBackoff: !!options.allowBackoff,
        ignoreWhite: !!options.ignoreWhite
    };

    // âœ… historySize: recorte histÃ³rico para buscar ocorrÃªncias
    settings.historySize = Math.max(4, Math.floor(Math.max(1, settings.historySize)));
    settings.baseThreshold = clamp01(settings.baseThreshold);
    settings.minOccurrences = Math.max(1, Math.min(500, Math.floor(settings.minOccurrences)));

    const trimmedHistory = Array.isArray(history) ? history.slice(0, settings.historySize) : [];
    const chronologicalSpins = trimmedHistory.slice().reverse();
    const seq = chronologicalSpins.map(spin => normalizeSpinColorValue(spin)); // red/black/white/null
    const totalAvailable = seq.filter(c => c === 'red' || c === 'black' || c === 'white').length;

    const isRB = (c) => c === 'red' || c === 'black';
    const oppositeRB = (c) => (c === 'red' ? 'black' : (c === 'black' ? 'red' : null));

    const buildRunsBackward = (endIdx, groupSize) => {
        if (endIdx < 0 || endIdx >= seq.length) return null;
        const lastColor = seq[endIdx];
        if (!isRB(lastColor)) return null;

        const runs = [];
        let curColor = lastColor;
        let len = 0;
        for (let i = endIdx; i >= 0; i--) {
            const c = seq[i];
            if (!isRB(c)) break; // branco (ou invÃ¡lido) quebra
            if (c === curColor) {
                len += 1;
                if (len > groupSize) return null; // excedeu bloco â†’ nÃ£o Ã© alternÃ¢ncia desse tipo
            } else {
                runs.push({ color: curColor, len });
                curColor = c;
                len = 1;
            }
        }
        runs.push({ color: curColor, len });
        return runs; // newest-to-oldest
    };

    const checkAlternanceRuns = (runsNewestFirst, groupSize, neededBlocks) => {
        if (!Array.isArray(runsNewestFirst) || runsNewestFirst.length < neededBlocks) return null;
        const runs = runsNewestFirst.slice(0, neededBlocks);
        if (runs.length < 2) return null;

        // âœ… REGRA CRÃTICA (pedido do usuÃ¡rio):
        // AlternÃ¢ncia sÃ³ existe quando estÃ¡ CONCRETIZADA (blocos completos), ex:
        // - Simples:  R B R B  (g=1)
        // - Dupla:    RR BB    (g=2)
        // - Tripla:   RRR BBB  (g=3)
        // Se um bloco quebra antes de completar (len < groupSize), NÃƒO Ã© alternÃ¢ncia (ainda nÃ£o formou).
        // Branco jÃ¡ quebra antes (buildRunsBackward para em branco).
        if (groupSize > 1) {
            for (const r of runs) {
                if (r.len !== groupSize) return null;
            }
        }

        const newest = runs[0];
        // âœ… ApÃ³s completar o ciclo (bloco cheio), a prÃ³xima "cabeÃ§a" Ã© sempre a cor oposta.
        const expectedNext = oppositeRB(newest.color);
        if (!isRB(expectedNext)) return null;

        const spinsUsed = runs.reduce((acc, r) => acc + (r.len || 0), 0);
        return {
            runs,
            blocks: runs.length,
            groupSize,
            spinsUsed,
            currentRunLen: newest.len,
            expectedNext
        };
    };

    const detectCurrentAlternance = () => {
        const endIdx = seq.length - 1;
        if (endIdx < 0) return null;

        const groupSizes = [3, 2, 1];

        // âœ… Pedido do usuÃ¡rio: sÃ³ considerar alternÃ¢ncia quando o padrÃ£o jÃ¡ FORMOU (ciclo completo).
        // - simples: precisa de 4 blocos (R B R B)
        // - dupla/tripla: precisa de 2 blocos completos (RR BB / RRR BBB)
        const minBlocksFor = (g) => (g === 1 ? 4 : 2);

        let bestStructural = null;
        let bestPassing = null;

        for (const g of groupSizes) {
            const runsAll = buildRunsBackward(endIdx, g);
            if (!runsAll) continue;

            const maxBlocks = runsAll.length;
            const minBlocks = minBlocksFor(g);
            // âœ… Para medir "prÃ³ximo giro", precisamos de pelo menos 1 giro depois do padrÃ£o.
            const maxBlocksForStats = Math.min(maxBlocks, Math.floor((seq.length - 1) / g));
            // âœ… Comprimento automÃ¡tico: sempre tenta do maior para o menor para nÃ£o "bicar" alternÃ¢ncias menores.
            const blocksToTry = [];
            for (let b = maxBlocks; b >= minBlocks; b--) blocksToTry.push(b);

            // estrutural (apenas para dizer "existe alternÃ¢ncia")
            let structuralBlocksForG = null;
            for (let b of blocksToTry) {
                const det = checkAlternanceRuns(runsAll, g, b);
                if (!det) continue;
                structuralBlocksForG = b;
                if (!bestStructural ||
                    det.groupSize > bestStructural.groupSize ||
                    (det.groupSize === bestStructural.groupSize && det.blocks > bestStructural.blocks)
                ) {
                    bestStructural = { ...det, backoffApplied: b !== maxBlocks };
                }
                // Como tentamos do maior -> menor, o primeiro match Ã© o melhor "comprimento"
            break;
        }

            // passando critÃ©rios (probabilidade + ocorrÃªncias)
            if (!structuralBlocksForG) continue;
            const cappedStructural = Math.min(structuralBlocksForG, Math.max(minBlocks, maxBlocksForStats));
            if (cappedStructural < minBlocks) continue;
            const blocksToTryPassing = settings.allowBackoff
                ? Array.from({ length: cappedStructural - minBlocks + 1 }, (_, idx) => cappedStructural - idx)
                : [cappedStructural];

            for (const b of blocksToTryPassing) {
                const det = checkAlternanceRuns(runsAll, g, b);
                if (!det) continue;
                const stats = computeNextColorStats(g, b);
                const occurrences = stats.occurrences || 0;
                const bestColor = pickBestNextColor(stats.counts, settings.ignoreWhite);
                const bestHits = bestColor ? (stats.counts[bestColor] || 0) : 0;
                const bestRate = occurrences > 0 ? (bestHits / occurrences) : 0;

                if (!bestColor) continue;
                if (occurrences < settings.minOccurrences) continue;
                if (bestRate < settings.baseThreshold) continue;

                const candidate = {
                    ...det,
                    backoffApplied: b !== structuralBlocksForG,
                    stats,
                    bestColor,
                    bestRate
                };
                if (!bestPassing ||
                    candidate.groupSize > bestPassing.groupSize ||
                    (candidate.groupSize === bestPassing.groupSize && candidate.blocks > bestPassing.blocks) ||
                    (candidate.groupSize === bestPassing.groupSize && candidate.blocks === bestPassing.blocks && (candidate.bestRate || 0) > (bestPassing.bestRate || 0))
                ) {
                    bestPassing = candidate;
                }
                break;
            }
        }

        if (bestPassing) return { kind: 'pass', ...bestPassing };
        if (bestStructural) return { kind: 'struct', ...bestStructural };
        return null;
    };

    const detectAtIndex = (idx, groupSize, neededBlocks) => {
        // idx Ã© o "Ãºltimo giro observado"; prever idx+1
        if (idx < 0 || idx >= seq.length) return null;
        if (!isRB(seq[idx])) return null;

        const runsAll = buildRunsBackward(idx, groupSize);
        if (!runsAll) return null;
        return checkAlternanceRuns(runsAll, groupSize, neededBlocks);
    };

    const computeNextColorStats = (groupSize, neededBlocks) => {
        let occurrences = 0;
        const counts = { red: 0, black: 0, white: 0 };
        for (let i = 0; i < seq.length - 1; i++) {
            const det = detectAtIndex(i, groupSize, neededBlocks);
            if (!det) continue;
            occurrences += 1;
            const next = seq[i + 1];
            if (next === 'red') counts.red += 1;
            else if (next === 'black') counts.black += 1;
            else if (next === 'white') counts.white += 1;
        }
        return { occurrences, counts };
    };

    const pickBestNextColor = (counts, ignoreWhite) => {
        const c = counts && typeof counts === 'object' ? counts : { red: 0, black: 0, white: 0 };
        const candidates = ignoreWhite ? ['red', 'black'] : ['red', 'black', 'white'];
        let bestColor = null;
        let bestCount = -1;
        let tie = false;
        for (const key of candidates) {
            const v = Number(c[key] || 0);
            if (v > bestCount) {
                bestCount = v;
                bestColor = key;
                tie = false;
            } else if (v === bestCount && v > 0) {
                tie = true;
            }
        }
        if (tie) return null;
        return bestColor;
    };

    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${Array.isArray(history) ? history.length : 0}`);
    console.log(`   âš™ï¸ Config â†’ profundidade: ${settings.historySize} | rigor: ${(settings.baseThreshold * 100).toFixed(0)}% | min occ: ${settings.minOccurrences} | backoff: ${settings.allowBackoff ? 'sim' : 'nÃ£o'}`);
    console.log(`   âš™ï¸ Branco sempre quebra alternÃ¢ncia (fora do padrÃ£o)`);

    if (seq.length < 4) {
        const message = `Apenas ${seq.length} giros na janela (mÃ­nimo: 4)`;
        return {
            color: null,
            pattern: 'Dados insuficientes',
            alternationRate: '0.0',
            alternationSize: 0,
            confidence: 0,
            details: message,
            reason: 'insufficient_history',
            historyUsed: seq.length,
            historyConfigured: settings.historySize,
            override: false,
            alternanceRuns: null,
            alternanceTargetRuns: null,
            alternanceMaxRuns: null,
            alternanceBaseSize: null
        };
    }

    const current = detectCurrentAlternance();
    if (!current) {
        return {
            color: null,
            pattern: 'AlternÃ¢ncia',
            alternationRate: '0.0',
            alternationSize: 0,
            confidence: 0,
            details: 'NULO',
            reason: 'no_alternance_detected',
            historyUsed: totalAvailable,
            historyConfigured: settings.historySize,
            override: false,
            alternanceRuns: null,
            alternanceTargetRuns: null,
            alternanceMaxRuns: null,
            alternanceBaseSize: null
        };
    }

    const typeName = current.groupSize === 1 ? 'Simples' : (current.groupSize === 2 ? 'Dupla' : 'Tripla');

    const stats = current.kind === 'pass' && current.stats ? current.stats : computeNextColorStats(current.groupSize, current.blocks);
    const occurrences = stats && typeof stats.occurrences === 'number' ? stats.occurrences : 0;
    const counts = stats && stats.counts ? stats.counts : { red: 0, black: 0, white: 0 };

    const finalColor = current.kind === 'pass' && current.bestColor ? current.bestColor : null;
    const bestHits = finalColor ? (counts[finalColor] || 0) : 0;
    const bestRate = occurrences > 0 ? (bestHits / occurrences) : 0;

    const allowVote = Boolean(finalColor);
    const finalConfidence = allowVote ? clamp01(bestRate) : 0;

    const details = [
        `Alt ${typeName}`,
        `blocos ${current.blocks}`,
        `fase ${current.currentRunLen}/${current.groupSize}`,
        `amostra ${occurrences}`,
        allowVote ? `${finalColor.toUpperCase()} ${(bestRate * 100).toFixed(1)}% (${bestHits}/${occurrences})` : 'NULO',
        `rigor ${Math.round(settings.baseThreshold * 100)}%`,
        `minOcc ${settings.minOccurrences}`,
        current.backoffApplied ? 'backoff' : null
    ].filter(Boolean).join(' â€¢ ');

    const overrideActive = Boolean(
        allowVote &&
        bestRate >= clamp01(settings.baseThreshold + 0.10) &&
        occurrences >= settings.minOccurrences + 2
    );
    
    return {
        color: finalColor,
        pattern: `AlternÃ¢ncia ${typeName}`,
        // compat: alguns trechos antigos exibem alternationRate/baseRate*
        alternationRate: (bestRate * 100).toFixed(1),
        baseRate: bestRate,
        baseRatePct: (bestRate * 100).toFixed(1),
        baseOccurrences: occurrences,
        baseHits: bestHits,
        alternationSize: current.blocks,
        confidence: finalConfidence,
        probability: bestRate,
        probabilityPct: (bestRate * 100).toFixed(1),
        occurrences,
        window: null,
        windowLabel: null,
        threshold: settings.baseThreshold,
        thresholdPct: (settings.baseThreshold * 100).toFixed(1),
        contextThreshold: null,
        contextThresholdPct: null,
        minOccurrences: settings.minOccurrences,
        allowBackoff: settings.allowBackoff,
        ignoreWhite: settings.ignoreWhite,
        historyUsed: totalAvailable,
        historyConfigured: settings.historySize,
        details,
        reason: allowVote
            ? null
            : (occurrences < settings.minOccurrences
                ? 'min_occ_not_met'
                : (bestRate < settings.baseThreshold ? 'base_threshold_not_met' : 'no_vote')),
        backoffApplied: current.backoffApplied,
        override: overrideActive,
        alternanceRuns: current.blocks,
        alternanceTargetRuns: null,
        alternanceMaxRuns: null,
        alternanceBaseSize: current.groupSize
    };
}

/**
 * NÃVEL 8: AnÃ¡lise de Impacto de Zeros (Brancos)
 * ApÃ³s um branco, a tendÃªncia anterior costuma continuar
 * Analisa os Ãºltimos 15 giros + 5 giros antes do Ãºltimo branco
 */
/**
 * NÃVEL 5 (antigo 8): RADAR DE BRANCOS (ANÃLISE INTELIGENTE DE 2000 GIROS)
 * 
 * FUNÃ‡ÃƒO EXCLUSIVA: Analisar o comportamento dos BRANCOS (zeros)
 * 
 * METODOLOGIA CORRETA:
 * 1. Mapear TODOS os brancos do mais ANTIGO ao mais RECENTE
 * 2. Para cada branco, analisar:
 *    - NÃºmero que "puxou" o branco (giro imediatamente antes)
 *    - Minuto que o branco saiu (timestamp)
 *    - Quantos giros entre este branco e o anterior
 *    - PadrÃ£o dos Ãºltimos 3-5 giros antes do branco
 * 3. Detectar padrÃµes estatÃ­sticos (nÃºmeros favoritos, minutos favoritos, intervalos)
 * 4. PREVER BRANCO quando: nÃºmero atual + minuto atual + intervalo >= mÃ©dia
 * 
 * DOIS MODOS DE OPERAÃ‡ÃƒO:
 * 1ï¸âƒ£ MODO vote_color: Vota na cor que mais sai APÃ“S brancos
 * 2ï¸âƒ£ MODO force_white: FORÃ‡A entrada em BRANCO quando padrÃµes batem
 */
function analyzeWhiteRadar(fullHistory) {
    console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #16A085; font-weight: bold;');
    console.log('%câ”‚ ğŸ” NÃVEL 5: RADAR DE BRANCOS (2000 GIROS)             â”‚', 'color: #16A085; font-weight: bold;');
    console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #16A085; font-weight: bold;');
    
    console.log(`   ğŸ“Š Total de giros disponÃ­veis: ${fullHistory.length}`);
    console.log(`   ğŸ¯ Metodologia: AnÃ¡lise do PRIMEIRO ao ÃšLTIMO branco`);
    
    if (fullHistory.length < 50) {
        console.log(`   âŒ Dados insuficientes! MÃ­nimo: 50 giros`);
        return {
            mode: 'vote_color',
            color: null,
            whiteCount: 0,
            confidence: 0,
            details: 'Menos de 50 giros para anÃ¡lise'
        };
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š ETAPA 1: MAPEAR TODOS OS BRANCOS (DO MAIS ANTIGO AO MAIS RECENTE)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%cğŸ“Š ETAPA 1: MAPEANDO BRANCOS DO PRIMEIRO AO ÃšLTIMO', 'color: #FFD700; font-weight: bold;');
    
    const whiteOccurrences = []; // Array de objetos com dados completos de cada branco
    
    // Iterar do mais ANTIGO (final do array) ao mais RECENTE (inÃ­cio)
    for (let i = fullHistory.length - 1; i >= 0; i--) {
        if (fullHistory[i].color === 'white') {
            const whiteData = {
                index: i,
                position: fullHistory.length - i, // PosiÃ§Ã£o do giro (1 = mais antigo)
                timestamp: fullHistory[i].timestamp,
                minute: null,
                numberBefore: null, // NÃºmero que "puxou" o branco
                colorBefore: null,
                girosFromPrevious: null, // Giros entre este e o branco anterior
                last3Pattern: null, // Ãšltimos 3 giros antes do branco
                last5Pattern: null  // Ãšltimos 5 giros antes do branco
            };
            
            // Pegar minuto do timestamp
            if (whiteData.timestamp) {
                const date = new Date(whiteData.timestamp);
                whiteData.minute = date.getMinutes();
            }
            
            // Pegar nÃºmero que "puxou" o branco (giro imediatamente anterior)
            if (i + 1 < fullHistory.length) {
                const spinBefore = fullHistory[i + 1];
                whiteData.numberBefore = spinBefore.number;
                whiteData.colorBefore = spinBefore.color;
            }
            
            // Calcular giros desde o branco anterior
            if (whiteOccurrences.length > 0) {
                const previousWhite = whiteOccurrences[whiteOccurrences.length - 1];
                whiteData.girosFromPrevious = previousWhite.index - i;
            }
            
            // Pegar Ãºltimos 3 giros antes do branco (excluindo brancos)
            const last3 = [];
            for (let j = i + 1; j < fullHistory.length && last3.length < 3; j++) {
                if (fullHistory[j].color !== 'white') {
                    last3.push(fullHistory[j].color);
                }
            }
            whiteData.last3Pattern = last3.join('-');
            
            // Pegar Ãºltimos 5 giros antes do branco (excluindo brancos)
            const last5 = [];
            for (let j = i + 1; j < fullHistory.length && last5.length < 5; j++) {
                if (fullHistory[j].color !== 'white') {
                    last5.push(fullHistory[j].color);
                }
            }
            whiteData.last5Pattern = last5.join('-');
            
            whiteOccurrences.push(whiteData);
        }
    }
    
    console.log(`   âšª Total de brancos encontrados: ${whiteOccurrences.length}`);
    console.log(`   âšª FrequÃªncia: ${((whiteOccurrences.length / fullHistory.length) * 100).toFixed(2)}%`);
    
    if (whiteOccurrences.length < 2) {
        console.log(`   âš ï¸ Poucos brancos para anÃ¡lise confiÃ¡vel (mÃ­nimo: 2)`);
        return {
            mode: 'vote_color',
            color: null,
            whiteCount: whiteOccurrences.length,
            confidence: 0,
            details: 'Poucos brancos para anÃ¡lise'
        };
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ ETAPA 2: ANÃLISE ESTATÃSTICA DOS BRANCOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%cğŸ¯ ETAPA 2: ANÃLISE ESTATÃSTICA', 'color: #00D4FF; font-weight: bold;');
    
    // 2.1: NÃºmeros que "puxam" branco
    const numbersThatPull = {};
    for (const white of whiteOccurrences) {
        if (white.numberBefore !== null) {
            numbersThatPull[white.numberBefore] = (numbersThatPull[white.numberBefore] || 0) + 1;
        }
    }
    
    // Encontrar nÃºmero mais comum
    let mostCommonNumber = null;
    let mostCommonNumberCount = 0;
    for (const [num, count] of Object.entries(numbersThatPull)) {
        if (count > mostCommonNumberCount) {
            mostCommonNumber = parseInt(num);
            mostCommonNumberCount = count;
        }
    }
    
    console.log(`   ğŸ¯ NÃºmeros que "puxam" branco:`);
    const sortedNumbers = Object.entries(numbersThatPull).sort((a, b) => b[1] - a[1]).slice(0, 5);
    sortedNumbers.forEach(([num, count]) => {
        const percentage = ((count / whiteOccurrences.length) * 100).toFixed(1);
        console.log(`      NÂº ${num}: ${count}x (${percentage}%)`);
    });
    
    // 2.2: Minutos favoritos
    const favoriteMinutes = {};
    for (const white of whiteOccurrences) {
        if (white.minute !== null) {
            favoriteMinutes[white.minute] = (favoriteMinutes[white.minute] || 0) + 1;
        }
    }
    
    let mostCommonMinute = null;
    let mostCommonMinuteCount = 0;
    for (const [min, count] of Object.entries(favoriteMinutes)) {
        if (count > mostCommonMinuteCount) {
            mostCommonMinute = parseInt(min);
            mostCommonMinuteCount = count;
        }
    }
    
    console.log(`   ğŸ• Minutos favoritos:`);
    const sortedMinutes = Object.entries(favoriteMinutes).sort((a, b) => b[1] - a[1]).slice(0, 5);
    sortedMinutes.forEach(([min, count]) => {
        const percentage = ((count / whiteOccurrences.length) * 100).toFixed(1);
        console.log(`      :${String(min).padStart(2, '0')}: ${count}x (${percentage}%)`);
    });
    
    // 2.3: Intervalo mÃ©dio entre brancos
    const intervals = whiteOccurrences
        .filter(w => w.girosFromPrevious !== null)
        .map(w => w.girosFromPrevious);
    
    const avgInterval = intervals.length > 0 
        ? intervals.reduce((a, b) => a + b, 0) / intervals.length 
        : 0;
    
    const minInterval = intervals.length > 0 ? Math.min(...intervals) : 0;
    const maxInterval = intervals.length > 0 ? Math.max(...intervals) : 0;
    
    console.log(`   ğŸ“Š Intervalos entre brancos:`);
    console.log(`      MÃ©dia: ${avgInterval.toFixed(0)} giros`);
    console.log(`      MÃ­nimo: ${minInterval} giros`);
    console.log(`      MÃ¡ximo: ${maxInterval} giros`);
    
    // 2.4: PadrÃµes mais comuns antes de brancos
    const pattern3Counts = {};
    const pattern5Counts = {};
    
    for (const white of whiteOccurrences) {
        if (white.last3Pattern) {
            pattern3Counts[white.last3Pattern] = (pattern3Counts[white.last3Pattern] || 0) + 1;
        }
        if (white.last5Pattern) {
            pattern5Counts[white.last5Pattern] = (pattern5Counts[white.last5Pattern] || 0) + 1;
        }
    }
    
    console.log(`   ğŸ“ˆ PadrÃµes comuns (Ãºltimos 3 giros):`);
    const sortedPattern3 = Object.entries(pattern3Counts).sort((a, b) => b[1] - a[1]).slice(0, 3);
    sortedPattern3.forEach(([pattern, count]) => {
        console.log(`      ${pattern}: ${count}x`);
    });
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”® ETAPA 3: SITUAÃ‡ÃƒO ATUAL E PREVISÃƒO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%cğŸ”® ETAPA 3: ANALISANDO SITUAÃ‡ÃƒO ATUAL', 'color: #9C27B0; font-weight: bold;');
    
    // Ãšltimo branco (mais recente)
    const lastWhite = whiteOccurrences[whiteOccurrences.length - 1];
    const girosFromLastWhite = lastWhite.index; // Ãndice 0 = giro mais recente
    
    // Giro atual (mais recente)
    const currentSpin = fullHistory[0];
    const currentNumber = currentSpin.number;
    const currentMinute = currentSpin.timestamp ? new Date(currentSpin.timestamp).getMinutes() : null;
    
    // Ãšltimos 3 giros (excluindo brancos)
    const current3Pattern = fullHistory
        .slice(0, 10)
        .filter(s => s.color !== 'white')
        .slice(0, 3)
        .map(s => s.color)
        .join('-');
    
    console.log(`   ğŸ“ Giros desde Ãºltimo branco: ${girosFromLastWhite}`);
    console.log(`   ğŸ“ NÃºmero atual: ${currentNumber}`);
    console.log(`   ğŸ“ Minuto atual: ${currentMinute !== null ? ':' + String(currentMinute).padStart(2, '0') : 'N/A'}`);
    console.log(`   ğŸ“ PadrÃ£o atual (Ãºltimos 3): ${current3Pattern}`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ§  ETAPA 4: DECISÃƒO - PREVER BRANCO OU VOTAR EM COR?
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('%cğŸ§  ETAPA 4: TOMANDO DECISÃƒO', 'color: #FF6B35; font-weight: bold;');
    
    let predictionScore = 0;
    let scoreDetails = [];
    
    // CritÃ©rio 1: NÃºmero atual "puxa" branco?
    if (numbersThatPull[currentNumber] && numbersThatPull[currentNumber] >= 2) {
        const score = (numbersThatPull[currentNumber] / whiteOccurrences.length) * 40; // Max 40 pontos
        predictionScore += score;
        scoreDetails.push(`NÃºmero ${currentNumber} puxou ${numbersThatPull[currentNumber]}x (+${score.toFixed(1)} pts)`);
    }
    
    // CritÃ©rio 2: Minuto atual Ã© favorito?
    if (currentMinute !== null && favoriteMinutes[currentMinute] && favoriteMinutes[currentMinute] >= 2) {
        const score = (favoriteMinutes[currentMinute] / whiteOccurrences.length) * 30; // Max 30 pontos
        predictionScore += score;
        scoreDetails.push(`Minuto :${String(currentMinute).padStart(2, '0')} favorito ${favoriteMinutes[currentMinute]}x (+${score.toFixed(1)} pts)`);
    }
    
    // CritÃ©rio 3: Intervalo >= mÃ©dia?
    if (avgInterval > 0 && girosFromLastWhite >= avgInterval * 0.8) {
        const score = Math.min(30, (girosFromLastWhite / avgInterval) * 20); // Max 30 pontos
        predictionScore += score;
        scoreDetails.push(`Intervalo ${girosFromLastWhite} >= mÃ©dia ${avgInterval.toFixed(0)} (+${score.toFixed(1)} pts)`);
    }
    
    console.log(`   ğŸ¯ Score de previsÃ£o: ${predictionScore.toFixed(1)}/100`);
    scoreDetails.forEach(detail => console.log(`      âœ“ ${detail}`));
    
    // ğŸš¨ MODO FORCE_WHITE: Score >= 60 pontos
    if (predictionScore >= 60 && whiteOccurrences.length >= 3) {
        const confidence = Math.min(0.95, predictionScore / 100);
        console.log(`   ğŸš¨ MODO ATIVADO: FORCE_WHITE`);
        console.log(`   âšª Score alto (${predictionScore.toFixed(1)}/100) â†’ BRANCO previsto!`);
    console.log(`   ğŸ“Š ConfianÃ§a: ${(confidence * 100).toFixed(0)}%`);
        console.log(`   âš ï¸ TODOS OS OUTROS VOTOS SERÃƒO ANULADOS!`);
        
        return {
            mode: 'force_white',
            color: 'white',
            whiteCount: whiteOccurrences.length,
            patternDetected: current3Pattern,
            patternOccurrences: predictionScore,
            confidence: confidence,
            details: `Score: ${predictionScore.toFixed(1)}/100 â†’ BRANCO previsto`
        };
    }
    
    // ğŸ“Š MODO VOTE_COLOR: SÃ“ VOTA SE O ÃšLTIMO GIRO FOI BRANCO!
    console.log(`   ğŸ“Š MODO ATIVADO: VOTE_COLOR`);
    
    // âœ… VERIFICAÃ‡ÃƒO CRÃTICA: O ÃšLTIMO GIRO (mais recente) FOI BRANCO?
    const lastSpinWasWhite = currentSpin.color === 'white';
    
    console.log(`   ğŸ“ Ãšltimo giro: ${currentSpin.color.toUpperCase()} (${currentSpin.number})`);
    console.log(`   ğŸ¯ Foi branco? ${lastSpinWasWhite ? 'âœ… SIM' : 'âŒ NÃƒO'}`);
    
    if (!lastSpinWasWhite) {
        // âŒ ÃšLTIMO GIRO NÃƒO FOI BRANCO â†’ VOTO NULO
        console.log(`   âŒ VOTO NULO: Ãšltimo giro nÃ£o foi branco`);
        console.log(`   âš ï¸ SÃ³ voto em cor se o Ãºltimo giro for branco!`);
        
        return {
            mode: 'vote_color',
            color: null,
            whiteCount: whiteOccurrences.length,
            confidence: 0,
            details: 'Voto nulo - Ãºltimo giro nÃ£o foi branco'
        };
    }
    
    // âœ… ÃšLTIMO GIRO FOI BRANCO! Analisar APENAS os ÃšLTIMOS 5 BRANCOS
    console.log(`   âœ… Ãšltimo giro FOI BRANCO!`);
    console.log(`   ğŸ—³ï¸ Analisando os ÃšLTIMOS 5 BRANCOS para votar...`);
    
    // Pegar apenas os ÃšLTIMOS 5 brancos (mais recentes)
    const last5Whites = whiteOccurrences.slice(-5); // Ãšltimos 5 elementos do array
    
    console.log(`   ğŸ“Š Total de brancos no histÃ³rico: ${whiteOccurrences.length}`);
    console.log(`   ğŸ¯ Analisando Ãºltimos: ${last5Whites.length} brancos`);
    
    const afterWhiteColors = { red: 0, black: 0, white: 0 };
    
    // Para cada um dos ÃšLTIMOS 5 brancos, ver o que saiu logo apÃ³s
    for (const white of last5Whites) {
        if (white.index > 0) {
            const nextSpin = fullHistory[white.index - 1];
            if (nextSpin) {
                afterWhiteColors[nextSpin.color]++;
                console.log(`      Branco â†’ ${nextSpin.color.toUpperCase()}`);
            }
        }
    }
    
    const totalAfterWhite = afterWhiteColors.red + afterWhiteColors.black + afterWhiteColors.white;
    
    if (totalAfterWhite >= 2) {
        let voteColor = null;
        let colorPercentage = 0;
        
        if (afterWhiteColors.red > afterWhiteColors.black) {
            voteColor = 'red';
            colorPercentage = (afterWhiteColors.red / totalAfterWhite) * 100;
        } else if (afterWhiteColors.black > afterWhiteColors.red) {
            voteColor = 'black';
            colorPercentage = (afterWhiteColors.black / totalAfterWhite) * 100;
    } else {
            // Empate - usar tendÃªncia recente (Ãºltimos 20 giros)
            const last20 = fullHistory.slice(0, Math.min(20, fullHistory.length));
            const recent = { red: 0, black: 0 };
            last20.forEach(s => {
                if (s.color === 'red') recent.red++;
                if (s.color === 'black') recent.black++;
            });
            voteColor = recent.red > recent.black ? 'red' : 'black';
            colorPercentage = 50;
        }
        
        const confidence = Math.min(0.85, colorPercentage / 100);
        
        console.log(`   ğŸ“Š Resultado dos Ãºltimos ${last5Whites.length} brancos:`);
        console.log(`      ğŸ”´ VERMELHO: ${afterWhiteColors.red}x (${((afterWhiteColors.red / totalAfterWhite) * 100).toFixed(1)}%)`);
        console.log(`      âš« PRETO: ${afterWhiteColors.black}x (${((afterWhiteColors.black / totalAfterWhite) * 100).toFixed(1)}%)`);
        console.log(`   ğŸ—³ï¸ VOTA: ${voteColor.toUpperCase()} (${(confidence * 100).toFixed(0)}% confianÃ§a)`);
        console.log(`   âœ… Justificativa: Nos Ãºltimos ${last5Whites.length} brancos, ${voteColor.toUpperCase()} saiu ${colorPercentage.toFixed(1)}%`);
    
    return {
            mode: 'vote_color',
        color: voteColor,
            whiteCount: whiteOccurrences.length,
            afterWhiteStats: afterWhiteColors,
            last5WhitesCount: last5Whites.length,
        confidence: confidence,
            details: `Ãšltimos ${last5Whites.length} brancos â†’ ${voteColor.toUpperCase()} (${colorPercentage.toFixed(1)}%)`
        };
    }
    
    // âš ï¸ FALLBACK: Dados insuficientes (mas Ãºltimo giro foi branco)
    console.log(`   âš ï¸ VOTO NULO: Dados insuficientes no histÃ³rico`);
    
    return {
        mode: 'vote_color',
        color: null,
        whiteCount: whiteOccurrences.length,
        confidence: 0,
        details: 'Dados insuficientes para previsÃ£o'
    };
}

function shouldUseN4DynamicGalesForConfig(config = analyzerConfig) {
    try {
        if (!config || !config.aiMode) return false;
        // âœ… SÃ³ o N4 tem o comportamento de trocar a cor no Gale (G1/G2).
        // Se o N4 estiver desativado, nunca permitir gales dinÃ¢micos.
        if (!isDiamondLevelEnabled('N4', config)) return false;
        // âœ… Toggle do usuÃ¡rio: permitir ou nÃ£o mudar a cor no Gale (G1/G2)
        try {
            const fallback = !!(DEFAULT_ANALYZER_CONFIG && DEFAULT_ANALYZER_CONFIG.diamondLevelWindows && DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4DynamicGales);
            const allowDynamic = (config === analyzerConfig)
                ? getDiamondBoolean('n4DynamicGales', fallback)
                : getDiamondBooleanFromConfig(config, 'n4DynamicGales', fallback);
            return !!allowDynamic;
        } catch (_) {
            return true;
        }
    } catch (_) {
        return false;
    }
}

function pickN4DynamicGaleColor({ history, config, stageNumber, maxGales, forcePick = true }) {
    try {
        if (!shouldUseN4DynamicGalesForConfig(config)) return null;
        const historyRef = Array.isArray(history) ? history : [];
        if (!historyRef.length) return null;

        const overallMax = Math.max(0, Math.floor(Number(maxGales) || 0));
        const remaining = Math.max(0, Math.min(2, overallMax - Math.max(0, Math.floor(stageNumber))));
        const n4Window = (config === analyzerConfig)
            ? getDiamondWindow('n4Persistence', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence)
            : getDiamondWindowFromConfig(config, 'n4Persistence', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence);

        const n4 = analyzeAutointeligente(historyRef, {
            historySize: n4Window,
            maxGales: remaining,
            signalIntensity: (config && config.signalIntensity) || 'aggressive',
            whiteProtectionAsWin: !!(config && config.whiteProtectionAsWin),
            dynamicGales: true,
            forcePick: !!forcePick
        });
        return n4 && n4.color ? n4.color : null;
    } catch (_) {
        return null;
    }
}

/**
 * N4: Autointeligente (aprendizado direto do histÃ³rico cru)
 *
 * Objetivo:
 * - Decidir RED / BLACK / WHITE / NULO
 * - Prioridade: acertar a Entrada (prÃ³ximo giro), mas jÃ¡ "nascendo" com base para G1/G2 (se o usuÃ¡rio usar)
 *
 * EstratÃ©gia (sem depender dos nÃ­veis atuais):
 * - Modelo n-gram (Markov de ordem variÃ¡vel) com peso por recÃªncia (exponential decay)
 * - PolÃ­tica de abstenÃ§Ã£o (NULO) por thresholds de risco (prioriza acertar cedo e reduzir LOSS em G2)
 * - Probabilidades por horizonte (Entrada, atÃ© G1, atÃ© G2) para refletir cenÃ¡rio de Martingale do usuÃ¡rio
 */
function analyzeAutointeligente(history, options = {}) {
    const clamp01 = (v) => Math.max(0, Math.min(1, Number(v) || 0));
    const clampIntLocal = (v, min, max) => {
        const n = Math.floor(Number(v));
        if (!Number.isFinite(n)) return min;
        return Math.max(min, Math.min(max, n));
    };

    const normalizeHistorySize = (raw) => {
        const n = Number(raw);
        if (!Number.isFinite(n) || n <= 0) return 2000;
        // âœ… compatibilidade com N4 antigo (20..120): promover para escala de giros reais
        if (n >= 20 && n <= 120) return clampIntLocal(n * 100, 10, REALTIME_HISTORY_CAP);
        return clampIntLocal(n, 10, REALTIME_HISTORY_CAP);
    };

    const historySizeConfigured = normalizeHistorySize(options.historySize ?? 2000);
    const maxOrder = clampIntLocal(options.maxOrder ?? 6, 1, 10);
    const maxGalesConfigured = clampIntLocal(options.maxGales ?? 0, 0, 2); // apenas atÃ© G2 importa aqui
    const signalIntensity = (options && options.signalIntensity === 'conservative') ? 'conservative' : 'aggressive';
    // âœ… PolÃ­tica de Gale do N4:
    // - dyn: (N4-only) pode mudar a cor no G1/G2
    // - fix: (consenso multi-nÃ­veis) a cor do ciclo Ã© fixa
    // Default = dyn (compatibilidade com comportamento antigo do N4)
    const dynamicGales = (options && Object.prototype.hasOwnProperty.call(options, 'dynamicGales'))
        ? !!options.dynamicGales
        : true;
    const learningPolicy = dynamicGales ? 'dyn' : 'fix';

    const resolveN4LearningParams = (baselineCycle, steps) => {
        const store = (options && options.n4SelfLearning && typeof options.n4SelfLearning === 'object')
            ? options.n4SelfLearning
            : (signalsHistory && signalsHistory.n4SelfLearning ? signalsHistory.n4SelfLearning : null);
        const baseline = clamp01(baselineCycle);
        const s = Math.max(1, Math.min(3, Math.floor(Number(steps) || 1)));

        // âœ… Para G2, exigir "padrÃµes" vencedores de verdade.
        // Ex.: baseline ~0.85 (Double) -> bad~0.82, good~0.95
        const dynBad = clamp01(baseline - 0.03);
        const dynGood = clamp01(baseline + 0.10);

        let minSamples = Math.max(3, Math.min(80, Math.floor(Number(store?.minSamples) || 8)));
        // mais amostras para ciclos mais longos (evita overfit do auto-aprendizado)
        if (s >= 3) minSamples = Math.max(minSamples, 12);
        else if (s === 2) minSamples = Math.max(minSamples, 10);

        let bad = Number(store?.badWinRate);
        let good = Number(store?.goodWinRate);
        bad = clamp01(Number.isFinite(bad) ? bad : dynBad);
        good = clamp01(Number.isFinite(good) ? good : dynGood);

        // Se estiver em gales (steps>=2) e os thresholds forem "legado baixo", usar o dinÃ¢mico por baseline.
        if (s >= 2) {
            if (bad < 0.70) bad = dynBad;
            if (good < 0.80) good = dynGood;
        }
        if (good <= bad) {
            bad = dynBad;
            good = Math.max(bad + 0.05, dynGood);
        }
        return { store, minSamples, badWinRate: bad, goodWinRate: good, baseline };
    };

    const rawHistory = Array.isArray(history) ? history.slice(0, Math.min(historySizeConfigured, history.length)) : [];
    const chronological = rawHistory.slice().reverse();
    const tokens = chronological
        .map(spin => normalizeSpinColorValue(spin))
        .filter(c => c === 'red' || c === 'black' || c === 'white')
        .map(c => (c === 'red' ? 'R' : (c === 'black' ? 'B' : 'W')));

    if (tokens.length < 80) {
        return {
            color: null,
            confidence: 0,
            details: `NULO â€¢ histÃ³rico insuficiente (${tokens.length}/80)`,
            historyUsed: tokens.length,
            historyConfigured: historySizeConfigured
        };
    }

    // meia-vida dinÃ¢mica: dÃ¡ mais peso ao momento sem ignorar o contexto
    const decayHalfLife = clampIntLocal(
        options.decayHalfLife ?? Math.max(120, Math.min(900, Math.floor(tokens.length * 0.35))),
        40,
        2000
    );
    const decayLambda = Math.log(2) / decayHalfLife;
    const alpha = 0.6; // suavizaÃ§Ã£o (Laplace fracionÃ¡ria)
    const minSupport = 1.2; // peso mÃ­nimo para usar um contexto

    // âœ… P1-only (maxGales=0): no Double real, sem vazamento de futuro, nÃ£o existe "80%" no prÃ³ximo giro.
    // Se o usuÃ¡rio quer testar apenas 1 entrada, o N4 deve no mÃ­nimo NÃƒO ser pior que o baseline do prÃ³prio histÃ³rico.
    // EstratÃ©gia: escolher a cor RB mais frequente (inclui WHITE como perda) e retornar sempre essa cor.
    // Isso evita o caso do print (ficar abaixo do baseline por ruÃ­do de contexto).
    if (maxGalesConfigured === 0) {
        const plainCounts = { R: 0, B: 0, W: 0 };
        for (const t of tokens) {
            if (t === 'R') plainCounts.R++;
            else if (t === 'B') plainCounts.B++;
            else if (t === 'W') plainCounts.W++;
        }
        const total = plainCounts.R + plainCounts.B + plainCounts.W;
        const denom = (total > 0 ? total : tokens.length) + (3 * alpha);
        const pR = (plainCounts.R + alpha) / denom;
        const pB = (plainCounts.B + alpha) / denom;
        const pW = (plainCounts.W + alpha) / denom;
        const bestTokRB = (pB >= pR) ? 'B' : 'R';
        const otherTokRB = bestTokRB === 'B' ? 'R' : 'B';
        const ctxKeyP1Only = (() => {
            try {
                const limit = Math.min(maxOrder, tokens.length);
                const raw = tokens.slice(-limit);
                const lastW = raw.lastIndexOf('W');
                const tail = lastW >= 0 ? raw.slice(lastW) : raw;
                return tail.join('');
            } catch (_) {
                return '';
            }
        })();

        // ğŸ’ Auto-aprendizado (mesmo em P1-only): bloquear "tipo" que estÃ¡ dando muito LOSS
        let chosenTokRB = bestTokRB;
        let learningDecisionP1 = 'none'; // 'none' | 'swap' | 'blocked'
        let learningKeyP1 = null;
        let learningRecentNP1 = 0;
        let learningRecentWinRateP1 = null;
        try {
            const baseP1 = Math.max(Number(pR || 0), Number(pB || 0));
            const { minSamples, badWinRate, goodWinRate } = resolveN4LearningParams(baseP1, 1);

            const keyBest = buildN4SelfLearningKey(ctxKeyP1Only, bestTokRB, 1, signalIntensity, learningPolicy);
            const keyOther = buildN4SelfLearningKey(ctxKeyP1Only, otherTokRB, 1, signalIntensity, learningPolicy);
            const statsBest = keyBest ? getN4SelfLearningStatsForKey(keyBest) : null;
            const statsOther = keyOther ? getN4SelfLearningStatsForKey(keyOther) : null;

            const bestN = statsBest ? (statsBest.recentN || 0) : 0;
            const bestWR = statsBest ? statsBest.recentWinRate : null;
            const otherN = statsOther ? (statsOther.recentN || 0) : 0;
            const otherWR = statsOther ? statsOther.recentWinRate : null;

            // Se o "melhor RB marginal" estiver ruim, tentar trocar para o outro RB se ele estiver melhor.
            if (bestWR != null && bestN >= minSamples && bestWR <= badWinRate) {
                const otherLooksGood = (otherWR != null && otherN >= minSamples && otherWR >= goodWinRate);
                const otherLooksBetter = (otherWR != null && otherN >= minSamples && otherWR > bestWR && otherWR > badWinRate);
                if (otherLooksGood || otherLooksBetter) {
                    chosenTokRB = otherTokRB;
                    learningDecisionP1 = 'swap';
                } else {
                    // sem alternativa confiÃ¡vel -> bloquear sinal (NULO) para evitar repetir LOSS
                    learningDecisionP1 = 'blocked';
                }
            }

            if (learningDecisionP1 !== 'blocked') {
                learningKeyP1 = buildN4SelfLearningKey(ctxKeyP1Only, chosenTokRB, 1, signalIntensity, learningPolicy);
                const st = learningKeyP1 ? getN4SelfLearningStatsForKey(learningKeyP1) : null;
                if (st) {
                    learningRecentNP1 = st.recentN || 0;
                    learningRecentWinRateP1 = st.recentWinRate;
                }
            } else if (statsBest) {
                learningRecentNP1 = bestN;
                learningRecentWinRateP1 = bestWR;
            }
        } catch (_) {}

        if (learningDecisionP1 === 'blocked') {
            const pct = (learningRecentWinRateP1 != null) ? `${(learningRecentWinRateP1 * 100).toFixed(0)}%` : 'n/d';
            const n = learningRecentNP1 || 0;
            return {
                color: null,
                confidence: 0,
                details: `NULO â€¢ P1-only â€¢ AutoApr: BLOQUEADO (${pct} em ${n})`,
                historyUsed: tokens.length,
                historyConfigured: historySizeConfigured,
                learningKey: null,
                learningContext: ctxKeyP1Only || null,
                learningDecision: 'blocked'
            };
        }

        const bestP1 = chosenTokRB === 'B' ? pB : pR;
        const bestColor = chosenTokRB === 'B' ? 'black' : 'red';
        return {
            color: bestColor,
            confidence: clamp01(bestP1),
            p1: Number(clamp01(bestP1).toFixed(4)),
            p2: Number(clamp01(1 - Math.pow(1 - bestP1, 2)).toFixed(4)),
            p3: Number(clamp01(1 - Math.pow(1 - bestP1, 3)).toFixed(4)),
            pHit: Number(clamp01(bestP1).toFixed(4)),
            lossProb: Number(clamp01(1 - bestP1).toFixed(4)),
            margin: 0,
            requiredPHit: 0,
            lcb1: 0,
            edgeLcb: 0,
            pickedOrder: null,
            support: 0,
            maxOrder,
            decayHalfLife,
            maxGalesConsidered: 0,
            historyUsed: tokens.length,
            historyConfigured: historySizeConfigured,
            learningKey: learningKeyP1 || null,
            learningContext: ctxKeyP1Only || null,
            learningDecision: learningDecisionP1,
            details: `P1-only â€¢ Best ${bestColor.toUpperCase()} ${(bestP1 * 100).toFixed(1)}% â€¢ dist R ${(pR * 100).toFixed(1)}% / B ${(pB * 100).toFixed(1)}% / W ${(pW * 100).toFixed(1)}%` +
                (learningDecisionP1 === 'swap'
                    ? (() => {
                        const pct = (learningRecentWinRateP1 != null) ? `${(learningRecentWinRateP1 * 100).toFixed(0)}%` : 'n/d';
                        const n = learningRecentNP1 || 0;
                        return ` â€¢ AutoApr: SWAP (${pct} em ${n})`;
                    })()
                    : '')
        };
    }

    const countsByOrder = Array.from({ length: maxOrder + 1 }, () => new Map());
    const global = { R: 0, B: 0, W: 0, total: 0 };

    const bump = (map, key, nextTok, weight) => {
        let bucket = map.get(key);
        if (!bucket) {
            bucket = { R: 0, B: 0, W: 0, total: 0 };
            map.set(key, bucket);
        }
        bucket[nextTok] += weight;
        bucket.total += weight;
    };

    for (let i = 0; i < tokens.length - 1; i++) {
        const distFromEnd = (tokens.length - 2) - i; // 0 = transiÃ§Ã£o mais recente
        const w = Math.exp(-decayLambda * distFromEnd);
        const nextTok = tokens[i + 1];
        global[nextTok] += w;
        global.total += w;

        for (let order = 1; order <= maxOrder; order++) {
            const start = i - order + 1;
            if (start < 0) break;
            // âœ… WHITE quebra o contexto (reset), mas Ã© um evento vÃ¡lido:
            // - NÃ£o permitir "W no meio" (cruza a fronteira)
            // - Permitir contextos que COMEÃ‡AM com W (ex.: "W", "WR", "WRB"), pois representam o segmento apÃ³s o branco.
            const ctxArr = tokens.slice(start, i + 1);
            const firstW = ctxArr.indexOf('W');
            if (firstW > 0) continue; // W no meio (ou no fim) => cruza fronteira
            if (firstW === 0 && ctxArr.lastIndexOf('W') !== 0) continue; // mais de um W no contexto
            const ctx = ctxArr.join('');
            bump(countsByOrder[order], ctx, nextTok, w);
        }
    }

    const baseDist = () => {
        const denom = global.total + 3 * alpha;
        return {
            R: (global.R + alpha) / denom,
            B: (global.B + alpha) / denom,
            W: (global.W + alpha) / denom
        };
    };

    const normalizeDist = (d) => {
        const sum = (d.R || 0) + (d.B || 0) + (d.W || 0);
        if (!sum) return { R: 1 / 3, B: 1 / 3, W: 1 / 3 };
        return { R: d.R / sum, B: d.B / sum, W: d.W / sum };
    };

    const predict = (ctxTokens) => {
        const ctxArr = Array.isArray(ctxTokens) ? ctxTokens : [];
        let dist = baseDist();

        for (let order = 1; order <= maxOrder; order++) {
            if (ctxArr.length < order) continue;
            const key = ctxArr.slice(ctxArr.length - order).join('');
            const bucket = countsByOrder[order].get(key);
            if (!bucket || bucket.total < minSupport) continue;

            const denom = bucket.total + 3 * alpha;
            const local = {
                R: (bucket.R + alpha) / denom,
                B: (bucket.B + alpha) / denom,
                W: (bucket.W + alpha) / denom
            };

            // peso cresce com suporte e com ordem
            const supportFactor = Math.min(1, bucket.total / 8);
            const orderFactor = 0.55 + 0.45 * (order / maxOrder);
            const w = supportFactor * orderFactor;

            dist = {
                R: dist.R * (1 - w) + local.R * w,
                B: dist.B * (1 - w) + local.B * w,
                W: dist.W * (1 - w) + local.W * w
            };
        }

        return normalizeDist(dist);
    };

    const TOKENS = ['R', 'B', 'W'];
    const shiftCtx = (ctx, nextTok) => {
        const next = ctx.concat(nextTok);
        return next.slice(-maxOrder);
    };

    const pHit2 = (ctx, targetTok) => {
        const d1 = predict(ctx);
        let p = d1[targetTok] || 0;
        for (const t1 of TOKENS) {
            if (t1 === targetTok) continue;
            const d2 = predict(shiftCtx(ctx, t1));
            p += (d1[t1] || 0) * (d2[targetTok] || 0);
        }
        return clamp01(p);
    };

    const pHit3 = (ctx, targetTok) => {
        const d1 = predict(ctx);
        let p = d1[targetTok] || 0;
        for (const t1 of TOKENS) {
            if (t1 === targetTok) continue;
            const ctx2 = shiftCtx(ctx, t1);
            const d2 = predict(ctx2);
            // acerto no 2Âº giro (G1)
            p += (d1[t1] || 0) * (d2[targetTok] || 0);
            // acerto no 3Âº giro (G2), condicionado a errar no 2Âº
            for (const t2 of TOKENS) {
                if (t2 === targetTok) continue;
                const ctx3 = shiftCtx(ctx2, t2);
                const d3 = predict(ctx3);
                p += (d1[t1] || 0) * (d2[t2] || 0) * (d3[targetTok] || 0);
            }
        }
        return clamp01(p);
    };

    // âœ… Entrada-first (auto-suficiente): escolher a cor com melhor evidÃªncia para o PRÃ“XIMO GIRO.
    // - NÃ£o depende de outros nÃ­veis.
    // - NÃƒO considera branco como acerto quando a previsÃ£o foi red/black.
    // - Usa limite inferior (LCB) da probabilidade de acerto para evitar overfit por pouca amostra.
    // - Combina evidÃªncias de mÃºltiplas profundidades de contexto (ordens) em um Ãºnico posterior
    //   (reduz viÃ©s de "escolher o melhor contexto" e melhora generalizaÃ§Ã£o).
    const tokToColor = { R: 'red', B: 'black', W: 'white' };

    const base = baseDist(); // baseline global (com suavizaÃ§Ã£o)
    // âœ… WHITE: o N4 pode recomendar WHITE, mas sÃ³ deve fazÃª-lo quando houver evidÃªncia forte.
    // (o filtro minWhiteLCB continua sendo o guardrail principal)
    const allowWhite = (options && Object.prototype.hasOwnProperty.call(options, 'allowWhite'))
        ? !!options.allowWhite
        : true;
    const candidateList = (allowWhite ? ['R', 'B', 'W'] : ['R', 'B'])
        .slice()
        // remover viÃ©s de desempate: priorizar a cor mais provÃ¡vel no baseline
        .sort((a, b) => (Number(base[b] || 0) - Number(base[a] || 0)));

    const baseBestTokRB = (() => {
        const r = Number(base.R || 0);
        const b = Number(base.B || 0);
        return b > r ? 'B' : 'R';
    })();
    const baseBestPRB = Number(base[baseBestTokRB] || 0);
    const stepsToWin = Math.max(1, Math.min(3, maxGalesConfigured + 1)); // Entrada(1) + atÃ© G2(3)
    const baselinePcycle = clamp01(1 - Math.pow(1 - baseBestPRB, stepsToWin));

    const priorStrength = signalIntensity === 'conservative' ? 18 : 12; // prior mais forte => mais conservador
    const z = signalIntensity === 'conservative' ? 1.645 : 1.282;       // ~95% / ~90% (aprox normal)

    const betaPosterior = (success, attempts, priorP) => {
        const p0 = clamp01(priorP);
        const a0 = Math.max(1e-6, p0 * priorStrength);
        const b0 = Math.max(1e-6, (1 - p0) * priorStrength);
        const a = a0 + Math.max(0, Number(success) || 0);
        const b = b0 + Math.max(0, (Number(attempts) || 0) - (Number(success) || 0));
        const mean = a / (a + b);
        const variance = (a * b) / (((a + b) * (a + b)) * (a + b + 1));
        const lcb = mean - z * Math.sqrt(Math.max(0, variance));
        return { mean: clamp01(mean), lcb: clamp01(lcb) };
    };

    // fallback para forcePick (gales): usa distribuiÃ§Ã£o blended (predict)
    // âœ… Contexto: usar somente a "cauda" apÃ³s o Ãºltimo WHITE (white quebra sequÃªncias e distorce n-grams)
    const buildTailAfterWhite = (arr) => {
        const limit = Math.min(maxOrder, arr.length);
        const raw = arr.slice(-limit);
        const lastW = raw.lastIndexOf('W');
        // incluir o W como "marcador de fronteira" quando ele estiver dentro da cauda
        if (lastW >= 0) return raw.slice(lastW);
        return raw;
    };
    const ctxTail = buildTailAfterWhite(tokens);

    const pickTokByPredict = (ctxTokens) => {
        const d = predict(ctxTokens);
        return candidateList.reduce(
            (acc, tok) => ((d[tok] || 0) > (d[acc] || 0) ? tok : acc),
            candidateList[0] || 'R'
        );
    };

    const forcedDist = predict(ctxTail);
    const forcedTok = pickTokByPredict(ctxTail);

    const estimateWinWithinPolicyFirst = (ctxTokens, steps, firstTok) => {
        try {
            const s = Math.max(1, Math.min(3, Math.floor(Number(steps) || 1)));
            const first = firstTok && candidateList.includes(firstTok) ? firstTok : pickTokByPredict(ctxTokens);
            const memo = new Map();
            const keyOf = (ctxArr, remaining, firstPick) => `${ctxArr.join('')}|${remaining}|${firstPick || ''}`;

            const rec = (ctxArr, remaining, firstPick) => {
                const ctxSafe = buildTailAfterWhite(Array.isArray(ctxArr) ? ctxArr : []);
                const rem = Math.max(1, Math.min(3, remaining));
                const pick = firstPick && candidateList.includes(firstPick) ? firstPick : pickTokByPredict(ctxSafe);
                const k = keyOf(ctxSafe, rem, pick);
                if (memo.has(k)) return memo.get(k);

                const d = predict(ctxSafe);
                let p = clamp01(d[pick] || 0);
                if (rem === 1) {
                    memo.set(k, p);
                    return p;
                }

                for (const outTok of TOKENS) {
                    if (outTok === pick) continue;
                    const pOut = clamp01(d[outTok] || 0);
                    if (!pOut) continue;
                    const nextCtx = buildTailAfterWhite(shiftCtx(ctxSafe, outTok));
                    const nextPick = pickTokByPredict(nextCtx);
                    p += pOut * rec(nextCtx, rem - 1, nextPick);
                }
                p = clamp01(p);
                memo.set(k, p);
                return p;
            };

            return rec(ctxTokens, s, first);
        } catch (_) {
            return 0;
        }
    };

    // âœ… PolÃ­tica FIXA (consenso multi-nÃ­veis): mantÃ©m a cor do ciclo e calcula P(hit em â‰¤steps)
    // usando o prÃ³prio modelo (Markov) para evoluir o contexto apÃ³s cada resultado observado.
    const estimateWinWithinFixedBet = (ctxTokens, steps, betTok) => {
        try {
            const s = Math.max(1, Math.min(3, Math.floor(Number(steps) || 1)));
            const bet = betTok && candidateList.includes(betTok) ? betTok : pickTokByPredict(ctxTokens);
            const memo = new Map();
            const keyOf = (ctxArr, remaining) => `${ctxArr.join('')}|${remaining}|${bet}`;

            const rec = (ctxArr, remaining) => {
                const ctxSafe = buildTailAfterWhite(Array.isArray(ctxArr) ? ctxArr : []);
                const rem = Math.max(1, Math.min(3, remaining));
                const k = keyOf(ctxSafe, rem);
                if (memo.has(k)) return memo.get(k);

                const d = predict(ctxSafe);
                let p = clamp01(d[bet] || 0);
                if (rem === 1) {
                    memo.set(k, p);
                    return p;
                }
                for (const outTok of TOKENS) {
                    if (outTok === bet) continue;
                    const pOut = clamp01(d[outTok] || 0);
                    if (!pOut) continue;
                    const nextCtx = buildTailAfterWhite(shiftCtx(ctxSafe, outTok));
                    p += pOut * rec(nextCtx, rem - 1);
                }
                p = clamp01(p);
                memo.set(k, p);
                return p;
            };

            return rec(ctxTokens, s);
        } catch (_) {
            return 0;
        }
    };

    const estimateWinWithin = dynamicGales ? estimateWinWithinPolicyFirst : estimateWinWithinFixedBet;

    // Combinar evidÃªncias dos buckets (ordens) com peso parecido com o `predict()`
    // para evitar "winner's curse" de escolher uma ordem isolada.
    const evidence = { R: 0, B: 0, W: 0, total: 0 };
    let bestEvidenceOrder = 0;
    let bestEvidenceW = 0;
    for (let order = 1; order <= maxOrder; order++) {
        if (ctxTail.length < order) continue;
        const key = ctxTail.slice(ctxTail.length - order).join('');
        const bucket = countsByOrder[order].get(key);
        if (!bucket || !Number.isFinite(bucket.total) || bucket.total < minSupport) continue;

        const supportFactor = Math.min(1, bucket.total / 8);
        const orderFactor = 0.55 + 0.45 * (order / maxOrder);
        const w = supportFactor * orderFactor;

        evidence.R += w * Number(bucket.R || 0);
        evidence.B += w * Number(bucket.B || 0);
        evidence.W += w * Number(bucket.W || 0);
        evidence.total += w * Number(bucket.total || 0);

        if (w > bestEvidenceW) {
            bestEvidenceW = w;
            bestEvidenceOrder = order;
        }
    }

    const alphaR = (base.R * priorStrength) + evidence.R;
    const alphaB = (base.B * priorStrength) + evidence.B;
    const alphaW = (base.W * priorStrength) + evidence.W;
    const alphaTotal = alphaR + alphaB + alphaW;

    const scored = candidateList.map((tok) => {
        const priorP = Number(base[tok] || 0);
        const a = tok === 'R' ? alphaR : (tok === 'B' ? alphaB : alphaW);
        const b = Math.max(1e-9, alphaTotal - a);
        const mean = clamp01(a / (a + b));
        const variance = (a * b) / (((a + b) * (a + b)) * (a + b + 1));
        const lcb = clamp01(mean - z * Math.sqrt(Math.max(0, variance)));
        const edgeLcb = Math.max(0, lcb - priorP);
        const edgeMean = mean - priorP;
        return { tok, color: tokToColor[tok], mean, lcb, priorP, edgeLcb, edgeMean };
    }).sort((a, b) => (b.lcb - a.lcb) || (b.mean - a.mean) || (b.priorP - a.priorP));

    // âœ… Guardrail: evitar escolher uma cor com mÃ©dia condicional pior que o "baseline RB" (remove viÃ©s e piora artificial).
    const bestPickRaw = scored[0] || null;
    let secondPick = scored[1] || null;
    const baseBestObj = scored.find(s => s && s.tok === baseBestTokRB) || null;
    let bestPick = (bestPickRaw && baseBestObj && bestPickRaw.mean < baseBestPRB)
        ? baseBestObj
        : bestPickRaw;

    // âœ… Modo 1 entrada (sem gales):
    // Em dados reais (sem edge), alternar RED/BLACK por contexto costuma sÃ³ adicionar ruÃ­do e piorar o P1.
    // Aqui travamos no melhor RB marginal do recorte, e sÃ³ deixamos WHITE passar quando for MUITO forte.
    if (stepsToWin === 1) {
        if (bestPickRaw && bestPickRaw.tok === 'W') {
            const whiteMean = Number(bestPickRaw.mean || 0);
            const whiteLcb = Number(bestPickRaw.lcb || 0);
            const baselineWhite = Number(base.W || 0);
            const strongWhite = (whiteLcb >= 0.18) && (whiteMean >= Math.max(0.10, baselineWhite + 0.05));
            bestPick = strongWhite ? bestPickRaw : (baseBestObj || bestPick);
        } else {
            bestPick = baseBestObj || bestPick;
        }
    }
    let marginLcb = bestPick && secondPick ? Math.max(0, (bestPick.lcb - secondPick.lcb)) : (bestPick ? bestPick.lcb : 0);

    // âœ… Ajuste de VOLUME (pedido do usuÃ¡rio):
    // Limiar fixo alto derruba o nÃºmero de sinais. Aqui usamos um limiar adaptativo por percentil
    // (top X% dos melhores momentos), mantendo filtros mÃ­nimos para nÃ£o virar "cara ou coroa".
    // âœ… PERFIL DE VOLUME:
    // - conservative: mantÃ©m filtros fortes (poucas entradas, mais seletivo)
    // - aggressive: volume alto (pedido do usuÃ¡rio: nÃ£o ficar "2 dias" esperando sinal)
    //   ObservaÃ§Ã£o: o LCB jÃ¡ Ã© um freio estatÃ­stico. Exigir "edge LCB > prior" + margem mÃ­nima derrubava quase tudo.
    const volumeProfile = signalIntensity === 'conservative'
        ? { targetRate: 0.08, scoreFloor: 0.46, minMargin: 0.006, minSupport: 10, minEdge: 0.002, minWhiteLCB: 0.18, minP1Mean: 0.50 }
        // aggressive: mais volume (pedido do usuÃ¡rio) sem liberar WHITE "fÃ¡cil"
        : { targetRate: 0.50, scoreFloor: 0.40, minMargin: 0.000, minSupport: 1,  minEdge: 0.000, minWhiteLCB: 0.18, minP1Mean: 0.48 };

    const computeScore = (best, second) => {
        if (!best) return { score: -1, margin: 0, edge: 0 };
        const margin = second ? Math.max(0, (best.lcb - second.lcb)) : Math.max(0, best.lcb);
        const edge = Math.max(0, best.edgeLcb || 0);
        // Score principal: LCB com bÃ´nus leve de margem/edge (nÃ£o domina o LCB).
        let score = (best.lcb || 0) + (margin * 0.35) + (edge * 0.25);
        // White: mais raro/mais caro â€” exigir evidÃªncia extra (penalizar score).
        if (best.tok === 'W') score -= 0.03;
        return { score, margin, edge };
    };

    const passesNonScoreFilters = (bestObj, secondObj, supportTotal) => {
        if (!bestObj) return false;
        const margin = secondObj ? Math.max(0, (bestObj.lcb - secondObj.lcb)) : Math.max(0, bestObj.lcb);
        const edge = Math.max(0, bestObj.edgeLcb || 0);
        if (margin < volumeProfile.minMargin) return false;
        if (edge < volumeProfile.minEdge) return false;
        if (Number(supportTotal || 0) < volumeProfile.minSupport) return false;
        if (bestObj.tok === 'W' && bestObj.lcb < volumeProfile.minWhiteLCB) return false;
        return true;
    };

    // Threshold adaptativo (calibrado por HIT real no histÃ³rico) para manter volume + qualidade.
    // âœ… A partir daqui, HIT = "ganha o ciclo em atÃ© stepsToWin tentativas (Entrada+G1+G2)",
    // simulando re-pick (gales dinÃ¢micos) com base no `predict()`.
    const computeAdaptiveScoreThreshold = () => {
        try {
            const end = tokens.length - 1 - stepsToWin; // precisa ter futuro suficiente para simular atÃ© G2
            if (end < 10) return volumeProfile.scoreFloor;
            const lookback = Math.max(250, Math.min(1500, end)); // 250..1500
            const start = Math.max(maxOrder, end - lookback);
            const span = Math.max(1, end - start + 1);
            const sampleCount = Math.max(80, Math.min(220, span));
            const step = Math.max(1, Math.floor(span / sampleCount));

            const ctxForIndex = (idx) => {
                const from = Math.max(0, idx - maxOrder + 1);
                const ctxArr = tokens.slice(from, idx + 1);
                return buildTailAfterWhite(ctxArr);
            };

            const simulateCycleHit = (idx, firstTok) => {
                try {
                    let betTok = firstTok && candidateList.includes(firstTok) ? firstTok : pickTokByPredict(ctxForIndex(idx));
                    // âœ… FIXED: a cor do ciclo nÃ£o muda â€” basta checar se ela aparece em â‰¤stepsToWin giros.
                    if (!dynamicGales) {
                        for (let s = 1; s <= stepsToWin; s++) {
                            const actualTok = tokens[idx + s];
                            if (!actualTok) return false;
                            if (actualTok === betTok) return true;
                        }
                        return false;
                    }

                    let ctx = ctxForIndex(idx);
                    for (let s = 1; s <= stepsToWin; s++) {
                        const actualTok = tokens[idx + s];
                        if (!actualTok) return false;
                        if (actualTok === betTok) return true;
                        ctx = buildTailAfterWhite(shiftCtx(ctx, actualTok));
                        betTok = pickTokByPredict(ctx);
                    }
                    return false;
                } catch (_) {
                    return false;
                }
            };

            const samples = [];
            for (let idx = start; idx <= end; idx += step) {
                // montar evidÃªncia combinada para o contexto que termina em idx
                const ev = { R: 0, B: 0, W: 0, total: 0 };
                for (let order = 1; order <= maxOrder; order++) {
                    const ctxStart = idx - order + 1;
                    if (ctxStart < 0) break;
                    const ctxArr = tokens.slice(ctxStart, idx + 1);
                    const firstW = ctxArr.indexOf('W');
                    if (firstW > 0) continue;
                    if (firstW === 0 && ctxArr.lastIndexOf('W') !== 0) continue;
                    const key = ctxArr.join('');
                    const bucket = countsByOrder[order].get(key);
                    if (!bucket || !Number.isFinite(bucket.total) || bucket.total < minSupport) continue;
                    const supportFactor = Math.min(1, bucket.total / 8);
                    const orderFactor = 0.55 + 0.45 * (order / maxOrder);
                    const w = supportFactor * orderFactor;
                    ev.R += w * Number(bucket.R || 0);
                    ev.B += w * Number(bucket.B || 0);
                    ev.W += w * Number(bucket.W || 0);
                    ev.total += w * Number(bucket.total || 0);
                }
                const aR = (base.R * priorStrength) + ev.R;
                const aB = (base.B * priorStrength) + ev.B;
                const aW = (base.W * priorStrength) + ev.W;
                const aT = aR + aB + aW;
                if (!Number.isFinite(aT) || aT <= 0) continue;

                const localScored = candidateList.map((tok) => {
                    const priorP = Number(base[tok] || 0);
                    const a = tok === 'R' ? aR : (tok === 'B' ? aB : aW);
                    const b = Math.max(1e-9, aT - a);
                    const mean = clamp01(a / (a + b));
                    const variance = (a * b) / (((a + b) * (a + b)) * (a + b + 1));
                    const lcb = clamp01(mean - z * Math.sqrt(Math.max(0, variance)));
                    const edgeLcb = Math.max(0, lcb - priorP);
                    return { tok, lcb, edgeLcb };
                }).sort((x, y) => (y.lcb - x.lcb) || (Number(base[y.tok] || 0) - Number(base[x.tok] || 0)));

                const b0 = localScored[0] || null;
                const b1 = localScored[1] || null;
                if (!b0) continue;
                const bestObj = { tok: b0.tok, lcb: b0.lcb, edgeLcb: b0.edgeLcb };
                const secondObj = b1 ? { tok: b1.tok, lcb: b1.lcb, edgeLcb: b1.edgeLcb } : null;
                if (!passesNonScoreFilters(bestObj, secondObj, ev.total)) continue;
                const s = computeScore(bestObj, secondObj).score;
                if (!Number.isFinite(s)) continue;
                const hit = simulateCycleHit(idx, bestObj.tok);
                samples.push({ score: s, hit: !!hit });
            }

            if (samples.length < 40) return volumeProfile.scoreFloor;

            // ordenar por score (maior primeiro) e escolher um corte que maximize HIT (LCB) sem fugir muito do targetRate
            samples.sort((a, b) => b.score - a.score);
            const n = samples.length;
            const targetRate = Math.max(0.02, Math.min(0.90, Number(volumeProfile.targetRate) || 0.25));
            // âœ… permitir o calibrador "apertar" bem mais se necessÃ¡rio para reduzir RET
            const minRate = signalIntensity === 'conservative'
                ? Math.max(0.02, Math.min(0.90, targetRate * 0.70))
                : Math.max(0.05, Math.min(0.90, targetRate * 0.85));
            const maxRate = signalIntensity === 'conservative'
                ? Math.max(minRate, Math.min(0.90, targetRate * 1.35))
                : Math.max(minRate, Math.min(0.90, targetRate * 1.15));
            const kMin = Math.max(25, Math.floor(minRate * n));
            const kMax = Math.max(kMin, Math.min(n, Math.ceil(maxRate * n)));
            // âœ… agressivo: penalizar mais desvio do target (para realmente entregar volume)
            const penalty = signalIntensity === 'conservative' ? 0.18 : 0.28;

            let hits = 0;
            let bestCut = null;
            let bestObjective = -Infinity;
            for (let i = 0; i < n; i++) {
                hits += samples[i].hit ? 1 : 0;
                const k = i + 1;
                if (k < kMin || k > kMax) continue;
                const p = hits / k;
                const se = Math.sqrt(Math.max(0, p * (1 - p)) / k);
                const lcb = p - z * se;
                const rate = k / n;
                const objective = lcb - penalty * Math.abs(rate - targetRate);
                if (objective > bestObjective) {
                    bestObjective = objective;
                    bestCut = { threshold: samples[i].score, rate, lcb, p, k };
                }
            }

            if (!bestCut || !Number.isFinite(bestCut.threshold)) return volumeProfile.scoreFloor;
            return Math.max(volumeProfile.scoreFloor, bestCut.threshold);
        } catch (_) {
            return volumeProfile.scoreFloor;
        }
    };

    const adaptiveScoreMinBase = computeAdaptiveScoreThreshold();
    let adaptiveScoreMin = adaptiveScoreMinBase;
    const requiredPHit = adaptiveScoreMin; // compat: exibimos o limiar usado

    let currentScore = computeScore(bestPick, secondPick);

    let allowed = !!bestPick
        && passesNonScoreFilters(bestPick, secondPick, evidence.total)
        && (currentScore.score >= adaptiveScoreMin)
        && (Number(bestPick.mean || 0) >= volumeProfile.minP1Mean);

    const forcePick = !!(options && options.forcePick);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ’ AUTO-APRENDIZADO (N4): usar o histÃ³rico de WIN/LOSS do prÃ³prio N4
    // - Bloqueia "tipos" com muito LOSS (recente)
    // - Libera com pequeno boost quando um tipo Ã© muito vencedor (recente)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let learningDecision = 'none'; // 'none' | 'swap' | 'boost' | 'blocked'
    let learningRecentN = 0;
    let learningRecentWinRate = null;
    let learningKey = null;
    try {
        const { minSamples, badWinRate, goodWinRate } = resolveN4LearningParams(baselinePcycle, stepsToWin);

        const ctxKey = Array.isArray(ctxTail) ? ctxTail.join('') : '';
        let bestTok = bestPick && bestPick.tok ? bestPick.tok : null;
        let candidateKey = buildN4SelfLearningKey(ctxKey, bestTok, stepsToWin, signalIntensity, learningPolicy);
        let stats = candidateKey ? getN4SelfLearningStatsForKey(candidateKey) : null;

        // âœ… Swap inteligente (G2): se o tipo atual estÃ¡ ruim e a alternativa estÃ¡ muito melhor, troque a cor (em vez de sÃ³ bloquear).
        if (!forcePick && ctxKey && (bestTok === 'R' || bestTok === 'B')) {
            const otherTok = bestTok === 'R' ? 'B' : 'R';
            const otherKey = buildN4SelfLearningKey(ctxKey, otherTok, stepsToWin, signalIntensity, learningPolicy);
            const otherStats = otherKey ? getN4SelfLearningStatsForKey(otherKey) : null;
            const bestWR = stats && typeof stats.recentWinRate === 'number' ? stats.recentWinRate : null;
            const bestN = stats && Number.isFinite(Number(stats.recentN)) ? Number(stats.recentN) : 0;
            const otherWR = otherStats && typeof otherStats.recentWinRate === 'number' ? otherStats.recentWinRate : null;
            const otherN = otherStats && Number.isFinite(Number(otherStats.recentN)) ? Number(otherStats.recentN) : 0;

            const bestLooksBad = (bestWR != null && bestN >= minSamples && bestWR <= badWinRate);
            const otherLooksGood = (otherWR != null && otherN >= minSamples && otherWR >= goodWinRate);
            const otherLooksBetter = (otherWR != null && otherN >= minSamples && bestWR != null && otherWR > bestWR + 0.06);
            if (bestLooksBad && (otherLooksGood || otherLooksBetter)) {
                const otherPick = scored.find(s => s && s.tok === otherTok) || null;
                const otherSecond = otherPick ? (scored.find(s => s && s.tok !== otherTok) || null) : null;
                if (otherPick) {
                    const nextScore = computeScore(otherPick, otherSecond);
                    const nextAllowed = !!otherPick
                        && passesNonScoreFilters(otherPick, otherSecond, evidence.total)
                        && (nextScore.score >= adaptiveScoreMin)
                        && (Number(otherPick.mean || 0) >= volumeProfile.minP1Mean);
                    if (nextAllowed) {
                        bestPick = otherPick;
                        secondPick = otherSecond;
                        marginLcb = bestPick && secondPick ? Math.max(0, (bestPick.lcb - secondPick.lcb)) : (bestPick ? bestPick.lcb : 0);
                        currentScore = nextScore;
                        allowed = true;
                        bestTok = otherTok;
                        candidateKey = otherKey;
                        stats = otherStats;
                        learningDecision = 'swap';
                    }
                }
            }
        }

        if (stats && stats.recentN != null) {
            learningRecentN = stats.recentN;
            learningRecentWinRate = stats.recentWinRate;

                // âœ… Boost leve: se o tipo estÃ¡ MUITO vencedor, afrouxa um pouco o limiar (sem burlar filtros estruturais)
                if (!allowed && stats.recentWinRate != null && stats.recentN >= minSamples && stats.recentWinRate >= goodWinRate) {
                    const boostMargin = signalIntensity === 'conservative' ? 0.010 : 0.015;
                    const minMeanSlack = signalIntensity === 'conservative' ? 0.00 : 0.01;
                    const boostedOk = !!bestPick
                        && passesNonScoreFilters(bestPick, secondPick, evidence.total)
                        && (currentScore.score >= (adaptiveScoreMinBase - boostMargin))
                        && (Number(bestPick.mean || 0) >= (volumeProfile.minP1Mean - minMeanSlack));
                    if (boostedOk) {
                        allowed = true;
                        adaptiveScoreMin = Math.max(0, adaptiveScoreMinBase - boostMargin);
                        learningDecision = 'boost';
                    }
                }

                // ğŸš« Bloqueio: se o tipo estÃ¡ dando LOSS demais, anula o voto do N4
                if (allowed && stats.recentWinRate != null && stats.recentN >= minSamples && stats.recentWinRate <= badWinRate) {
                    // NÃ£o bloquear picks forÃ§ados (gales dinÃ¢micos) â€” isso Ã© "salvar o ciclo", nÃ£o gerar novo sinal.
                    if (!forcePick) {
                        allowed = false;
                        learningDecision = 'blocked';
                    }
                }
        }
        if (allowed) {
            learningKey = candidateKey;
        }
    } catch (_) {}

    const chosenTok = allowed ? (bestPick ? bestPick.tok : null) : (forcePick ? forcedTok : null);
    const chosenColor = chosenTok ? tokToColor[chosenTok] : null;

    const p1 = chosenTok
        ? (allowed ? (bestPick?.mean || 0) : (forcedDist[chosenTok] || 0))
        : 0;
    const p2 = chosenTok ? (stepsToWin >= 2 ? estimateWinWithin(ctxTail, 2, chosenTok) : p1) : 0;
    const p3 = chosenTok ? (stepsToWin >= 3 ? estimateWinWithin(ctxTail, 3, chosenTok) : p2) : 0;

    const confidence = chosenTok ? clamp01(p1) : 0;
    const lossProb = chosenTok ? clamp01(1 - p1) : 1;
    const margin = allowed ? Number(marginLcb || 0) : 0;

    const ctxLabel = bestEvidenceOrder ? `ctx O${bestEvidenceOrder} w${evidence.total.toFixed(1)}` : 'ctx n/d';
    const edge = allowed ? Number(bestPick?.edgeLcb || 0) : 0;
    const lcb1 = allowed ? Number(bestPick?.lcb || 0) : 0;

    const learningSuffix = (() => {
        if (learningDecision === 'none') return '';
        const pct = (learningRecentWinRate != null) ? `${(learningRecentWinRate * 100).toFixed(0)}%` : 'n/d';
        const n = learningRecentN || 0;
        if (learningDecision === 'swap') return ` â€¢ AutoApr: SWAP (${pct} em ${n})`;
        if (learningDecision === 'boost') return ` â€¢ AutoApr: BOOST (${pct} em ${n})`;
        if (learningDecision === 'blocked') return ` â€¢ AutoApr: BLOQUEADO (${pct} em ${n})`;
        return '';
    })();

    const details = chosenTok && allowed
        ? `P1 ${(p1 * 100).toFixed(1)}% â€¢ P${stepsToWin}est ${(p3 * 100).toFixed(1)}% â€¢ BaseP${stepsToWin} ${(baselinePcycle * 100).toFixed(1)}% â€¢ LCB ${(lcb1 * 100).toFixed(1)}% â€¢ Score ${(currentScore.score * 100).toFixed(1)}â‰¥${(adaptiveScoreMin * 100).toFixed(1)} â€¢ ${ctxLabel} â€¢ ${signalIntensity}/${learningPolicy}${learningSuffix}`
        : chosenTok && forcePick
        ? `FORCE â€¢ P1 ${(p1 * 100).toFixed(1)}% â€¢ ${ctxLabel} â€¢ ${signalIntensity}/${learningPolicy}`
        : `NULO â€¢ ${bestPick ? `Score ${(currentScore.score * 100).toFixed(1)} < ${(adaptiveScoreMin * 100).toFixed(1)} â€¢ LCB ${(bestPick.lcb * 100).toFixed(1)}% â€¢ BaseP${stepsToWin} ${(baselinePcycle * 100).toFixed(1)}% â€¢ ${ctxLabel}` : 'sem contexto Ãºtil'} â€¢ ${signalIntensity}/${learningPolicy}${learningSuffix}`;

    return {
        color: chosenColor,
        confidence,
        p1: Number(p1.toFixed(4)),
        p2: Number(p2.toFixed(4)),
        p3: Number(p3.toFixed(4)),
        pHit: Number(p1.toFixed(4)),
        lossProb: Number(lossProb.toFixed(4)),
        margin: Number(margin.toFixed(4)),
        requiredPHit: Number(requiredPHit.toFixed(4)),
        lcb1: Number(lcb1.toFixed(4)),
        edgeLcb: Number(edge.toFixed(4)),
        pickedOrder: bestEvidenceOrder || null,
        support: Number((evidence.total || 0).toFixed(2)),
        maxOrder,
        decayHalfLife,
        maxGalesConsidered: maxGalesConfigured,
        historyUsed: tokens.length,
        historyConfigured: historySizeConfigured,
        // ğŸ”¥ N4 auto-aprendizado: chave + contexto (usado para registrar WIN/LOSS por tipo)
        learningKey: (allowed && !forcePick) ? (learningKey || null) : null,
        learningContext: Array.isArray(ctxTail) ? ctxTail.join('') : null,
        learningDecision,
        details
    };
}

/**
 * â±ï¸ HELPER: Sleep para delay entre nÃ­veis
 */
// âœ… Em modo "sinal rÃ¡pido", NUNCA bloquear o loop de anÃ¡lise com sleeps longos.
// Isso evita o bug relatado pelo usuÃ¡rio: sinal chegando quando a roleta jÃ¡ estÃ¡ â€œgirandoâ€.
let fastLiveAnalysisDepth = 0;
function sleep(ms) {
    try {
        const n = Math.floor(Number(ms) || 0);
        // Em contexto de anÃ¡lise ao vivo, ignorar delays â€œcosmÃ©ticosâ€ (>=250ms).
        // Mantemos 0/pequenos yields caso algum trecho dependa disso.
        if (fastLiveAnalysisDepth > 0 && n >= 250) {
            return Promise.resolve();
        }
    } catch (_) {}
    return new Promise(resolve => setTimeout(resolve, ms));
}

const N0_DEFAULTS = Object.freeze({
    historySize: 2000,
    windowSize: 100,
    analysesToRun: 1000,
    minWindowsRequired: 4,
    precisionMin: 0.45,
    confidenceGrid: [0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95],
    holdoutEnabled: true,
    holdoutTolerance: 0.2,
    seed: 42,
    softBlockFactor: 0.5
});

// âœ… Cache em memÃ³ria do N0 (evita re-treinar 1000 configs a cada giro, especialmente no backtest).
// Importante: Ã© runtime-only (service worker). NÃ£o persiste entre reinÃ­cios do SW.
const N0_RUNTIME_MODEL_CACHE_VERSION = 1;
const n0RuntimeModelCache = new Map(); // cacheKey -> { version, model, trainedAt, trainedOnSpinKey, spinsSinceTrain, lastSeenSpinKey, lastResult }

// âœ… Controle de volume do Branco (N0):
// Objetivo: evitar "chute em massa" (muitos sinais por hora) e manter sinais proporcionais ao volume real de brancos.
const N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK = 7; // mÃ©dia tÃ­pica (usuÃ¡rio): ~6-8
const N0_WHITE_SIGNAL_TARGET_MIN = 3;
const N0_WHITE_SIGNAL_TARGET_MAX = 18;
const N0_WHITE_SIGNAL_TARGET_LOOKBACK_HOURS = 6; // janela curta para adaptaÃ§Ã£o ao "momento"
const N0_WHITE_SIGNAL_MIN_LIFT = 1.45; // exigir lift acima do baseline do branco no horizonte
let n0WhiteBudgetState = {
    hourKey: null,
    target: N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK,
    used: 0,
    lastUpdateMs: 0,
    // informativo (nÃ£o afeta budget diretamente)
    avgUsed: null,
    avgRecent: null,
    avgHourOfDay: null,
    hourOfDaySamples: 0
};

function buildHourKeyLocal(ms) {
    try {
        const d = new Date(Number(ms) || Date.now());
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const h = String(d.getHours()).padStart(2, '0');
        return `${y}-${m}-${day} ${h}`;
    } catch (_) {
        return `unknown_${Math.floor(Date.now() / 3600000)}`;
    }
}

function estimateAvgWhitesPerHour(history, nowMs, lookbackHours = N0_WHITE_SIGNAL_TARGET_LOOKBACK_HOURS) {
    try {
        const arr = Array.isArray(history) ? history : [];
        const now = Number(nowMs) || Date.now();
        const lookback = Math.max(1, Math.min(24, Math.floor(Number(lookbackHours) || 6)));
        const cutoff = now - lookback * 60 * 60 * 1000;
        const hourSet = new Set();
        let whites = 0;
        for (let i = 0; i < arr.length; i++) {
            const s = arr[i];
            const ms = Number.isFinite(parseSpinTimestamp(s)) ? parseSpinTimestamp(s) : 0;
            if (!ms) continue;
            if (ms < cutoff) break; // history vem mais recente -> mais antigo
            hourSet.add(buildHourKeyLocal(ms));
            if (s && s.color === 'white') whites += 1;
        }
        const hours = hourSet.size;
        if (hours <= 0) return null;
        return whites / hours;
    } catch (_) {
        return null;
    }
}

function estimateAvgWhitesPerHourOfDay(history, nowMs, lookbackHours = 72) {
    try {
        const arr = Array.isArray(history) ? history : [];
        const now = Number(nowMs) || Date.now();
        const lookback = Math.max(6, Math.min(240, Math.floor(Number(lookbackHours) || 72)));
        const cutoff = now - lookback * 60 * 60 * 1000;
        const targetHour = (() => {
            try { return new Date(now).getHours(); } catch (_) { return null; }
        })();
        if (targetHour == null) return null;

        const perHour = new Map(); // hourKey -> whites
        for (let i = 0; i < arr.length; i++) {
            const s = arr[i];
            const ms = Number.isFinite(parseSpinTimestamp(s)) ? parseSpinTimestamp(s) : 0;
            if (!ms) continue;
            if (ms < cutoff) break;
            const d = new Date(ms);
            if (d.getHours() !== targetHour) continue;
            const hk = buildHourKeyLocal(ms); // YYYY-MM-DD HH
            if (!perHour.has(hk)) perHour.set(hk, 0);
            if (isWhiteSpinForN0Guard(s)) perHour.set(hk, (perHour.get(hk) || 0) + 1);
        }
        const counts = [...perHour.values()].filter((n) => Number.isFinite(n) && n >= 0);
        if (counts.length < 2) return null;
        const sum = counts.reduce((acc, n) => acc + n, 0);
        const mean = sum / counts.length;
        return { mean, nHours: counts.length };
    } catch (_) {
        return null;
    }
}

function computeN0TargetWhitesPerHour(history, nowMs) {
    const now = Number(nowMs) || Date.now();
    const avgRecent = estimateAvgWhitesPerHour(history, now, N0_WHITE_SIGNAL_TARGET_LOOKBACK_HOURS);
    const hod = estimateAvgWhitesPerHourOfDay(history, now, 72);
    const avgHourOfDay = (hod && typeof hod.mean === 'number' && Number.isFinite(hod.mean)) ? hod.mean : null;
    const hourOfDaySamples = (hod && Number.isFinite(Number(hod.nHours))) ? Math.floor(Number(hod.nHours)) : 0;

    let avgUsed = null;
    if (avgHourOfDay != null && Number.isFinite(avgHourOfDay)) {
        if (typeof avgRecent === 'number' && Number.isFinite(avgRecent)) {
            // peso cresce com mais amostras por "hora do dia"
            const w = Math.max(0.35, Math.min(0.75, hourOfDaySamples / 8));
            avgUsed = avgHourOfDay * w + avgRecent * (1 - w);
        } else {
            avgUsed = avgHourOfDay;
        }
    } else {
        avgUsed = (typeof avgRecent === 'number' && Number.isFinite(avgRecent)) ? avgRecent : null;
    }

    const proposed = Number.isFinite(avgUsed) ? Math.round(avgUsed) : N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK;
    const target = Math.max(N0_WHITE_SIGNAL_TARGET_MIN, Math.min(N0_WHITE_SIGNAL_TARGET_MAX, proposed));
    return { target, avgUsed, avgRecent: (Number.isFinite(avgRecent) ? avgRecent : null), avgHourOfDay, hourOfDaySamples };
}

function ensureN0WhiteBudgetForNow(history, nowMs) {
    const now = Number(nowMs) || Date.now();
    const hourKey = buildHourKeyLocal(now);
    if (n0WhiteBudgetState.hourKey !== hourKey) {
        const info = computeN0TargetWhitesPerHour(history, now);
        const proposed = info && Number.isFinite(Number(info.target)) ? Math.floor(Number(info.target)) : N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK;
        const avgUsed = (info && typeof info.avgUsed === 'number' && Number.isFinite(info.avgUsed)) ? info.avgUsed : null;
        const avgRecent = (info && typeof info.avgRecent === 'number' && Number.isFinite(info.avgRecent)) ? info.avgRecent : null;
        const avgHourOfDay = (info && typeof info.avgHourOfDay === 'number' && Number.isFinite(info.avgHourOfDay)) ? info.avgHourOfDay : null;
        const hourOfDaySamples = (info && Number.isFinite(Number(info.hourOfDaySamples))) ? Math.floor(Number(info.hourOfDaySamples)) : 0;
        n0WhiteBudgetState = {
            hourKey,
            target: Math.max(N0_WHITE_SIGNAL_TARGET_MIN, Math.min(N0_WHITE_SIGNAL_TARGET_MAX, proposed)),
            used: 0,
            lastUpdateMs: now,
            avgUsed,
            avgRecent,
            avgHourOfDay,
            hourOfDaySamples
        };
    }
    return n0WhiteBudgetState;
}

function decideN0WhiteSignalEmission({ history, nowMs, confidence, lookaheadSpins, override = false, commit = true }) {
    const state = ensureN0WhiteBudgetForNow(history, nowMs);
    const L = Math.max(1, Math.min(6, Math.floor(Number(lookaheadSpins) || 1)));
    const base = 1 - Math.pow(1 - (1 / 15), L); // baseline P(hit branco em atÃ© L)
    const minConf = Math.max(0.12, Math.min(0.75, clamp01(base * N0_WHITE_SIGNAL_MIN_LIFT)));
    const conf = clamp01(typeof confidence === 'number' ? confidence : Number(confidence) || 0);
    if (!override) {
        if (state.used >= state.target) {
            return { ok: false, reason: 'budget_exceeded', target: state.target, used: state.used, minConf, base };
        }
        if (conf < minConf) {
            return { ok: false, reason: 'below_min_conf', target: state.target, used: state.used, minConf, base };
        }
    }
    if (commit) {
        state.used += 1;
        state.lastUpdateMs = Number(nowMs) || Date.now();
    }
    return { ok: true, reason: override ? 'override' : 'ok', committed: !!commit, target: state.target, used: state.used, minConf, base };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ‘€ N0 (Detector de Branco): Observadores (explicaÃ§Ã£o + gate de qualidade)
// - Objetivo: NÃƒO recomendar branco sÃ³ por um gatilho fraco (ex.: "gap=7").
// - Integra: saturaÃ§Ã£o do horÃ¡rio, puxadores, espelho, quebras, resistÃªncia, fim de hora,
//   repetiÃ§Ã£o (dia anterior), chuva/descanso e vizinhanÃ§a.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const N0_OBS_END_OF_HOUR_MINUTE = 55;
const N0_OBS_NEIGHBOR_GAP_THRESHOLD = 12; // "isolado": > ~6min sem branco
const N0_OBS_NEIGHBOR_MIN_CHAIN = 3;      // quantos brancos isolados seguidos para alertar vizinhanÃ§a
const N0_OBS_CONFIRM_MIN_DEFAULT = 2;     // mÃ­nimo de confirmaÃ§Ãµes para sinal
const N0_OBS_CONFIRM_MIN_STRONG = 3;      // mÃ­nimo para BLOCK ALL (mais rÃ­gido)
// âœ… PUX (puxador) deve ser "recente" (como vocÃª pediu): nÃ£o usar estatÃ­stica muito antiga
const N0_OBS_PULLER_LOOKBACK_SPINS = 240;
const N0_OBS_PULLER_MIN_OCC = 3;

function getHourBoundsLocalMs(nowMs) {
    try {
        const d = new Date(Number(nowMs) || Date.now());
        d.setMinutes(0, 0, 0);
        const start = d.getTime();
        return { hourStartMs: start, hourEndMs: start + 60 * 60 * 1000 };
    } catch (_) {
        const n = Number(nowMs) || Date.now();
        const start = n - (n % (60 * 60 * 1000));
        return { hourStartMs: start, hourEndMs: start + 60 * 60 * 1000 };
    }
}

function countWhitesInCurrentHourNewestFirst(history, nowMs) {
    const arr = Array.isArray(history) ? history : [];
    const bounds = getHourBoundsLocalMs(nowMs);
    const hourStartMs = bounds.hourStartMs;
    const hourEndMs = bounds.hourEndMs;
    let whites = 0;
    let spins = 0;
    let sawInHour = false;

    for (let i = 0; i < arr.length; i++) {
        const s = arr[i];
        const ms = Number.isFinite(parseSpinTimestamp(s)) ? parseSpinTimestamp(s) : 0;
        if (!ms) continue;

        if (ms >= hourStartMs && ms < hourEndMs) {
            sawInHour = true;
            spins += 1;
            if (isWhiteSpinForN0Guard(s)) whites += 1;
            continue;
        }
        // history normalmente vem mais recente -> mais antigo: quando passar do comeÃ§o da hora, pode parar
        if (sawInHour && ms < hourStartMs) break;
    }
    return { whites, spins, hourStartMs, hourEndMs };
}

function computeN0MinuteSlotFromMs(ms) {
    try {
        const d = new Date(Number(ms) || Date.now());
        const hour = d.getHours();
        const minute = d.getMinutes();
        const sec = d.getSeconds();
        // Blaze Double ~2 giros por minuto â†’ aproximar slot pelo segundo (0-29 / 30-59)
        const slot = sec >= 30 ? 2 : 1;
        return { hour, minute, slot, key: `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}#${slot}` };
    } catch (_) {
        return { hour: null, minute: null, slot: null, key: null };
    }
}

function computeN0HourStats(history, nowMs, lookaheadSpins) {
    const now = Number(nowMs) || Date.now();
    const timeSlot = computeN0MinuteSlotFromMs(now);
    const budgetState = ensureN0WhiteBudgetForNow(history, now);
    const target = (budgetState && Number.isFinite(Number(budgetState.target)))
        ? Math.max(N0_WHITE_SIGNAL_TARGET_MIN, Math.min(N0_WHITE_SIGNAL_TARGET_MAX, Math.floor(Number(budgetState.target))))
        : N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK;
    const inHour = countWhitesInCurrentHourNewestFirst(history, now);

    const minute = (() => {
        try { return new Date(now).getMinutes(); } catch (_) { return 0; }
    })();
    const minutesLeft = Math.max(0, 59 - minute);
    const spinsLeftApprox = Math.max(0, Math.round((60 - minute) * 2));
    const deficit = Math.max(0, target - inHour.whites);

    const lookahead = Math.max(1, Math.min(6, Math.floor(Number(lookaheadSpins) || 1)));
    const baseWhite = 1 - Math.pow(1 - (1 / 15), lookahead);

    // "Chuva" (burst): hora acima da mÃ©dia OU muita densidade de brancos no curto prazo
    const recent = (() => {
        const max = Math.min(40, Array.isArray(history) ? history.length : 0);
        let w = 0;
        for (let i = 0; i < max; i++) if (isWhiteSpinForN0Guard(history[i])) w += 1;
        return { spins: max, whites: w };
    })();
    const burst = (inHour.whites >= Math.max(target + 4, Math.ceil(target * 1.7))) || (recent.whites >= 2 && recent.spins <= 30);

    const endOfHour = minute >= N0_OBS_END_OF_HOUR_MINUTE;
    const needFill = endOfHour && deficit > 0;
    const saturated = (inHour.whites >= target) && !burst;

    return {
        timeSlot,
        target,
        avgWhitesPerHour: (budgetState && typeof budgetState.avgUsed === 'number' && Number.isFinite(budgetState.avgUsed)) ? budgetState.avgUsed : null,
        avgHourOfDay: (budgetState && typeof budgetState.avgHourOfDay === 'number' && Number.isFinite(budgetState.avgHourOfDay)) ? budgetState.avgHourOfDay : null,
        avgRecent: (budgetState && typeof budgetState.avgRecent === 'number' && Number.isFinite(budgetState.avgRecent)) ? budgetState.avgRecent : null,
        hourOfDaySamples: (budgetState && Number.isFinite(Number(budgetState.hourOfDaySamples))) ? Number(budgetState.hourOfDaySamples) : 0,
        baseWhite,
        whitesThisHour: inHour.whites,
        spinsThisHour: inHour.spins,
        deficit,
        minute,
        minutesLeft,
        spinsLeftApprox,
        endOfHour,
        needFill,
        burst,
        saturated
    };
}

function computeN0RecentPullerStats(history, lookaheadSpins, maxSpins = N0_OBS_PULLER_LOOKBACK_SPINS) {
    try {
        const arr = Array.isArray(history) ? history : [];
        const max = Math.max(40, Math.min(arr.length, Math.floor(Number(maxSpins) || N0_OBS_PULLER_LOOKBACK_SPINS)));
        const L = Math.max(1, Math.min(6, Math.floor(Number(lookaheadSpins) || 3)));
        // history aqui Ã© newest-first; inverter para avaliar "prÃ³ximos giros" corretamente
        const chron = arr.slice(0, max).slice().reverse();
        const map = {}; // num -> { occ, white }
        for (let i = 0; i < chron.length; i++) {
            const cur = chron[i];
            if (!cur) continue;
            // puxador: nÃºmero NÃƒO-branco que precede branco em atÃ© L giros
            if (isWhiteSpinForN0Guard(cur)) continue;
            const num = Number(cur.number ?? cur.numero ?? cur.value ?? null);
            if (!Number.isFinite(num)) continue;
            const n = Math.floor(num);
            if (n < 0 || n > 14) continue;
            // lookahead futuro (sem estourar)
            const end = Math.min(chron.length, i + 1 + L);
            let hasWhite = false;
            for (let j = i + 1; j < end; j++) {
                if (isWhiteSpinForN0Guard(chron[j])) { hasWhite = true; break; }
            }
            const key = String(n);
            if (!map[key]) map[key] = { occ: 0, white: 0 };
            map[key].occ += 1;
            if (hasWhite) map[key].white += 1;
        }
        return map;
    } catch (_) {
        return {};
    }
}

function detectN0Mirror(windowChars, options = {}) {
    try {
        const w = Array.isArray(windowChars) ? windowChars : [];
        const maxLookback = Math.max(12, Math.min(60, Math.floor(Number(options.maxLookback) || 30)));
        const minOppRun = Math.max(2, Math.min(12, Math.floor(Number(options.minOppRun) || 3)));
        if (w.length < 8) return { hit: false };

        const seg = w.slice(Math.max(0, w.length - maxLookback));
        // achar Ãºltimo nÃ£o-branco
        let end = seg.length - 1;
        while (end >= 0 && seg[end] === 'W') end -= 1;
        if (end < 0) return { hit: false };
        const A = seg[end];
        if (!(A === 'R' || A === 'B')) return { hit: false };
        const B = A === 'R' ? 'B' : 'R';

        let runB = 0;
        let i = end - 1;
        while (i >= 0 && seg[i] === B) { runB += 1; i -= 1; }
        if (runB < minOppRun) return { hit: false };
        if (i < 0 || seg[i] !== A) return { hit: false };
        i -= 1;
        // precisa existir um branco antes do 1Âº A (dentro do lookback)
        while (i >= 0) {
            if (seg[i] === 'W') {
                return { hit: true, A, B, runB, span: (end - i + 1) };
            }
            i -= 1;
        }
        return { hit: false };
    } catch (_) {
        return { hit: false };
    }
}

function detectN0ResistanceBreak(windowChars, options = {}) {
    try {
        const w = Array.isArray(windowChars) ? windowChars : [];
        const maxLookback = Math.max(20, Math.min(w.length, Math.floor(Number(options.maxLookback) || 80)));
        const seg = w.slice(Math.max(0, w.length - maxLookback));
        if (seg.length < 12) return { hit: false };

        // achar Ãºltimo branco dentro do segmento
        let lastW = -1;
        for (let i = seg.length - 1; i >= 0; i--) {
            if (seg[i] === 'W') { lastW = i; break; }
        }
        if (lastW < 0 || lastW >= seg.length - 2) return { hit: false };

        const after = seg.slice(lastW + 1).filter(c => c === 'R' || c === 'B');
        if (after.length < 8) return { hit: false };

        const lastColor = after[after.length - 1];
        let curRun = 1;
        for (let i = after.length - 2; i >= 0; i--) {
            if (after[i] === lastColor) curRun += 1;
            else break;
        }

        // mÃ¡ximo histÃ³rico (excluindo a run atual)
        let prevMax = 0;
        let run = 0;
        let runColor = null;
        const upto = Math.max(0, after.length - curRun);
        for (let i = 0; i < upto; i++) {
            const c = after[i];
            if (c !== runColor) {
                prevMax = Math.max(prevMax, run);
                runColor = c;
                run = 1;
            } else {
                run += 1;
            }
        }
        prevMax = Math.max(prevMax, run);

        // regra: ficou "travado" em <=3 por bastante tempo e agora rompeu (>=4)
        const hit = prevMax <= 3 && curRun >= 4 && curRun > prevMax;
        return { hit, prevMax, curRun, color: lastColor };
    } catch (_) {
        return { hit: false };
    }
}

function computeN0TimeSlotStatsFromHistory(history, nowMs, lookbackSpins = 5000) {
    try {
        const arr = Array.isArray(history) ? history : [];
        const max = Math.min(arr.length, Math.max(200, Math.min(REALTIME_HISTORY_CAP, Math.floor(Number(lookbackSpins) || 5000))));
        const nowSlot = computeN0MinuteSlotFromMs(nowMs);
        if (!nowSlot || !nowSlot.key) return { nowKey: null, nowCount: 0, top: [] };

        const map = new Map(); // key -> count
        for (let i = 0; i < max; i++) {
            const s = arr[i];
            const ms = Number.isFinite(parseSpinTimestamp(s)) ? parseSpinTimestamp(s) : 0;
            if (!ms) continue;
            if (!isWhiteSpinForN0Guard(s)) continue;
            const k = computeN0MinuteSlotFromMs(ms).key;
            if (!k) continue;
            map.set(k, (map.get(k) || 0) + 1);
        }
        const entries = [...map.entries()].sort((a, b) => b[1] - a[1]);
        const nowCount = map.get(nowSlot.key) || 0;
        return { nowKey: nowSlot.key, nowCount, top: entries.slice(0, 6) };
    } catch (_) {
        return { nowKey: null, nowCount: 0, top: [] };
    }
}

function findPrevDayRepeatWhite(history, nowMs, toleranceMs = 90 * 1000) {
    try {
        const arr = Array.isArray(history) ? history : [];
        const now = Number(nowMs) || Date.now();
        const target = now - 24 * 60 * 60 * 1000;
        if (!Number.isFinite(target) || target <= 0) return null;

        let best = null;
        let bestDelta = Infinity;
        for (let i = 0; i < arr.length; i++) {
            const s = arr[i];
            const ms = Number.isFinite(parseSpinTimestamp(s)) ? parseSpinTimestamp(s) : 0;
            if (!ms) continue;
            const delta = Math.abs(ms - target);
            if (delta <= toleranceMs && delta < bestDelta) {
                best = s;
                bestDelta = delta;
            }
            // se o histÃ³rico jÃ¡ passou de 26h pra trÃ¡s, dÃ¡ pra encerrar (mais antigo)
            if (ms < (target - 2 * 60 * 60 * 1000)) break;
        }
        if (best && isWhiteSpinForN0Guard(best)) {
            const slot = computeN0MinuteSlotFromMs(Number.isFinite(parseSpinTimestamp(best)) ? parseSpinTimestamp(best) : now).key;
            return { hit: true, mode: 'prev_day', deltaMin: Math.round(bestDelta / 60000), slot };
        }

        // fallback: repetiu o MESMO horÃ¡rio:minute#slot em algum ponto do histÃ³rico disponÃ­vel
        const nowSlot = computeN0MinuteSlotFromMs(now);
        if (!nowSlot || !nowSlot.key) return null;
        for (let i = 0; i < arr.length; i++) {
            const s = arr[i];
            const ms = Number.isFinite(parseSpinTimestamp(s)) ? parseSpinTimestamp(s) : 0;
            if (!ms) continue;
            if (!isWhiteSpinForN0Guard(s)) continue;
            const k = computeN0MinuteSlotFromMs(ms).key;
            if (k === nowSlot.key) {
                const deltaH = Math.round(Math.abs(now - ms) / (60 * 60 * 1000));
                return { hit: true, mode: 'same_slot', deltaHours: deltaH, slot: k };
            }
        }
        return null;
    } catch (_) {
        return null;
    }
}

function computeN0ObserverPackage({ history, nowMs, n0Result, lookaheadSpins }) {
    const hourStats = computeN0HourStats(history, nowMs, lookaheadSpins);
    const pos = [];
    const neg = [];

    // SAT (saturaÃ§Ã£o do horÃ¡rio) / FIM (fim do horÃ¡rio com dÃ©ficit) / CHU (chuva)
    if (hourStats.burst) pos.push(`CHU${hourStats.whitesThisHour}/${hourStats.target}`);
    if (hourStats.needFill) pos.push(`FIM${hourStats.whitesThisHour}/${hourStats.target}`);
    if (hourStats.saturated) neg.push(`SAT${hourStats.whitesThisHour}/${hourStats.target}`);

    // DES (descanso / gap alto) + VIZ (sequÃªncia de brancos isolados)
    try {
        const gaps = computeWhiteGapsNewestFirst(history, Math.max(600, Math.min(REALTIME_HISTORY_CAP, Math.floor((lookaheadSpins || 3) * 1200))));
        const sorted = gaps.filter((n) => Number.isFinite(n) && n >= 0).slice().sort((a, b) => a - b);
        const p75 = quantileFromSorted(sorted, 0.75);
        const p90 = quantileFromSorted(sorted, 0.90);
        const lastWhiteIdx = findMostRecentWhiteIndexForN0(history, 400);
        const gapNow = (lastWhiteIdx != null) ? Math.max(0, lastWhiteIdx) : null;
        if (gapNow != null && p75 != null && gapNow >= p75 && gapNow >= 10) {
            pos.push(`DESg${gapNow}â‰¥p75${p75}`);
        }
        if (gapNow != null) {
            // cadeia de isolados (gaps longos)
            const lastGaps = sorted.length ? gaps.slice(-10) : [];
            let chain = 0;
            for (let i = lastGaps.length - 1; i >= 0; i--) {
                const g = Number(lastGaps[i]);
                if (!Number.isFinite(g)) break;
                if (g >= N0_OBS_NEIGHBOR_GAP_THRESHOLD) chain += 1;
                else break;
            }
            if (chain >= N0_OBS_NEIGHBOR_MIN_CHAIN && gapNow <= 12 && gapNow >= 1) {
                pos.push(`VIZc${chain}`);
            }
            // Em "chuva", vizinhanÃ§a jÃ¡ Ã© implÃ­cita; nÃ£o poluir
        }
    } catch (_) {}

    // Contexto do N0 (puxadores/quebra/gap) a partir do modelo leve
    const ctx = (n0Result && n0Result.context_stats && typeof n0Result.context_stats === 'object')
        ? n0Result.context_stats
        : null;
    const base = (ctx && typeof ctx.base_white_rate === 'number' && Number.isFinite(ctx.base_white_rate) && ctx.base_white_rate > 0)
        ? clamp01(ctx.base_white_rate)
        : (hourStats && typeof hourStats.baseWhite === 'number' ? clamp01(hourStats.baseWhite) : clamp01(1 - Math.pow(1 - (1 / 15), Math.max(1, Math.min(6, Math.floor(Number(lookaheadSpins) || 3))))));

    const liveChars = (n0Result && Array.isArray(n0Result.live_window_chars)) ? n0Result.live_window_chars : null;
    const liveNums = (n0Result && Array.isArray(n0Result.live_window_numbers)) ? n0Result.live_window_numbers : null;

    // PUX (puxador)
    try {
        const tailNum = getTailNonWhiteNumberFromWindow(liveChars, liveNums);
        // âœ… Usar APENAS os Ãºltimos ~240 giros para puxador (recente)
        const pullersRecent = computeN0RecentPullerStats(history, lookaheadSpins, N0_OBS_PULLER_LOOKBACK_SPINS);
        const row = tailNum != null ? pullersRecent[String(tailNum)] : null;
        if (row && row.occ >= N0_OBS_PULLER_MIN_OCC) {
            const p = row.white / Math.max(1, row.occ);
            if (p >= Math.max(base * 1.35, 0.10)) {
                pos.push(`PUXr${tailNum}=${row.white}/${row.occ}`);
            }
        }
    } catch (_) {}

    // GAP (hazard por bucket)
    try {
        const lastWhiteIdx = findMostRecentWhiteIndexForN0(history, 400);
        const gapNow = (lastWhiteIdx != null) ? Math.max(0, lastWhiteIdx) : null;
        if (gapNow != null && ctx && ctx.gap_stats) {
            const b = bucketGapForN0(gapNow);
            const row = ctx.gap_stats[b];
            if (row && row.occ >= 4) {
                const p = row.white / Math.max(1, row.occ);
                if (p >= Math.max(base * 1.25, 0.10)) {
                    pos.push(`GAP${b}=${row.white}/${row.occ}`);
                }
            }
        }
    } catch (_) {}

    // QBR (quebra apÃ³s streak)
    try {
        const br = computeBreakAfterStreak(liveChars);
        if (br && br.broke && ctx && ctx.break_stats) {
            const bucket = bucketRunLenForN0(br.prevRunLen || 0);
            const key = `prev=${bucket}|from=${br.from}|to=${br.to}`;
            const row = ctx.break_stats[key] || ctx.break_stats[`prev=${bucket}`] || null;
            if (row && row.occ >= 3) {
                const p = row.white / Math.max(1, row.occ);
                if (p >= Math.max(base * 1.25, 0.10)) {
                    pos.push(`QBR${bucket}${br.from}->${br.to}=${row.white}/${row.occ}`);
                }
            }
        }
    } catch (_) {}

    // ESP (espelhamento)
    const mirror = detectN0Mirror(liveChars);
    if (mirror && mirror.hit) {
        pos.push(`ESP${mirror.runB}${mirror.B}`);
    }

    // RES (quebra de resistÃªncia)
    const res = detectN0ResistanceBreak(liveChars);
    if (res && res.hit) {
        pos.push(`RES${res.prevMax}->${res.curRun}${res.color}`);
    }

    // POS (posiÃ§Ã£o por horÃ¡rio:minute#slot) e REP (repetiÃ§Ã£o do dia anterior/slot)
    const slotStats = computeN0TimeSlotStatsFromHistory(history, nowMs);
    if (slotStats && slotStats.nowKey && slotStats.nowCount >= 2) {
        // sÃ³ marcar se for relativamente relevante (top 6)
        const topKeys = (slotStats.top || []).map(([k]) => k);
        if (topKeys.includes(slotStats.nowKey)) {
            pos.push(`POS${slotStats.nowKey}=${slotStats.nowCount}x`);
        }
    }
    const rep = findPrevDayRepeatWhite(history, nowMs);
    if (rep && rep.hit) {
        pos.push(rep.mode === 'prev_day'
            ? `REP-1d Î”${rep.deltaMin}m`
            : `REP${rep.slot}`);
    }

    // confirmaÃ§Ã£o = quantidade de observadores "fortes" (exclui GAP)
    const isStrong = (tag) => {
        const t = String(tag || '').toUpperCase();
        if (t.startsWith('GAP')) return false;
        if (t.startsWith('SAT')) return false;
        return true;
    };
    const strongCount = pos.filter(isStrong).length;

    const short = (() => {
        const hour = hourStats && hourStats.timeSlot && hourStats.timeSlot.hour != null ? `H${String(hourStats.timeSlot.hour).padStart(2, '0')}` : 'H??';
        const hourPart = `${hour} ${hourStats.whitesThisHour}/${hourStats.target}`;
        const tagsPos = (() => {
            if (!pos.length) return '';
            const list = pos.slice(0, 6);
            const suffix = pos.length > list.length ? ',â€¦' : '';
            return `+${list.join(',')}${suffix}`;
        })();
        const tagsNeg = (() => {
            if (!neg.length) return '';
            const list = neg.slice(0, 4);
            const suffix = neg.length > list.length ? ',â€¦' : '';
            return `-${list.join(',')}${suffix}`;
        })();
        const parts = [hourPart].filter(Boolean);
        if (tagsPos) parts.push(tagsPos);
        if (tagsNeg) parts.push(tagsNeg);
        return parts.join(' â€¢ ');
    })();

    return {
        hourStats,
        pos,
        neg,
        strongCount,
        short
    };
}

function evaluateN0WhiteSignalGate({ history, nowMs, lookaheadSpins, baseConfidence, softThreshold, n0Result, mode = 'alert' }) {
    const pack = computeN0ObserverPackage({ history, nowMs, n0Result, lookaheadSpins });
    const hourStats = pack.hourStats;

    // regras "duras" primeiro
    if (hourStats && hourStats.saturated) {
        return { ok: false, reason: 'hour_saturated', pack, effectiveConfidence: clamp01(baseConfidence || 0) };
    }

    // confirmaÃ§Ãµes mÃ­nimas
    const required = (mode === 'block_all')
        ? N0_OBS_CONFIRM_MIN_STRONG
        : N0_OBS_CONFIRM_MIN_DEFAULT;
    const relaxedRequired = (hourStats && hourStats.needFill) ? Math.max(1, required - 1) : required;
    if ((pack.strongCount || 0) < relaxedRequired) {
        return { ok: false, reason: 'insufficient_confirmations', required: relaxedRequired, got: pack.strongCount || 0, pack, effectiveConfidence: clamp01(baseConfidence || 0) };
    }

    // confianÃ§a efetiva (boost leve por mÃºltiplas confirmaÃ§Ãµes / fim de hora)
    const base = clamp01(typeof baseConfidence === 'number' ? baseConfidence : Number(baseConfidence) || 0);
    const boost = (() => {
        let b = 0;
        if (hourStats && hourStats.needFill) b += 0.06;
        if (hourStats && hourStats.burst) b += 0.04;
        const extra = Math.max(0, (pack.strongCount || 0) - 2);
        b += Math.min(0.08, extra * 0.03);
        return b;
    })();
    const effectiveConfidence = clamp01(base + boost);

    // threshold "soft" (compatÃ­vel com o N0 atual)
    const softT = clamp01(typeof softThreshold === 'number' ? softThreshold : Number(softThreshold) || 0);
    if (effectiveConfidence < softT && !(hourStats && hourStats.needFill)) {
        return { ok: false, reason: 'below_soft_threshold', softThreshold: softT, pack, effectiveConfidence };
    }

    // budget final (sem commit)
    const budget = (() => {
        try {
            return decideN0WhiteSignalEmission({
                history,
                nowMs,
                confidence: effectiveConfidence,
                lookaheadSpins,
                override: false,
                commit: false
            });
        } catch (_) {
            return { ok: false, reason: 'budget_error' };
        }
    })();
    if (!budget || !budget.ok) {
        return { ok: false, reason: budget && budget.reason ? budget.reason : 'budget_block', budget, pack, effectiveConfidence };
    }
    return { ok: true, reason: 'ok', budget, pack, effectiveConfidence };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  N0 (Detector de Branco): guard rails + memÃ³ria viva (cooldown pÃ³s-WIN)
// - Pedido do usuÃ¡rio: apÃ³s pegar WIN no branco, NÃƒO entrar no giro seguinte.
// - Baseado em estatÃ­stica real do histÃ³rico (gaps entre brancos).
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function snapshotN0WhiteBudgetStateIntoSignalsHistory() {
    try {
        if (!signalsHistory || typeof signalsHistory !== 'object') return false;
        if (!signalsHistory.n0Guard || typeof signalsHistory.n0Guard !== 'object') return false;
        if (!n0WhiteBudgetState || typeof n0WhiteBudgetState !== 'object') return false;
        const snap = {
            hourKey: n0WhiteBudgetState.hourKey || null,
            target: Number.isFinite(Number(n0WhiteBudgetState.target)) ? Number(n0WhiteBudgetState.target) : null,
            used: Number.isFinite(Number(n0WhiteBudgetState.used)) ? Number(n0WhiteBudgetState.used) : 0,
            lastUpdateMs: Number.isFinite(Number(n0WhiteBudgetState.lastUpdateMs)) ? Number(n0WhiteBudgetState.lastUpdateMs) : null
        };
        signalsHistory.n0Guard.budgetSnapshot = snap;
        return true;
    } catch (_) {
        return false;
    }
}

function isWhiteSpinForN0Guard(spin) {
    try {
        if (!spin) return false;
        const n = Number(spin.number ?? spin.numero ?? spin.value ?? null);
        if (Number.isFinite(n) && Math.floor(n) === 0) return true;
        const c = String(spin.color || spin.result || spin.cor || '').toLowerCase().trim();
        return c === 'white' || c === 'w' || c.includes('branc');
    } catch (_) {
        return false;
    }
}

function getSpinKeyForN0Guard(spin) {
    try {
        if (!spin) return null;
        if (spin.id != null) return String(spin.id);
        const ts = spin.created_at ?? spin.timestamp ?? spin.createdAt ?? spin.time ?? null;
        if (ts != null) return String(ts);
        return null;
    } catch (_) {
        return null;
    }
}

function getSpinTimestampRawForN0Guard(spin) {
    try {
        if (!spin) return null;
        const ts = spin.created_at ?? spin.timestamp ?? spin.createdAt ?? null;
        return ts != null ? String(ts) : null;
    } catch (_) {
        return null;
    }
}

function quantileFromSorted(listSorted, q) {
    const arr = Array.isArray(listSorted) ? listSorted : [];
    if (arr.length === 0) return null;
    const qq = Math.max(0, Math.min(1, Number(q) || 0));
    const idx = Math.floor((arr.length - 1) * qq);
    const v = arr[Math.max(0, Math.min(arr.length - 1, idx))];
    return Number.isFinite(v) ? v : null;
}

function computeWhiteGapsNewestFirst(history, maxSpins = 3000) {
    const arr = Array.isArray(history) ? history.slice(0, Math.max(10, Math.min(REALTIME_HISTORY_CAP, Math.floor(Number(maxSpins) || 3000)))) : [];
    const gaps = [];
    let since = null;
    // iterar do mais antigo -> mais recente
    for (let i = arr.length - 1; i >= 0; i--) {
        const s = arr[i];
        if (isWhiteSpinForN0Guard(s)) {
            if (since != null) gaps.push(since);
            since = 0;
        } else if (since != null) {
            since += 1;
        }
    }
    return gaps;
}

function computeDynamicN0PostWinCooldownSpins(history, options = {}) {
    try {
        const lookback = Math.max(500, Math.min(REALTIME_HISTORY_CAP, Math.floor(Number(options.lookbackSpins) || 3000)));
        const gaps = computeWhiteGapsNewestFirst(history, lookback)
            .filter((n) => Number.isFinite(n) && n >= 0)
            .sort((a, b) => a - b);
        if (gaps.length < 12) {
            return { cooldownSpins: 2, stats: { n: gaps.length, p50: null, p25: null, p10: null } };
        }
        const p10 = quantileFromSorted(gaps, 0.10);
        const p25 = quantileFromSorted(gaps, 0.25);
        const p50 = quantileFromSorted(gaps, 0.50);
        // âœ… FÃ³rmula simples e estÃ¡vel:
        // - baseia no "gap mediano" (p50) do histÃ³rico real (evento raro)
        // - aplica fraÃ§Ã£o conservadora para nÃ£o travar o N0
        const raw = Math.round((Number(p50) || 0) * 0.25);
        const cooldownSpins = Math.max(2, Math.min(6, raw || 2));
        return { cooldownSpins, stats: { n: gaps.length, p10, p25, p50 } };
    } catch (_) {
        return { cooldownSpins: 2, stats: { n: 0, p50: null, p25: null, p10: null } };
    }
}

function findSpinIndexByGuardKey(history, key) {
    try {
        const arr = Array.isArray(history) ? history : [];
        const k = String(key || '').trim();
        if (!k) return null;
        const maxScan = Math.min(arr.length, 5000);
        for (let i = 0; i < maxScan; i++) {
            const s = arr[i];
            if (!s) continue;
            if (s.id != null && String(s.id) === k) return i;
            const ts = s.created_at ?? s.timestamp ?? s.createdAt ?? s.time ?? null;
            if (ts != null && String(ts) === k) return i;
        }
        return null;
    } catch (_) {
        return null;
    }
}

function findMostRecentWhiteIndexForN0(history, maxScan = 200) {
    try {
        const arr = Array.isArray(history) ? history : [];
        const lim = Math.max(1, Math.min(REALTIME_HISTORY_CAP, Math.floor(Number(maxScan) || 200)));
        const max = Math.min(arr.length, lim);
        for (let i = 0; i < max; i++) {
            if (isWhiteSpinForN0Guard(arr[i])) return i;
        }
        return null;
    } catch (_) {
        return null;
    }
}

function getN0PostWinCooldownGate({ history, nowMs }) {
    try {
        const guard = (signalsHistory && signalsHistory.n0Guard && typeof signalsHistory.n0Guard === 'object')
            ? signalsHistory.n0Guard
            : null;
        if (!guard) return { ok: true, active: false, reason: 'no_guard' };
        const required = Math.max(0, Math.min(60, Math.floor(Number(guard.cooldownSpins) || 0)));
        if (required <= 0) return { ok: true, active: false, reason: 'no_cooldown' };

        const keys = [guard.lastWhiteWinSpinId, guard.lastWhiteWinTimestamp]
            .map((v) => (v != null ? String(v).trim() : ''))
            .filter(Boolean);
        if (keys.length === 0) return { ok: true, active: false, reason: 'no_last_win' };

        let spinsSince = null;
        for (const k of keys) {
            const idx = findSpinIndexByGuardKey(history, k);
            if (idx != null) { spinsSince = idx; break; }
        }

        // Fallback: estimar por tempo (Blaze Double ~30s por giro)
        if (spinsSince == null) {
            const lastMs = Number(guard.lastWhiteWinAtMs);
            const now = Number.isFinite(Number(nowMs)) ? Number(nowMs)
                : (Number.isFinite(parseSpinTimestamp(history && history[0])) ? parseSpinTimestamp(history[0]) : Date.now());
            if (Number.isFinite(lastMs) && Number.isFinite(now) && now >= lastMs) {
                spinsSince = Math.max(0, Math.floor((now - lastMs) / 30000));
            }
        }

        if (spinsSince == null) {
            // Fail-open: sem referÃªncia confiÃ¡vel, nÃ£o travar sinais.
            return { ok: true, active: false, reason: 'unknown_spins_since' };
        }

        const remaining = Math.max(0, required - spinsSince);
        if (remaining > 0) {
            return {
                ok: false,
                active: true,
                reason: 'post_white_win_cooldown',
                required,
                spinsSinceWin: spinsSince,
                remaining
            };
        }
        return { ok: true, active: false, reason: 'cooldown_passed', required, spinsSinceWin: spinsSince, remaining: 0 };
    } catch (_) {
        return { ok: true, active: false, reason: 'cooldown_error' };
    }
}

async function armN0PostWinCooldownAfterWhiteWin({ latestSpin, history, lookbackSpins = 3000 } = {}) {
    try {
        if (!signalsHistory || typeof signalsHistory !== 'object') return null;
        if (!signalsHistory.n0Guard || typeof signalsHistory.n0Guard !== 'object') {
            signalsHistory.n0Guard = {
                version: 1,
                lastWhiteWinSpinId: null,
                lastWhiteWinTimestamp: null,
                lastWhiteWinAtMs: null,
                cooldownSpins: 0,
                setAtMs: null,
                budgetSnapshot: null
            };
        }

        const { cooldownSpins, stats } = computeDynamicN0PostWinCooldownSpins(history, { lookbackSpins });
        const spinId = getSpinKeyForN0Guard(latestSpin);
        const spinTsRaw = getSpinTimestampRawForN0Guard(latestSpin);
        const spinMs = Number.isFinite(parseSpinTimestamp(latestSpin)) ? parseSpinTimestamp(latestSpin) : null;

        signalsHistory.n0Guard.version = 1;
        signalsHistory.n0Guard.lastWhiteWinSpinId = spinId || signalsHistory.n0Guard.lastWhiteWinSpinId || null;
        signalsHistory.n0Guard.lastWhiteWinTimestamp = spinTsRaw || signalsHistory.n0Guard.lastWhiteWinTimestamp || null;
        signalsHistory.n0Guard.lastWhiteWinAtMs = spinMs != null ? spinMs : (signalsHistory.n0Guard.lastWhiteWinAtMs || null);
        signalsHistory.n0Guard.cooldownSpins = cooldownSpins;
        signalsHistory.n0Guard.setAtMs = Date.now();

        await saveSignalsHistory();
        console.log(
            `%câšª [N0] Cooldown pÃ³s-WIN armado: aguardar ${cooldownSpins} giro(s) (gaps n=${stats.n} â€¢ p50=${stats.p50} â€¢ p25=${stats.p25} â€¢ p10=${stats.p10})`,
            'color: #FFAA00; font-weight: bold;'
        );
        return { cooldownSpins, stats };
    } catch (e) {
        console.warn('âš ï¸ [N0] Falha ao armar cooldown pÃ³s-WIN:', e && e.message ? e.message : e);
        return null;
    }
}

function buildN0RuntimeCacheKey(settings) {
    try {
        const s = settings && typeof settings === 'object' ? settings : {};
        return [
            `v${N0_RUNTIME_MODEL_CACHE_VERSION}`,
            `H${Number(s.historySize) || 0}`,
            `W${Number(s.windowSize) || 0}`,
            `L${Number(s.lookaheadSpins) || 1}`,
            `A${Number(s.analysesToRun) || 0}`,
            `minW${Number(s.minWindowsRequired) || 0}`,
            `prec${Number.isFinite(Number(s.precisionMin)) ? Number(s.precisionMin).toFixed(4) : '0'}`,
            `hold${s.holdoutEnabled ? 1 : 0}`,
            `tol${Number.isFinite(Number(s.holdoutTolerance)) ? Number(s.holdoutTolerance).toFixed(4) : '0'}`,
            `seed${Number(s.seed) || 0}`
        ].join('|');
    } catch (_) {
        return `v${N0_RUNTIME_MODEL_CACHE_VERSION}|fallback`;
    }
}

const N0_FAMILY_LIST = Object.freeze([
    'freq_threshold',
    'freq_segmented',
    'weighted_recency',
    'last_run',
    'run_stats',
    'markov',
    'n_gram_pattern',
    'tail_ngram',
    'gap_hazard',
    'number_puller',
    'break_after_streak',
    'burst_detector',
    'entropy_change',
    'lagged_sum',
    'trend_accel',
    'switch_pattern',
    'compound_and',
    'compound_or'
]);

const N0_FAMILY_MIN_PER_TYPE = 20;
const N0_DIVERSITY_MIN_DISTANCE_BASE = 0.2;
const N0_CONFIG_LIBRARY_KEY = 'n0_diverse_configs_cache_v1';

function clamp01(value) {
    return Math.max(0, Math.min(1, Number.isFinite(value) ? value : 0));
}

let n0ConfigLibraryCache = null;
let n0ConfigLibrarySeed = null;

const N8_DEFAULTS = Object.freeze({
    historySize: 1200,
    windowSize: 20,
    analysesToRun: 1000,
    minWindowsRequired: 6,
    precisionMin: 0.55,
    confidenceGrid: [0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95],
    holdoutEnabled: true,
    holdoutTolerance: 0.18,
    seed: 1337,
    confMinLive: 0.58
});

// âœ… Cache runtime do N8 (Walk-forward): evita re-treinar 1000 configs a cada giro em simulaÃ§Ãµes.
const N8_RUNTIME_MODEL_CACHE_VERSION = 1;
const n8RuntimeModelCache = new Map(); // cacheKey -> { version, model, trainedAt, trainedOnSpinKey, spinsSinceTrain, lastSeenSpinKey, lastResult }

function buildN8RuntimeCacheKey(settings) {
    try {
        const s = settings && typeof settings === 'object' ? settings : {};
        return [
            `v${N8_RUNTIME_MODEL_CACHE_VERSION}`,
            `H${Number(s.historySize) || 0}`,
            `W${Number(s.windowSize) || 0}`,
            `A${Number(s.analysesToRun) || 0}`,
            `minW${Number(s.minWindowsRequired) || 0}`,
            `prec${Number.isFinite(Number(s.precisionMin)) ? Number(s.precisionMin).toFixed(4) : '0'}`,
            `hold${s.holdoutEnabled ? 1 : 0}`,
            `tol${Number.isFinite(Number(s.holdoutTolerance)) ? Number(s.holdoutTolerance).toFixed(4) : '0'}`,
            `seed${Number(s.seed) || 0}`,
            `confMin${Number.isFinite(Number(s.confMinLive)) ? Number(s.confMinLive).toFixed(4) : '0'}`
        ].join('|');
    } catch (_) {
        return `v${N8_RUNTIME_MODEL_CACHE_VERSION}|fallback`;
    }
}

const N8_FAMILY_LIST = Object.freeze([
    'dominance_threshold',
    'segmented_dominance',
    'recency_weighted',
    'momentum_split',
    'markov_chain',
    'pattern_follow',
    'streak_bias',
    'entropy_shift',
    'lagged_correlation',
    'compound_vote'
]);

const N8_FAMILY_MIN_PER_TYPE = 22;
const N8_DIVERSITY_MIN_DISTANCE_BASE = 0.18;
const N8_CONFIG_LIBRARY_KEY = 'n8_diverse_configs_cache_v1';

let n8ConfigLibraryCache = null;
let n8ConfigLibrarySeed = null;

function normalizeN0History(entries) {
    if (!Array.isArray(entries)) return [];
    const normalized = [];
    const mapNumberToChar = (value) => {
        const n = Math.floor(Number(value));
        if (!Number.isFinite(n)) return null;
        // Blaze Double: 0 = white, 1-7 = red, 8-14 = black
        if (n === 0) return 'W';
        if (n >= 1 && n <= 7) return 'R';
        if (n >= 8 && n <= 14) return 'B';
        return null;
    };
    for (const item of entries) {
        if (item == null) {
            normalized.push('W');
            continue;
        }
        if (typeof item === 'string' || typeof item === 'number') {
            const parsed = String(item).trim().toLowerCase();
            if (parsed.includes('branc') || parsed === 'w' || parsed.includes('white')) {
                normalized.push('W');
                continue;
            }
            if (parsed.includes('verm') || parsed === 'r' || parsed.includes('red')) {
                normalized.push('R');
                continue;
            }
            if (parsed.includes('pret') || parsed === 'b' || parsed.includes('black')) {
                normalized.push('B');
                continue;
            }
            const numeric = Number(parsed);
            if (Number.isFinite(numeric)) {
                const mapped = mapNumberToChar(numeric);
                if (mapped) normalized.push(mapped);
                continue;
            }
            // valor desconhecido â†’ ignorar (nÃ£o inferir como branco)
            continue;
        }
        if (typeof item === 'object') {
            const colorValue = item.color || item.result || item.Color || item.cor || null;
            if (colorValue != null) {
                const parsed = String(colorValue).trim().toLowerCase();
                if (parsed.includes('branc') || parsed === 'w' || parsed.includes('white')) {
                    normalized.push('W');
                    continue;
                }
                if (parsed.includes('verm') || parsed === 'r' || parsed.includes('red')) {
                    normalized.push('R');
                    continue;
                }
                if (parsed.includes('pret') || parsed === 'b' || parsed.includes('black')) {
                    normalized.push('B');
                    continue;
                }
                const numeric = Number(parsed);
                if (Number.isFinite(numeric)) {
                    const mapped = mapNumberToChar(numeric);
                    if (mapped) {
                        normalized.push(mapped);
                        continue;
                    }
                }
            }
            const numberValue = item.number ?? item.numero ?? item.slot ?? null;
            if (Number.isFinite(Number(numberValue))) {
                const mapped = mapNumberToChar(numberValue);
                if (mapped) normalized.push(mapped);
                continue;
            }
        }
        // item desconhecido â†’ ignorar (nÃ£o inferir como branco)
    }
    return normalized;
}

// âœ… Variante do N0 que preserva o nÃºmero (para "puxadores" de branco / contexto).
// Retorna array de { c:'R'|'B'|'W', n:number|null } alinhado 1:1.
function normalizeN0HistoryPairs(entries) {
    if (!Array.isArray(entries)) return [];
    const out = [];
    const mapNumberToChar = (value) => {
        const n = Math.floor(Number(value));
        if (!Number.isFinite(n)) return null;
        // Blaze Double: 0 = white, 1-7 = red, 8-14 = black
        if (n === 0) return 'W';
        if (n >= 1 && n <= 7) return 'R';
        if (n >= 8 && n <= 14) return 'B';
        return null;
    };
    const parseNumber = (value) => {
        const n = Math.floor(Number(value));
        return Number.isFinite(n) ? n : null;
    };
    const push = (c, n) => {
        if (!(c === 'R' || c === 'B' || c === 'W')) return;
        const num = (c === 'W') ? 0 : (Number.isFinite(Number(n)) ? Math.floor(Number(n)) : null);
        out.push({ c, n: num });
    };

    for (const item of entries) {
        // compat: algumas fontes podem enviar null para branco
        if (item == null) {
            push('W', 0);
            continue;
        }

        if (typeof item === 'string' || typeof item === 'number') {
            const parsed = String(item).trim().toLowerCase();
            if (parsed.includes('branc') || parsed === 'w' || parsed.includes('white')) {
                push('W', 0);
                continue;
            }
            if (parsed.includes('verm') || parsed === 'r' || parsed.includes('red')) {
                push('R', null);
                continue;
            }
            if (parsed.includes('pret') || parsed === 'b' || parsed.includes('black')) {
                push('B', null);
                continue;
            }
            const numeric = parseNumber(parsed);
            if (numeric != null) {
                const mapped = mapNumberToChar(numeric);
                if (mapped) push(mapped, numeric);
            }
            continue;
        }

        if (typeof item === 'object') {
            // Preferir nÃºmero, pois Ã© a fonte mais confiÃ¡vel (0..14)
            const numberValue = item.number ?? item.numero ?? item.slot ?? item.value ?? null;
            const numeric = parseNumber(numberValue);
            if (numeric != null) {
                const mapped = mapNumberToChar(numeric);
                if (mapped) {
                    push(mapped, numeric);
                    continue;
                }
            }

            const colorValue = item.color || item.result || item.Color || item.cor || null;
            if (colorValue != null) {
                const parsed = String(colorValue).trim().toLowerCase();
                if (parsed.includes('branc') || parsed === 'w' || parsed.includes('white')) {
                    push('W', 0);
                    continue;
                }
                if (parsed.includes('verm') || parsed === 'r' || parsed.includes('red')) {
                    push('R', null);
                    continue;
                }
                if (parsed.includes('pret') || parsed === 'b' || parsed.includes('black')) {
                    push('B', null);
                    continue;
                }
                const maybeNum = parseNumber(parsed);
                if (maybeNum != null) {
                    const mapped = mapNumberToChar(maybeNum);
                    if (mapped) push(mapped, maybeNum);
                }
            }
        }
    }

    return out;
}

function buildN0Windows(sequence, windowSize, stepSize = windowSize, lookaheadSpins = 1) {
    const windows = [];
    if (!Array.isArray(sequence) || sequence.length < windowSize + 1) return windows;
    const total = sequence.length;
    const step = Math.max(1, Math.floor(Number(stepSize) || windowSize));
    const lookahead = Math.max(1, Math.min(20, Math.floor(Number(lookaheadSpins) || 1)));
    const maxStart = total - (windowSize + lookahead); // precisa existir alvo em `end` (com lookahead)
    let k = 0;
    for (let start = 0; start <= maxStart; start += step) {
        const end = start + windowSize;
        const targetIndex = end;
        if (targetIndex + lookahead - 1 >= total) break;
        const targetSlice = sequence.slice(targetIndex, targetIndex + lookahead);
        const targetHasWhite = targetSlice.includes('W');
        windows.push({
            index: k,
            window: sequence.slice(start, end),
            // âœ… target = WHITE se sair em qualquer um dos prÃ³ximos `lookahead` giros (Entrada/G1/G2...).
            // Caso contrÃ¡rio, manter a cor do primeiro giro pÃ³s-janela (Ãºtil para logs).
            target: targetHasWhite ? 'W' : sequence[targetIndex],
            start,
            targetIndex,
            lookahead,
            target_has_white: targetHasWhite
        });
        k += 1;
    }
    return windows;
}

function createSeededRandomGenerator(seed) {
    let state = seed >>> 0;
    return function nextRandom() {
        state = Math.imul(state ^ state >>> 11, 0x45d9f3b);
        state ^= state << 7;
        state = Math.imul(state ^ state >>> 15, 0x45d9f3b);
        return ((state ^ state >>> 14) >>> 0) / 4294967296;
    };
}

function generateN0ConfigsLegacy(count, seed = N0_DEFAULTS.seed) {
    const configs = [];

    const addConfig = (cfg) => {
        if (configs.length < count) {
            configs.push(cfg);
        }
    };

    // Grade fixa
    [0.01, 0.02, 0.03, 0.05, 0.08, 0.1, 0.15, 0.2].forEach(thresh => {
        addConfig({ type: 'freq', thresh });
    });

    [2, 3, 4, 5].forEach(L => {
        [0.6, 0.7, 0.8, 0.9].forEach(next_threshold => {
            addConfig({ type: 'pattern', L, next_threshold });
        });
    });

    [1, 2].forEach(k => {
        [0.4, 0.5, 0.6, 0.7].forEach(thresh => {
            addConfig({ type: 'markov', k, thresh });
        });
    });

    [0.7, 0.8, 0.9].forEach(decay => {
        [0.05, 0.1, 0.15, 0.2].forEach(thresh => {
            addConfig({ type: 'recency', decay, thresh });
        });
    });

    [1, 2, 3].forEach(min_run => {
        addConfig({ type: 'lastrun', min_run });
    });

    if (configs.length >= count) {
        return configs.slice(0, count);
    }

    const random = createSeededRandomGenerator(seed);
    const typePool = ['freq', 'pattern', 'markov', 'recency', 'lastrun'];
    while (configs.length < count) {
        const type = typePool[Math.floor(random() * typePool.length)];
        if (type === 'freq') {
            const options = [0.01, 0.02, 0.03, 0.05, 0.08, 0.1, 0.12, 0.15, 0.2];
            addConfig({ type, thresh: options[Math.floor(random() * options.length)] });
        } else if (type === 'pattern') {
            const lengths = [2, 3, 4, 5];
            const thresholds = [0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9];
            addConfig({
                type,
                L: lengths[Math.floor(random() * lengths.length)],
                next_threshold: thresholds[Math.floor(random() * thresholds.length)]
            });
        } else if (type === 'markov') {
            const orders = [1, 2];
            const thresholds = [0.35, 0.4, 0.5, 0.6, 0.7];
            addConfig({
                type,
                k: orders[Math.floor(random() * orders.length)],
                thresh: thresholds[Math.floor(random() * thresholds.length)]
            });
        } else if (type === 'recency') {
            const decays = [0.6, 0.7, 0.8, 0.9];
            const thresholds = [0.03, 0.05, 0.08, 0.1, 0.12, 0.15, 0.2];
            addConfig({
                type,
                decay: decays[Math.floor(random() * decays.length)],
                thresh: thresholds[Math.floor(random() * thresholds.length)]
            });
        } else {
            const runs = [1, 2, 3, 4];
            addConfig({ type, min_run: runs[Math.floor(random() * runs.length)] });
        }
    }

    return configs.slice(0, count);
}

function applyN0AnalysisLegacy(cfg, window) {
    const cleanWindow = Array.isArray(window) ? window.filter(c => c === 'R' || c === 'B' || c === 'W') : [];
    if (cleanWindow.length === 0) {
        return { prediction: null, confidence: 0 };
    }

    switch (cfg.type) {
        case 'freq': {
            const total = cleanWindow.length;
            const whites = cleanWindow.filter(c => c === 'W').length;
            const pW = total > 0 ? whites / total : 0;
            return pW >= (cfg.thresh ?? 0.05)
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, pW)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, pW)) };
        }
        case 'pattern': {
            const L = Math.max(1, Number(cfg.L) || 3);
            const nextThreshold = cfg.next_threshold != null ? Number(cfg.next_threshold) : 0.6;
            if (cleanWindow.length < L + 1) return { prediction: null, confidence: 0 };
            const pattern = cleanWindow.slice(cleanWindow.length - L).join('');
            const followers = [];
            for (let i = 0; i + L < cleanWindow.length; i++) {
                const candidate = cleanWindow.slice(i, i + L).join('');
                if (candidate === pattern) {
                    followers.push(cleanWindow[i + L]);
                }
            }
            if (followers.length === 0) return { prediction: null, confidence: 0 };
            const whites = followers.filter(c => c === 'W').length;
            const pW = whites / followers.length;
            return pW >= nextThreshold
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, pW)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, pW)) };
        }
        case 'markov': {
            const order = Math.max(1, Number(cfg.k) || 1);
            const thresh = cfg.thresh != null ? Number(cfg.thresh) : 0.5;
            if (cleanWindow.length <= order) return { prediction: null, confidence: 0 };
            const transitions = new Map();
            for (let i = 0; i + order < cleanWindow.length; i++) {
                const key = cleanWindow.slice(i, i + order).join('');
                const next = cleanWindow[i + order];
                if (!transitions.has(key)) {
                    transitions.set(key, { R: 0, B: 0, W: 0 });
                }
                const entry = transitions.get(key);
                entry[next] = (entry[next] || 0) + 1;
            }
            const lastKey = cleanWindow.slice(cleanWindow.length - order).join('');
            if (!transitions.has(lastKey)) return { prediction: null, confidence: 0 };
            const counts = transitions.get(lastKey);
            const total = (counts.R || 0) + (counts.B || 0) + (counts.W || 0);
            if (total === 0) return { prediction: null, confidence: 0 };
            const pW = (counts.W || 0) / total;
            return pW >= thresh
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, pW)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, pW)) };
        }
        case 'recency': {
            const decay = cfg.decay != null ? Number(cfg.decay) : 0.9;
            const thresh = cfg.thresh != null ? Number(cfg.thresh) : 0.1;
            let weight = 1;
            let totalWeight = 0;
            let weightedWhite = 0;
            for (let i = cleanWindow.length - 1; i >= 0; i--) {
                const value = cleanWindow[i];
                totalWeight += weight;
                if (value === 'W') {
                    weightedWhite += weight;
                }
                weight *= decay;
            }
            const pW = totalWeight > 0 ? weightedWhite / totalWeight : 0;
            return pW >= thresh
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, pW)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, pW)) };
        }
        case 'lastrun': {
            const minRun = Math.max(1, Number(cfg.min_run) || 1);
            let run = 0;
            for (let i = cleanWindow.length - 1; i >= 0; i--) {
                if (cleanWindow[i] === 'W') {
                    run += 1;
                } else {
                    break;
                }
            }
            const confidence = cleanWindow.length > 0 ? run / cleanWindow.length : 0;
            return run >= minRun
                ? { prediction: 'W', confidence: Math.max(0, Math.min(1, confidence)) }
                : { prediction: null, confidence: Math.max(0, Math.min(1, confidence)) };
        }
        default:
            return { prediction: null, confidence: 0 };
    }
}

function hashStringToUnit(value) {
    if (value == null) return 0;
    const str = String(value);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
    }
    return Math.abs(hash % 1000) / 1000;
}

function createN0ConfigId(index) {
    return `N0CFG-${String(index + 1).padStart(4, '0')}`;
}

function describeN0Config(cfg) {
    if (!cfg || !cfg.family) return 'config invÃ¡lida';
    const params = cfg.params || {};
    const entries = Object.entries(params)
        .map(([key, value]) => `${key}=${Array.isArray(value) ? JSON.stringify(value) : value}`)
        .join(', ');
    return `${cfg.family}${entries ? ` (${entries})` : ''}`;
}

function encodeN0ConfigVector(cfg) {
    const vectorLength = N0_FAMILY_LIST.length + 15;
    const vector = new Array(vectorLength).fill(0);
    const familyIndex = Math.max(0, N0_FAMILY_LIST.indexOf(cfg.family));
    vector[familyIndex] = 1;
    const baseIndex = N0_FAMILY_LIST.length;
    const params = cfg.params || {};
    vector[baseIndex + 0] = clamp01(params.thresh);
    vector[baseIndex + 1] = clamp01(params.seg_thresh ?? params.thresh);
    vector[baseIndex + 2] = clamp01((params.segments ?? params.segment_count ?? 0) / 6);
    vector[baseIndex + 3] = clamp01(params.decay ?? 0);
    vector[baseIndex + 4] = clamp01((params.min_run ?? params.min_max_run ?? 0) / 15);
    vector[baseIndex + 5] = clamp01((params.min_run_count ?? params.min_occurrences ?? 0) / 12);
    vector[baseIndex + 6] = clamp01((params.order ?? params.k ?? params.L ?? 0) / 8);
    vector[baseIndex + 7] = clamp01(params.prob_thresh ?? params.next_thresh ?? 0);
    vector[baseIndex + 8] = clamp01(hashStringToUnit(params.pattern ?? params.pattern_code));
    vector[baseIndex + 9] = clamp01((params.sub_window ?? params.subW ?? 0) / 50);
    vector[baseIndex + 10] = clamp01(params.frac_thresh ?? params.seg_thresh ?? 0);
    vector[baseIndex + 11] = clamp01(params.delta_thresh ?? params.accel_thresh ?? params.min_switch_rate ?? 0);
    vector[baseIndex + 12] = clamp01((params.lag_k ?? params.lag ?? 0) / 20);
    vector[baseIndex + 13] = clamp01((params.sum_thresh ?? params.switch_count ?? 0) / 30);
    vector[baseIndex + 14] = clamp01((Array.isArray(params.parts) ? params.parts.length : params.component_count ?? 0) / 6);
    return vector;
}

function n0ConfigDistance(vectorA, vectorB) {
    let sum = 0;
    for (let i = 0; i < vectorA.length; i++) {
        const diff = vectorA[i] - vectorB[i];
        sum += diff * diff;
    }
    return Math.sqrt(sum);
}

function maybePersistN0ConfigLibrary(configs) {
    try {
        if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
            chrome.storage.local.set({ [N0_CONFIG_LIBRARY_KEY]: configs });
        }
    } catch (error) {
        console.debug('âš ï¸ [N0] Falha ao persistir biblioteca de configs:', error);
    }
}

function buildN0BaseConfigs() {
    const configs = [];
    const push = (family, params) => configs.push({ family, params });

    [0.06, 0.08, 0.1, 0.12, 0.15, 0.18, 0.2, 0.22, 0.25, 0.3].forEach(thresh => {
        push('freq_threshold', { thresh: Number(thresh.toFixed(3)) });
    });

    [3, 4, 5].forEach(segments => {
        [0.18, 0.22, 0.25, 0.28, 0.3, 0.35].forEach(seg_thresh => {
            push('freq_segmented', { segments, seg_thresh: Number(seg_thresh.toFixed(3)) });
        });
    });

    [0.6, 0.7, 0.8, 0.85, 0.9].forEach(decay => {
        // âšª whites na janela (W=100) giram perto de ~0.06-0.08. Thresholds altos demais geram "silÃªncio".
        [0.06, 0.07, 0.08, 0.09, 0.1, 0.11, 0.12, 0.14].forEach(thresh => {
            push('weighted_recency', { decay: Number(decay.toFixed(2)), thresh: Number(thresh.toFixed(3)) });
        });
    });

    [2, 3, 4, 5, 6, 7].forEach(min_run => {
        push('last_run', { min_run });
    });

    [
        { min_max_run: 3, min_run_count: 2 },
        { min_max_run: 4, min_run_count: 2 },
        { min_max_run: 4, min_run_count: 3 },
        { min_max_run: 5, min_run_count: 3 },
        { min_max_run: 6, min_run_count: 3 },
        { min_max_run: 6, min_run_count: 4 },
        { min_max_run: 7, min_run_count: 4 }
    ].forEach(params => push('run_stats', params));

    [1, 2, 3].forEach(order => {
        // âšª prob de WHITE em atÃ© N giros (alvo) costuma ser baixa-moderada; 0.45+ Ã© rigor demais.
        [0.22, 0.26, 0.3, 0.34, 0.38, 0.42, 0.46].forEach(prob_thresh => {
            push('markov', { order, prob_thresh: Number(prob_thresh.toFixed(2)) });
        });
    });

    const patternLibrary = ['RR', 'RB', 'BR', 'BB', 'RRR', 'RBR', 'BRB', 'BBB', 'RBRB', 'BRBR'];
    patternLibrary.forEach(pattern => {
        // âšª thresholds muito altos fazem o n-gram quase nunca disparar
        [0.22, 0.26, 0.3, 0.34, 0.38, 0.42, 0.46].forEach(next_thresh => {
            push('n_gram_pattern', { pattern, next_thresh: Number(next_thresh.toFixed(2)) });
        });
    });

    // âœ… Tail n-gram: condicionado ao contexto atual (tail) e alinhado ao horizonte de lookahead.
    [2, 3, 4, 5].forEach(L => {
        // âšª prob de WHITE em atÃ© N giros raramente chega em 0.52+; baixar para nÃ£o "matar" o observador
        [0.22, 0.26, 0.3, 0.34, 0.38, 0.42, 0.46].forEach(next_thresh => {
            [2, 3, 4].forEach(min_occurrences => {
                push('tail_ngram', {
                    L,
                    next_thresh: Number(next_thresh.toFixed(2)),
                    min_occurrences
                });
            });
        });
    });

    // âœ… Observadores "inteligentes" do branco (puxadores / gap / quebra) â€” guiados pelo histÃ³rico.
    // âšª Esses observadores estimam P(WHITE no horizonte). Em G2 (3 giros), baseline â‰ˆ 0.18.
    // Se comeÃ§armos em 0.26+ ele fica "mudo" por horas.
    [0.18, 0.2, 0.22, 0.24, 0.26, 0.28, 0.3, 0.32].forEach(prob_thresh => {
        [4, 6, 8, 10, 12].forEach(min_occurrences => {
            push('number_puller', { prob_thresh: Number(prob_thresh.toFixed(2)), min_occurrences });
            push('gap_hazard', { prob_thresh: Number(prob_thresh.toFixed(2)), min_occurrences });
        });
    });
    [3, 4, 5, 6, 7, 8, 9].forEach(min_run => {
        [0.18, 0.2, 0.22, 0.24, 0.26, 0.28, 0.3].forEach(prob_thresh => {
            [4, 6, 8, 10].forEach(min_occurrences => {
                push('break_after_streak', {
                    min_run,
                    prob_thresh: Number(prob_thresh.toFixed(2)),
                    min_occurrences
                });
            });
        });
    });

    [8, 10, 12, 15, 20, 25].forEach(sub_window => {
        [0.35, 0.4, 0.45, 0.5, 0.55, 0.6].forEach(frac_thresh => {
            push('burst_detector', { sub_window, frac_thresh: Number(frac_thresh.toFixed(2)) });
        });
    });

    [0.08, 0.1, 0.12, 0.15, 0.18].forEach(delta_thresh => {
        [1.0, 1.1, 1.2].forEach(max_entropy => {
            push('entropy_change', { delta_thresh: Number(delta_thresh.toFixed(2)), max_entropy });
        });
    });

    [2, 3, 4, 5, 6, 7].forEach(lag_k => {
        [3, 4, 5, 6, 7, 8, 9, 10, 12].forEach(sum_thresh => {
            push('lagged_sum', { lag_k, sum_thresh });
        });
    });

    [3, 4, 5, 6].forEach(segments => {
        [0.06, 0.08, 0.1, 0.12, 0.15, 0.18].forEach(accel_thresh => {
            push('trend_accel', { segments, accel_thresh: Number(accel_thresh.toFixed(3)), min_final_pw: 0.25 });
        });
    });

    [0.65, 0.7, 0.75, 0.8, 0.85, 0.9].forEach(min_switch_rate => {
        [6, 8, 10, 12, 14, 16, 18].forEach(min_total_switches => {
            push('switch_pattern', { min_switch_rate: Number(min_switch_rate.toFixed(2)), min_total_switches });
        });
    });

    const compoundParts = [
        [
            { family: 'freq_threshold', params: { thresh: 0.16 } },
            { family: 'last_run', params: { min_run: 3 } }
        ],
        [
            { family: 'weighted_recency', params: { decay: 0.85, thresh: 0.2 } },
            { family: 'trend_accel', params: { segments: 4, accel_thresh: 0.1, min_final_pw: 0.25 } }
        ],
        [
            { family: 'freq_segmented', params: { segments: 4, seg_thresh: 0.25 } },
            { family: 'lagged_sum', params: { lag_k: 3, sum_thresh: 6 } }
        ]
    ];

    compoundParts.forEach((parts, idx) => {
        push('compound_and', { parts, component_count: parts.length, id: `AND_BASE_${idx + 1}` });
        push('compound_or', { parts, component_count: parts.length, min_hits: 1, id: `OR_BASE_${idx + 1}` });
    });

    return configs;
}

function sampleRandomN0Config(rng, forcedFamily) {
    const family = forcedFamily || N0_FAMILY_LIST[Math.floor(rng() * N0_FAMILY_LIST.length)];
    const rFloat = () => rng();
    const randBetween = (min, max, decimals = 3) => {
        const value = min + (max - min) * rFloat();
        const factor = Math.pow(10, decimals);
        return Math.round(value * factor) / factor;
    };
    const randInt = (min, max) => Math.floor(min + (max - min + 1) * rFloat());

    switch (family) {
        case 'freq_threshold':
            return { family, params: { thresh: randBetween(0.04, 0.22) } };
        case 'freq_segmented':
            return {
                family,
                params: {
                    segments: randInt(3, 6),
                    seg_thresh: randBetween(0.18, 0.35)
                }
            };
        case 'weighted_recency':
            return {
                family,
                params: {
                    decay: randBetween(0.6, 0.95, 2),
                    // âšª thresholds altos viram "silÃªncio" (pW janela ~0.06-0.08)
                    thresh: randBetween(0.06, 0.14)
                }
            };
        case 'last_run':
            return {
                family,
                params: {
                    min_run: randInt(2, 8)
                }
            };
        case 'run_stats':
            return {
                family,
                params: {
                    min_max_run: randInt(3, 9),
                    min_run_count: randInt(2, 5)
                }
            };
        case 'markov':
            return {
                family,
                params: {
                    order: randInt(1, 3),
                    prob_thresh: randBetween(0.18, 0.55, 2)
                }
            };
        case 'n_gram_pattern': {
            const patterns = ['RR', 'RB', 'BB', 'BR', 'RRR', 'RBR', 'BRB', 'BBR', 'RBB', 'RRBR', 'BRRB'];
            const pattern = patterns[Math.floor(rng() * patterns.length)];
            return {
                family,
                params: {
                    pattern,
                    next_thresh: randBetween(0.18, 0.55, 2)
                }
            };
        }
        case 'tail_ngram':
            return {
                family,
                params: {
                    L: randInt(2, 6),
                    next_thresh: randBetween(0.18, 0.55, 2),
                    min_occurrences: randInt(2, 6)
                }
            };
        case 'gap_hazard':
            return {
                family,
                params: {
                    prob_thresh: randBetween(0.16, 0.36, 2),
                    min_occurrences: randInt(4, 16)
                }
            };
        case 'number_puller':
            return {
                family,
                params: {
                    prob_thresh: randBetween(0.16, 0.36, 2),
                    min_occurrences: randInt(4, 18)
                }
            };
        case 'break_after_streak':
            return {
                family,
                params: {
                    min_run: randInt(3, 10),
                    prob_thresh: randBetween(0.16, 0.36, 2),
                    min_occurrences: randInt(4, 14)
                }
            };
        case 'burst_detector':
            return {
                family,
                params: {
                    sub_window: randInt(6, 30),
                    frac_thresh: randBetween(0.3, 0.7, 2)
                }
            };
        case 'entropy_change':
            return {
                family,
                params: {
                    delta_thresh: randBetween(0.08, 0.2, 3),
                    max_entropy: randBetween(0.9, 1.3, 3)
                }
            };
        case 'lagged_sum':
            return {
                family,
                params: {
                    lag_k: randInt(2, 8),
                    sum_thresh: randInt(4, 12)
                }
            };
        case 'trend_accel':
            return {
                family,
                params: {
                    segments: randInt(3, 6),
                    accel_thresh: randBetween(0.05, 0.2, 3),
                    min_final_pw: randBetween(0.2, 0.35, 3)
                }
            };
        case 'switch_pattern':
            return {
                family,
                params: {
                    min_switch_rate: randBetween(0.6, 0.92, 2),
                    min_total_switches: randInt(6, 20)
                }
            };
        case 'compound_and':
        case 'compound_or': {
            const partCount = randInt(2, 3);
            const partFamilies = ['freq_threshold', 'weighted_recency', 'last_run', 'run_stats', 'lagged_sum', 'trend_accel'];
            const parts = [];
            for (let i = 0; i < partCount; i++) {
                const subFamily = partFamilies[Math.floor(rng() * partFamilies.length)];
                parts.push(sampleRandomN0Config(rng, subFamily));
            }
            const params = {
                parts,
                component_count: parts.length,
                id: `${family.toUpperCase()}_${hashStringToUnit(JSON.stringify(parts)).toString(36).slice(2, 8)}`
            };
            if (family === 'compound_or') {
                params.min_hits = Math.max(1, Math.min(parts.length, Math.round(parts.length * randBetween(0.4, 0.7, 2))));
            }
            return { family, params };
        }
        default:
            return null;
    }
}

function tryAddN0Config(candidate, accepted, acceptedVectors, diversityThreshold) {
    if (!candidate || !candidate.family) return false;
    const vector = encodeN0ConfigVector(candidate);
    for (const existingVector of acceptedVectors) {
        if (n0ConfigDistance(vector, existingVector) < diversityThreshold) {
            return false;
        }
    }
    accepted.push(candidate);
    acceptedVectors.push(vector);
    return true;
}

function generateN0Configs(count, seed = N0_DEFAULTS.seed) {
    if (n0ConfigLibraryCache && n0ConfigLibraryCache.length >= count && n0ConfigLibrarySeed === seed) {
        return n0ConfigLibraryCache.slice(0, count);
    }

    const rng = createSeededRandomGenerator(seed);
    const baseConfigs = buildN0BaseConfigs();
    const accepted = [];
    const acceptedVectors = [];
    const familyCounts = {};
    let diversityThreshold = N0_DIVERSITY_MIN_DISTANCE_BASE;

    const pushWithDiversity = (cfg, allowRelax = false) => {
        if (!cfg) return false;
        const success = tryAddN0Config(cfg, accepted, acceptedVectors, diversityThreshold);
        if (success) {
            familyCounts[cfg.family] = (familyCounts[cfg.family] || 0) + 1;
        } else if (allowRelax && diversityThreshold > 0.08) {
            const relaxedSuccess = tryAddN0Config(cfg, accepted, acceptedVectors, diversityThreshold * 0.9);
            if (relaxedSuccess) {
                familyCounts[cfg.family] = (familyCounts[cfg.family] || 0) + 1;
            }
            return relaxedSuccess;
        }
        return success;
    };

    baseConfigs.forEach(cfg => {
        if (accepted.length < count) {
            pushWithDiversity(cfg, true);
        }
    });

    let attempts = 0;
    const maxAttempts = count * 50;
    while (accepted.length < count && attempts < maxAttempts) {
        const candidateFamily = N0_FAMILY_LIST[Math.floor(rng() * N0_FAMILY_LIST.length)];
        const candidate = sampleRandomN0Config(rng, candidateFamily);
        const added = pushWithDiversity(candidate, true);
        if (!added && attempts % N0_FAMILY_LIST.length === 0 && diversityThreshold > 0.08) {
            diversityThreshold *= 0.97;
        }
        attempts++;
    }

    N0_FAMILY_LIST.forEach(family => {
        while ((familyCounts[family] || 0) < N0_FAMILY_MIN_PER_TYPE && accepted.length < count) {
            const candidate = sampleRandomN0Config(rng, family);
            if (!pushWithDiversity(candidate, true)) {
                break;
            }
        }
    });

    diversityThreshold = Math.max(0.05, diversityThreshold);
    while (accepted.length < count) {
        const candidate = sampleRandomN0Config(rng);
        if (!candidate) continue;
        if (!pushWithDiversity(candidate, true)) {
            if (diversityThreshold > 0.05) {
                diversityThreshold *= 0.95;
            } else {
                accepted.push(candidate);
                acceptedVectors.push(encodeN0ConfigVector(candidate));
                familyCounts[candidate.family] = (familyCounts[candidate.family] || 0) + 1;
            }
        }
    }

    const trimmed = accepted.slice(0, count).map((cfg, index) => ({
        id: createN0ConfigId(index),
        family: cfg.family,
        params: cfg.params || {},
        description: describeN0Config(cfg)
    }));

    n0ConfigLibraryCache = trimmed;
    n0ConfigLibrarySeed = seed;
    maybePersistN0ConfigLibrary(trimmed);

    return trimmed;
}

function computeWindowStats(windowChars) {
    const total = windowChars.length;
    let whites = 0;
    let reds = 0;
    let blacks = 0;
    let currentWhiteRun = 0;
    let maxWhiteRun = 0;
    let whiteRunCount = 0;
    let tailWhiteRun = 0;
    let consecutiveSwitches = 0;
    let nonWhiteTransitions = 0;
    let lastNonWhite = null;
    const whitePrefix = new Array(total + 1).fill(0);
    let entropyFirstHalf = 0;
    let entropySecondHalf = 0;

    for (let i = 0; i < total; i++) {
        const color = windowChars[i];
        whitePrefix[i + 1] = whitePrefix[i] + (color === 'W' ? 1 : 0);
        if (color === 'W') {
            whites += 1;
            currentWhiteRun += 1;
        } else {
            if (currentWhiteRun > 0) {
                whiteRunCount += 1;
                if (currentWhiteRun > maxWhiteRun) {
                    maxWhiteRun = currentWhiteRun;
                }
                currentWhiteRun = 0;
            }
            if (color === 'R') reds += 1;
            if (color === 'B') blacks += 1;
            if (color === 'R' || color === 'B') {
                if (lastNonWhite && lastNonWhite !== color) {
                    consecutiveSwitches += 1;
                }
                if (lastNonWhite) {
                    nonWhiteTransitions += 1;
                }
                lastNonWhite = color;
            }
        }
    }

    if (currentWhiteRun > 0) {
        whiteRunCount += 1;
        if (currentWhiteRun > maxWhiteRun) {
            maxWhiteRun = currentWhiteRun;
        }
    }

    tailWhiteRun = 0;
    for (let i = total - 1; i >= 0; i--) {
        if (windowChars[i] === 'W') tailWhiteRun += 1;
        else if (windowChars[i] === 'R' || windowChars[i] === 'B') break;
    }

    const half = Math.max(1, Math.floor(total / 2));
    const firstHalfCounts = { W: 0, R: 0, B: 0 };
    const secondHalfCounts = { W: 0, R: 0, B: 0 };
    for (let i = 0; i < total; i++) {
        const color = windowChars[i];
        if (i < half) firstHalfCounts[color] = (firstHalfCounts[color] || 0) + 1;
        else secondHalfCounts[color] = (secondHalfCounts[color] || 0) + 1;
    }

    const entropy = (counts) => {
        const sum = Object.values(counts).reduce((acc, val) => acc + val, 0);
        if (sum === 0) return 0;
        let value = 0;
        Object.values(counts).forEach(count => {
            if (count <= 0) return;
            const p = count / sum;
            value -= p * Math.log2(p);
        });
        return value;
    };

    entropyFirstHalf = entropy(firstHalfCounts);
    entropySecondHalf = entropy(secondHalfCounts);

    return {
        total,
        whites,
        reds,
        blacks,
        pW: total > 0 ? whites / total : 0,
        pR: total > 0 ? reds / total : 0,
        pB: total > 0 ? blacks / total : 0,
        maxWhiteRun,
        whiteRunCount,
        tailWhiteRun,
        switches: consecutiveSwitches,
        nonWhiteTransitions,
        whitePrefix,
        entropyFirstHalf,
        entropySecondHalf,
        segmentCache: new Map(),
        weightedCache: new Map()
    };
}

function getSegmentFractions(stats, segments, windowChars) {
    if (stats.segmentCache.has(segments)) {
        return stats.segmentCache.get(segments);
    }
    const fractions = [];
    const len = stats.total;
    const segSize = Math.max(1, Math.floor(len / segments));
    for (let s = 0; s < segments; s++) {
        const start = s * segSize;
        const end = s === segments - 1 ? len : Math.min(len, start + segSize);
        if (start >= len) {
            fractions.push(0);
            continue;
        }
        let whites = 0;
        for (let i = start; i < end; i++) {
            if (windowChars[i] === 'W') whites += 1;
        }
        fractions.push((end - start) > 0 ? whites / (end - start) : 0);
    }
    stats.segmentCache.set(segments, fractions);
    return fractions;
}

function getWeightedWhiteness(stats, windowChars, decay) {
    const key = `decay_${decay}`;
    if (stats.weightedCache.has(key)) {
        return stats.weightedCache.get(key);
    }
    let weightedWhites = 0;
    let totalWeight = 0;
    let currentWeight = 1;
    for (let i = windowChars.length - 1; i >= 0; i--) {
        const color = windowChars[i];
        if (color === 'W') {
            weightedWhites += currentWeight;
        }
        totalWeight += currentWeight;
        currentWeight *= decay;
    }
    const result = totalWeight > 0 ? weightedWhites / totalWeight : 0;
    stats.weightedCache.set(key, result);
    return result;
}

function getTailNonWhiteNumberFromWindow(windowChars, windowNumbers) {
    try {
        if (!Array.isArray(windowChars) || !Array.isArray(windowNumbers)) return null;
        for (let i = windowChars.length - 1; i >= 0; i--) {
            const c = windowChars[i];
            if (!(c === 'R' || c === 'B')) continue;
            const n = windowNumbers[i];
            const num = Number.isFinite(Number(n)) ? Math.floor(Number(n)) : null;
            // puxadores: 1..14 (0 = branco)
            if (num != null && num > 0 && num <= 14) return num;
        }
        return null;
    } catch (_) {
        return null;
    }
}

function computeGapSinceLastWhite(windowChars) {
    try {
        if (!Array.isArray(windowChars) || windowChars.length === 0) return 0;
        let gap = 0;
        for (let i = windowChars.length - 1; i >= 0; i--) {
            const c = windowChars[i];
            if (c === 'W') return gap;
            gap += 1;
        }
        return gap;
    } catch (_) {
        return 0;
    }
}

function bucketGapForN0(gapValue) {
    const g = Math.max(0, Math.floor(Number(gapValue) || 0));
    if (g <= 2) return '0-2';
    if (g <= 5) return '3-5';
    if (g <= 9) return '6-9';
    if (g <= 14) return '10-14';
    if (g <= 19) return '15-19';
    return '20+';
}

function bucketRunLenForN0(lenValue) {
    const n = Math.max(0, Math.floor(Number(lenValue) || 0));
    if (n >= 10) return '10+';
    if (n >= 7) return '7-9';
    if (n >= 5) return '5-6';
    if (n >= 3) return '3-4';
    return '0-2';
}

function computeBreakAfterStreak(windowChars) {
    try {
        const w = Array.isArray(windowChars) ? windowChars : [];
        let last = null;
        let lastIdx = -1;
        for (let i = w.length - 1; i >= 0; i--) {
            if (w[i] === 'R' || w[i] === 'B') { last = w[i]; lastIdx = i; break; }
        }
        if (!last) return { broke: false, from: null, to: null, prevRunLen: 0 };
        let prev = null;
        let prevIdx = -1;
        for (let i = lastIdx - 1; i >= 0; i--) {
            if (w[i] === 'R' || w[i] === 'B') { prev = w[i]; prevIdx = i; break; }
        }
        if (!prev || prev === last) return { broke: false, from: prev, to: last, prevRunLen: 0 };
        // contar streak anterior ignorando brancos (espÃ©cie de "streak de cor" real)
        let runLen = 0;
        for (let i = prevIdx; i >= 0; i--) {
            const c = w[i];
            if (c === 'W') continue;
            if (c === prev) runLen += 1;
            else break;
        }
        return { broke: true, from: prev, to: last, prevRunLen: runLen };
    } catch (_) {
        return { broke: false, from: null, to: null, prevRunLen: 0 };
    }
}

function buildN0WindowContext(windows, options = {}) {
    const winList = Array.isArray(windows) ? windows : [];
    const loo = options && Object.prototype.hasOwnProperty.call(options, 'loo') ? !!options.loo : true;
    const stats = winList.map(entry => computeWindowStats(entry.window));
    const whitenessSeries = stats.map(s => s.pW);
    const whiteCounts = stats.map(s => s.whites);

    // Mapas de contexto (aprendizado leve) â€” usados por famÃ­lias do N0 que observam "como o branco saiu".
    const numberStats = {}; // { [num]: { occ, white } }
    const gapStats = {};    // { [bucket]: { occ, white } }
    const breakStats = {};  // { [key]: { occ, white } }
    let labeledTotal = 0;
    let labeledWhite = 0;

    const bump = (map, key, isWhite) => {
        if (!key) return;
        if (!map[key]) map[key] = { occ: 0, white: 0 };
        map[key].occ += 1;
        if (isWhite) map[key].white += 1;
    };

    winList.forEach((entry) => {
        if (!entry || typeof entry !== 'object') return;
        const hasLabel = entry.target === 'W' || entry.target === 'R' || entry.target === 'B' || entry.target === 'N';
        if (!hasLabel) return; // live window (target=null) nÃ£o entra no aprendizado

        const isWhite = entry.target === 'W';
        labeledTotal += 1;
        if (isWhite) labeledWhite += 1;

        const wChars = Array.isArray(entry.window) ? entry.window : [];
        const wNums = Array.isArray(entry.window_numbers) ? entry.window_numbers : null;

        const tailNum = getTailNonWhiteNumberFromWindow(wChars, wNums);
        if (tailNum != null) bump(numberStats, String(tailNum), isWhite);

        const gap = computeGapSinceLastWhite(wChars);
        bump(gapStats, bucketGapForN0(gap), isWhite);

        const br = computeBreakAfterStreak(wChars);
        if (br && br.broke) {
            const bucket = bucketRunLenForN0(br.prevRunLen);
            const key = `prev=${bucket}|from=${br.from}|to=${br.to}`;
            bump(breakStats, key, isWhite);
            // tambÃ©m guardar uma versÃ£o mais geral (sem direÃ§Ã£o)
            bump(breakStats, `prev=${bucket}`, isWhite);
        }
    });

    const baseWhiteRate = labeledTotal > 0 ? (labeledWhite / labeledTotal) : 0;

    return {
        stats,
        whitenessSeries,
        whiteCounts,
        loo,
        base_white_rate: clamp01(baseWhiteRate),
        number_stats: numberStats,
        gap_stats: gapStats,
        break_stats: breakStats
    };
}

function applyN0Config(cfg, windowChars, idxWindow, windows, context, depth = 0) {
    if (!cfg || !cfg.family || !Array.isArray(windowChars) || windowChars.length === 0) {
        return { prediction: null, confidence: 0 };
    }
    if (depth > 3) {
        return { prediction: null, confidence: 0 };
    }
    const params = cfg.params || {};
    const stats = context.stats[idxWindow];
    const meta = (Array.isArray(windows) && windows[idxWindow]) ? windows[idxWindow] : null;
    const lookahead = Math.max(1, Math.min(6, Math.floor(Number(meta && meta.lookahead) || 1)));
    const leaveOneOut = !!(context && context.loo);

    switch (cfg.family) {
        case 'freq_threshold': {
            const confidence = stats.pW;
            return {
                prediction: confidence >= (params.thresh ?? 0.2) ? 'W' : null,
                confidence
            };
        }
        case 'freq_segmented': {
            const segments = Math.max(2, Math.min(8, Number(params.segments) || 4));
            const fractions = getSegmentFractions(stats, segments, windowChars);
            const maxSegment = Math.max(...fractions);
            return {
                prediction: maxSegment >= (params.seg_thresh ?? 0.25) ? 'W' : null,
                confidence: clamp01(maxSegment)
            };
        }
        case 'weighted_recency': {
            const decay = clamp01(params.decay ?? 0.85);
            const thresh = params.thresh ?? 0.22;
            const confidence = getWeightedWhiteness(stats, windowChars, Math.max(0.4, Math.min(0.98, decay)));
            return {
                prediction: confidence >= thresh ? 'W' : null,
                confidence: clamp01(confidence)
            };
        }
        case 'last_run': {
            const minRun = Math.max(1, Number(params.min_run) || 3);
            const tail = stats.tailWhiteRun;
            const confidence = clamp01(tail / Math.max(1, minRun));
            return {
                prediction: tail >= minRun ? 'W' : null,
                confidence
            };
        }
        case 'run_stats': {
            const minMaxRun = Math.max(2, Number(params.min_max_run) || 4);
            const minRunCount = Math.max(1, Number(params.min_run_count) || 2);
            const condition = stats.maxWhiteRun >= minMaxRun && stats.whiteRunCount >= minRunCount;
            const confidence = clamp01(
                ((stats.maxWhiteRun / Math.max(1, minMaxRun)) + (stats.whiteRunCount / Math.max(1, minRunCount))) / 2
            );
            return {
                prediction: condition ? 'W' : null,
                confidence
            };
        }
        case 'markov': {
            const order = Math.max(1, Math.min(3, Number(params.order) || 1));
            const probThresh = clamp01(params.prob_thresh ?? 0.55);
            const transitions = {};
            // âœ… Para N0, considerar WHITE em atÃ© `lookahead` giros apÃ³s o estado, nÃ£o sÃ³ no prÃ³ximo giro.
            for (let i = 0; i + order + lookahead - 1 < windowChars.length; i++) {
                const key = windowChars.slice(i, i + order).join('');
                const future = windowChars.slice(i + order, i + order + lookahead);
                const hasWhite = future.includes('W');
                if (!transitions[key]) transitions[key] = { W: 0, N: 0 };
                if (hasWhite) transitions[key].W += 1;
                else transitions[key].N += 1;
            }
            const lastKey = windowChars.slice(-order).join('');
            const statsKey = transitions[lastKey];
            if (!statsKey) {
                return { prediction: null, confidence: 0 };
            }
            const total = statsKey.W + statsKey.N;
            const confidence = total > 0 ? statsKey.W / total : 0;
            return {
                prediction: confidence >= probThresh ? 'W' : null,
                confidence: clamp01(confidence)
            };
        }
        case 'n_gram_pattern': {
            const pattern = String(params.pattern || '').replace(/[^R BW]/g, '').replace(/\s+/g, '');
            const nextThresh = clamp01(params.next_thresh ?? 0.6);
            const L = pattern.length;
            if (!pattern || L < 2 || windowChars.length <= L) {
                return { prediction: null, confidence: 0 };
            }
            // âœ… IMPORTANTÃSSIMO: sÃ³ faz sentido se o padrÃ£o for o CONTEXTO ATUAL (tail).
            // Antes, o N0 "via" o padrÃ£o em qualquer lugar da janela e chutava WHITE â€” isso gera falso positivo.
            const tail = windowChars.slice(-L).join('');
            if (tail !== pattern) {
                return { prediction: null, confidence: 0 };
            }
            const minOcc = Math.max(1, Math.min(20, Math.floor(Number(params.min_occurrences) || 2)));
            let occurrences = 0;
            let whiteFollowers = 0; // WHITE em atÃ© `lookahead` giros apÃ³s o padrÃ£o
            for (let i = 0; i + L + lookahead - 1 < windowChars.length; i++) {
                const candidate = windowChars.slice(i, i + L).join('');
                if (candidate === pattern) {
                    occurrences += 1;
                    const future = windowChars.slice(i + L, i + L + lookahead);
                    if (future.includes('W')) {
                        whiteFollowers += 1;
                    }
                }
            }
            if (occurrences === 0) {
                return { prediction: null, confidence: 0 };
            }
            // Laplace smoothing (evita 100% com 1 ocorrÃªncia)
            const alpha = 1;
            const confidence = (whiteFollowers + alpha) / (occurrences + 2 * alpha);
            return {
                prediction: (occurrences >= minOcc && confidence >= nextThresh) ? 'W' : null,
                confidence: clamp01(confidence)
            };
        }
        case 'tail_ngram': {
            const L = Math.max(2, Math.min(10, Math.floor(Number(params.L) || 3)));
            const nextThresh = clamp01(params.next_thresh ?? 0.6);
            const minOcc = Math.max(1, Math.min(25, Math.floor(Number(params.min_occurrences) || 3)));
            if (windowChars.length <= L) {
                return { prediction: null, confidence: 0 };
            }
            const tailPattern = windowChars.slice(-L).join('');
            if (!tailPattern) {
                return { prediction: null, confidence: 0 };
            }
            let occurrences = 0;
            let whiteFollowers = 0;
            for (let i = 0; i + L + lookahead - 1 < windowChars.length; i++) {
                const candidate = windowChars.slice(i, i + L).join('');
                if (candidate === tailPattern) {
                    occurrences += 1;
                    const future = windowChars.slice(i + L, i + L + lookahead);
                    if (future.includes('W')) {
                        whiteFollowers += 1;
                    }
                }
            }
            if (occurrences === 0) {
                return { prediction: null, confidence: 0 };
            }
            const alpha = 1;
            const confidence = (whiteFollowers + alpha) / (occurrences + 2 * alpha);
            return {
                prediction: (occurrences >= minOcc && confidence >= nextThresh) ? 'W' : null,
                confidence: clamp01(confidence)
            };
        }
        case 'number_puller': {
            const probThresh = clamp01(params.prob_thresh ?? 0.3);
            const minOcc = Math.max(3, Math.min(300, Math.floor(Number(params.min_occurrences) || 10)));
            const wNums = meta && Array.isArray(meta.window_numbers) ? meta.window_numbers : null;
            const tailNum = getTailNonWhiteNumberFromWindow(windowChars, wNums);
            if (tailNum == null) return { prediction: null, confidence: 0 };
            const key = String(tailNum);
            const rowRaw = context && context.number_stats ? context.number_stats[key] : null;
            if (!rowRaw) return { prediction: null, confidence: 0 };
            let occ = Math.max(0, Math.floor(Number(rowRaw.occ) || 0));
            let whites = Math.max(0, Math.floor(Number(rowRaw.white) || 0));
            if (leaveOneOut && meta && (meta.target === 'W' || meta.target === 'R' || meta.target === 'B' || meta.target === 'N')) {
                // excluir a prÃ³pria janela (evita vazamento de label no treino)
                occ = Math.max(0, occ - 1);
                if (meta.target === 'W') {
                    whites = Math.max(0, whites - 1);
                }
            }
            if (occ <= 0) return { prediction: null, confidence: 0 };
            const alpha = 1;
            const p = (whites + alpha) / (occ + 2 * alpha);
            return {
                prediction: (occ >= minOcc && p >= probThresh) ? 'W' : null,
                confidence: clamp01(p)
            };
        }
        case 'gap_hazard': {
            const probThresh = clamp01(params.prob_thresh ?? 0.3);
            const minOcc = Math.max(3, Math.min(300, Math.floor(Number(params.min_occurrences) || 10)));
            const gap = computeGapSinceLastWhite(windowChars);
            const key = bucketGapForN0(gap);
            const rowRaw = context && context.gap_stats ? context.gap_stats[key] : null;
            if (!rowRaw) return { prediction: null, confidence: 0 };
            let occ = Math.max(0, Math.floor(Number(rowRaw.occ) || 0));
            let whites = Math.max(0, Math.floor(Number(rowRaw.white) || 0));
            if (leaveOneOut && meta && (meta.target === 'W' || meta.target === 'R' || meta.target === 'B' || meta.target === 'N')) {
                occ = Math.max(0, occ - 1);
                if (meta.target === 'W') {
                    whites = Math.max(0, whites - 1);
                }
            }
            if (occ <= 0) return { prediction: null, confidence: 0 };
            const alpha = 1;
            const p = (whites + alpha) / (occ + 2 * alpha);
            return {
                prediction: (occ >= minOcc && p >= probThresh) ? 'W' : null,
                confidence: clamp01(p)
            };
        }
        case 'break_after_streak': {
            const minRun = Math.max(2, Math.min(30, Math.floor(Number(params.min_run) || 5)));
            const probThresh = clamp01(params.prob_thresh ?? 0.3);
            const minOcc = Math.max(3, Math.min(300, Math.floor(Number(params.min_occurrences) || 8)));
            const br = computeBreakAfterStreak(windowChars);
            if (!br || !br.broke) return { prediction: null, confidence: 0 };
            if ((br.prevRunLen || 0) < minRun) return { prediction: null, confidence: 0 };
            const bucket = bucketRunLenForN0(br.prevRunLen || 0);
            const dirKey = `prev=${bucket}|from=${br.from}|to=${br.to}`;
            const genKey = `prev=${bucket}`;
            const map = context && context.break_stats ? context.break_stats : null;
            if (!map) return { prediction: null, confidence: 0 };

            const pickRow = (key) => {
                const row = map[key];
                if (!row) return null;
                return {
                    occ: Math.max(0, Math.floor(Number(row.occ) || 0)),
                    white: Math.max(0, Math.floor(Number(row.white) || 0)),
                    key
                };
            };
            let row = pickRow(dirKey);
            const rowGen = pickRow(genKey);
            if (!row && rowGen) row = rowGen;
            // se direÃ§Ã£o tem pouca amostra, cair para o geral
            if (row && rowGen && row.key === dirKey && row.occ < Math.max(minOcc, 8) && rowGen.occ >= row.occ) {
                row = rowGen;
            }
            if (!row) return { prediction: null, confidence: 0 };

            let occ = row.occ;
            let whites = row.white;
            if (leaveOneOut && meta && (meta.target === 'W' || meta.target === 'R' || meta.target === 'B' || meta.target === 'N')) {
                // excluir a prÃ³pria janela se ela contribui para esta chave
                const curKey = row.key === dirKey ? dirKey : genKey;
                // A janela atual sempre cairÃ¡ na mesma chave escolhida (por construÃ§Ã£o)
                occ = Math.max(0, occ - 1);
                if (meta.target === 'W') whites = Math.max(0, whites - 1);
                // Evitar usar curKey apenas para clareza (sem efeito funcional)
                void curKey;
            }
            if (occ <= 0) return { prediction: null, confidence: 0 };
            const alpha = 1;
            const p = (whites + alpha) / (occ + 2 * alpha);
            return {
                prediction: (occ >= minOcc && p >= probThresh) ? 'W' : null,
                confidence: clamp01(p)
            };
        }
        case 'burst_detector': {
            const subWindow = Math.max(3, Math.min(windowChars.length, Number(params.sub_window) || 12));
            const fracThresh = clamp01(params.frac_thresh ?? 0.45);
            let maxFraction = 0;
            for (let start = 0; start + subWindow <= windowChars.length; start++) {
                const whitesInSubWindow = stats.whitePrefix[start + subWindow] - stats.whitePrefix[start];
                const fraction = whitesInSubWindow / subWindow;
                if (fraction > maxFraction) {
                    maxFraction = fraction;
                }
            }
            return {
                prediction: maxFraction >= fracThresh ? 'W' : null,
                confidence: clamp01(maxFraction)
            };
        }
        case 'entropy_change': {
            const deltaThresh = params.delta_thresh ?? 0.1;
            const maxEntropy = params.max_entropy ?? 1.2;
            const delta = stats.entropyFirstHalf - stats.entropySecondHalf;
            const confidence = clamp01(stats.pW + Math.max(0, delta));
            const condition = delta >= deltaThresh && stats.entropySecondHalf <= maxEntropy;
            return {
                prediction: condition ? 'W' : null,
                confidence
            };
        }
        case 'lagged_sum': {
            const lagK = Math.max(1, Number(params.lag_k) || 3);
            if (idxWindow + 1 < lagK) {
                return { prediction: null, confidence: 0 };
            }
            let sumWhites = 0;
            for (let i = idxWindow - lagK + 1; i <= idxWindow; i++) {
                sumWhites += context.whiteCounts[i];
            }
            const sumThresh = Number(params.sum_thresh) || 6;
            const confidence = clamp01(sumWhites / (lagK * windowChars.length));
            return {
                prediction: sumWhites >= sumThresh ? 'W' : null,
                confidence
            };
        }
        case 'trend_accel': {
            const segments = Math.max(3, Math.min(6, Number(params.segments) || 4));
            const fractions = getSegmentFractions(stats, segments, windowChars);
            if (fractions.length < 3) {
                return { prediction: null, confidence: 0 };
            }
            const midIndex = Math.floor(fractions.length / 2);
            const slopeEarly = fractions[midIndex] - fractions[0];
            const slopeLate = fractions[fractions.length - 1] - fractions[midIndex];
            const accel = slopeLate - slopeEarly;
            const accelThresh = params.accel_thresh ?? 0.1;
            const minFinal = params.min_final_pw ?? 0.25;
            const confidence = clamp01(fractions[fractions.length - 1] + Math.max(0, accel));
            const condition = accel >= accelThresh && fractions[fractions.length - 1] >= minFinal;
            return {
                prediction: condition ? 'W' : null,
                confidence
            };
        }
        case 'switch_pattern': {
            const minRate = clamp01(params.min_switch_rate ?? 0.75);
            const minTotal = Math.max(3, Number(params.min_total_switches) || 8);
            const switchRate = stats.nonWhiteTransitions > 0
                ? stats.switches / stats.nonWhiteTransitions
                : 0;
            const confidence = clamp01((switchRate + stats.pW) / 2);
            const condition = stats.switches >= minTotal && switchRate >= minRate;
            return {
                prediction: condition ? 'W' : null,
                confidence
            };
        }
        case 'compound_and':
        case 'compound_or': {
            const parts = Array.isArray(params.parts) ? params.parts : [];
            if (parts.length === 0) {
                return { prediction: null, confidence: 0 };
            }
            const results = parts.map(part => applyN0Config(part, windowChars, idxWindow, windows, context, depth + 1));
            const activeParts = results.filter(res => res.prediction === 'W');
            if (cfg.family === 'compound_and') {
                const condition = activeParts.length === results.length;
                const confidenceAvg = activeParts.length > 0
                    ? activeParts.reduce((acc, item) => acc + item.confidence, 0) / activeParts.length
                    : 0;
                return {
                    prediction: condition ? 'W' : null,
                    confidence: clamp01(confidenceAvg)
                };
            }
            const minHits = Math.max(1, Math.min(results.length, Number(params.min_hits) || 1));
            const condition = activeParts.length >= minHits;
            const confidenceAvg = activeParts.length > 0
                ? activeParts.reduce((acc, item) => acc + item.confidence, 0) / activeParts.length
                : 0;
            return {
                prediction: condition ? 'W' : null,
                confidence: clamp01(confidenceAvg)
            };
        }
        default:
            return { prediction: null, confidence: 0 };
    }
}

function computeN0RecentRecall(confList) {
    if (!Array.isArray(confList) || confList.length === 0) return 0;
    const half = Math.max(1, Math.floor(confList.length / 2));
    const recent = confList.slice(-half);
    let truePositives = 0;
    let falseNegatives = 0;
    recent.forEach(({ confidence, isWhite }) => {
        if (!isWhite) return;
        if (confidence >= 0.5) truePositives += 1;
        else falseNegatives += 1;
    });
    return truePositives + falseNegatives > 0 ? truePositives / (truePositives + falseNegatives) : 0;
}

function evaluateN0Config(windows, cfg, context, options = {}) {
    const { collectLogs = false } = options;
    let TP = 0;
    let FP = 0;
    let FN = 0;
    let nPreds = 0;
    const confList = [];
    const perWindowLog = collectLogs ? [] : null;

    windows.forEach((entry, idx) => {
        const { window, target } = entry;
        const result = applyN0Config(cfg, window, idx, windows, context);
        const confidence = clamp01(result.confidence ?? 0);
        const predictedWhite = result.prediction === 'W';
        const targetIsWhite = target === 'W';

        confList.push({
            confidence,
            isWhite: targetIsWhite,
            predictedWhite
        });

        let logResult = 'nulo';
        if (predictedWhite) {
            nPreds += 1;
            if (targetIsWhite) {
                TP += 1;
                logResult = 'hit';
            } else {
                FP += 1;
                logResult = 'false_positive';
            }
        } else if (targetIsWhite) {
            FN += 1;
            logResult = 'miss_white';
        } else {
            logResult = 'null';
        }

        if (perWindowLog) {
            perWindowLog.push({
                window_index: entry.index,
                start_idx: entry.start,
                prediction: predictedWhite ? 'W' : '-',
                confidence: Number(confidence.toFixed(4)),
                target,
                result: logResult
            });
        }
    });

    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    const coverage = windows.length > 0 ? nPreds / windows.length : 0;
    const accRecent = computeN0RecentRecall(confList);

    return {
        cfg,
        metrics: {
            TP,
            FP,
            FN,
            n_preds: nPreds,
            precision,
            recall,
            f1,
            coverage,
            acc_recent: accRecent,
            n_windows: windows.length
        },
        confList,
        perWindowLog
    };
}

function evaluateN0ConfigLegacy(windows, cfg) {
    let TP = 0;
    let FP = 0;
    let FN = 0;
    let nPreds = 0;
    const confList = [];

    windows.forEach(({ window, target }) => {
        const { prediction, confidence } = applyN0AnalysisLegacy(cfg, window);
        const confValue = Number.isFinite(confidence) ? Math.max(0, Math.min(1, confidence)) : 0;
        confList.push({ confidence: confValue, isWhite: target === 'W' });
        if (prediction === 'W') {
            nPreds += 1;
            if (target === 'W') TP += 1;
            else FP += 1;
        } else if (target === 'W') {
            FN += 1;
        }
    });

    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    const coverage = windows.length > 0 ? nPreds / windows.length : 0;
    const accRecent = computeN0RecentRecall(confList);

    return {
        cfg,
        n_preds: nPreds,
        TP,
        FP,
        FN,
        precision,
        recall,
        f1,
        coverage,
        acc_recent: accRecent,
        confList
    };
}

function calculateN0BlockMetrics(confList, threshold) {
    let TP = 0;
    let FP = 0;
    let FN = 0;
    confList.forEach(({ confidence, isWhite }) => {
        const passes = confidence >= threshold;
        if (passes && isWhite) TP += 1;
        else if (passes && !isWhite) FP += 1;
        else if (!passes && isWhite) FN += 1;
    });
    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    return { TP, FP, FN, precision, recall, f1 };
}

function determineDominantNonWhite(window) {
    if (!Array.isArray(window) || window.length === 0) return null;
    let reds = 0;
    let blacks = 0;
    window.forEach(char => {
        if (char === 'R') reds += 1;
        if (char === 'B') blacks += 1;
    });
    if (reds === blacks) return null;
    if (reds === 0 && blacks === 0) return null;
    return reds > blacks ? 'red' : 'black';
}

function runN0DetectorLegacy(history, options = {}) {
    try {
        const settings = {
            historySize: Number(options.historySize) > 0 ? Math.floor(options.historySize) : N0_DEFAULTS.historySize,
            windowSize: Number(options.windowSize) > 0 ? Math.floor(options.windowSize) : N0_DEFAULTS.windowSize,
            analysesToRun: Number(options.analysesToRun) > 0 ? Math.floor(options.analysesToRun) : N0_DEFAULTS.analysesToRun,
            minWindowsRequired: Number(options.minWindowsRequired) > 0 ? Math.floor(options.minWindowsRequired) : N0_DEFAULTS.minWindowsRequired,
            precisionMin: typeof options.precisionMin === 'number' ? Math.max(0, Math.min(1, options.precisionMin)) : N0_DEFAULTS.precisionMin,
            confidenceGrid: Array.isArray(options.confidenceGrid) && options.confidenceGrid.length > 0
                ? options.confidenceGrid.map(Number).filter(v => Number.isFinite(v) && v > 0 && v < 1).sort((a, b) => a - b)
                : [...N0_DEFAULTS.confidenceGrid],
            holdoutEnabled: options.holdoutEnabled !== undefined ? !!options.holdoutEnabled : N0_DEFAULTS.holdoutEnabled,
            holdoutTolerance: typeof options.holdoutTolerance === 'number'
                ? Math.max(0, Math.min(1, options.holdoutTolerance))
                : N0_DEFAULTS.holdoutTolerance,
            seed: Number.isFinite(Number(options.seed)) ? Number(options.seed) : N0_DEFAULTS.seed
        };

        // âœ… Determinismo + ordem correta + dedup:
        // o histÃ³rico pode vir com duplicados e fora de ordem (cache/servidor).
        const desiredHistory = Math.max(settings.historySize, settings.windowSize * 3);
        const stableWindow = getStableChronologicalHistoryWindow({
            limit: Math.min(desiredHistory, Array.isArray(history) ? history.length : 0),
            sourceHistory: Array.isArray(history) ? history : []
        });
        const chronologicalHistory = stableWindow.chronological; // antigo -> recente
        const normalizedHistory = normalizeN0History(chronologicalHistory).slice(-settings.historySize);

        if (normalizedHistory.length < settings.windowSize * 2) {
            return {
                enabled: false,
                reason: `HistÃ³rico insuficiente: ${normalizedHistory.length}/${settings.windowSize * 2}`,
                code: 'insufficient_history'
            };
        }

        // âš ï¸ Importante: com histÃ³rico 2000 e W=100, janelas 100% nÃ£o-sobrepostas geram pouquÃ­ssimas amostras (~19).
        // Para o N0 (evento raro), isso torna a validaÃ§Ã£o instÃ¡vel e o nÃ­vel tende a nunca disparar.
        // SoluÃ§Ã£o: manter janelas NÃƒO-sobrepostas, mas coletar mÃºltiplos "offsets" (ex.: 0,10,20...),
        // aumentando n de amostras sem mudar W.
        const offsetStep = Math.max(1, Math.min(settings.windowSize, Math.floor(settings.windowSize / 10)));
        const stride = settings.windowSize; // nÃ£o-sobreposto dentro de cada offset
        const windows = [];
        let windowIndex = 0;
        for (let offset = 0; offset < settings.windowSize; offset += offsetStep) {
            const sliced = normalizedHistory.slice(offset);
            const chunk = buildN0Windows(sliced, settings.windowSize, stride);
            for (const entry of chunk) {
                windows.push({
                    ...entry,
                    index: windowIndex++,
                    start: entry.start + offset,
                    targetIndex: entry.targetIndex + offset,
                    offset
                });
            }
        }
        if (windows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                reason: `Janelas Ãºteis insuficientes: ${windows.length}/${settings.minWindowsRequired}`,
                code: 'insufficient_windows'
            };
        }

        const n0DataStats = {
            history_total: normalizedHistory.length,
            history_whites: normalizedHistory.filter(c => c === 'W').length,
            windows_total: windows.length,
            target_whites: windows.filter(w => w && w.target === 'W').length
        };

        const holdoutPossible = settings.holdoutEnabled && windows.length >= settings.minWindowsRequired * 2;
        const trainingWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 0) : windows;
        const validationWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 1) : [];

        if (trainingWindows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                reason: `ValidaÃ§Ã£o: menos de ${settings.minWindowsRequired} janelas na amostra de treino`,
                code: 'insufficient_training'
            };
        }

        const candidateConfigs = generateN0Configs(settings.analysesToRun, settings.seed);
        const evaluations = [];
        candidateConfigs.forEach(cfg => {
            const evaluation = evaluateN0Config(trainingWindows, cfg);
            if (evaluation.n_preds >= settings.minWindowsRequired) {
                evaluations.push(evaluation);
            }
        });

        if (evaluations.length === 0) {
            return {
                enabled: false,
                reason: 'Nenhuma configuraÃ§Ã£o elegÃ­vel',
                code: 'no_valid_configs',
                tested_configs: candidateConfigs.length
            };
        }

        evaluations.sort((a, b) => {
            if (b.f1 !== a.f1) return b.f1 - a.f1;
            if (b.recall !== a.recall) return b.recall - a.recall;
            if (b.precision !== a.precision) return b.precision - a.precision;
            if ((b.acc_recent || 0) !== (a.acc_recent || 0)) return (b.acc_recent || 0) - (a.acc_recent || 0);
            if (b.coverage !== a.coverage) return b.coverage - a.coverage;
            return 0;
        });

        const bestEvaluation = evaluations[0];
        const grid = settings.confidenceGrid.length > 0 ? settings.confidenceGrid : [...N0_DEFAULTS.confidenceGrid];

        let chosenThreshold = null;
        let chosenMetrics = null;
        grid.forEach(candidate => {
            const metrics = calculateN0BlockMetrics(bestEvaluation.confList, candidate);
            if (metrics.precision >= settings.precisionMin) {
                if (!chosenMetrics || metrics.f1 > chosenMetrics.f1) {
                    chosenMetrics = metrics;
                    chosenThreshold = candidate;
                }
            }
        });

        if (!chosenMetrics) {
            const confValues = bestEvaluation.confList
                .map(entry => entry.confidence)
                .filter(Number.isFinite)
                .sort((a, b) => a - b);
            const percentileIndex = Math.max(0, Math.min(confValues.length - 1, Math.floor(confValues.length * 0.9)));
            const percentile90 = confValues.length > 0 ? confValues[percentileIndex] : 0.8;
            chosenThreshold = Math.max(0.8, percentile90);
            chosenMetrics = calculateN0BlockMetrics(bestEvaluation.confList, chosenThreshold);
        }

        const holdoutInfo = {
            enabled: holdoutPossible,
            passed: true,
            reason: null,
            training: chosenMetrics,
            validation: null
        };

        if (holdoutPossible && validationWindows.length >= settings.minWindowsRequired) {
            const validationEval = evaluateN0Config(validationWindows, bestEvaluation.cfg);
            const validationMetrics = calculateN0BlockMetrics(validationEval.confList, chosenThreshold);
            holdoutInfo.validation = validationMetrics;
            const trainingF1 = chosenMetrics.f1;
            const validationF1 = validationMetrics.f1;
            if (validationMetrics.precision < settings.precisionMin) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `PrecisÃ£o da validaÃ§Ã£o abaixo do mÃ­nimo (${(validationMetrics.precision * 100).toFixed(1)}% < ${(settings.precisionMin * 100).toFixed(1)}%)`;
            } else if (validationF1 < (trainingF1 - settings.holdoutTolerance)) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `F1 caiu de ${(trainingF1 * 100).toFixed(1)}% para ${(validationF1 * 100).toFixed(1)}%`;
            }
        }

        const liveWindow = normalizedHistory.slice(-settings.windowSize);
        if (liveWindow.length < settings.windowSize) {
            return {
                enabled: false,
                reason: 'Janela incompleta para prediÃ§Ã£o ao vivo',
                code: 'incomplete_live_window'
            };
        }
        const liveAnalysis = applyN0Analysis(bestEvaluation.cfg, liveWindow);
        const liveConfidence = Number.isFinite(liveAnalysis.confidence) ? Math.max(0, Math.min(1, liveAnalysis.confidence)) : 0;
        const livePrediction = liveAnalysis.prediction === 'W' ? 'W' : null;

        let blockingAction = 'no_block';
        if (livePrediction === 'W') {
            if (liveConfidence >= chosenThreshold) {
                blockingAction = 'block_all';
            } else if (liveConfidence >= chosenThreshold * 0.8) {
                blockingAction = 'soft_block';
            }
        }

        if (!holdoutInfo.passed && blockingAction !== 'no_block') {
            blockingAction = 'no_block';
        }

        const dominantNonWhite = determineDominantNonWhite(liveWindow);

        return {
            enabled: true,
            best_config: bestEvaluation.cfg,
            metrics: {
                training: bestEvaluation,
                block: chosenMetrics
            },
            pred_live: livePrediction,
            white_confidence: liveConfidence,
            blocking_action: blockingAction,
            blocking_threshold: chosenThreshold,
            dominant_nonwhite: dominantNonWhite,
            n_windows: windows.length,
            tested_configs: evaluations.length,
            holdout: holdoutInfo
        };
    } catch (error) {
        console.error('âŒ Erro no detector de branco (N0):', error);
        return {
            enabled: false,
            reason: 'Erro interno no detector de branco',
            code: 'internal_error',
            error: String(error)
        };
    }
}

function runN0Detector(history, options = {}) {
    const runTimestamp = Date.now();
    const runId = `N0-${runTimestamp}-${Math.floor(Math.random() * 1e6).toString(16)}`;
    try {
        const lookaheadRaw = Math.floor(Number(options.lookaheadSpins));
        // âœ… N0 agora otimiza para WHITE em atÃ© N giros (Entrada/G1/G2...), nÃ£o sÃ³ "no prÃ³ximo giro".
        // Default = 3 (ENTRADA + G1 + G2). MantÃ©m compatibilidade e alinha com o ciclo real.
        const lookaheadSpins = Number.isFinite(lookaheadRaw) && lookaheadRaw > 0 ? lookaheadRaw : 3;
        const settings = {
            historySize: Number(options.historySize) > 0 ? Math.floor(options.historySize) : N0_DEFAULTS.historySize,
            windowSize: Number(options.windowSize) > 0 ? Math.floor(options.windowSize) : N0_DEFAULTS.windowSize,
            analysesToRun: Number(options.analysesToRun) > 0 ? Math.floor(options.analysesToRun) : N0_DEFAULTS.analysesToRun,
            minWindowsRequired: Number(options.minWindowsRequired) > 0 ? Math.floor(options.minWindowsRequired) : N0_DEFAULTS.minWindowsRequired,
            precisionMin: typeof options.precisionMin === 'number' ? clamp01(options.precisionMin) : N0_DEFAULTS.precisionMin,
            // âœ… mÃ¡ximo 6 = ENTRADA + G1..G5 (configuraÃ§Ã£o mÃ¡xima do Branco)
            lookaheadSpins: Math.max(1, Math.min(6, lookaheadSpins)),
            confidenceGrid: Array.isArray(options.confidenceGrid) && options.confidenceGrid.length > 0
                ? options.confidenceGrid.map(Number).filter(v => Number.isFinite(v) && v > 0 && v < 1).sort((a, b) => a - b)
                : [...N0_DEFAULTS.confidenceGrid],
            holdoutEnabled: options.holdoutEnabled !== undefined ? !!options.holdoutEnabled : N0_DEFAULTS.holdoutEnabled,
            holdoutTolerance: typeof options.holdoutTolerance === 'number'
                ? clamp01(options.holdoutTolerance)
                : N0_DEFAULTS.holdoutTolerance,
            seed: Number.isFinite(Number(options.seed)) ? Number(options.seed) : N0_DEFAULTS.seed
        };

        const silent = !!options.silent;
        const cacheEnabled = options.cache !== false;
        const assumeStableHistory = !!options.assumeStableHistory;
        const cacheMaxAgeSpinsRaw = Math.floor(Number(options.cacheMaxAgeSpins));
        const cacheMaxAgeSpins = Number.isFinite(cacheMaxAgeSpinsRaw) && cacheMaxAgeSpinsRaw > 0
            ? cacheMaxAgeSpinsRaw
            : Math.max(10, Math.min(60, Math.floor(settings.windowSize / 3)));

        // âœ… Determinismo + ordem correta + dedup:
        // - Ao vivo: histÃ³rico pode vir com duplicados e fora de ordem (cache/servidor).
        // - Backtest: histÃ³rico jÃ¡ Ã© estÃ¡vel (ordenado + sem duplicados) â†’ pode pular dedup para ficar em segundos.
        const desiredHistory = Math.max(settings.historySize, settings.windowSize * 3 + settings.lookaheadSpins);
        const sourceHistory = Array.isArray(history) ? history : [];
        let stableWindow = null;
        let chronologicalHistory = [];
        if (assumeStableHistory) {
            const limit = Math.min(desiredHistory, sourceHistory.length);
            // sourceHistory: mais recente -> mais antigo (simulaÃ§Ã£o) â†’ inverter para antigo -> recente
            chronologicalHistory = sourceHistory.slice(0, limit).reverse();
            stableWindow = {
                chronological: chronologicalHistory,
                meta: {
                    availableHistory: sourceHistory.length,
                    uniqueCount: limit,
                    droppedDuplicates: 0,
                    droppedInvalidTs: 0,
                    usedHistoryLimit: limit
                }
            };
        } else {
            stableWindow = getStableChronologicalHistoryWindow({
                limit: Math.min(desiredHistory, sourceHistory.length),
                sourceHistory
            });
            chronologicalHistory = stableWindow.chronological; // antigo -> recente
        }

        const latestSpin = chronologicalHistory.length ? chronologicalHistory[chronologicalHistory.length - 1] : null;
        const latestSpinKey = latestSpin
            ? String(latestSpin.id || latestSpin.timestamp || latestSpin.number || chronologicalHistory.length)
            : `len_${chronologicalHistory.length}`;

        const normalizedPairs = normalizeN0HistoryPairs(chronologicalHistory).slice(-settings.historySize);
        const normalizedHistory = normalizedPairs.map((e) => (e ? e.c : null));

        if (normalizedHistory.length < (settings.windowSize * 2 + settings.lookaheadSpins)) {
            return {
                enabled: false,
                reason: `HistÃ³rico insuficiente: ${normalizedHistory.length}/${settings.windowSize * 2 + settings.lookaheadSpins}`,
                code: 'insufficient_history'
            };
        }

        // Janela ao vivo (sempre usada, com ou sem cache)
        const liveWindow = normalizedHistory.slice(-settings.windowSize);
        const liveWindowNumbers = normalizedPairs
            .slice(-settings.windowSize)
            .map((p) => (p && Number.isFinite(Number(p.n)) ? Math.floor(Number(p.n)) : null));

        // âœ… Modelo congelado (do backtest): usar exatamente o mesmo modelo, sem re-treinar
        const frozenModel = (options && typeof options.frozenModel === 'object' && options.frozenModel)
            ? options.frozenModel
            : null;
        if (frozenModel && frozenModel.best_config && frozenModel.blocking_threshold != null) {
            try {
                const model = frozenModel;
                const warnings = [];

                const liveStats = computeWindowStats(liveWindow);
                const liveContext = {
                    stats: [liveStats],
                    whitenessSeries: [liveStats.pW],
                    whiteCounts: [liveStats.whites],
                    loo: false,
                    base_white_rate: clamp01(model.base_white_rate ?? model.baseline_white ?? 0),
                    number_stats: model.number_stats || {},
                    gap_stats: model.gap_stats || {},
                    break_stats: model.break_stats || {}
                };

                const liveWindows = [{
                    window: liveWindow,
                    target: null,
                    index: 0,
                    start: Math.max(0, normalizedHistory.length - settings.windowSize),
                    targetIndex: normalizedHistory.length,
                    lookahead: settings.lookaheadSpins,
                    window_numbers: liveWindowNumbers
                }];

                const liveResult = applyN0Config(model.best_config, liveWindow, 0, liveWindows, liveContext);
                const liveConfidence = clamp01(liveResult.confidence ?? 0);
                const livePrediction = liveResult.prediction === 'W' ? 'W' : null;

                const chosenThreshold = clamp01(model.blocking_threshold ?? 0);
                let blockingAction = 'no_block';
                if (livePrediction === 'W') {
                    if (liveConfidence >= chosenThreshold) blockingAction = 'block_all';
                    else if (liveConfidence >= chosenThreshold * 0.8) blockingAction = 'soft_block';
                }

                const holdoutInfo = model.holdout || { enabled: false, passed: true, reason: null, training: model.blocking_metrics || null, validation: null };
                if (holdoutInfo && holdoutInfo.passed === false && blockingAction !== 'no_block') {
                    blockingAction = 'no_block';
                    warnings.push('AÃ§Ã£o de bloqueio suprimida devido Ã  reprovaÃ§Ã£o no holdout.');
                }

                const dominantNonWhite = determineDominantNonWhite(liveWindow);

                // Auto-aprendizado: mantÃ©m a mesma regra do modo real (mas o aprendizado pode estar pausado no config)
                let learningContext = '';
                let learningKey = null;
                let learningDecision = 'none';
                let learningRecentN = 0;
                let learningRecentWinRate = null;
                const baselineWhite = clamp01(model.baseline_white ?? (1 - Math.pow(1 - (1 / 15), Math.max(1, settings.lookaheadSpins))));
                try {
                    if (livePrediction === 'W' && blockingAction !== 'no_block') {
                        learningContext = buildN0LearningContextKey({
                            windowChars: liveWindow,
                            windowNumbers: liveWindowNumbers,
                            dominantNonWhite,
                            maxTail: 12
                        });
                        learningKey = buildN0SelfLearningKey(learningContext, blockingAction, model.best_config);
                        const st = learningKey ? getN0SelfLearningStatsForKey(learningKey) : null;
                        if (st) {
                            learningRecentN = st.recentN || 0;
                            learningRecentWinRate = st.recentWinRate;
                        }
                        const store = signalsHistory && signalsHistory.n0SelfLearning ? signalsHistory.n0SelfLearning : null;
                        const clampFactor = (v, min, max, fallback) => {
                            const n = Number(v);
                            if (!Number.isFinite(n)) return fallback;
                            return Math.max(min, Math.min(max, n));
                        };
                        const minSamples = Math.max(3, Math.min(120, Math.floor(Number(store?.minSamples) || 8)));
                        const badFactor = clampFactor(store?.badFactor, 0.1, 2.0, 0.8);
                        const badWinRate = clamp01(baselineWhite * badFactor);
                        if (learningRecentWinRate != null && learningRecentN >= minSamples && learningRecentWinRate <= badWinRate) {
                            blockingAction = 'no_block';
                            learningDecision = 'blocked';
                            warnings.push(`AutoApr N0: bloqueado (${(learningRecentWinRate * 100).toFixed(1)}% em ${learningRecentN} â€¢ base ${(baselineWhite * 100).toFixed(1)}%)`);
                        }
                    }
                } catch (_) {}

                const runSummary = {
                    run_id: runId,
                    timestamp: runTimestamp,
                    frozen: true,
                    history_size: settings.historySize,
                    available_history: stableWindow && stableWindow.meta ? stableWindow.meta.availableHistory : undefined,
                    unique_history: stableWindow && stableWindow.meta ? stableWindow.meta.uniqueCount : undefined,
                    dropped_duplicates: stableWindow && stableWindow.meta ? stableWindow.meta.droppedDuplicates : undefined,
                    dropped_invalid_ts: stableWindow && stableWindow.meta ? stableWindow.meta.droppedInvalidTs : undefined,
                    used_history_size: stableWindow && stableWindow.meta ? stableWindow.meta.usedHistoryLimit : undefined,
                    window_size: settings.windowSize,
                    lookahead_spins: settings.lookaheadSpins,
                    seed: settings.seed
                };

                return {
                    enabled: true,
                    run_summary: runSummary,
                    best_config: model.best_config,
                    best_metrics: model.best_metrics,
                    conf_list: model.conf_list || null,
                    per_window_log: null,
                    blocking_threshold: chosenThreshold,
                    blocking_metrics: model.blocking_metrics,
                    pred_live: livePrediction,
                    white_confidence: liveConfidence,
                    blocking_action: blockingAction,
                    dominant_nonwhite: dominantNonWhite,
                    tested_configs: model.tested_configs,
                    effective_configs: model.effective_configs,
                    top_candidates: model.top_candidates || [],
                    n_windows: model.n_windows,
                    holdout: holdoutInfo,
                    config_library: null,
                    // âœ… Contexto leve para observadores/explicaÃ§Ã£o (nÃ£o pesa no payload)
                    context_stats: {
                        base_white_rate: clamp01(liveContext && liveContext.base_white_rate),
                        number_stats: (liveContext && liveContext.number_stats) ? liveContext.number_stats : {},
                        gap_stats: (liveContext && liveContext.gap_stats) ? liveContext.gap_stats : {},
                        break_stats: (liveContext && liveContext.break_stats) ? liveContext.break_stats : {}
                    },
                    // âœ… Janela ao vivo (para observadores como puxadores/espelho/quebra)
                    live_window_chars: liveWindow,
                    live_window_numbers: liveWindowNumbers,
                    learning_context: learningContext || null,
                    learning_key: learningKey || null,
                    learning_decision: learningDecision,
                    learning_recent_n: learningRecentN || 0,
                    learning_recent_win_rate: learningRecentWinRate,
                    warnings
                };
            } catch (e) {
                // se falhar, cai para o fluxo normal
            }
        }

        // âœ… Cache runtime: reusar o modelo treinado por alguns giros (evita 10+ min no backtest).
        const cacheKey = buildN0RuntimeCacheKey(settings);
        const cachedRow = cacheEnabled ? n0RuntimeModelCache.get(cacheKey) : null;
        if (cachedRow && cachedRow.lastSeenSpinKey === latestSpinKey && cachedRow.lastResult) {
            return cachedRow.lastResult;
        }

        const canReuseModel = !!(
            cachedRow &&
            cachedRow.version === N0_RUNTIME_MODEL_CACHE_VERSION &&
            cachedRow.model &&
            (cachedRow.spinsSinceTrain || 0) < cacheMaxAgeSpins
        );

        if (canReuseModel) {
            const model = cachedRow.model;
            const warnings = [];

            const liveStats = computeWindowStats(liveWindow);
            const liveContext = {
                stats: [liveStats],
                whitenessSeries: [liveStats.pW],
                whiteCounts: [liveStats.whites],
                loo: false,
                base_white_rate: clamp01(model.base_white_rate ?? 0),
                number_stats: model.number_stats || {},
                gap_stats: model.gap_stats || {},
                break_stats: model.break_stats || {}
            };

            const liveWindows = [{
                window: liveWindow,
                target: null,
                index: 0,
                start: Math.max(0, normalizedHistory.length - settings.windowSize),
                targetIndex: normalizedHistory.length,
                lookahead: settings.lookaheadSpins,
                window_numbers: liveWindowNumbers
            }];

            const liveResult = applyN0Config(model.best_config, liveWindow, 0, liveWindows, liveContext);
            const liveConfidence = clamp01(liveResult.confidence ?? 0);
            const livePrediction = liveResult.prediction === 'W' ? 'W' : null;

            const chosenThreshold = clamp01(model.blocking_threshold ?? 0);
            let blockingAction = 'no_block';
            if (livePrediction === 'W') {
                if (liveConfidence >= chosenThreshold) {
                    blockingAction = 'block_all';
                } else if (liveConfidence >= chosenThreshold * 0.8) {
                    blockingAction = 'soft_block';
                }
            }

            const holdoutInfo = model.holdout || { enabled: false, passed: true, reason: null, training: model.blocking_metrics || null, validation: null };
            if (holdoutInfo && holdoutInfo.passed === false && blockingAction !== 'no_block') {
                blockingAction = 'no_block';
                warnings.push('AÃ§Ã£o de bloqueio suprimida devido Ã  reprovaÃ§Ã£o no holdout.');
            }

            const dominantNonWhite = determineDominantNonWhite(liveWindow);

            // Auto-aprendizado (mesma lÃ³gica do fluxo completo)
            let learningContext = '';
            let learningKey = null;
            let learningDecision = 'none';
            let learningRecentN = 0;
            let learningRecentWinRate = null;
            const baselineWhite = clamp01(model.baseline_white ?? (1 - Math.pow(1 - (1 / 15), Math.max(1, settings.lookaheadSpins))));
            try {
                if (livePrediction === 'W' && blockingAction !== 'no_block') {
                    learningContext = buildN0LearningContextKey({
                        windowChars: liveWindow,
                        windowNumbers: liveWindowNumbers,
                        dominantNonWhite,
                        maxTail: 12
                    });
                    learningKey = buildN0SelfLearningKey(learningContext, blockingAction, model.best_config);
                    const st = learningKey ? getN0SelfLearningStatsForKey(learningKey) : null;
                    if (st) {
                        learningRecentN = st.recentN || 0;
                        learningRecentWinRate = st.recentWinRate;
                    }

                    const store = signalsHistory && signalsHistory.n0SelfLearning ? signalsHistory.n0SelfLearning : null;
                    const clampFactor = (v, min, max, fallback) => {
                        const n = Number(v);
                        if (!Number.isFinite(n)) return fallback;
                        return Math.max(min, Math.min(max, n));
                    };
                    const minSamples = Math.max(3, Math.min(120, Math.floor(Number(store?.minSamples) || 8)));
                    const badFactor = clampFactor(store?.badFactor, 0.1, 2.0, 0.8);
                    const badWinRate = clamp01(baselineWhite * badFactor);
                    if (learningRecentWinRate != null && learningRecentN >= minSamples && learningRecentWinRate <= badWinRate) {
                        blockingAction = 'no_block';
                        learningDecision = 'blocked';
                        warnings.push(`AutoApr N0: bloqueado (${(learningRecentWinRate * 100).toFixed(1)}% em ${learningRecentN} â€¢ base ${(baselineWhite * 100).toFixed(1)}%)`);
                    }
                }
            } catch (_) {}

            const runSummary = {
                run_id: runId,
                timestamp: runTimestamp,
                cached: true,
                cache_age_spins: cachedRow.spinsSinceTrain || 0,
                history_size: settings.historySize,
                available_history: stableWindow && stableWindow.meta ? stableWindow.meta.availableHistory : undefined,
                unique_history: stableWindow && stableWindow.meta ? stableWindow.meta.uniqueCount : undefined,
                dropped_duplicates: stableWindow && stableWindow.meta ? stableWindow.meta.droppedDuplicates : undefined,
                dropped_invalid_ts: stableWindow && stableWindow.meta ? stableWindow.meta.droppedInvalidTs : undefined,
                used_history_size: stableWindow && stableWindow.meta ? stableWindow.meta.usedHistoryLimit : undefined,
                window_size: settings.windowSize,
                lookahead_spins: settings.lookaheadSpins,
                seed: settings.seed
            };

            const result = {
                enabled: true,
                run_summary: runSummary,
                best_config: model.best_config,
                best_metrics: model.best_metrics,
                conf_list: model.conf_list || null,
                per_window_log: null,
                blocking_threshold: chosenThreshold,
                blocking_metrics: model.blocking_metrics,
                pred_live: livePrediction,
                white_confidence: liveConfidence,
                blocking_action: blockingAction,
                dominant_nonwhite: dominantNonWhite,
                tested_configs: model.tested_configs,
                effective_configs: model.effective_configs,
                top_candidates: model.top_candidates || [],
                n_windows: model.n_windows,
                holdout: holdoutInfo,
                config_library: null,
                // âœ… Contexto leve para observadores/explicaÃ§Ã£o (nÃ£o pesa no payload)
                context_stats: {
                    base_white_rate: clamp01(liveContext && liveContext.base_white_rate),
                    number_stats: (liveContext && liveContext.number_stats) ? liveContext.number_stats : {},
                    gap_stats: (liveContext && liveContext.gap_stats) ? liveContext.gap_stats : {},
                    break_stats: (liveContext && liveContext.break_stats) ? liveContext.break_stats : {}
                },
                // âœ… Janela ao vivo (para observadores como puxadores/espelho/quebra)
                live_window_chars: liveWindow,
                live_window_numbers: liveWindowNumbers,
                learning_context: learningContext || null,
                learning_key: learningKey || null,
                learning_decision: learningDecision,
                learning_recent_n: learningRecentN || 0,
                learning_recent_win_rate: learningRecentWinRate,
                warnings
            };

            const nextRow = {
                ...cachedRow,
                lastSeenSpinKey: latestSpinKey,
                lastResult: result,
                spinsSinceTrain: Math.max(0, Math.floor(Number(cachedRow.spinsSinceTrain) || 0)) + 1
            };
            n0RuntimeModelCache.set(cacheKey, nextRow);
            return result;
        }

        // âš ï¸ Importante: com histÃ³rico 2000 e W=100, janelas 100% nÃ£o-sobrepostas geram pouquÃ­ssimas amostras (~19).
        // Para o N0 (evento raro), isso torna a validaÃ§Ã£o instÃ¡vel e o nÃ­vel tende a nunca disparar.
        // SoluÃ§Ã£o: manter janelas NÃƒO-sobrepostas, mas coletar mÃºltiplos "offsets" (ex.: 0,10,20...),
        // aumentando n de amostras sem mudar W.
        const offsetStep = Math.max(1, Math.min(settings.windowSize, Math.floor(settings.windowSize / 10)));
        const stride = settings.windowSize; // nÃ£o-sobreposto dentro de cada offset
        const windows = [];
        let windowIndex = 0;
        for (let offset = 0; offset < settings.windowSize; offset += offsetStep) {
            const sliced = normalizedHistory.slice(offset);
            const chunk = buildN0Windows(sliced, settings.windowSize, stride, settings.lookaheadSpins);
            for (const entry of chunk) {
                const globalStart = entry.start + offset;
                const windowNumbers = normalizedPairs
                    .slice(globalStart, globalStart + settings.windowSize)
                    .map((p) => (p && Number.isFinite(Number(p.n)) ? Math.floor(Number(p.n)) : null));
                windows.push({
                    ...entry,
                    index: windowIndex++,
                    start: globalStart,
                    targetIndex: entry.targetIndex + offset,
                    offset,
                    window_numbers: windowNumbers
                });
            }
        }
        if (windows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                reason: `Janelas Ãºteis insuficientes: ${windows.length}/${settings.minWindowsRequired}`,
                code: 'insufficient_windows'
            };
        }

        const n0DataStats = {
            history_total: normalizedHistory.length,
            history_whites: normalizedHistory.filter(c => c === 'W').length,
            windows_total: windows.length,
            target_whites: windows.filter(w => w && w.target === 'W').length
        };

        const holdoutPossible = settings.holdoutEnabled && windows.length >= settings.minWindowsRequired * 2;
        const trainingWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 0) : windows;
        const validationWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 1) : [];

        if (trainingWindows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                reason: `ValidaÃ§Ã£o: menos de ${settings.minWindowsRequired} janelas na amostra de treino`,
                code: 'insufficient_training'
            };
        }

        const candidateConfigs = generateN0Configs(settings.analysesToRun, settings.seed);
        if (!silent) {
            console.log(`%c   â¤ Biblioteca N0: ${candidateConfigs.length} configs avaliadas`, 'color: #CCCCFF; font-weight: bold;');
        }
        const trainingContext = buildN0WindowContext(trainingWindows);
        const evaluations = [];

        candidateConfigs.forEach(cfg => {
            const evaluation = evaluateN0Config(trainingWindows, cfg, trainingContext);
            if (evaluation.metrics.n_preds >= settings.minWindowsRequired) {
                evaluations.push(evaluation);
            }
        });

        if (evaluations.length === 0) {
            return {
                enabled: false,
                reason: 'Nenhuma configuraÃ§Ã£o elegÃ­vel',
                code: 'no_valid_configs',
                tested_configs: candidateConfigs.length
            };
        }

        // âœ… Anti-"silÃªncio": evitar configs ultra-rÃ­gidas que quase nunca disparam.
        // Exigir uma cobertura mÃ­nima baseada na taxa base de WHITE no horizonte (target W nas janelas).
        const targetWhiteRate = trainingWindows.length > 0
            ? (trainingWindows.filter(w => w && w.target === 'W').length / trainingWindows.length)
            : 0;
        const minCoverageFloor = Math.max(0.03, Math.min(0.25, targetWhiteRate * 0.35));
        const coverageEligible = evaluations.filter(ev => (ev && ev.metrics && typeof ev.metrics.coverage === 'number')
            ? (ev.metrics.coverage >= minCoverageFloor)
            : false
        );
        const rankingPool = coverageEligible.length > 0 ? coverageEligible : evaluations;

        rankingPool.sort((a, b) => {
            const mA = a.metrics;
            const mB = b.metrics;
            if (mB.f1 !== mA.f1) return mB.f1 - mA.f1;
            if (mB.recall !== mA.recall) return mB.recall - mA.recall;
            // âœ… preferir modelos que nÃ£o "morrem" (mais sinais) quando F1/recall empatam
            if (mB.coverage !== mA.coverage) return mB.coverage - mA.coverage;
            if (mB.precision !== mA.precision) return mB.precision - mA.precision;
            if ((mB.acc_recent || 0) !== (mA.acc_recent || 0)) return (mB.acc_recent || 0) - (mA.acc_recent || 0);
            return 0;
        });

        const TOP_K = Math.min(20, rankingPool.length);
        const topEvaluations = rankingPool.slice(0, TOP_K);
        const bestEvaluation = topEvaluations[0];
        const bestDetailed = evaluateN0Config(trainingWindows, bestEvaluation.cfg, trainingContext, { collectLogs: !silent });
        const bestMetrics = bestDetailed.metrics;
        const bestConfList = bestDetailed.confList;
        const perWindowLog = bestDetailed.perWindowLog || [];

        // âœ… Para N0 (evento raro), calibrar "precisÃ£o mÃ­nima" em cima do baseline observado.
        // Se exigirmos 45% de precisÃ£o "absoluta" para BRANCO, o nÃ­vel tende a nunca disparar.
        // Aqui mantemos `precisionMin` como fator de melhoria sobre o baseline (lift), nÃ£o como valor absoluto.
        const BASELINE_WHITE_SPIN = 1 / 15; // Blaze Double (0..14)
        const BASELINE_WHITE_FALLBACK = 1 - Math.pow(1 - BASELINE_WHITE_SPIN, Math.max(1, settings.lookaheadSpins));
        const observedBaseRate = Array.isArray(bestConfList) && bestConfList.length > 0
            ? bestConfList.filter(entry => entry && entry.isWhite).length / bestConfList.length
            : 0;
        const baselineWhite = (Number.isFinite(observedBaseRate) && observedBaseRate > 0) ? observedBaseRate : BASELINE_WHITE_FALLBACK;
        const minPrecisionForWhite = clamp01(baselineWhite * (1 + settings.precisionMin));

        // Grade de thresholds: se a distribuiÃ§Ã£o de confianÃ§a for "baixa" (ex.: < 0.5),
        // adaptamos a grade para cobrir a faixa real de confidences do melhor modelo.
        const baseGrid = settings.confidenceGrid.length > 0 ? settings.confidenceGrid : [...N0_DEFAULTS.confidenceGrid];
        const confValuesSorted = bestConfList
            .map(entry => entry && entry.confidence)
            .filter(Number.isFinite)
            .sort((a, b) => a - b);
        const confMax = confValuesSorted.length > 0 ? confValuesSorted[confValuesSorted.length - 1] : 1;
        const gridMin = baseGrid.length > 0 ? baseGrid[0] : 0.5;
        let grid = baseGrid;
        if (confMax < gridMin) {
            const quantiles = [0.5, 0.6, 0.7, 0.75, 0.8, 0.85, 0.9, 0.92, 0.94, 0.95];
            const derived = quantiles
                .map((q) => {
                    if (confValuesSorted.length === 0) return null;
                    const idx = Math.max(0, Math.min(confValuesSorted.length - 1, Math.floor((confValuesSorted.length - 1) * q)));
                    return confValuesSorted[idx];
                })
                .filter((v) => Number.isFinite(v));
            grid = [...new Set(derived.map(v => Number(v.toFixed(4))))].sort((a, b) => a - b);
        }

        let chosenThreshold = null;
        let chosenMetrics = null;
        grid.forEach(candidate => {
            const metrics = calculateN0BlockMetrics(bestConfList, candidate);
            if (metrics.precision >= minPrecisionForWhite) {
                if (!chosenMetrics || metrics.f1 > chosenMetrics.f1) {
                    chosenMetrics = { ...metrics, threshold: candidate };
                    chosenThreshold = candidate;
                }
            }
        });

        if (!chosenMetrics) {
            const percentileIndex = Math.max(0, Math.min(confValuesSorted.length - 1, Math.floor(confValuesSorted.length * 0.9)));
            const percentile90 = confValuesSorted.length > 0 ? confValuesSorted[percentileIndex] : 0.5;
            // fallback: usar p90 da distribuiÃ§Ã£o real (nÃ£o travar em 0.8, o que pode tornar o N0 impossÃ­vel)
            chosenThreshold = clamp01(percentile90);
            const fallbackMetrics = calculateN0BlockMetrics(bestConfList, chosenThreshold);
            chosenMetrics = { ...fallbackMetrics, threshold: chosenThreshold, fallback: true };
        } else if (!('threshold' in chosenMetrics)) {
            chosenMetrics.threshold = chosenThreshold;
        }

        const holdoutInfo = {
            enabled: holdoutPossible,
            passed: true,
            reason: null,
            training: chosenMetrics,
            validation: null
        };
        const warnings = [];
        if (n0DataStats.history_whites === 0) {
            warnings.push(`HistÃ³rico normalizado sem BRANCOS (W=0/${n0DataStats.history_total}) â€” verifique o mapeamento de cores/nÃºmeros.`);
        }
        if (n0DataStats.target_whites === 0) {
            warnings.push(`Nenhum BRANCO nos alvos das janelas (targets W=0/${n0DataStats.windows_total}). A validaÃ§Ã£o pode ficar instÃ¡vel.`);
        }

        if (holdoutPossible && validationWindows.length >= settings.minWindowsRequired) {
            // âœ… Holdout real: validar usando o "aprendizado" do TREINO (sem vazar labels da validaÃ§Ã£o).
            // Ainda precisamos das stats por janela da validaÃ§Ã£o para os modelos que dependem disso.
            const validationStats = validationWindows.map((entry) => computeWindowStats(entry.window));
            const validationContext = {
                ...trainingContext,
                stats: validationStats,
                whitenessSeries: validationStats.map(s => s.pW),
                whiteCounts: validationStats.map(s => s.whites),
                loo: false
            };
            const validationEval = evaluateN0Config(validationWindows, bestDetailed.cfg, validationContext);
            const validationMetrics = calculateN0BlockMetrics(validationEval.confList, chosenThreshold);
            holdoutInfo.validation = { ...validationMetrics, threshold: chosenThreshold };
            const trainingF1 = chosenMetrics.f1 ?? 0;
            const validationF1 = validationMetrics.f1 ?? 0;
            const validationWhiteTargets = validationWindows.filter(w => w && w.target === 'W').length;
            // Se a validaÃ§Ã£o tem pouquÃ­ssimos brancos, a mÃ©trica fica instÃ¡vel e vira "falso negativo" constante.
            // Nesses casos, tratamos o holdout como inconclusivo (nÃ£o vetar a aÃ§Ã£o), mas avisamos.
            if (validationWhiteTargets < 2) {
                holdoutInfo.passed = true;
                holdoutInfo.reason = `Holdout inconclusivo: poucos brancos na validaÃ§Ã£o (${validationWhiteTargets})`;
                warnings.push(holdoutInfo.reason);
            } else if (validationMetrics.precision < minPrecisionForWhite) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `PrecisÃ£o da validaÃ§Ã£o abaixo do mÃ­nimo (prec ${(validationMetrics.precision * 100).toFixed(1)}% < min ${(minPrecisionForWhite * 100).toFixed(1)}% â€¢ baseline ${(baselineWhite * 100).toFixed(1)}%)`;
                warnings.push(holdoutInfo.reason);
            } else if (validationF1 < (trainingF1 - settings.holdoutTolerance)) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `F1 caiu de ${(trainingF1 * 100).toFixed(1)}% para ${(validationF1 * 100).toFixed(1)}%`;
                warnings.push(holdoutInfo.reason);
            }
        }

        if (liveWindow.length < settings.windowSize) {
            return {
                enabled: false,
                reason: 'Janela incompleta para prediÃ§Ã£o ao vivo',
                code: 'incomplete_live_window'
            };
        }
        const liveWindows = [{
            window: liveWindow,
            target: null,
            index: windows.length,
            start: Math.max(0, normalizedHistory.length - settings.windowSize),
            targetIndex: normalizedHistory.length,
            lookahead: settings.lookaheadSpins,
            window_numbers: liveWindowNumbers
        }];
        // âœ… PrevisÃ£o ao vivo: usar "aprendizado" do treino + stats da janela atual (sem LOO).
        const liveStats = computeWindowStats(liveWindow);
        const liveContext = {
            ...trainingContext,
            stats: [liveStats],
            whitenessSeries: [liveStats.pW],
            whiteCounts: [liveStats.whites],
            loo: false
        };
        const liveResult = applyN0Config(bestDetailed.cfg, liveWindow, 0, liveWindows, liveContext);
        const liveConfidence = clamp01(liveResult.confidence ?? 0);
        const livePrediction = liveResult.prediction === 'W' ? 'W' : null;

        let blockingAction = 'no_block';
        if (livePrediction === 'W') {
            if (liveConfidence >= chosenThreshold) {
                blockingAction = 'block_all';
            } else if (liveConfidence >= chosenThreshold * 0.8) {
                blockingAction = 'soft_block';
            }
        }

        if (!holdoutInfo.passed && blockingAction !== 'no_block') {
            blockingAction = 'no_block';
            warnings.push('AÃ§Ã£o de bloqueio suprimida devido Ã  reprovaÃ§Ã£o no holdout.');
        }

        const dominantNonWhite = determineDominantNonWhite(liveWindow);
        // âšª N0 Auto-aprendizado: bloquear/downgrade quando um "tipo de alerta" estiver ruim no histÃ³rico da conta.
        // Importante: aqui NÃƒO relaxamos thresholds; apenas evitamos repetir contextos que dÃ£o LOSS sistemÃ¡tico.
        let learningContext = '';
        let learningKey = null;
        let learningDecision = 'none'; // 'none' | 'blocked'
        let learningRecentN = 0;
        let learningRecentWinRate = null;
        try {
            if (livePrediction === 'W' && blockingAction !== 'no_block') {
                learningContext = buildN0LearningContextKey({
                    windowChars: liveWindow,
                    windowNumbers: liveWindowNumbers,
                    dominantNonWhite,
                    maxTail: 12
                });
                learningKey = buildN0SelfLearningKey(learningContext, blockingAction, bestDetailed.cfg);
                const st = learningKey ? getN0SelfLearningStatsForKey(learningKey) : null;
                if (st) {
                    learningRecentN = st.recentN || 0;
                    learningRecentWinRate = st.recentWinRate;
                }

                const store = signalsHistory && signalsHistory.n0SelfLearning ? signalsHistory.n0SelfLearning : null;
                const clampFactor = (v, min, max, fallback) => {
                    const n = Number(v);
                    if (!Number.isFinite(n)) return fallback;
                    return Math.max(min, Math.min(max, n));
                };
                const minSamples = Math.max(3, Math.min(120, Math.floor(Number(store?.minSamples) || 8)));
                const badFactor = clampFactor(store?.badFactor, 0.1, 2.0, 0.8);
                const baseline = clamp01(baselineWhite);
                const badWinRate = clamp01(baseline * badFactor);

                if (learningRecentWinRate != null && learningRecentN >= minSamples && learningRecentWinRate <= badWinRate) {
                    blockingAction = 'no_block';
                    learningDecision = 'blocked';
                    warnings.push(
                        `AutoApr N0: bloqueado (${(learningRecentWinRate * 100).toFixed(1)}% em ${learningRecentN} â€¢ base ${(baseline * 100).toFixed(1)}%)`
                    );
                }
            }
        } catch (_) {}

        const topCandidates = topEvaluations.slice(0, Math.min(10, topEvaluations.length)).map(entry => ({
            id: entry.cfg.id,
            family: entry.cfg.family,
            params: entry.cfg.params,
            metrics: entry.metrics
        }));

        const runSummary = {
            run_id: runId,
            timestamp: runTimestamp,
            history_size: settings.historySize,
            available_history: stableWindow && stableWindow.meta ? stableWindow.meta.availableHistory : undefined,
            unique_history: stableWindow && stableWindow.meta ? stableWindow.meta.uniqueCount : undefined,
            dropped_duplicates: stableWindow && stableWindow.meta ? stableWindow.meta.droppedDuplicates : undefined,
            dropped_invalid_ts: stableWindow && stableWindow.meta ? stableWindow.meta.droppedInvalidTs : undefined,
            used_history_size: stableWindow && stableWindow.meta ? stableWindow.meta.usedHistoryLimit : undefined,
            window_size: settings.windowSize,
            lookahead_spins: settings.lookaheadSpins,
            window_stride: stride,
            offset_step: offsetStep,
            analyses_to_run: settings.analysesToRun,
            min_windows_required: settings.minWindowsRequired,
            seed: settings.seed
        };

        const bestDescription = bestDetailed.cfg.description || bestDetailed.cfg.family || 'desconhecido';
        const f1Display = bestMetrics.f1 != null ? (bestMetrics.f1 * 100).toFixed(1) : 'n/d';
        const precisionDisplay = bestMetrics.precision != null ? (bestMetrics.precision * 100).toFixed(1) : 'n/d';
        const recallDisplay = bestMetrics.recall != null ? (bestMetrics.recall * 100).toFixed(1) : 'n/d';
        const coverageDisplay = bestMetrics.coverage != null ? (bestMetrics.coverage * 100).toFixed(1) : 'n/d';
        if (!silent) {
            console.log(`âœ… [N0] Melhor anÃ¡lise: ${bestDescription} | F1 ${f1Display}% | prec ${precisionDisplay}% | rec ${recallDisplay}% | coverage ${coverageDisplay}% | n_preds ${bestMetrics.n_preds}/${bestMetrics.n_windows}`);
        }
        const finalColor = livePrediction === 'W' ? 'white' : null;
        const finalConfidence = liveConfidence;
        const thresholdGate = chosenThreshold;
        if (!silent) {
            if (finalColor) {
                console.log(`ğŸ¯ [N0] Voto ao vivo: ${finalColor.toUpperCase()} (confianÃ§a ${(finalConfidence * 100).toFixed(1)}%) | conf_live ${Math.round(liveConfidence * 100)}% | t* ${Math.round(thresholdGate * 100)}%`);
            } else {
                console.log(`âš ï¸ [N0] Sem voto ao vivo (conf ${Math.round(liveConfidence * 100)}% | limiar ${Math.round(thresholdGate * 100)}%${holdoutInfo.passed ? '' : ' | holdout reprovado'})`);
            }
        }

        const result = {
            enabled: true,
            run_summary: runSummary,
            best_config: bestDetailed.cfg,
            best_metrics: bestMetrics,
            conf_list: bestConfList,
            per_window_log: perWindowLog,
            blocking_threshold: chosenThreshold,
            blocking_metrics: chosenMetrics,
            pred_live: livePrediction,
            white_confidence: liveConfidence,
            blocking_action: blockingAction,
            dominant_nonwhite: dominantNonWhite,
            tested_configs: candidateConfigs.length,
            effective_configs: evaluations.length,
            top_candidates: topCandidates,
            n_windows: windows.length,
            holdout: holdoutInfo,
            // em backtest/silent, evitar devolver payload gigante (nÃ£o Ã© usado pela UI e custa CPU/memÃ³ria)
            config_library: silent ? null : candidateConfigs,
            // âœ… Contexto leve para observadores/explicaÃ§Ã£o (nÃ£o pesa no payload)
            context_stats: {
                base_white_rate: clamp01(trainingContext && trainingContext.base_white_rate),
                number_stats: (trainingContext && trainingContext.number_stats) ? trainingContext.number_stats : {},
                gap_stats: (trainingContext && trainingContext.gap_stats) ? trainingContext.gap_stats : {},
                break_stats: (trainingContext && trainingContext.break_stats) ? trainingContext.break_stats : {}
            },
            // âœ… Janela ao vivo (para observadores como puxadores/espelho/quebra)
            live_window_chars: liveWindow,
            live_window_numbers: liveWindowNumbers,
            // Auto-aprendizado (N0)
            learning_context: learningContext || null,
            learning_key: learningKey || null,
            learning_decision: learningDecision,
            learning_recent_n: learningRecentN || 0,
            learning_recent_win_rate: learningRecentWinRate,
            warnings
        };

        // âœ… Persistir modelo em cache runtime (para reutilizar nos prÃ³ximos giros).
        if (cacheEnabled) {
            try {
                const model = {
                    best_config: bestDetailed.cfg,
                    best_metrics: bestMetrics,
                    blocking_threshold: chosenThreshold,
                    blocking_metrics: chosenMetrics,
                    holdout: holdoutInfo,
                    baseline_white: baselineWhite,
                    n_windows: windows.length,
                    tested_configs: candidateConfigs.length,
                    effective_configs: evaluations.length,
                    top_candidates: topCandidates,
                    // Contexto agregado (para observadores: gap/numero/quebra)
                    base_white_rate: trainingContext.base_white_rate ?? 0,
                    number_stats: trainingContext.number_stats || {},
                    gap_stats: trainingContext.gap_stats || {},
                    break_stats: trainingContext.break_stats || {},
                    // opcional: usado por validaÃ§Ã£o/telemetria
                    conf_list: bestConfList
                };
                n0RuntimeModelCache.set(cacheKey, {
                    version: N0_RUNTIME_MODEL_CACHE_VERSION,
                    model,
                    trainedAt: runTimestamp,
                    trainedOnSpinKey: latestSpinKey,
                    spinsSinceTrain: 0,
                    lastSeenSpinKey: latestSpinKey,
                    lastResult: result
                });
            } catch (_) {}
        }

        return result;
    } catch (error) {
        console.error('âŒ Erro no detector de branco (N0):', error);
        return {
            enabled: false,
            reason: 'Erro interno no detector de branco',
            code: 'internal_error',
            error: String(error),
            run_summary: {
                run_id: runId,
                timestamp: runTimestamp
            }
        };
    }
}

function getN0SettingsFromAnalyzerConfig() {
    const windows = analyzerConfig && analyzerConfig.diamondLevelWindows ? analyzerConfig.diamondLevelWindows : {};
    const historySizeRaw = Number(windows.n0History);
    const windowSizeRaw = Number(windows.n0Window);
    const historySize = Number.isFinite(historySizeRaw) && historySizeRaw > 0 ? Math.floor(historySizeRaw) : N0_DEFAULTS.historySize;
    const windowSize = Number.isFinite(windowSizeRaw) && windowSizeRaw > 0 ? Math.floor(windowSizeRaw) : N0_DEFAULTS.windowSize;
    return {
        historySize: Math.max(200, Math.min(REALTIME_HISTORY_CAP, historySize)),
        windowSize: Math.max(25, Math.min(250, windowSize)),
        allowBlockAll: analyzerConfig && analyzerConfig.n0AllowBlockAll !== false
    };
}

/**
 * LEGACY: implementaÃ§Ã£o anterior do walk-forward (mantida apenas para referÃªncia)
 */
function runDiamondLevelN10Legacy(history, options = {}) {
    try {
        const windowSize = Math.max(2, Number(options.windowSize) || 20);   // W
        const historySize = Math.max(windowSize * 2, Number(options.historySize) || 500); // N_total mÃ­nimo 2W
        const analysesToRun = Math.max(50, Number(options.analysesToRun) || 600);
        const minWindowsRequired = Math.max(3, Number(options.minWindows) || 8);
        const confMin = Math.max(0, Math.min(1, Number(options.confMin) || 0.6)); // 0..1
        
        if (!Array.isArray(history) || history.length < windowSize * 2) {
            const available = history ? history.length : 0;
            console.log('âš ï¸ [N10] HistÃ³rico insuficiente para anÃ¡lise:', available, `/< ${windowSize * 2} giros necessÃ¡rios`);
            return {
                enabled: false,
                summaryText: `N10 - Walk-forward â†’ NULO (dados insuficientes: ${available} giros, mÃ­nimo ${windowSize * 2})`
            };
        }
        
        console.log('%câ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”', 'color: #00FFFF; font-weight: bold;');
        console.log('%câ”‚ ğŸ”Ÿ N10: WALK-FORWARD NÃƒO-SOBREPOSTO                    â”‚', 'color: #00FFFF; font-weight: bold;');
        console.log('%câ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜', 'color: #00FFFF; font-weight: bold;');
        console.log(`   ğŸ“Š Janela (W): ${windowSize} giros | HistÃ³rico base alvo: ${historySize} giros`);
        
        // Converter histÃ³rico (mais recente â†’ mais antigo) para ordem cronolÃ³gica (mais antigo â†’ mais recente)
        const chronologicalSpins = history.slice().reverse().filter(s => s && s.color);
        
        const normalizedChars = chronologicalSpins.map(s => {
            if (s.color === 'red') return 'R';
            if (s.color === 'black') return 'B';
            return 'W';
        });
        
        const N_total = Math.min(historySize, normalizedChars.length);
        const seqStart = normalizedChars.length - N_total;
        const seq = normalizedChars.slice(seqStart); // mais antigo â†’ mais recente
        
        const m = Math.floor(N_total / windowSize); // nÃºmero de janelas completas
        if (m < 2) {
            console.log('âš ï¸ [N10] Menos de 2 janelas completas disponÃ­veis:', m);
            return {
                enabled: false,
                summaryText: `N10 - Walk-forward â†’ NULO (menos de 2 janelas completas para W=${windowSize})`
            };
        }
        
        const windows = [];
        for (let k = 0; k < m; k++) {
            const start = k * windowSize;
            const end = start + windowSize;
            const targetIdx = end;
            if (targetIdx >= seq.length) continue;
            const window = seq.slice(start, end);
            const target = seq[targetIdx];
            windows.push({ window, target, start, targetIdx });
        }
        
        const n_windows = windows.length;
        if (n_windows < minWindowsRequired) {
            console.log('âš ï¸ [N10] Poucas janelas Ãºteis:', n_windows, `< minWindowsRequired=${minWindowsRequired}`);
            return {
                enabled: false,
                summaryText: `N10 - Walk-forward â†’ NULO (janelas Ãºteis ${n_windows}, mÃ­nimo exigido ${minWindowsRequired})`
            };
        }
        
        // Helpers de anÃ¡lise bÃ¡sica
        const majority = (window) => {
            let r = 0, b = 0;
            for (const c of window) {
                if (c === 'R') r++;
                else if (c === 'B') b++;
            }
            if (r === 0 && b === 0) return null;
            if (r > b) return 'R';
            if (b > r) return 'B';
            return null;
        };
        
        const majorityThreshold = (window, thresh) => {
            let r = 0, b = 0;
            for (const c of window) {
                if (c === 'R') r++;
                else if (c === 'B') b++;
            }
            const total = r + b;
            if (total === 0) return null;
            const pR = r / total;
            const pB = b / total;
            if (pR >= thresh && pR > pB) return 'R';
            if (pB >= thresh && pB > pR) return 'B';
            return null;
        };
        
        const lastPattern = (window, L, nextThreshold) => {
            const nonWhite = window.filter(c => c !== 'W');
            if (nonWhite.length < L + 1) return null;
            const pattern = nonWhite.slice(nonWhite.length - L); // Ãºltimos L
            const seqNoW = window.filter(c => c !== 'W');
            const followers = [];
            for (let i = 0; i + L < seqNoW.length; i++) {
                const slice = seqNoW.slice(i, i + L);
                if (slice.every((c, idx) => c === pattern[idx])) {
                    const follower = seqNoW[i + L];
                    if (follower === 'R' || follower === 'B') {
                        followers.push(follower);
                    }
                }
            }
            if (followers.length === 0) return null;
            let r = 0, b = 0;
            followers.forEach(c => { if (c === 'R') r++; else if (c === 'B') b++; });
            const total = r + b;
            if (total === 0) return null;
            const pR = r / total;
            const pB = b / total;
            if (pR >= nextThreshold && pR > pB) return 'R';
            if (pB >= nextThreshold && pB > pR) return 'B';
            return null;
        };
        
        const markovOrderK = (window, k) => {
            if (window.length <= k) return null;
            const transitions = {};
            const clean = window.filter(c => c === 'R' || c === 'B'); // ignorar W
            if (clean.length <= k) return null;
            for (let i = 0; i + k < clean.length; i++) {
                const key = clean.slice(i, i + k).join('');
                const next = clean[i + k];
                if (next !== 'R' && next !== 'B') continue;
                if (!transitions[key]) transitions[key] = { R: 0, B: 0 };
                transitions[key][next]++;
            }
            const lastSeq = clean.slice(clean.length - k).join('');
            const stats = transitions[lastSeq];
            if (!stats) return null;
            if (stats.R === 0 && stats.B === 0) return null;
            return stats.R >= stats.B ? 'R' : 'B';
        };
        
        const momentumCompare = (window, splitRatio, delta) => {
            const nonWhite = window.filter(c => c !== 'W');
            if (nonWhite.length < 4) return null;
            const splitIndex = Math.max(1, Math.min(nonWhite.length - 1, Math.floor(nonWhite.length * splitRatio)));
            const prev = nonWhite.slice(0, splitIndex);
            const recent = nonWhite.slice(splitIndex);
            const countStats = arr => {
                let r = 0, b = 0;
                arr.forEach(c => { if (c === 'R') r++; else if (c === 'B') b++; });
                const total = r + b;
                if (total === 0) return { pR: 0, pB: 0 };
                return { pR: r / total, pB: b / total };
            };
            const prevStats = countStats(prev);
            const recentStats = countStats(recent);
            const diffR = recentStats.pR - prevStats.pR;
            const diffB = recentStats.pB - prevStats.pB;
            if (Math.abs(diffR) < delta && Math.abs(diffB) < delta) return null;
            if (diffR > diffB && diffR >= delta) return 'R';
            if (diffB > diffR && diffB >= delta) return 'B';
            return null;
        };
        
        const retraction = (window, upperThresh) => {
            let r = 0, b = 0;
            for (const c of window) {
                if (c === 'R') r++;
                else if (c === 'B') b++;
            }
            const total = r + b;
            if (total === 0) return null;
            const pR = r / total;
            const pB = b / total;
            if (pR >= upperThresh && pR > pB) return 'B';
            if (pB >= upperThresh && pB > pR) return 'R';
            return null;
        };
        
        const weightedRecency = (window, mode) => {
            let score = 0;
            const n = window.length;
            for (let i = 0; i < n; i++) {
                const c = window[i];
                if (c !== 'R' && c !== 'B') continue;
                const pos = i + 1; // mais antigo = menor peso
                let w;
                if (mode === 'exp') {
                    w = Math.pow(1.3, pos);
                } else {
                    w = pos;
                }
                const sign = c === 'R' ? 1 : -1;
                score += sign * w;
            }
            if (score > 0) return 'R';
            if (score < 0) return 'B';
            return null;
        };
        
        // Gerar conjunto determinÃ­stico de configuraÃ§Ãµes
        const configs = [];
        
        // majority simples
        configs.push({ type: 'majority', params: {} });
        
        // majority_threshold
        [0.55, 0.6, 0.65, 0.7].forEach(thresh => {
            configs.push({ type: 'majority_threshold', params: { thresh } });
        });
        
        // last_pattern
        [2, 3, 4, 5].forEach(L => {
            [0.6, 0.7].forEach(next_threshold => {
                configs.push({ type: 'last_pattern', params: { L, next_threshold } });
            });
        });
        
        // markov
        [1, 2, 3].forEach(k => {
            configs.push({ type: 'markov', params: { k } });
        });
        
        // momentum
        [0.3, 0.4, 0.5].forEach(split_ratio => {
            [0.05, 0.1].forEach(delta => {
                configs.push({ type: 'momentum', params: { split_ratio, delta } });
            });
        });
        
        // retraction
        [0.7, 0.75, 0.8].forEach(upper => {
            configs.push({ type: 'retraction', params: { upper } });
        });
        
        // weighted recency
        ['linear', 'exp'].forEach(mode => {
            configs.push({ type: 'weighted_recency', params: { mode } });
        });
        
        // Garantir limite de anÃ¡lises
        const limitedConfigs = configs.slice(0, analysesToRun);
        
        const summary = [];
        const detailsByConfig = new Map();
        
        const applyAnalysis = (cfg, window) => {
            switch (cfg.type) {
                case 'majority': return majority(window);
                case 'majority_threshold': return majorityThreshold(window, cfg.params.thresh);
                case 'last_pattern': return lastPattern(window, cfg.params.L, cfg.params.next_threshold);
                case 'markov': return markovOrderK(window, cfg.params.k);
                case 'momentum': return momentumCompare(window, cfg.params.split_ratio, cfg.params.delta);
                case 'retraction': return retraction(window, cfg.params.upper);
                case 'weighted_recency': return weightedRecency(window, cfg.params.mode);
                default: return null;
            }
        };
        
        for (let idx = 0; idx < limitedConfigs.length; idx++) {
            const cfg = limitedConfigs[idx];
            const cfgId = `${cfg.type}#${idx}`;
            const preds = [];
            const trues = [];
            const details = [];
            
            for (let j = 0; j < n_windows; j++) {
                const { window, target, start, targetIdx } = windows[j];
                const pred = applyAnalysis(cfg, window);
                
                if (pred === null || (target !== 'R' && target !== 'B')) {
                    continue;
                }
                
                preds.push(pred);
                trues.push(target);
                details.push({ start, targetIdx, pred, target });
            }
            
            const n_preds = preds.length;
            let accuracy = null;
            let coverage = 0;
            let acc_recent = null;
            
            if (n_preds > 0) {
                let hits = 0;
                for (let i = 0; i < n_preds; i++) {
                    if (preds[i] === trues[i]) hits++;
                }
                accuracy = hits / n_preds;
                coverage = n_preds / n_windows;
                
                const half = Math.max(1, Math.floor(n_preds / 2));
                let recentHits = 0;
                for (let i = n_preds - half; i < n_preds; i++) {
                    if (preds[i] === trues[i]) recentHits++;
                }
                acc_recent = recentHits / half;
            }
            
            summary.push({
                cfg,
                cfgId,
                n_preds,
                accuracy,
                coverage,
                acc_recent
            });
            detailsByConfig.set(cfgId, details);
        }
        
        const valid = summary.filter(rec => rec.n_preds >= minWindowsRequired && rec.accuracy !== null);
        if (valid.length === 0) {
            console.log('âš ï¸ [N10] Nenhuma anÃ¡lise elegÃ­vel (n_preds < minWindowsRequired)');
            return { enabled: false };
        }
        
        valid.sort((a, b) => {
            if (b.accuracy !== a.accuracy) return b.accuracy - a.accuracy;
            if ((b.acc_recent || 0) !== (a.acc_recent || 0)) return (b.acc_recent || 0) - (a.acc_recent || 0);
            if (b.coverage !== a.coverage) return b.coverage - a.coverage;
            if (b.n_preds !== a.n_preds) return b.n_preds - a.n_preds;
            if (a.cfg.type < b.cfg.type) return -1;
            if (a.cfg.type > b.cfg.type) return 1;
            return 0;
        });
        
        const best = valid[0];
        const bestCfg = best.cfg;
        const bestDetails = detailsByConfig.get(best.cfgId) || [];
        
        const lastWindowStart = (m - 1) * windowSize;
        const lastWindow = seq.slice(lastWindowStart, lastWindowStart + windowSize);
        const pred_live = applyAnalysis(bestCfg, lastWindow);
        
        if (pred_live !== 'R' && pred_live !== 'B') {
            console.log('âš ï¸ [N10] Melhor anÃ¡lise nÃ£o conseguiu votar na Ãºltima janela (voto nulo)');
            return { enabled: false, bestConfig: bestCfg, metrics: best };
        }
        
        const accuracyVal = best.accuracy || 0;
        const accRecentVal = best.acc_recent != null ? best.acc_recent : accuracyVal;
        const coverageVal = best.coverage || 0;
        let conf = 0.5 * accuracyVal + 0.4 * accRecentVal + 0.1 * coverageVal;
        conf = Math.max(0, Math.min(1, conf));
        
        if (conf < confMin) {
            const confPct = (conf * 100).toFixed(1);
            const confMinPct = (confMin * 100).toFixed(1);
            console.log(`âš ï¸ [N10] ConfianÃ§a ${confPct}% abaixo do mÃ­nimo configurado (${confMinPct}%) - voto neutro`);
            return {
                enabled: false,
                bestConfig: bestCfg,
                metrics: {
                    accuracy: accuracyVal,
                    acc_recent: accRecentVal,
                    coverage: coverageVal,
                    n_preds: best.n_preds,
                    n_windows
                },
                summaryText: `N10 - Walk-forward â†’ NULO (conf. ${confPct}% < mÃ­nimo ${confMinPct}% | melhor anÃ¡lise ${bestCfg.type}, W=${windowSize}, hist=${N_total}, acurÃ¡cia ${(accuracyVal * 100).toFixed(1)}%, coverage ${(coverageVal * 100).toFixed(1)}%, n_preds=${best.n_preds}/${n_windows})`
            };
        }
        
        const color = pred_live === 'R' ? 'red' : 'black';
        
        const confPct = (conf * 100).toFixed(1);
        console.log(`âœ… [N10] Melhor anÃ¡lise: ${bestCfg.type} | acurÃ¡cia ${(accuracyVal * 100).toFixed(1)}% | acc_recent ${(accRecentVal * 100).toFixed(1)}% | coverage ${(coverageVal * 100).toFixed(1)}% | n_preds=${best.n_preds}/${n_windows}`);
        console.log(`ğŸ¯ [N10] Voto ao vivo: ${color.toUpperCase()} (confianÃ§a ${confPct}%)`);
        
        const summaryText = `N10 - Walk-forward â†’ ${color.toUpperCase()} (${confPct}% | melhor anÃ¡lise: ${bestCfg.type}, W=${windowSize}, hist=${N_total}, acurÃ¡cia ${(accuracyVal * 100).toFixed(1)}%, coverage ${(coverageVal * 100).toFixed(1)}%, n_preds=${best.n_preds}/${n_windows})`;
        
        return {
            enabled: true,
            color,
            confidence: conf, // 0..1
            metrics: {
                accuracy: accuracyVal,
                acc_recent: accRecentVal,
                coverage: coverageVal,
                n_preds: best.n_preds,
                n_windows
            },
            bestConfig: bestCfg,
            summaryText
        };
    } catch (e) {
        console.error('âŒ Erro em runDiamondLevelN10Legacy:', e);
        return {
            enabled: false,
            summaryText: 'N10 - Walk-forward â†’ NULO (erro interno na anÃ¡lise)'
        };
    }
}

function formatN8Number(value, digits = 2) {
    const num = Number(value);
    if (!Number.isFinite(num)) return 'n/a';
    return num.toFixed(digits);
}

function createN8ConfigId(index) {
    return `N8CFG-${String(index).padStart(4, '0')}`;
}

function describeN8Config(cfg) {
    if (!cfg || !cfg.family) return 'desconhecido';
    const params = cfg.params || {};
    switch (cfg.family) {
        case 'dominance_threshold':
            return `dominance_threshold (thresh=${formatN8Number(params.thresh)}, delta=${formatN8Number(params.delta)})`;
        case 'segmented_dominance':
            return `segmented_dominance (segments=${params.segments ?? 'n/a'}, seg_thresh=${formatN8Number(params.seg_thresh)}, delta=${formatN8Number(params.delta)})`;
        case 'recency_weighted':
            return `recency_weighted (${params.mode || 'linear'}, decay=${formatN8Number(params.decay)}, min_delta=${formatN8Number(params.min_delta)})`;
        case 'momentum_split':
            return `momentum_split (split=${formatN8Number(params.split_ratio)}, delta=${formatN8Number(params.delta)})`;
        case 'markov_chain':
            return `markov_chain (order=${params.order ?? 'n/a'}, prob=${formatN8Number(params.prob_thresh)}, support=${params.min_support ?? 'n/a'})`;
        case 'pattern_follow':
            return `pattern_follow (length=${params.length ?? 'n/a'}, next=${formatN8Number(params.next_threshold)}, min_occ=${params.min_occurrences ?? 'n/a'})`;
        case 'streak_bias':
            return `streak_bias (${params.mode || 'continue'}, min_run=${params.min_run ?? 'n/a'}, tolerance=${formatN8Number(params.tolerance)})`;
        case 'entropy_shift':
            return `entropy_shift (delta=${formatN8Number(params.delta)}, variance=${formatN8Number(params.variance)})`;
        case 'lagged_correlation':
            return `lagged_correlation (lag=${params.lag ?? 'n/a'}, bias=${formatN8Number(params.bias_thresh)}, support=${params.min_support ?? 'n/a'})`;
        case 'compound_vote':
            return `compound_vote (parts=${Array.isArray(params.parts) ? params.parts.length : 0}, min_hits=${params.min_hits ?? 'n/a'})`;
        default:
            return `${cfg.family}`;
    }
}

function encodeN8ConfigVector(cfg) {
    const vector = [];
    if (!cfg || !cfg.family) return [0, 0, 0, 0, 0, 0, 0, 0];
    const familyIndex = Math.max(0, N8_FAMILY_LIST.indexOf(cfg.family));
    vector.push(familyIndex / Math.max(1, N8_FAMILY_LIST.length - 1));
    const params = cfg.params || {};
    switch (cfg.family) {
        case 'dominance_threshold': {
            const thresh = clamp01(params.thresh ?? 0.6);
            const delta = clamp01(params.delta ?? 0.05);
            vector.push(thresh, delta, 0, 0, 0, 0, 0);
            break;
        }
        case 'segmented_dominance': {
            const segments = Math.max(2, Math.min(10, Number(params.segments) || 4));
            const segThresh = clamp01(params.seg_thresh ?? 0.6);
            const delta = clamp01(params.delta ?? 0.05);
            vector.push(segments / 10, segThresh, delta, 0, 0, 0, 0);
            break;
        }
        case 'recency_weighted': {
            const decay = clamp01(params.decay ?? 0.9);
            const minDelta = clamp01(params.min_delta ?? 0.08);
            const modeHash = hashStringToUnit(String(params.mode || 'linear'));
            vector.push(decay, minDelta, modeHash, 0, 0, 0, 0);
            break;
        }
        case 'momentum_split': {
            const split = clamp01(params.split_ratio ?? 0.45);
            const delta = clamp01(params.delta ?? 0.1);
            vector.push(split, delta, 0, 0, 0, 0, 0);
            break;
        }
        case 'markov_chain': {
            const order = Math.max(1, Math.min(4, Number(params.order) || 1));
            const prob = clamp01(params.prob_thresh ?? 0.6);
            const support = Math.max(2, Math.min(20, Number(params.min_support) || (order + 2)));
            vector.push(order / 4, prob, support / 20, 0, 0, 0, 0);
            break;
        }
        case 'pattern_follow': {
            const length = Math.max(2, Math.min(6, Number(params.length) || 3));
            const next = clamp01(params.next_threshold ?? 0.65);
            const minOcc = Math.max(1, Math.min(12, Number(params.min_occurrences) || 2));
            vector.push(length / 6, next, minOcc / 12, 0, 0, 0, 0);
            break;
        }
        case 'streak_bias': {
            const modeHash = hashStringToUnit(String(params.mode || 'continue'));
            const minRun = Math.max(1, Math.min(12, Number(params.min_run) || 3));
            const tolerance = clamp01(params.tolerance ?? 0.25);
            vector.push(modeHash, minRun / 12, tolerance, 0, 0, 0, 0);
            break;
        }
        case 'entropy_shift': {
            const delta = clamp01(params.delta ?? 0.15);
            const variance = clamp01(params.variance ?? 0.08);
            vector.push(delta, variance, 0, 0, 0, 0, 0);
            break;
        }
        case 'lagged_correlation': {
            const lag = Math.max(1, Math.min(10, Number(params.lag) || 2));
            const bias = clamp01(params.bias_thresh ?? 0.12);
            const support = Math.max(2, Math.min(30, Number(params.min_support) || (lag + 2)));
            vector.push(lag / 10, bias, support / 30, 0, 0, 0, 0);
            break;
        }
        case 'compound_vote': {
            const parts = Array.isArray(params.parts) ? params.parts.length : 0;
            const minHits = Math.max(1, Math.min(parts, Number(params.min_hits) || Math.ceil(parts * 0.6)));
            vector.push(parts / 6, minHits / Math.max(1, parts), 0, 0, 0, 0, 0);
            break;
        }
        default:
            vector.push(0, 0, 0, 0, 0, 0, 0);
    }
    while (vector.length < 8) {
        vector.push(0);
    }
    return vector;
}

function n8ConfigDistance(vectorA, vectorB) {
    const len = Math.min(vectorA.length, vectorB.length);
    let sum = 0;
    for (let i = 0; i < len; i++) {
        const diff = vectorA[i] - vectorB[i];
        sum += diff * diff;
    }
    return Math.sqrt(sum);
}

function maybePersistN8ConfigLibrary(configs) {
    try {
        if (typeof chrome !== 'undefined' && chrome.storage && chrome.storage.local) {
            chrome.storage.local.set({ [N8_CONFIG_LIBRARY_KEY]: configs });
        }
    } catch (error) {
        console.debug('âš ï¸ [N8] Falha ao persistir biblioteca de configs:', error);
    }
}

function buildN8BaseConfigs() {
    const base = [];
    const add = (family, params) => base.push({ family, params });

    [0.56, 0.6, 0.64, 0.68].forEach(thresh => {
        [0.03, 0.05, 0.08].forEach(delta => add('dominance_threshold', { thresh, delta }));
    });

    [3, 4, 5, 6].forEach(segments => {
        [0.58, 0.62, 0.68].forEach(seg_thresh => {
            [0.03, 0.05].forEach(delta => add('segmented_dominance', { segments, seg_thresh, delta }));
        });
    });

    ['linear', 'exp'].forEach(mode => {
        [0.84, 0.88, 0.92, 0.96].forEach(decay => {
            [0.06, 0.1, 0.15].forEach(min_delta => add('recency_weighted', { mode, decay, min_delta }));
        });
    });

    [0.35, 0.4, 0.45, 0.5].forEach(split_ratio => {
        [0.08, 0.12, 0.16].forEach(delta => add('momentum_split', { split_ratio, delta }));
    });

    [1, 2, 3].forEach(order => {
        [0.55, 0.6, 0.66].forEach(prob_thresh => {
            [order + 1, order + 3, order + 5].forEach(min_support =>
                add('markov_chain', { order, prob_thresh, min_support })
            );
        });
    });

    [2, 3, 4].forEach(length => {
        [0.6, 0.68, 0.75].forEach(next_threshold => {
            [2, 3, 4].forEach(min_occurrences =>
                add('pattern_follow', { length, next_threshold, min_occurrences })
            );
        });
    });

    ['continue', 'revert'].forEach(mode => {
        [2, 3, 4].forEach(min_run => {
            [0.2, 0.3, 0.4].forEach(tolerance =>
                add('streak_bias', { mode, min_run, tolerance })
            );
        });
    });

    [0.12, 0.18, 0.24].forEach(delta => {
        [0.06, 0.1, 0.14].forEach(variance =>
            add('entropy_shift', { delta, variance })
        );
    });

    [2, 3, 4, 5].forEach(lag => {
        [0.1, 0.14, 0.18].forEach(bias_thresh => {
            [lag + 1, lag + 3, lag + 5].forEach(min_support =>
                add('lagged_correlation', { lag, bias_thresh, min_support })
            );
        });
    });

    // Compound combinations
    const compoundSeeds = [
        {
            parts: [
                { family: 'dominance_threshold', params: { thresh: 0.6, delta: 0.05 } },
                { family: 'recency_weighted', params: { mode: 'exp', decay: 0.9, min_delta: 0.08 } },
                { family: 'momentum_split', params: { split_ratio: 0.4, delta: 0.12 } }
            ],
            min_hits: 2
        },
        {
            parts: [
                { family: 'markov_chain', params: { order: 2, prob_thresh: 0.6, min_support: 6 } },
                { family: 'pattern_follow', params: { length: 3, next_threshold: 0.68, min_occurrences: 3 } }
            ],
            min_hits: 2
        },
        {
            parts: [
                { family: 'streak_bias', params: { mode: 'continue', min_run: 3, tolerance: 0.25 } },
                { family: 'segmented_dominance', params: { segments: 4, seg_thresh: 0.62, delta: 0.05 } },
                { family: 'lagged_correlation', params: { lag: 3, bias_thresh: 0.14, min_support: 6 } }
            ],
            min_hits: 2
        }
    ];
    compoundSeeds.forEach(seed => add('compound_vote', seed));

    return base;
}

function sampleRandomN8Config(rng, family) {
    const pick = (arr) => arr[Math.floor(rng() * arr.length)];
    switch (family) {
        case 'dominance_threshold':
            return {
                family,
                params: {
                    thresh: 0.53 + rng() * 0.2,
                    delta: 0.02 + rng() * 0.08
                }
            };
        case 'segmented_dominance':
            return {
                family,
                params: {
                    segments: Math.floor(3 + rng() * 4),
                    seg_thresh: 0.55 + rng() * 0.25,
                    delta: 0.02 + rng() * 0.08
                }
            };
        case 'recency_weighted':
            return {
                family,
                params: {
                    mode: rng() < 0.5 ? 'linear' : 'exp',
                    decay: 0.82 + rng() * 0.16,
                    min_delta: 0.05 + rng() * 0.12
                }
            };
        case 'momentum_split':
            return {
                family,
                params: {
                    split_ratio: 0.32 + rng() * 0.26,
                    delta: 0.06 + rng() * 0.14
                }
            };
        case 'markov_chain':
            return {
                family,
                params: {
                    order: Math.floor(1 + rng() * 3),
                    prob_thresh: 0.52 + rng() * 0.25,
                    min_support: Math.floor(3 + rng() * 8)
                }
            };
        case 'pattern_follow':
            return {
                family,
                params: {
                    length: Math.floor(2 + rng() * 4),
                    next_threshold: 0.58 + rng() * 0.25,
                    min_occurrences: Math.floor(2 + rng() * 4)
                }
            };
        case 'streak_bias':
            return {
                family,
                params: {
                    mode: rng() < 0.5 ? 'continue' : 'revert',
                    min_run: Math.floor(2 + rng() * 4),
                    tolerance: 0.15 + rng() * 0.35
                }
            };
        case 'entropy_shift':
            return {
                family,
                params: {
                    delta: 0.1 + rng() * 0.2,
                    variance: 0.05 + rng() * 0.12
                }
            };
        case 'lagged_correlation':
            return {
                family,
                params: {
                    lag: Math.floor(2 + rng() * 4),
                    bias_thresh: 0.08 + rng() * 0.18,
                    min_support: Math.floor(3 + rng() * 10)
                }
            };
        case 'compound_vote': {
            const partFamilies = ['dominance_threshold', 'recency_weighted', 'momentum_split', 'markov_chain', 'pattern_follow', 'streak_bias'];
            const partsCount = Math.floor(2 + rng() * 2);
            const parts = [];
            for (let i = 0; i < partsCount; i++) {
                const fam = pick(partFamilies);
                parts.push(sampleRandomN8Config(rng, fam));
            }
            const min_hits = Math.max(1, Math.min(parts.length, Math.floor(1 + rng() * parts.length)));
            return { family, params: { parts, min_hits } };
        }
        default:
            return null;
    }
}

function tryAddN8Config(candidate, accepted, acceptedVectors, diversityThreshold) {
    if (!candidate || !candidate.family) return false;
    const vector = encodeN8ConfigVector(candidate);
    for (const existing of acceptedVectors) {
        if (n8ConfigDistance(vector, existing) < diversityThreshold) {
            return false;
        }
    }
    accepted.push(candidate);
    acceptedVectors.push(vector);
    return true;
}

function generateN8Configs(count, seed = N8_DEFAULTS.seed) {
    if (n8ConfigLibraryCache && n8ConfigLibraryCache.length >= count && n8ConfigLibrarySeed === seed) {
        return n8ConfigLibraryCache.slice(0, count);
    }

    const rng = createSeededRandomGenerator(seed);
    const baseConfigs = buildN8BaseConfigs();
    const accepted = [];
    const acceptedVectors = [];
    const familyCounts = {};
    let diversityThreshold = N8_DIVERSITY_MIN_DISTANCE_BASE;

    const pushWithDiversity = (cfg, allowRelax = false) => {
        if (!cfg) return false;
        const success = tryAddN8Config(cfg, accepted, acceptedVectors, diversityThreshold);
        if (success) {
            familyCounts[cfg.family] = (familyCounts[cfg.family] || 0) + 1;
        } else if (allowRelax && diversityThreshold > 0.06) {
            const relaxed = tryAddN8Config(cfg, accepted, acceptedVectors, diversityThreshold * 0.9);
            if (relaxed) {
                familyCounts[cfg.family] = (familyCounts[cfg.family] || 0) + 1;
            }
            return relaxed;
        }
        return success;
    };

    baseConfigs.forEach(cfg => {
        if (accepted.length < count) {
            pushWithDiversity(cfg, true);
        }
    });

    let attempts = 0;
    const maxAttempts = count * 60;
    while (accepted.length < count && attempts < maxAttempts) {
        const family = N8_FAMILY_LIST[Math.floor(rng() * N8_FAMILY_LIST.length)];
        const candidate = sampleRandomN8Config(rng, family);
        if (!pushWithDiversity(candidate, true) && attempts % N8_FAMILY_LIST.length === 0 && diversityThreshold > 0.06) {
            diversityThreshold *= 0.97;
        }
        attempts++;
    }

    N8_FAMILY_LIST.forEach(family => {
        while ((familyCounts[family] || 0) < N8_FAMILY_MIN_PER_TYPE && accepted.length < count) {
            const candidate = sampleRandomN8Config(rng, family);
            if (!pushWithDiversity(candidate, true)) {
                break;
            }
        }
    });

    diversityThreshold = Math.max(0.04, diversityThreshold);
    while (accepted.length < count) {
        const candidate = sampleRandomN8Config(rng, N8_FAMILY_LIST[Math.floor(rng() * N8_FAMILY_LIST.length)]);
        if (!candidate) continue;
        if (!pushWithDiversity(candidate, true)) {
            if (diversityThreshold > 0.04) {
                diversityThreshold *= 0.95;
            } else {
                accepted.push(candidate);
                acceptedVectors.push(encodeN8ConfigVector(candidate));
                familyCounts[candidate.family] = (familyCounts[candidate.family] || 0) + 1;
            }
        }
    }

    const trimmed = accepted.slice(0, count).map((cfg, index) => ({
        id: createN8ConfigId(index),
        family: cfg.family,
        params: cfg.params || {},
        description: describeN8Config(cfg)
    }));

    n8ConfigLibraryCache = trimmed;
    n8ConfigLibrarySeed = seed;
    maybePersistN8ConfigLibrary(trimmed);

    return trimmed;
}

function buildN8WindowContext(windows) {
    return {
        stats: windows.map(entry => computeWindowStats(entry.window)),
        clean: windows.map(entry => entry.window.filter(char => char === 'R' || char === 'B')),
        windows
    };
}

function applyN8Config(cfg, windowChars, idxWindow, windows, context, depth = 0) {
    if (!cfg || !cfg.family || !Array.isArray(windowChars) || windowChars.length === 0) {
        return { prediction: null, confidence: 0 };
    }
    if (depth > 3) {
        return { prediction: null, confidence: 0 };
    }

    const params = cfg.params || {};
    const stats = context.stats[idxWindow] || computeWindowStats(windowChars);
    const clean = context.clean[idxWindow] || windowChars.filter(char => char === 'R' || char === 'B');

    switch (cfg.family) {
        case 'dominance_threshold': {
            const thresh = clamp01(params.thresh ?? 0.6);
            const delta = clamp01(params.delta ?? 0.05);
            const pR = stats.pR || 0;
            const pB = stats.pB || 0;
            if (pR >= thresh && (pR - pB) >= delta) {
                return { prediction: 'R', confidence: clamp01(pR) };
            }
            if (pB >= thresh && (pB - pR) >= delta) {
                return { prediction: 'B', confidence: clamp01(pB) };
            }
            const diff = Math.abs(pR - pB);
            if (diff >= delta * 0.7 && (pR + pB) > 0) {
                const color = pR >= pB ? 'R' : 'B';
                return { prediction: color, confidence: clamp01(Math.max(pR, pB)) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'segmented_dominance': {
            const segments = Math.max(2, Math.min(12, Number(params.segments) || 4));
            const segThresh = clamp01(params.seg_thresh ?? 0.6);
            const delta = clamp01(params.delta ?? 0.05);
            const len = windowChars.length;
            const segSize = Math.max(1, Math.floor(len / segments));
            let bestColor = null;
            let bestScore = 0;
            for (let s = 0; s < segments; s++) {
                const start = s * segSize;
                const end = s === segments - 1 ? len : Math.min(len, start + segSize);
                if (start >= len) break;
                let reds = 0;
                let blacks = 0;
                for (let i = start; i < end; i++) {
                    const c = windowChars[i];
                    if (c === 'R') reds++;
                    else if (c === 'B') blacks++;
                }
                const total = reds + blacks;
                if (total === 0) continue;
                const frac = Math.max(reds, blacks) / total;
                if (frac >= segThresh && frac > bestScore) {
                    bestScore = frac;
                    bestColor = reds >= blacks ? 'R' : 'B';
                }
            }
            if (bestColor) {
                return { prediction: bestColor, confidence: clamp01(bestScore + delta) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'recency_weighted': {
            const mode = params.mode === 'linear' ? 'linear' : 'exp';
            const decay = clamp01(params.decay ?? 0.9);
            const minDelta = clamp01(params.min_delta ?? 0.08);
            if (clean.length === 0) return { prediction: null, confidence: 0 };
            let score = 0;
            let totalWeight = 0;
            if (mode === 'exp') {
                let weight = 1;
                for (let i = clean.length - 1; i >= 0; i--) {
                    const color = clean[i];
                    if (color !== 'R' && color !== 'B') continue;
                    const sign = color === 'R' ? 1 : -1;
                    score += sign * weight;
                    totalWeight += Math.abs(weight);
                    weight *= decay;
                }
            } else {
                for (let i = 0; i < clean.length; i++) {
                    const color = clean[i];
                    if (color !== 'R' && color !== 'B') continue;
                    const weight = i + 1;
                    const sign = color === 'R' ? 1 : -1;
                    score += sign * weight;
                    totalWeight += weight;
                }
            }
            if (totalWeight === 0) return { prediction: null, confidence: 0 };
            const normalized = score / totalWeight;
            if (Math.abs(normalized) < minDelta) {
                return { prediction: null, confidence: 0 };
            }
            const color = normalized >= 0 ? 'R' : 'B';
            return { prediction: color, confidence: clamp01(Math.abs(normalized)) };
        }
        case 'momentum_split': {
            const splitRatio = clamp01(params.split_ratio ?? 0.45);
            const delta = clamp01(params.delta ?? 0.1);
            if (clean.length < 4) return { prediction: null, confidence: 0 };
            const splitIndex = Math.max(1, Math.min(clean.length - 1, Math.floor(clean.length * splitRatio)));
            const prev = clean.slice(0, splitIndex);
            const recent = clean.slice(splitIndex);
            const countStats = (arr) => {
                let r = 0;
                let b = 0;
                arr.forEach(c => {
                    if (c === 'R') r++;
                    else if (c === 'B') b++;
                });
                const total = r + b;
                return {
                    pR: total > 0 ? r / total : 0,
                    pB: total > 0 ? b / total : 0
                };
            };
            const prevStats = countStats(prev);
            const recentStats = countStats(recent);
            const diffR = recentStats.pR - prevStats.pR;
            const diffB = recentStats.pB - prevStats.pB;
            if (Math.abs(diffR) < delta && Math.abs(diffB) < delta) {
                return { prediction: null, confidence: 0 };
            }
            if (diffR > diffB && diffR >= delta) {
                return { prediction: 'R', confidence: clamp01(diffR) };
            }
            if (diffB > diffR && diffB >= delta) {
                return { prediction: 'B', confidence: clamp01(diffB) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'markov_chain': {
            const order = Math.max(1, Math.min(4, Number(params.order) || 1));
            const probThresh = clamp01(params.prob_thresh ?? 0.6);
            const minSupport = Math.max(order + 1, Number(params.min_support) || (order + 2));
            if (clean.length <= order) return { prediction: null, confidence: 0 };
            const transitions = {};
            for (let i = 0; i + order < clean.length; i++) {
                const key = clean.slice(i, i + order).join('');
                const next = clean[i + order];
                if (next !== 'R' && next !== 'B') continue;
                if (!transitions[key]) transitions[key] = { R: 0, B: 0 };
                transitions[key][next] += 1;
            }
            const lastKey = clean.slice(-order).join('');
            const statsKey = transitions[lastKey];
            if (!statsKey) return { prediction: null, confidence: 0 };
            const total = statsKey.R + statsKey.B;
            if (total < minSupport) return { prediction: null, confidence: 0 };
            const pR = statsKey.R / total;
            const pB = statsKey.B / total;
            if (pR >= probThresh && pR > pB) {
                return { prediction: 'R', confidence: clamp01(pR) };
            }
            if (pB >= probThresh && pB > pR) {
                return { prediction: 'B', confidence: clamp01(pB) };
            }
            const diff = Math.abs(pR - pB);
            if (diff >= 0.15) {
                const color = pR >= pB ? 'R' : 'B';
                return { prediction: color, confidence: clamp01(Math.max(pR, pB)) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'pattern_follow': {
            const length = Math.max(2, Math.min(6, Number(params.length) || 3));
            const nextThreshold = clamp01(params.next_threshold ?? 0.65);
            const minOccurrences = Math.max(1, Number(params.min_occurrences) || 2);
            if (clean.length <= length) return { prediction: null, confidence: 0 };
            const pattern = clean.slice(clean.length - length);
            let followersR = 0;
            let followersB = 0;
            let occurrences = 0;
            const arraysEqual = (a, b) => a.length === b.length && a.every((val, idx) => val === b[idx]);
            for (let i = 0; i + length < clean.length; i++) {
                const slice = clean.slice(i, i + length);
                if (arraysEqual(slice, pattern)) {
                    occurrences += 1;
                    const follower = clean[i + length];
                    if (follower === 'R') followersR += 1;
                    if (follower === 'B') followersB += 1;
                }
            }
            if (occurrences < minOccurrences) return { prediction: null, confidence: 0 };
            const totalFollowers = followersR + followersB;
            if (totalFollowers === 0) return { prediction: null, confidence: 0 };
            const pR = followersR / totalFollowers;
            const pB = followersB / totalFollowers;
            if (pR >= nextThreshold && pR > pB) {
                return { prediction: 'R', confidence: clamp01(pR) };
            }
            if (pB >= nextThreshold && pB > pR) {
                return { prediction: 'B', confidence: clamp01(pB) };
            }
            return { prediction: null, confidence: 0 };
        }
        case 'streak_bias': {
            if (clean.length === 0) return { prediction: null, confidence: 0 };
            const mode = params.mode === 'revert' ? 'revert' : 'continue';
            const minRun = Math.max(1, Number(params.min_run) || 3);
            const tolerance = clamp01(params.tolerance ?? 0.25);
            const lastColor = clean[clean.length - 1];
            let currentRun = 1;
            for (let i = clean.length - 2; i >= 0; i--) {
                if (clean[i] === lastColor) currentRun += 1;
                else break;
            }
            let runSumR = 0;
            let runCountR = 0;
            let runSumB = 0;
            let runCountB = 0;
            let currentColor = clean[0];
            let runLength = 1;
            for (let i = 1; i < clean.length; i++) {
                if (clean[i] === currentColor) {
                    runLength += 1;
                } else {
                    if (currentColor === 'R') {
                        runSumR += runLength;
                        runCountR += 1;
                    } else if (currentColor === 'B') {
                        runSumB += runLength;
                        runCountB += 1;
                    }
                    currentColor = clean[i];
                    runLength = 1;
                }
            }
            if (currentColor === 'R') {
                runSumR += runLength;
                runCountR += 1;
            } else if (currentColor === 'B') {
                runSumB += runLength;
                runCountB += 1;
            }
            const avgR = runCountR > 0 ? runSumR / runCountR : 1;
            const avgB = runCountB > 0 ? runSumB / runCountB : 1;
            const avgForColor = lastColor === 'R' ? avgR : avgB;
            if (mode === 'continue') {
                if (currentRun >= minRun) {
                    const confidence = clamp01((currentRun / Math.max(1, avgForColor)) + tolerance / 2);
                    return { prediction: lastColor, confidence };
                }
            } else {
                const diff = currentRun - avgForColor;
                if (diff >= Math.max(1, avgForColor * tolerance)) {
                    const opposite = lastColor === 'R' ? 'B' : 'R';
                    const confidence = clamp01(diff / Math.max(1, avgForColor + diff));
                    return { prediction: opposite, confidence };
                }
            }
            return { prediction: null, confidence: 0 };
        }
        case 'entropy_shift': {
            const delta = clamp01(params.delta ?? 0.15);
            const variance = clamp01(params.variance ?? 0.08);
            const entropyDiff = (stats.entropyFirstHalf || 0) - (stats.entropySecondHalf || 0);
            if (Math.abs(entropyDiff) < delta) {
                return { prediction: null, confidence: 0 };
            }
            const bias = (stats.pR || 0) - (stats.pB || 0);
            const color = bias >= 0 ? 'R' : 'B';
            const confidence = clamp01(Math.abs(entropyDiff) + Math.abs(bias) - variance);
            if (confidence <= 0) return { prediction: null, confidence: 0 };
            return { prediction: color, confidence };
        }
        case 'lagged_correlation': {
            const lag = Math.max(1, Math.min(6, Number(params.lag) || 2));
            const biasThresh = clamp01(params.bias_thresh ?? 0.12);
            const minSupport = Math.max(lag + 1, Number(params.min_support) || (lag + 2));
            if (clean.length <= lag) return { prediction: null, confidence: 0 };
            const transitions = {};
            for (let i = lag; i < clean.length; i++) {
                const key = clean.slice(i - lag, i).join('');
                const next = clean[i];
                if (next !== 'R' && next !== 'B') continue;
                if (!transitions[key]) transitions[key] = { R: 0, B: 0 };
                transitions[key][next] += 1;
            }
            const lastKey = clean.slice(-lag).join('');
            const statsKey = transitions[lastKey];
            if (!statsKey) return { prediction: null, confidence: 0 };
            const total = statsKey.R + statsKey.B;
            if (total < minSupport) return { prediction: null, confidence: 0 };
            const bias = Math.abs(statsKey.R - statsKey.B) / total;
            if (bias < biasThresh) return { prediction: null, confidence: 0 };
            const color = statsKey.R >= statsKey.B ? 'R' : 'B';
            return { prediction: color, confidence: clamp01(bias) };
        }
        case 'compound_vote': {
            const parts = Array.isArray(params.parts) ? params.parts : [];
            if (parts.length === 0) return { prediction: null, confidence: 0 };
            const minHits = Math.max(1, Math.min(parts.length, Number(params.min_hits) || Math.ceil(parts.length * 0.6)));
            const results = parts.map(part => applyN8Config(part, windowChars, idxWindow, windows, context, depth + 1));
            const votes = results.filter(res => res && (res.prediction === 'R' || res.prediction === 'B'));
            if (votes.length < minHits) return { prediction: null, confidence: 0 };
            const count = votes.reduce((acc, item) => {
                if (item.prediction === 'R') acc.R += 1;
                else if (item.prediction === 'B') acc.B += 1;
                return acc;
            }, { R: 0, B: 0 });
            const color = count.R > count.B ? 'R' : count.B > count.R ? 'B' : null;
            if (!color) return { prediction: null, confidence: 0 };
            const supporters = votes.filter(item => item.prediction === color);
            if (supporters.length < minHits) return { prediction: null, confidence: 0 };
            const confidence = clamp01(supporters.reduce((acc, item) => acc + clamp01(item.confidence ?? 0), 0) / supporters.length);
            return { prediction: color, confidence };
        }
        default:
            return { prediction: null, confidence: 0 };
    }
}

function computeN8RecentAccuracy(confList) {
    if (!Array.isArray(confList) || confList.length === 0) return 0;
    const half = Math.max(1, Math.floor(confList.length / 2));
    const recent = confList.slice(-half);
    let hits = 0;
    let total = 0;
    recent.forEach(entry => {
        if (!entry || !entry.predictedColor) return;
        total += 1;
        if (entry.predictedColor === entry.targetColor) {
            hits += 1;
        }
    });
    return total > 0 ? hits / total : 0;
}

function evaluateN8Config(windows, cfg, context, options = {}) {
    const { collectLogs = false } = options;
    let TP = 0;
    let FP = 0;
    let FN = 0;
    let nPreds = 0;
    let totalTargets = 0;
    const confList = [];
    const perWindowLog = collectLogs ? [] : null;

    windows.forEach((entry, idx) => {
        const target = entry.target === 'R' || entry.target === 'B' ? entry.target : null;
        if (!target) return;
        totalTargets += 1;
        const result = applyN8Config(cfg, entry.window, idx, windows, context);
        const confidence = clamp01(result.confidence ?? 0);
        const predicted = result.prediction === 'R' || result.prediction === 'B' ? result.prediction : null;

        confList.push({
            confidence,
            predictedColor: predicted,
            targetColor: target,
            isHit: predicted != null && predicted === target
        });

        if (predicted) {
            nPreds += 1;
            if (predicted === target) {
                TP += 1;
            } else {
                FP += 1;
            }
        } else {
            FN += 1;
        }

        if (perWindowLog) {
            perWindowLog.push({
                window_index: entry.index,
                start_idx: entry.start,
                prediction: predicted || '-',
                confidence: Number(confidence.toFixed(4)),
                target,
                result: predicted === target ? 'hit' : predicted ? 'miss' : 'null'
            });
        }
    });

    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    const coverage = windows.length > 0 ? nPreds / windows.length : 0;
    const accuracy = totalTargets > 0 ? TP / totalTargets : 0;
    const accRecent = computeN8RecentAccuracy(confList);

    return {
        cfg,
        metrics: {
            TP,
            FP,
            FN,
            n_preds: nPreds,
            precision,
            recall,
            f1,
            coverage,
            accuracy,
            acc_recent: accRecent,
            n_windows: windows.length,
            targets: totalTargets
        },
        confList,
        perWindowLog
    };
}

function calculateN8ThresholdMetrics(confList, threshold) {
    let TP = 0;
    let FP = 0;
    let FN = 0;
    let considered = 0;
    confList.forEach(entry => {
        if (!entry || !entry.targetColor) return;
        considered += 1;
        const passes = entry.predictedColor && entry.confidence >= threshold;
        if (passes && entry.predictedColor === entry.targetColor) {
            TP += 1;
        } else if (passes && entry.predictedColor !== entry.targetColor) {
            FP += 1;
        } else {
            FN += 1;
        }
    });
    const precision = TP + FP > 0 ? TP / (TP + FP) : 0;
    const recall = TP + FN > 0 ? TP / (TP + FN) : 0;
    const f1 = precision + recall > 0 ? (2 * precision * recall) / (precision + recall) : 0;
    const coverage = considered > 0 ? (TP + FP) / considered : 0;
    return { TP, FP, FN, precision, recall, f1, coverage };
}

function runN8Detector(history, options = {}) {
    const runTimestamp = Date.now();
    const runId = `N8-${runTimestamp}-${Math.floor(Math.random() * 1e6).toString(16)}`;
    try {
        const settings = {
            historySize: Number(options.historySize) > 0 ? Math.floor(options.historySize) : N8_DEFAULTS.historySize,
            windowSize: Number(options.windowSize) > 0 ? Math.floor(options.windowSize) : N8_DEFAULTS.windowSize,
            analysesToRun: Number(options.analysesToRun) > 0 ? Math.floor(options.analysesToRun) : N8_DEFAULTS.analysesToRun,
            minWindowsRequired: Number(options.minWindows) > 0 ? Math.floor(options.minWindows) : N8_DEFAULTS.minWindowsRequired,
            precisionMin: typeof options.precisionMin === 'number' ? clamp01(options.precisionMin) : N8_DEFAULTS.precisionMin,
            confidenceGrid: Array.isArray(options.confidenceGrid) && options.confidenceGrid.length > 0
                ? options.confidenceGrid.map(Number).filter(v => Number.isFinite(v) && v > 0 && v < 1).sort((a, b) => a - b)
                : [...N8_DEFAULTS.confidenceGrid],
            holdoutEnabled: options.holdoutEnabled !== undefined ? !!options.holdoutEnabled : N8_DEFAULTS.holdoutEnabled,
            holdoutTolerance: typeof options.holdoutTolerance === 'number'
                ? clamp01(options.holdoutTolerance)
                : N8_DEFAULTS.holdoutTolerance,
            seed: Number.isFinite(Number(options.seed)) ? Number(options.seed) : N8_DEFAULTS.seed,
            confMinLive: typeof options.confMinLive === 'number'
                ? clamp01(options.confMinLive)
                : N8_DEFAULTS.confMinLive
        };

        const silent = !!options.silent;
        const cacheEnabled = options.cache !== false;
        const assumeStableHistory = !!options.assumeStableHistory;
        const cacheMaxAgeSpinsRaw = Math.floor(Number(options.cacheMaxAgeSpins));
        const cacheMaxAgeSpins = Number.isFinite(cacheMaxAgeSpinsRaw) && cacheMaxAgeSpinsRaw > 0
            ? cacheMaxAgeSpinsRaw
            : Math.max(20, Math.min(60, settings.windowSize));

        // âœ… Determinismo + ordem correta + dedup:
        // - Ao vivo: histÃ³rico pode vir com duplicados e fora de ordem (cache/servidor).
        // - Backtest: histÃ³rico jÃ¡ Ã© estÃ¡vel â†’ pode pular dedup para ficar em segundos.
        const desiredHistory = Math.max(settings.historySize, settings.windowSize * 3);
        const sourceHistory = Array.isArray(history) ? history : [];
        let stableWindow = null;
        let chronologicalHistory = [];
        if (assumeStableHistory) {
            const limit = Math.min(desiredHistory, sourceHistory.length);
            chronologicalHistory = sourceHistory.slice(0, limit).reverse(); // mais recente -> antigo => antigo -> recente
            stableWindow = {
                chronological: chronologicalHistory,
                meta: {
                    availableHistory: sourceHistory.length,
                    uniqueCount: limit,
                    droppedDuplicates: 0,
                    droppedInvalidTs: 0,
                    usedHistoryLimit: limit
                }
            };
        } else {
            stableWindow = getStableChronologicalHistoryWindow({
                limit: Math.min(desiredHistory, sourceHistory.length),
                sourceHistory
            });
            chronologicalHistory = stableWindow.chronological; // antigo -> recente
        }

        const latestSpin = chronologicalHistory.length ? chronologicalHistory[chronologicalHistory.length - 1] : null;
        const latestSpinKey = latestSpin
            ? String(latestSpin.id || latestSpin.timestamp || latestSpin.number || chronologicalHistory.length)
            : `len_${chronologicalHistory.length}`;

        const normalizedHistory = normalizeN0History(chronologicalHistory);
        const trimmedHistory = normalizedHistory.slice(-desiredHistory);

        if (trimmedHistory.length < settings.windowSize + 1) {
            return {
                enabled: false,
                summaryText: `N8 - Walk-forward â†’ NULO (histÃ³rico insuficiente: ${trimmedHistory.length}/${settings.windowSize + 1})`,
                code: 'insufficient_history',
                run_summary: {
                    run_id: runId,
                    timestamp: runTimestamp,
                    requested_history_size: settings.historySize,
                    used_history_size: stableWindow.meta.usedHistoryLimit,
                    available_history: stableWindow.meta.availableHistory,
                    unique_history: stableWindow.meta.uniqueCount
                }
            };
        }

        // âœ… Cache runtime (evita re-treinar em sequÃªncia no backtest)
        const cacheKey = buildN8RuntimeCacheKey(settings);
        const cachedRow = cacheEnabled ? n8RuntimeModelCache.get(cacheKey) : null;
        if (cachedRow && cachedRow.lastSeenSpinKey === latestSpinKey && cachedRow.lastResult) {
            return cachedRow.lastResult;
        }

        const canReuseModel = !!(
            cachedRow &&
            cachedRow.version === N8_RUNTIME_MODEL_CACHE_VERSION &&
            cachedRow.model &&
            (cachedRow.spinsSinceTrain || 0) < cacheMaxAgeSpins
        );

        if (canReuseModel) {
            const model = cachedRow.model;
            const warnings = [];

            const liveWindow = trimmedHistory.slice(-settings.windowSize);
            if (liveWindow.length < settings.windowSize) {
                return {
                    enabled: false,
                    summaryText: 'N8 - Walk-forward â†’ NULO (janela incompleta para previsÃ£o ao vivo)',
                    code: 'incomplete_live_window',
                    run_summary: {
                        run_id: runId,
                        timestamp: runTimestamp,
                        requested_history_size: settings.historySize,
                        used_history_size: stableWindow.meta.usedHistoryLimit,
                        available_history: stableWindow.meta.availableHistory,
                        unique_history: stableWindow.meta.uniqueCount
                    }
                };
            }

            const liveWindows = [{
                window: liveWindow,
                target: null,
                index: 0,
                start: Math.max(0, trimmedHistory.length - settings.windowSize),
                targetIndex: trimmedHistory.length
            }];
            const liveContext = buildN8WindowContext(liveWindows);
            const liveResult = applyN8Config(model.best_config, liveWindow, 0, liveWindows, liveContext);
            const liveConfidence = clamp01(liveResult.confidence ?? 0);
            const livePrediction = liveResult.prediction === 'R' || liveResult.prediction === 'B' ? liveResult.prediction : null;

            const chosenThreshold = clamp01(model.threshold ?? 0);
            const holdoutInfo = model.holdout || { enabled: false, passed: true, reason: null, training: model.threshold_metrics || null, validation: null };
            const thresholdGate = Math.max(settings.confMinLive, chosenThreshold || settings.confMinLive);
            let finalColor = null;
            if (livePrediction && liveConfidence >= thresholdGate && holdoutInfo.passed !== false) {
                finalColor = livePrediction === 'R' ? 'red' : 'black';
            } else if (holdoutInfo.passed === false) {
                warnings.push('PrevisÃ£o ao vivo suprimida devido Ã  reprovaÃ§Ã£o no holdout.');
            } else if (livePrediction && liveConfidence < thresholdGate) {
                warnings.push(`ConfianÃ§a ao vivo ${Math.round(liveConfidence * 100)}% abaixo do limiar ${Math.round(thresholdGate * 100)}%.`);
            }

            const bestMetrics = model.best_metrics || {};
            const trainingStrength = clamp01(
                (bestMetrics.f1 ?? 0) * 0.5 +
                (bestMetrics.precision ?? 0) * 0.2 +
                (bestMetrics.acc_recent ?? 0) * 0.2 +
                (bestMetrics.coverage ?? 0) * 0.1
            );
            const liveBoost = clamp01(
                thresholdGate < 1
                    ? (liveConfidence - thresholdGate) / Math.max(0.05, 1 - thresholdGate)
                    : liveConfidence
            );
            let finalConfidence = clamp01(trainingStrength * 0.6 + liveBoost * 0.4);
            if (holdoutInfo.passed === false) {
                finalConfidence *= 0.5;
            }
            if (!finalColor) {
                finalConfidence = 0;
            }

            const summaryParts = [];
            if (finalColor) {
                summaryParts.push(`N8 - Walk-forward â†’ ${finalColor.toUpperCase()} (${Math.round(finalConfidence * 100)}%)`);
            } else {
                summaryParts.push('N8 - Walk-forward â†’ NULO');
            }
            summaryParts.push(`melhor famÃ­lia: ${(model.best_config && model.best_config.family) ? model.best_config.family : 'n/d'}`);
            summaryParts.push(`F1 ${((bestMetrics.f1 ?? 0) * 100).toFixed(1)}%`);
            summaryParts.push(`precision ${((bestMetrics.precision ?? 0) * 100).toFixed(1)}%`);
            summaryParts.push(`recall ${((bestMetrics.recall ?? 0) * 100).toFixed(1)}%`);
            const summaryText = summaryParts.join(' | ');

            const runSummary = {
                run_id: runId,
                timestamp: runTimestamp,
                cached: true,
                cache_age_spins: cachedRow.spinsSinceTrain || 0,
                requested_history_size: settings.historySize,
                used_history_size: stableWindow.meta.usedHistoryLimit,
                available_history: stableWindow.meta.availableHistory,
                unique_history: stableWindow.meta.uniqueCount,
                dropped_duplicates: stableWindow.meta.droppedDuplicates,
                dropped_invalid_ts: stableWindow.meta.droppedInvalidTs,
                window_size: settings.windowSize,
                analyses_to_run: settings.analysesToRun,
                min_windows_required: settings.minWindowsRequired,
                seed: settings.seed
            };

            const result = {
                enabled: true,
                run_summary: runSummary,
                best_config: model.best_config,
                best_metrics: bestMetrics,
                conf_list: null,
                per_window_log: null,
                threshold: chosenThreshold,
                threshold_metrics: model.threshold_metrics,
                color: finalColor,
                confidence: finalConfidence,
                live_confidence: liveConfidence,
                live_threshold_gate: thresholdGate,
                tested_configs: model.tested_configs,
                effective_configs: model.effective_configs,
                top_candidates: model.top_candidates || [],
                n_windows: model.n_windows,
                holdout: holdoutInfo,
                warnings,
                summaryText,
                metrics: {
                    accuracy: bestMetrics.accuracy ?? 0,
                    acc_recent: bestMetrics.acc_recent ?? 0,
                    coverage: bestMetrics.coverage ?? 0,
                    precision: bestMetrics.precision ?? 0,
                    recall: bestMetrics.recall ?? 0,
                    f1: bestMetrics.f1 ?? 0,
                    n_preds: bestMetrics.n_preds ?? 0,
                    n_windows: bestMetrics.n_windows ?? model.n_windows
                }
            };

            n8RuntimeModelCache.set(cacheKey, {
                ...cachedRow,
                lastSeenSpinKey: latestSpinKey,
                lastResult: result,
                spinsSinceTrain: Math.max(0, Math.floor(Number(cachedRow.spinsSinceTrain) || 0)) + 1
            });

            return result;
        }

        const rawWindows = buildN0Windows(trimmedHistory, settings.windowSize);
        const windows = rawWindows.filter(entry => entry.target === 'R' || entry.target === 'B');
        if (windows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                summaryText: `N8 - Walk-forward â†’ NULO (janelas Ãºteis ${windows.length}, mÃ­nimo ${settings.minWindowsRequired})`,
                code: 'insufficient_windows',
                run_summary: {
                    run_id: runId,
                    timestamp: runTimestamp,
                    requested_history_size: settings.historySize,
                    used_history_size: stableWindow.meta.usedHistoryLimit,
                    available_history: stableWindow.meta.availableHistory,
                    unique_history: stableWindow.meta.uniqueCount
                }
            };
        }

        const holdoutPossible = settings.holdoutEnabled && windows.length >= settings.minWindowsRequired * 2;
        const trainingWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 0) : windows;
        const validationWindows = holdoutPossible ? windows.filter((_, idx) => idx % 2 === 1) : [];

        if (trainingWindows.length < settings.minWindowsRequired) {
            return {
                enabled: false,
                summaryText: `N8 - Walk-forward â†’ NULO (treino com ${trainingWindows.length} janelas)`,
                code: 'insufficient_training',
                run_summary: {
                    run_id: runId,
                    timestamp: runTimestamp,
                    requested_history_size: settings.historySize,
                    used_history_size: stableWindow.meta.usedHistoryLimit,
                    available_history: stableWindow.meta.availableHistory,
                    unique_history: stableWindow.meta.uniqueCount
                }
            };
        }

        const candidateConfigs = generateN8Configs(settings.analysesToRun, settings.seed);
        if (!silent) {
            console.log(`%c   â¤ Biblioteca N8: ${candidateConfigs.length} configs avaliadas`, 'color: #33CCFF; font-weight: bold;');
        }
        const trainingContext = buildN8WindowContext(trainingWindows);
        const evaluations = [];
        candidateConfigs.forEach(cfg => {
            const evaluation = evaluateN8Config(trainingWindows, cfg, trainingContext);
            if (evaluation.metrics.n_preds >= settings.minWindowsRequired) {
                evaluations.push(evaluation);
            }
        });

        if (evaluations.length === 0) {
            return {
                enabled: false,
                summaryText: 'N8 - Walk-forward â†’ NULO (nenhuma configuraÃ§Ã£o elegÃ­vel)',
                code: 'no_valid_configs',
                tested_configs: candidateConfigs.length,
                run_summary: { run_id: runId, timestamp: runTimestamp }
            };
        }

        evaluations.sort((a, b) => {
            const mA = a.metrics;
            const mB = b.metrics;
            if (mB.f1 !== mA.f1) return mB.f1 - mA.f1;
            if (mB.recall !== mA.recall) return mB.recall - mA.recall;
            if (mB.precision !== mA.precision) return mB.precision - mA.precision;
            if ((mB.acc_recent || 0) !== (mA.acc_recent || 0)) return (mB.acc_recent || 0) - (mA.acc_recent || 0);
            if (mB.coverage !== mA.coverage) return mB.coverage - mA.coverage;
            return 0;
        });

        const TOP_K = Math.min(20, evaluations.length);
        const topEvaluations = evaluations.slice(0, TOP_K);
        const bestEvaluation = topEvaluations[0];
        const bestDetailed = evaluateN8Config(trainingWindows, bestEvaluation.cfg, trainingContext, { collectLogs: !silent });
        const bestMetrics = bestDetailed.metrics;
        const bestConfList = bestDetailed.confList;
        const perWindowLog = bestDetailed.perWindowLog || [];

        const grid = settings.confidenceGrid.length > 0 ? settings.confidenceGrid : [...N8_DEFAULTS.confidenceGrid];
        let chosenThreshold = null;
        let chosenMetrics = null;
        grid.forEach(candidate => {
            const metrics = calculateN8ThresholdMetrics(bestConfList, candidate);
            if (metrics.precision >= settings.precisionMin) {
                if (!chosenMetrics || metrics.f1 > chosenMetrics.f1) {
                    chosenMetrics = { ...metrics, threshold: candidate };
                    chosenThreshold = candidate;
                }
            }
        });

        if (!chosenMetrics) {
            const confValues = bestConfList
                .map(entry => entry.confidence)
                .filter(Number.isFinite)
                .sort((a, b) => a - b);
            const percentileIndex = Math.max(0, Math.min(confValues.length - 1, Math.floor(confValues.length * 0.85)));
            const fallbackThreshold = confValues.length > 0 ? confValues[percentileIndex] : settings.confMinLive;
            chosenThreshold = clamp01(Math.max(settings.confMinLive, fallbackThreshold));
            chosenMetrics = { ...calculateN8ThresholdMetrics(bestConfList, chosenThreshold), threshold: chosenThreshold, fallback: true };
        }

        const holdoutInfo = {
            enabled: holdoutPossible,
            passed: true,
            reason: null,
            training: chosenMetrics,
            validation: null
        };
        const warnings = [];

        if (holdoutPossible && validationWindows.length >= settings.minWindowsRequired) {
            const validationContext = buildN8WindowContext(validationWindows);
            const validationEval = evaluateN8Config(validationWindows, bestDetailed.cfg, validationContext);
            const validationMetrics = calculateN8ThresholdMetrics(validationEval.confList, chosenThreshold);
            holdoutInfo.validation = { ...validationMetrics, threshold: chosenThreshold };
            const trainingF1 = chosenMetrics.f1 ?? 0;
            const validationF1 = validationMetrics.f1 ?? 0;
            if (validationMetrics.precision < settings.precisionMin) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `PrecisÃ£o da validaÃ§Ã£o abaixo do mÃ­nimo (${(validationMetrics.precision * 100).toFixed(1)}% < ${(settings.precisionMin * 100).toFixed(1)}%)`;
                warnings.push(holdoutInfo.reason);
            } else if (validationF1 < (trainingF1 - settings.holdoutTolerance)) {
                holdoutInfo.passed = false;
                holdoutInfo.reason = `F1 caiu de ${(trainingF1 * 100).toFixed(1)}% para ${(validationF1 * 100).toFixed(1)}%`;
                warnings.push(holdoutInfo.reason);
            }
        }

        const liveWindow = trimmedHistory.slice(-settings.windowSize);
        if (liveWindow.length < settings.windowSize) {
            return {
                enabled: false,
                summaryText: 'N8 - Walk-forward â†’ NULO (janela incompleta para previsÃ£o ao vivo)',
                code: 'incomplete_live_window',
                run_summary: {
                    run_id: runId,
                    timestamp: runTimestamp,
                    requested_history_size: settings.historySize,
                    used_history_size: stableWindow.meta.usedHistoryLimit,
                    available_history: stableWindow.meta.availableHistory,
                    unique_history: stableWindow.meta.uniqueCount
                }
            };
        }

        const liveWindows = [{
            window: liveWindow,
            target: null,
            index: windows.length,
            start: Math.max(0, trimmedHistory.length - settings.windowSize),
            targetIndex: trimmedHistory.length
        }];
        const liveContext = buildN8WindowContext(liveWindows);
        const liveResult = applyN8Config(bestDetailed.cfg, liveWindow, 0, liveWindows, liveContext);
        const liveConfidence = clamp01(liveResult.confidence ?? 0);
        const livePrediction = liveResult.prediction === 'R' || liveResult.prediction === 'B' ? liveResult.prediction : null;

        const thresholdGate = Math.max(settings.confMinLive, chosenThreshold ?? settings.confMinLive);
        let finalColor = null;
        if (livePrediction && liveConfidence >= thresholdGate && holdoutInfo.passed) {
            finalColor = livePrediction === 'R' ? 'red' : 'black';
        } else if (!holdoutInfo.passed) {
            warnings.push('PrevisÃ£o ao vivo suprimida devido Ã  reprovaÃ§Ã£o no holdout.');
        } else if (livePrediction && liveConfidence < thresholdGate) {
            warnings.push(`ConfianÃ§a ao vivo ${Math.round(liveConfidence * 100)}% abaixo do limiar ${Math.round(thresholdGate * 100)}%.`);
        }

        const trainingStrength = clamp01(
            (bestMetrics.f1 ?? 0) * 0.5 +
            (bestMetrics.precision ?? 0) * 0.2 +
            (bestMetrics.acc_recent ?? 0) * 0.2 +
            (bestMetrics.coverage ?? 0) * 0.1
        );
        const liveBoost = clamp01(
            thresholdGate < 1
                ? (liveConfidence - thresholdGate) / Math.max(0.05, 1 - thresholdGate)
                : liveConfidence
        );
        let finalConfidence = clamp01(trainingStrength * 0.6 + liveBoost * 0.4);
        if (!holdoutInfo.passed) {
            finalConfidence *= 0.5;
        }
        if (!finalColor) {
            finalConfidence = 0;
        }

        const topCandidates = topEvaluations.slice(0, Math.min(10, topEvaluations.length)).map(entry => ({
            id: entry.cfg.id,
            family: entry.cfg.family,
            params: entry.cfg.params,
            metrics: entry.metrics
        }));

        const summaryParts = [];
        if (finalColor) {
            summaryParts.push(`N8 - Walk-forward â†’ ${finalColor.toUpperCase()} (${Math.round(finalConfidence * 100)}%)`);
        } else {
            summaryParts.push('N8 - Walk-forward â†’ NULO');
        }
        summaryParts.push(`melhor famÃ­lia: ${bestDetailed.cfg.family}`);
        summaryParts.push(`F1 ${(bestMetrics.f1 * 100).toFixed(1)}%`);
        summaryParts.push(`precision ${(bestMetrics.precision * 100).toFixed(1)}%`);
        summaryParts.push(`recall ${(bestMetrics.recall * 100).toFixed(1)}%`);
        const summaryText = summaryParts.join(' | ');

        const runSummary = {
            run_id: runId,
            timestamp: runTimestamp,
            requested_history_size: settings.historySize,
            used_history_size: stableWindow.meta.usedHistoryLimit,
            available_history: stableWindow.meta.availableHistory,
            unique_history: stableWindow.meta.uniqueCount,
            dropped_duplicates: stableWindow.meta.droppedDuplicates,
            dropped_invalid_ts: stableWindow.meta.droppedInvalidTs,
            window_size: settings.windowSize,
            analyses_to_run: settings.analysesToRun,
            min_windows_required: settings.minWindowsRequired,
            seed: settings.seed
        };

        const result = {
            enabled: true,
            run_summary: runSummary,
            best_config: bestDetailed.cfg,
            best_metrics: bestMetrics,
            conf_list: silent ? null : bestConfList,
            per_window_log: silent ? null : perWindowLog,
            threshold: chosenThreshold,
            threshold_metrics: chosenMetrics,
            color: finalColor,
            confidence: finalConfidence,
            live_confidence: liveConfidence,
            live_threshold_gate: thresholdGate,
            tested_configs: candidateConfigs.length,
            effective_configs: evaluations.length,
            top_candidates: topCandidates,
            n_windows: windows.length,
            holdout: holdoutInfo,
            warnings,
            summaryText,
            metrics: {
                accuracy: bestMetrics.accuracy ?? 0,
                acc_recent: bestMetrics.acc_recent ?? 0,
                coverage: bestMetrics.coverage ?? 0,
                precision: bestMetrics.precision ?? 0,
                recall: bestMetrics.recall ?? 0,
                f1: bestMetrics.f1 ?? 0,
                n_preds: bestMetrics.n_preds ?? 0,
                n_windows: bestMetrics.n_windows ?? windows.length
            }
        };

        // âœ… Cache runtime
        if (cacheEnabled) {
            try {
                const model = {
                    best_config: bestDetailed.cfg,
                    best_metrics: bestMetrics,
                    threshold: chosenThreshold,
                    threshold_metrics: chosenMetrics,
                    holdout: holdoutInfo,
                    n_windows: windows.length,
                    tested_configs: candidateConfigs.length,
                    effective_configs: evaluations.length,
                    top_candidates: topCandidates
                };
                n8RuntimeModelCache.set(cacheKey, {
                    version: N8_RUNTIME_MODEL_CACHE_VERSION,
                    model,
                    trainedAt: runTimestamp,
                    trainedOnSpinKey: latestSpinKey,
                    spinsSinceTrain: 0,
                    lastSeenSpinKey: latestSpinKey,
                    lastResult: result
                });
            } catch (_) {}
        }

        return result;
    } catch (error) {
        console.error('âŒ Erro em runN8Detector:', error);
        return {
            enabled: false,
            summaryText: 'N8 - Walk-forward â†’ NULO (erro interno na anÃ¡lise)',
            code: 'internal_error',
            error: String(error),
            run_summary: { run_id: runId, timestamp: runTimestamp }
        };
    }
}

/**
 * FUNÃ‡ÃƒO PRINCIPAL: AnÃ¡lise AvanÃ§ada - NÃVEL DIAMANTE
 * Fluxo atual: 11 nÃ­veis com pontuaÃ§Ã£o contÃ­nua + barreira final
 * - N0 detecta branco e pode bloquear os demais nÃ­veis
 * - N1..N7 geram votos especializados
 * - N8 valida sequÃªncia (barreira final)
 * - N9 calibra probabilidades bayesianas e ajusta a forÃ§a dos demais nÃ­veis
 */
async function analyzeWithPatternSystem(history) {
    
    const totalDiamondLevels = DIAMOND_LEVEL_IDS.length;
    const diamondLevelEnabledMap = {};
    DIAMOND_LEVEL_IDS.forEach(id => {
        diamondLevelEnabledMap[id] = isDiamondLevelEnabled(id);
    });
    const isLevelEnabledLocal = (id) => !!diamondLevelEnabledMap[id];
    const activeDiamondLevels = DIAMOND_LEVEL_IDS.filter(id => diamondLevelEnabledMap[id]);
    const activeLevelsSummary = `${activeDiamondLevels.length}/${totalDiamondLevels}`;
    
    // âœ… DEBUG: Enviar mensagem inicial
    sendAnalysisStatus(`ğŸ” Iniciando anÃ¡lise (${activeLevelsSummary} nÃ­veis ativos)...`);
    console.log(`âœ… DEBUG: sendAnalysisStatus chamado - Iniciando anÃ¡lise com ${activeLevelsSummary} nÃ­veis ativos...`);

    if (activeDiamondLevels.length === 0) {
        console.warn('âš ï¸ Nenhum nÃ­vel do modo Diamante estÃ¡ ativo. AnÃ¡lise cancelada.');
        await restoreIAStatus();
        return null;
    }
    
    // âš¡ Modo "sinal rÃ¡pido": desativar sleeps longos dentro desta anÃ¡lise (nÃ£o bloquear o giro atual).
    // Isso corrige o problema relatado: sinal chegando quando o resultado jÃ¡ estÃ¡ quase saindo.
    fastLiveAnalysisDepth++;
    const __fastStartMs = Date.now();
    await sleep(1000);
    
    // VALIDAÃ‡ÃƒO DE DADOS DE ENTRADA
    logSection('ğŸ“Š 1. ValidaÃ§Ã£o de dados de entrada');
    console.log(`   âœ“ history existe? ${!!history ? 'âœ… SIM' : 'âŒ NÃƒO'}`);
    console.log(`   âœ“ history.length = ${history ? history.length : 'N/A'}`);
    
    if (history && history.length > 0) {
        logSection('ğŸ“œ Ãšltimos 20 giros do histÃ³rico (dados reais)');
        const last20 = history.slice(0, 20);
        last20.forEach((spin, idx) => {
            const colorEmoji = spin.color === 'red' ? 'ğŸ”´' : spin.color === 'black' ? 'âš«' : 'âšª';
            const timestamp = spin.timestamp ? new Date(spin.timestamp).toLocaleTimeString('pt-BR') : 'N/A';
            console.log(`   ${idx + 1}. ${colorEmoji} ${spin.color.toUpperCase()} (nÂº ${spin.number}) Ã s ${timestamp}`);
        });
    }
    
        logDivider();
        logSection(`[Diamante] AnÃ¡lise (${activeLevelsSummary} nÃ­veis ativos)`);
        [
            'N0 - Detector de Branco Â· bloqueio dinÃ¢mico',
            'N1 - Zona Segura Â· predominÃ¢ncia confirmada',
            'N2 - Ritmo AutÃ´nomo Â· duplas/sequÃªncia (W Ãºnico)',
            'N3 - AlternÃ¢ncia Inteligente Â· n-grams configurÃ¡veis',
            'N4 - Autointeligente Â· leitura do momento (n-grams adaptativos)',
            'N5 - Ritmo por Giro (minuto alvo)',
            'N6 - RetraÃ§Ã£o HistÃ³rica',
            'N7 - Continuidade Global',
            'N8 - Walk-forward nÃ£o sobreposto',
            'N9 - Barreira Final',
            'N10 - CalibraÃ§Ã£o Bayesiana'
        ].forEach(text => console.log(`   ${text}`));
        logDivider();
        logSection(`[Diamante] ConfiguraÃ§Ãµes atuais`);
    
    // Pegar configuraÃ§Ãµes do analyzerConfig
    const userDiamondWindows = analyzerConfig.diamondLevelWindows || {};
    const n1WindowSize = getDiamondWindow('n1WindowSize', SAFE_ZONE_DEFAULTS.windowSize);
    const n1PrimaryRequirement = getDiamondWindow('n1PrimaryRequirement', SAFE_ZONE_DEFAULTS.primaryRequirement);
    const n1SecondaryRequirement = getDiamondWindow('n1SecondaryRequirement', SAFE_ZONE_DEFAULTS.secondaryRequirement);
    const n2W = getDiamondWindow('n2Recent', 10);
    const n3Window = getDiamondWindow('n3Alternance', 2000);
    const n4Window = getDiamondWindow('n4Persistence', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence);
    const n5Window = getDiamondWindow('n5MinuteBias', 60);
    const n6Window = getDiamondWindow('n6RetracementWindow', 80);
    const n7DecisionWindow = getDiamondWindow('n7DecisionWindow', 20);
    const n7HistoryWindow = getDiamondWindow('n7HistoryWindow', 100);
    const n8WalkWindow = getDiamondWindow('n10Window', 20);
    const n8WalkHistory = Number(userDiamondWindows.n10History) > 0 ? Number(userDiamondWindows.n10History) : 500;
    const n9BarrierWindow = getDiamondWindow('n8Barrier', 50);
    const displayValue = (key, fallback, ...legacyKeys) => {
        if (Number.isFinite(Number(userDiamondWindows[key])) && Number(userDiamondWindows[key]) > 0) {
            return Number(userDiamondWindows[key]);
        }
        for (const legacyKey of legacyKeys) {
            if (Number.isFinite(Number(userDiamondWindows[legacyKey])) && Number(userDiamondWindows[legacyKey]) > 0) {
                return Number(userDiamondWindows[legacyKey]);
            }
        }
        return fallback;
    };
    
    const n0HistoryConfigured = displayValue('n0History', N0_DEFAULTS.historySize);
    const n0WindowConfigured = getDiamondWindow('n0Window', N0_DEFAULTS.windowSize);
    
    [
        ['N0', `Hist ${n0HistoryConfigured} | W ${n0WindowConfigured} | BlockAll ${analyzerConfig.n0AllowBlockAll !== false ? 'sim' : 'nÃ£o'}`],
        ['N1', `Zona Segura â†’ W ${n1WindowSize} | minA ${n1PrimaryRequirement} | minB ${n1SecondaryRequirement}`],
        ['N2', `W ${n2W} (auto)`],
        ['N3', `Prof ${n3Window} | Rigor ${getDiamondWindow('n3BaseThresholdPct', 60)}% | minOcc ${getDiamondWindow('n3MinOccurrences', 3)}`],
        ['N4', `Hist ${n4Window}`],
        ['N5', `${n5Window} amostras`],
        ['N6', `${n6Window} giros`],
        ['N7', `DecisÃµes ${n7DecisionWindow} | HistÃ³rico ${n7HistoryWindow}`],
        ['N8', `Hist ${n8WalkHistory} | W ${n8WalkWindow}`],
        ['N9', `${n9BarrierWindow} giros`],
        ['N10', `Hist ${getDiamondWindow('n10History', 500)} | W ${getDiamondWindow('n10Window', 20)}`]
    ].forEach(([label, detail]) => logInfo(label, detail));
    logDivider();
    
    // Verificar se os valores sÃ£o padrÃ£o ou personalizados
    const isN0Custom = n0HistoryConfigured !== N0_DEFAULTS.historySize || n0WindowConfigured !== N0_DEFAULTS.windowSize;
    const isN1Custom = n1WindowSize !== SAFE_ZONE_DEFAULTS.windowSize ||
        n1PrimaryRequirement !== SAFE_ZONE_DEFAULTS.primaryRequirement ||
        n1SecondaryRequirement !== SAFE_ZONE_DEFAULTS.secondaryRequirement;
    const isN2Custom = n2W !== 10;
    const isN3Custom = n3Window !== 2000;
    const isN4Custom = n4Window !== DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence;
    const isN5Custom = n5Window !== 60;
    const isN6Custom = n6Window !== 80;
    const isN7Custom = n7DecisionWindow !== 20 || n7HistoryWindow !== 100;
    const isN8Custom = n8WalkWindow !== 20 || n8WalkHistory !== 500;
    const isN9Custom = n9BarrierWindow !== 50;
    
    const customCount = [
        isN0Custom,
        isN1Custom,
        isN2Custom,
        isN3Custom,
        isN4Custom,
        isN5Custom,
        isN6Custom,
        isN7Custom,
        isN8Custom,
        isN9Custom
    ].filter(Boolean).length;
    
    if (customCount === 0) {
        logInfo('PersonalizaÃ§Ã£o', 'Todos os nÃ­veis usando valores padrÃ£o');
    } else {
        const customLevels = [];
        if (isN0Custom) customLevels.push('N0');
        if (isN1Custom) customLevels.push('N1');
        if (isN2Custom) customLevels.push('N2');
        if (isN3Custom) customLevels.push('N3');
        if (isN4Custom) customLevels.push('N4');
        if (isN5Custom) customLevels.push('N5');
        if (isN6Custom) customLevels.push('N6');
        if (isN7Custom) customLevels.push('N7');
        if (isN8Custom) customLevels.push('N8');
        if (isN9Custom) customLevels.push('N9');
        logInfo('PersonalizaÃ§Ã£o', `${customCount} nÃ­vel(is): ${customLevels.join(', ')}`);
    }
    logInfo('ConfirmaÃ§Ã£o', 'Esses sÃ£o os valores sendo usados na anÃ¡lise atual');
    logDivider();
    console.log('');
    
    try {
        // Logs de debug removidos: reduÃ§Ã£o de verbosidade
        console.log('');
        
        // Verificar acerto do sinal anterior (se houver)
        if (history.length > 0) {
            // âœ… NÃ£o bloquear a geraÃ§Ã£o do prÃ³ximo sinal com verificaÃ§Ã£o/telemetria do sinal anterior.
            // (Essa checagem pode envolver IO + logs; rodar em background.)
            try { checkPreviousSignalAccuracy(history[0]).catch(() => {}); } catch (_) {}
        }
        
        console.log('');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â±ï¸ VERIFICAÃ‡ÃƒO DE INTERVALO MÃNIMO ENTRE SINAIS (APENAS MODO DIAMANTE)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // âŒ Removido a pedido do usuÃ¡rio: nÃ£o aplicar cooldown/intervalo entre sinais.
        let minIntervalSpins = 0;
        // âœ… N4-only (com N9 opcional): o usuÃ¡rio quer volume alto, entÃ£o nÃ£o aplicar cooldown entre sinais.
        if (shouldUseN4DynamicGalesForConfig(analyzerConfig)) {
            minIntervalSpins = 0;
        }
        
        // âœ… FLAG: Guardar se intervalo estÃ¡ bloqueado (MAS CONTINUAR ANÃLISE)
        let intervalBlocked = false;
        let intervalMessage = '';
        
        if (analyzerConfig.aiMode) {
        console.log('');
        logSection('â±ï¸ VerificaÃ§Ã£o de intervalo entre sinais');
        console.log(`ğŸ“Š Intervalo mÃ­nimo configurado: ${minIntervalSpins} giro(s)`);
        console.log(`ğŸ“Š Giro atual: #${history[0]?.number || 'N/A'}`);
        
        if (minIntervalSpins > 0) {
            // âœ… IMPORTANTE (Modo Diamante):
            // O intervalo deve ser contado a partir do FIM DO CICLO (WIN/RET), e nÃ£o do momento do sinal.
            const entriesResult = await chrome.storage.local.get([
                'lastCycleResolvedSpinId',
                'lastCycleResolvedSpinTimestamp',
                'lastCycleResolvedTimestamp',
                // fallback legado:
                'lastSignalSpinNumber',
                'lastSignalTimestamp',
                'lastSignalSpinId',
                'lastSignalSpinTimestamp'
            ]);

            const lastCycleResolvedSpinId = entriesResult.lastCycleResolvedSpinId || null;
            const lastCycleResolvedSpinTimestamp = entriesResult.lastCycleResolvedSpinTimestamp || null;
            const lastCycleResolvedTimestamp = entriesResult.lastCycleResolvedTimestamp || null;

            const lastSignalSpinNumber = entriesResult.lastSignalSpinNumber ?? null;
            const lastSignalTimestamp = entriesResult.lastSignalTimestamp || null;
            const lastSignalSpinId = entriesResult.lastSignalSpinId || null;
            const lastSignalSpinTimestamp = entriesResult.lastSignalSpinTimestamp || null;
            
            const usingCycleMarker = !!(lastCycleResolvedSpinId || lastCycleResolvedSpinTimestamp || lastCycleResolvedTimestamp);

            if (usingCycleMarker) {
                console.log(`ğŸ“Š Ãšltimo ciclo finalizado (WIN/RET): ${lastCycleResolvedSpinId ? `id ${lastCycleResolvedSpinId}` : (lastCycleResolvedSpinTimestamp ? lastCycleResolvedSpinTimestamp : 'registrado')}`);
                if (lastCycleResolvedTimestamp) {
                    const tempoDecorrido = Math.round((Date.now() - lastCycleResolvedTimestamp) / 1000);
                    console.log(`   â±ï¸ Registrado hÃ¡ ${tempoDecorrido}s`);
                }
            } else {
                console.log(`ğŸ“Š Ãšltimo sinal salvo (fallback): ${lastSignalSpinNumber !== null ? '#' + lastSignalSpinNumber : 'Nenhum'}`);
            if (lastSignalTimestamp) {
                const tempoDecorrido = Math.round((Date.now() - lastSignalTimestamp) / 1000);
                console.log(`   â±ï¸ Registrado hÃ¡ ${tempoDecorrido}s`);
                }
            }

            const refSpinId = usingCycleMarker ? lastCycleResolvedSpinId : lastSignalSpinId;
            const refSpinTimestamp = usingCycleMarker ? lastCycleResolvedSpinTimestamp : lastSignalSpinTimestamp;
            const refTimestampMs = usingCycleMarker ? lastCycleResolvedTimestamp : lastSignalTimestamp;

            let spinsSince = null;
            if (history.length > 0) {
                if (refSpinId) {
                    const indexById = history.findIndex(spin => spin && spin.id === refSpinId);
                    spinsSince = indexById >= 0 ? indexById : history.length;
                } else if (refSpinTimestamp) {
                    const referenceTime = new Date(refSpinTimestamp).getTime();
                    if (!Number.isNaN(referenceTime)) {
                        for (let i = 0; i < history.length; i++) {
                            const spinTime = history[i]?.timestamp ? new Date(history[i].timestamp).getTime() : NaN;
                            if (!Number.isNaN(spinTime) && spinTime <= referenceTime) {
                                spinsSince = i;
                                break;
                            }
                        }
                        if (spinsSince === null) spinsSince = history.length;
                    }
                }
            }

            if (spinsSince !== null) {
                console.log(`ğŸ“Š Giros desde o ${usingCycleMarker ? 'fim do ciclo' : 'Ãºltimo sinal'} (histÃ³rico real): ${spinsSince}`);
                if (spinsSince >= minIntervalSpins) {
                    console.log('âœ… Intervalo de giros respeitado!');
                } else {
                    const remaining = minIntervalSpins - spinsSince;
                    intervalBlocked = true;
                    intervalMessage = `â³ Aguardando ${remaining} giro(s)... ${spinsSince}/${minIntervalSpins}`;
                    console.log('âš ï¸ Intervalo insuficiente: anÃ¡lise continua, mas sinal serÃ¡ bloqueado');
                }
            } else if (refTimestampMs && history.length > 0) {
                const timeSince = Date.now() - refTimestampMs;
                const minutosDecorridos = timeSince / 60000;
                const girosEstimados = Math.floor(minutosDecorridos * 2);
                console.log(`ğŸ“Š Giros estimados desde o ${usingCycleMarker ? 'fim do ciclo' : 'Ãºltimo sinal'}: ~${girosEstimados}`);
                
                if (girosEstimados >= minIntervalSpins) {
                    console.log('âœ… Intervalo estimado suficiente (fallback temporal)');
            } else {
                    const remaining = minIntervalSpins - girosEstimados;
                    intervalBlocked = true;
                    intervalMessage = `â³ Aguardando ${remaining} giro(s)... ${girosEstimados}/${minIntervalSpins}`;
                    console.log('âš ï¸ Intervalo insuficiente (estimativa temporal)');
                }
            } else {
                console.log('âœ… Nenhum ciclo anterior registrado â€“ permitido seguir');
            }
        } else {
            console.log('âœ… Sem intervalo configurado â€“ sinais liberados sempre que houver padrÃ£o vÃ¡lido');
            }
        } // âœ… fim do if (analyzerConfig.aiMode)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ’ FLUXO ATUAL - NÃVEL DIAMANTE: 5 NÃVEIS COM PONTUAÃ‡ÃƒO
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // âœ… Obter tamanho REAL do histÃ³rico disponÃ­vel (para NÃ­vel 4 e 6)
        const configuredSize = Math.min(Math.max(analyzerConfig.aiHistorySize || 60, 60), 2000);
        const availableSize = history.length;
        const historySize = Math.min(configuredSize, availableSize); // âœ… Usar o menor entre configurado e disponÃ­vel
        const totalHistory = history.slice(0, historySize);
        
        console.log('%câ•‘  ğŸ“Š VERIFICAÃ‡ÃƒO DO HISTÃ“RICO DISPONÃVEL                          â•‘', 'color: #00BFFF; font-weight: bold;');
        console.log(`%c   ğŸ¯ Configurado pelo usuÃ¡rio: ${configuredSize} giros`, 'color: #00BFFF;');
        console.log(`%c   ğŸ“¦ DisponÃ­vel no servidor: ${availableSize} giros`, availableSize < configuredSize ? 'color: #FFA500; font-weight: bold;' : 'color: #00FF88;');
        console.log(`%c   âœ… ANALISANDO REALMENTE: ${historySize} giros`, 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
        if (availableSize < configuredSize) {
            console.log(`%c   âš ï¸ ATENÃ‡ÃƒO: Servidor tem menos giros que o configurado!`, 'color: #FFA500; font-weight: bold;');
            console.log(`%c   â¤ Sistema usarÃ¡ APENAS os ${historySize} giros disponÃ­veis`, 'color: #FFA500; font-weight: bold;');
            console.log(`%c   â¤ Aguarde mais giros serem coletados para anÃ¡lise completa`, 'color: #FFA500;');
        }
        
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âŒ NÃVEIS 1, 2 e 3 REMOVIDOS (anÃ¡lise superficial baseada apenas em frequÃªncia)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    console.log('%câš ï¸ NÃVEIS 1, 2 e 3 DESATIVADOS (anÃ¡lise superficial de frequÃªncia)', 'color: #888; font-style: italic;');
    
    // âŒ NÃVEL 1 REMOVIDO: Cor Dominante (15 giros) - apenas frequÃªncia simples
    // âŒ NÃVEL 2 REMOVIDO: PosiÃ§Ã£o do Giro (30 giros) - sem base estatÃ­stica sÃ³lida  
    // âŒ NÃVEL 3 REMOVIDO: Soma dos Minutos (30 giros) - aleatoriedade pura
    
    // âœ… Identificar posiÃ§Ã£o do giro (ainda necessÃ¡rio para NÃ­vel 6 - Barreira)
    const lastSpinTimestamp = history[0]?.timestamp || Date.now();
    const lastSpinPosition = history[0]?.timestamp ? identifySpinPosition(lastSpinTimestamp) : 1;
    const nextSpinPosition = lastSpinPosition === 1 ? 2 : 1;
    const lastSpinDate = new Date(lastSpinTimestamp);
    const nextSpinDate = new Date(lastSpinDate);
    if (lastSpinPosition === 2) {
        nextSpinDate.setMinutes(nextSpinDate.getMinutes() + 1);
    }
    const targetMinute = nextSpinDate.getMinutes();
        
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¯ NÃVEL 1: ZONA SEGURA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log('%câ•‘  ğŸ›¡ï¸ NÃVEL 1: ZONA SEGURA                             â•‘', 'color: #FF6B35; font-weight: bold; font-size: 14px;');
        
        let safeZoneVote = null;
        let safeZoneMeta = null;
		let patternDescription = 'AnÃ¡lise NÃ­vel Diamante - 11 NÃ­veis';
        
        const safeZoneSettings = getSafeZoneSettingsFromAnalyzerConfig();
        console.log(`%c   ConfiguraÃ§Ãµes: janela ${safeZoneSettings.windowSize} | mÃ­n A ${safeZoneSettings.minPrimary} | mÃ­n B ${safeZoneSettings.minSecondary} | entradas ${safeZoneSettings.maxEntries}`, 'color: #FF6B35;');
        safeZoneMeta = analyzeSafeZone(history, safeZoneSettings);
        safeZoneMeta.maxEntries = safeZoneSettings.maxEntries;
        safeZoneMeta.entriesUsed = safeZoneEntryState.entriesUsed || 0;
        
        if (!safeZoneMeta.zoneActive) {
            console.log(`%câš ï¸ Zona inativa â†’ ${describeSafeZoneReason(safeZoneMeta.reason)}`, 'color: #888; font-style: italic;');
            safeZoneEntryState = { signature: null, entriesUsed: 0 };
        } else {
            console.log(`%c   Dominante: ${safeZoneMeta.dominant?.toUpperCase() || 'N/A'} (${safeZoneMeta.counts[safeZoneMeta.dominant]}/${safeZoneMeta.windowSize})`, 'color: #FF6B35;');
            console.log(`%c   SecundÃ¡ria: ${safeZoneMeta.secondary ? safeZoneMeta.secondary.toUpperCase() + ` (${safeZoneMeta.counts[safeZoneMeta.secondary]})` : 'N/A'}`, 'color: #FF6B35;');
            console.log(`%c   Ãšltima cor: ${safeZoneMeta.lastColor ? safeZoneMeta.lastColor.toUpperCase() : 'N/A'}`, 'color: #FF6B35;');
            
            if (safeZoneMeta.signal) {
                const signature = buildSafeZoneSignature(safeZoneMeta);
                if (safeZoneEntryState.signature !== signature) {
                    safeZoneEntryState = { signature, entriesUsed: 0 };
                }
                safeZoneMeta.entriesUsed = safeZoneEntryState.entriesUsed;
                if (safeZoneEntryState.entriesUsed >= safeZoneSettings.maxEntries) {
                    console.log(`%c   âš ï¸ Limite de ${safeZoneSettings.maxEntries} entradas atingido para esta zona.`, 'color: #FFAA00; font-weight: bold;');
                    safeZoneMeta.signal = false;
                    safeZoneMeta.reason = 'entry_limit_reached';
                }
            }
            // âœ… NÃƒO resetar aqui - apenas quando zona ficar inativa (linha 12855)
        }
        
        if (safeZoneMeta.zoneActive && safeZoneMeta.signal && safeZoneMeta.dominant) {
            safeZoneVote = {
                color: safeZoneMeta.dominant,
                source: 'safe-zone',
                confidence: safeZoneMeta.strength,
                detail: safeZoneMeta
            };
            const signature = buildSafeZoneSignature(safeZoneMeta);
            safeZoneEntryState = {
                signature,
                entriesUsed: Math.min(safeZoneSettings.maxEntries, (safeZoneEntryState.signature === signature ? safeZoneEntryState.entriesUsed : 0) + 1)
            };
            safeZoneMeta.entriesUsed = safeZoneEntryState.entriesUsed;
            safeZoneMeta.reason = 'zone_active_last_is_dominant';
            patternDescription = JSON.stringify({
                type: 'safe_zone',
                dominant: safeZoneMeta.dominant,
                secondary: safeZoneMeta.secondary,
                counts: safeZoneMeta.counts,
                windowSize: safeZoneMeta.windowSize,
                minPrimary: safeZoneMeta.minPrimary,
                minSecondary: safeZoneMeta.minSecondary,
                lastColor: safeZoneMeta.lastColor,
                status: safeZoneMeta.reason,
                entriesUsed: safeZoneMeta.entriesUsed,
                maxEntries: safeZoneSettings.maxEntries
            });
        } else if (safeZoneMeta.zoneActive) {
            patternDescription = JSON.stringify({
                type: 'safe_zone',
                dominant: safeZoneMeta.dominant,
                secondary: safeZoneMeta.secondary,
                counts: safeZoneMeta.counts,
                windowSize: safeZoneMeta.windowSize,
                minPrimary: safeZoneMeta.minPrimary,
                minSecondary: safeZoneMeta.minSecondary,
                lastColor: safeZoneMeta.lastColor,
                status: safeZoneMeta.reason,
                entriesUsed: safeZoneMeta.entriesUsed,
                maxEntries: safeZoneSettings.maxEntries
            });
        }
        
        if (!safeZoneVote) {
            console.log('%câš ï¸ NÃVEL 1 VOTA: NULO (zona fora de sinal)', 'color: #888; font-weight: bold; font-size: 14px;');
    } else {
            console.log(`%cğŸ—³ï¸ NÃVEL 1 VOTA: ${safeZoneVote.color.toUpperCase()}`, `color: ${safeZoneVote.color === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 14px;`);
    }
    
    // âš¡ NÃƒO EXIBIR na UI ainda (anÃ¡lise rÃ¡pida, mostraremos depois)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // âš¡ N2: RITMO AUTÃ”NOMO (W Ãºnico + ajuste automÃ¡tico)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log('%câ•‘  âš¡ N2: RITMO AUTÃ”NOMO (W Ãºnico â€¢ ajuste automÃ¡tico)   â•‘', 'color: #00AAFF; font-weight: bold; font-size: 14px;');
        
        const nivel5 = analyzeMomentum(history);
        const n2Vote = nivel5 && nivel5.color ? String(nivel5.color).toUpperCase() : 'NULO';
        const p2Red = Number(nivel5?.momentum?.red ?? 0);
        const p2Black = Number(nivel5?.momentum?.black ?? 0);
        const n2Details = (nivel5 && nivel5.details) ? nivel5.details : (nivel5 && nivel5.reason ? `NULO â€¢ ${nivel5.reason}` : 'N/A');

        console.log('%cğŸ“Š ANÃLISE N2 (RITMO):', 'color: #00AAFF; font-weight: bold;');
        console.log(`%c   P(2+ por run): ğŸ”´ ${p2Red.toFixed(1)}% | âš« ${p2Black.toFixed(1)}%`, 'color: #00AAFF;');
        console.log(`%c   Detalhes: ${n2Details}`, 'color: #00AAFF;');
        console.log(`%cğŸ—³ï¸ N2 VOTA: ${n2Vote}`, `color: ${n2Vote === 'RED' ? '#FF0000' : (n2Vote === 'BLACK' ? '#FFFFFF' : '#888888')}; font-weight: bold; font-size: 14px;`);
    
    // âš¡ NÃƒO EXIBIR na UI ainda (anÃ¡lise rÃ¡pida, mostraremos depois)
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”· N4 - PADRÃƒO DE ALTERNÃ‚NCIA (CONFIGURÃVEL PELO USUÃRIO)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log('%câ•‘  ğŸ”· N4 - PADRÃƒO DE ALTERNÃ‚NCIA (CONFIGURÃVEL)          â•‘', 'color: #8E44AD; font-weight: bold; font-size: 14px;');
        const n3HistoryWindow = Math.max(4, getDiamondWindow('n3Alternance', historySize));
        const n3BaseThresholdPctConfigured = Math.max(50, Math.min(95, getDiamondWindow('n3BaseThresholdPct', 60)));
        const n3MinOccurrencesConfigured = Math.max(1, Math.min(500, getDiamondWindow('n3MinOccurrences', 3)));
        const n3AllowBackoffConfigured = getDiamondBoolean('n3AllowBackoff', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n3AllowBackoff);
        const n3IgnoreWhiteConfigured = getDiamondBoolean('n3IgnoreWhite', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n3IgnoreWhite);
        const nivel7 = analyzeAlternancePattern(history, {
            historySize: n3HistoryWindow,
            baseThreshold: n3BaseThresholdPctConfigured / 100,
            minOccurrences: n3MinOccurrencesConfigured,
            allowBackoff: n3AllowBackoffConfigured,
            ignoreWhite: n3IgnoreWhiteConfigured
        });
        
        console.log('%cğŸ“Š ANÃLISE DE PADRÃƒO:', 'color: #8E44AD; font-weight: bold;');
        console.log(`%c   Profundidade do histÃ³rico: ${nivel7.historyUsed || n3HistoryWindow}/${n3HistoryWindow} giros`, 'color: #8E44AD;');
        console.log(`%c   AlternÃ¢ncia detectada: ${nivel7.pattern || 'N/A'} â€¢ ${nivel7.details || 'N/A'}`, 'color: #8E44AD;');
        console.log(
            `%c   Probabilidade: ${nivel7.probabilityPct || nivel7.baseRatePct || nivel7.alternationRate || '0.0'}% (limiar ${n3BaseThresholdPctConfigured}%)`,
            'color: #8E44AD;'
        );
        console.log(`%c   OcorrÃªncias histÃ³ricas: ${nivel7.occurrences != null ? nivel7.occurrences : 0}`, 'color: #8E44AD;');
        console.log(`%c   Detalhes: ${nivel7.details}`, 'color: #8E44AD;');
        
        if (nivel7.color) {
            console.log(`%cğŸ—³ï¸ N4 VOTA: ${nivel7.color.toUpperCase()}`, `color: ${nivel7.color === 'red' ? '#FF0000' : (nivel7.color === 'black' ? '#FFFFFF' : '#CCCCCC')}; font-weight: bold; font-size: 14px;`);
        } else {
            console.log(`%câš ï¸ N4 VOTA: NULO${nivel7.reason ? ` (${nivel7.reason})` : ''}`, 'color: #888; font-weight: bold; font-size: 14px;');
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”· N4 - AUTOINTELIGENTE (CONFIGURÃVEL PELO USUÃRIO)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        console.log('%câ•‘  ğŸ”· N4 - AUTOINTELIGENTE (CONFIGURÃVEL)                â•‘', 'color: #D35400; font-weight: bold; font-size: 14px;');
        
        const { maxGales: n4MaxGalesConfigured } = getMartingaleSettings('diamond', analyzerConfig);
        const n4HistoryWindow = getDiamondWindow('n4Persistence', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence);
        const nivel9 = analyzeAutointeligente(history, {
            historySize: n4HistoryWindow,
            maxGales: n4MaxGalesConfigured,
            signalIntensity: analyzerConfig.signalIntensity || 'aggressive',
            whiteProtectionAsWin: !!analyzerConfig.whiteProtectionAsWin,
            dynamicGales: shouldUseN4DynamicGalesForConfig(analyzerConfig),
            // âœ… passar estado de aprendizado do N4 (somente leitura) para filtrar/boost
            n4SelfLearning: signalsHistory && signalsHistory.n4SelfLearning ? signalsHistory.n4SelfLearning : null
        });
        
        const n4Decision = nivel9 && nivel9.color ? String(nivel9.color).toUpperCase() : 'NULO';
        const n4p1 = (nivel9 && typeof nivel9.p1 === 'number') ? `${(nivel9.p1 * 100).toFixed(1)}%` : 'n/d';
        const n4p2 = (nivel9 && typeof nivel9.p2 === 'number') ? `${(nivel9.p2 * 100).toFixed(1)}%` : 'n/d';
        const n4p3 = (nivel9 && typeof nivel9.p3 === 'number') ? `${(nivel9.p3 * 100).toFixed(1)}%` : 'n/d';
        console.log('%cğŸ“Š ANÃLISE N4 (AUTOINTELIGENTE):', 'color: #D35400; font-weight: bold;');
        console.log(`%c   HistÃ³rico: ${nivel9 && nivel9.historyUsed != null ? nivel9.historyUsed : 0}/${n4HistoryWindow} giros`, 'color: #D35400;');
        console.log(`%c   DecisÃ£o: ${n4Decision}`, 'color: #D35400; font-weight: bold;');
        console.log(`%c   P1 ${n4p1} â€¢ P2 ${n4p2} â€¢ P3 ${n4p3}`, 'color: #D35400;');
        console.log(`%c   Detalhes: ${nivel9 && nivel9.details ? nivel9.details : 'â€”'}`, 'color: #D35400;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ§® CONSOLIDAÃ‡ÃƒO DOS NÃVEIS (PONTUAÃ‡ÃƒO CONTÃNUA)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const levelWeights = {
            whiteDetector: 0,
            patterns: 0.19,
            momentum: 0.15,
            alternance: 0.13,
            persistence: 0.11,
            minuteSpin: 0.095,
            retracement: 0.085,
            globalContinuity: 0.11,
            barrier: 0.05,
            bayesianCalibration: 0.08,
            walkForward: 0.12
        };
        const levelMeta = {
            // Mantemos emoji aqui para logs internos, mas o texto exibido na UI (reasoning) NÃƒO usa emoji.
            N0: { emoji: 'âšª', label: 'N0 - Detector de Branco' },
            N1: { emoji: 'ğŸ›¡ï¸', label: 'N1 - Zona Segura' },
            N2: { emoji: 'âš¡', label: 'N2 - Ritmo AutÃ´nomo' },
            N3: { emoji: 'ğŸ”·', label: 'N3 - AlternÃ¢ncia' },
            N4: { emoji: 'ğŸ”·', label: 'N4 - Autointeligente' },
            N5: { emoji: 'ğŸ•‘', label: 'N5 - Ritmo por Giro' },
            N6: { emoji: 'ğŸ“‰', label: 'N6 - RetraÃ§Ã£o HistÃ³rica' },
            N7: { emoji: 'ğŸ“ˆ', label: 'N7 - Continuidade Global' },
            N8: { emoji: 'ğŸ”Ÿ', label: 'N8 - Walk-forward' },
            N9: { emoji: 'ğŸ›‘', label: 'N9 - Barreira Final' },
            N10:{ emoji: 'ğŸ§®', label: 'N10 - CalibraÃ§Ã£o Bayesiana' }
        };
        const clamp01 = (value) => Math.max(0, Math.min(1, typeof value === 'number' ? value : 0));
        const directionValue = (color) => color === 'red' ? 1 : color === 'black' ? -1 : 0;
        const levelReports = [];
        const describeLevel = (level, opts = {}) => {
            const meta = levelMeta[level.id] || { emoji: '', label: `${level.id}` };
            const includeEmoji = opts && opts.includeEmoji === false ? false : true;
            const prefix = includeEmoji && meta.emoji ? `${meta.emoji} ` : '';
            if (level.disabled) {
                return `${prefix}${meta.label} â†’ DESATIVADO`;
            }
            // âœ… N9 Ã© validador (nÃ£o vota). Nunca deve aparecer como "NULO" â€” mostrar APROVADO/BLOQUEADO + resumo.
            if (level.id === 'N9') {
                const detail = level.details ? String(level.details) : 'APROVADO';
                return `${prefix}${meta.label} â†’ ${detail}`;
            }
            if (!level.color) {
                return `${prefix}${meta.label} â†’ NULO`;
            }
            const strengthPct = Math.round((level.strength || 0) * 100);
            return `${prefix}${meta.label} â†’ ${level.color.toUpperCase()} (${strengthPct}% â€¢ ${level.details})`;
        };
const displayOrder = ['N0', 'N1', 'N2', 'N3', 'N4', 'N5', 'N6', 'N7', 'N8', 'N9', 'N10'];
        let diamondSequenceDisplayed = false;

        const n0Settings = getN0SettingsFromAnalyzerConfig();
        // âœ… IMPORTANTE: horizonte do N0 deve seguir os GALES DO BRANCO (config exclusiva),
        // nÃ£o o maxGales global de vermelho/preto.
        const { maxGales: n0MaxGalesConfigured } = getMartingaleSettingsForEntryColor('white', 'diamond', analyzerConfig);
        const n0LookaheadSpins = Math.max(
            1,
            Math.min(6, (Math.floor(Number(n0MaxGalesConfigured) || 0) + 1))
        );
        const n0Options = {
            historySize: n0Settings.historySize,
            windowSize: n0Settings.windowSize,
            lookaheadSpins: n0LookaheadSpins,
            cache: true,
            // âœ… Evita re-treinar o N0 em TODO giro (caro). MantÃ©m atualizaÃ§Ã£o frequente o suficiente.
            cacheMaxAgeSpins: Math.max(20, Math.min(60, n0Settings.windowSize)),
            analysesToRun: N0_DEFAULTS.analysesToRun,
            minWindowsRequired: N0_DEFAULTS.minWindowsRequired,
            precisionMin: N0_DEFAULTS.precisionMin,
            confidenceGrid: N0_DEFAULTS.confidenceGrid,
            holdoutEnabled: N0_DEFAULTS.holdoutEnabled,
            holdoutTolerance: N0_DEFAULTS.holdoutTolerance,
            seed: N0_DEFAULTS.seed
        };

        // âœ… Modelo congelado (salvo no backtest): usar SEM recalcular
        try {
            if (analyzerConfig && analyzerConfig.n0FrozenEnabled && analyzerConfig.n0FrozenModel && analyzerConfig.n0FrozenModel.best_config) {
                n0Options.frozenModel = analyzerConfig.n0FrozenModel;
                // evitar escrever/treinar cache quando congelado
                n0Options.cache = false;
                n0Options.cacheMaxAgeSpins = 0;
            }
        } catch (_) {}

        let n0Result = null;
        let n0EffectiveAction = 'no_block';
        let n0ForceWhite = false;
        let n0SoftBlockActive = false;
        let n0WhiteStrength = 0;
        let n0ActionSuppressed = false;
        let n0DetailSummary = 'NULO';
        // âœ… Gate + observadores (qualidade do sinal)
        let n0GateAlert = null;
        let n0GateBlockAll = null;
        let n0UiVoteWhite = false; // se false, nÃ£o mostrar "WHITE" no card do N0 (evita induzir entrada em cenÃ¡rio ruim)
        let n0EffectiveConfidence = null; // 0..1 (confianÃ§a ajustada por observadores)
        let n0CooldownInfo = null; // { ok, active, remaining, required } | null

        const n0Enabled = isLevelEnabledLocal('N0');
        if (!n0Enabled) {
            console.log('%câ•‘  âšª NÃVEL 0 - DETECTOR DE BRANCO (DESATIVADO PELO USUÃRIO) â•‘', 'color: #777777; font-weight: bold; font-size: 14px;');
            n0Result = {
                enabled: false,
                reason: 'Desativado pelo usuÃ¡rio'
            };
            n0DetailSummary = 'DESATIVADO';
        } else {
            try {
                console.log('%câ•‘  âšª NÃVEL 0 - DETECTOR DE BRANCO                         â•‘', 'color: #FFFFFF; font-weight: bold; font-size: 14px;');
                console.log(`%c   HistÃ³rico analisado: ${n0Options.historySize} giros | Janela: ${n0Options.windowSize} giros`, 'color: #FFFFFF; font-weight: bold;');
                console.log(`%c   Horizonte alvo: ${n0Options.lookaheadSpins} giro(s) (Entrada/G1/G2...)`, 'color: #FFFFFF; font-weight: bold;');
                console.log(`%c   Modelos avaliados: ${n0Options.analysesToRun} | Holdout: ${n0Options.holdoutEnabled ? 'ATIVO' : 'DESATIVADO'}`, 'color: #FFFFFF; font-weight: bold;');

                n0Result = runN0Detector(history, n0Options);

                if (n0Result && n0Result.enabled) {
                const actionRequested = n0Result.blocking_action || 'no_block';
                const blockAllAllowed = n0Settings.allowBlockAll;
                n0WhiteStrength = clamp01(n0Result.white_confidence || 0);
                const bestMetrics = n0Result.best_metrics || {};
                const blockMetrics = n0Result.blocking_metrics || {};
                const testedConfigs = n0Result.tested_configs != null ? n0Result.tested_configs : n0Options.analysesToRun;
                const effectiveConfigs = n0Result.effective_configs != null ? n0Result.effective_configs : testedConfigs;
                const holdoutData = n0Result.holdout || {};
                if (n0Result.run_summary) {
                    console.log('%c   â¤ Resumo da execuÃ§Ã£o N0:', 'color: #AAAAAA; font-weight: bold;');
                    console.log(n0Result.run_summary);
                }

                n0EffectiveAction = actionRequested;
                if (actionRequested === 'block_all' && !blockAllAllowed) {
                    n0EffectiveAction = 'no_block';
                    n0ActionSuppressed = true;
                }
                if (n0ActionSuppressed) {
                    console.log('%c   â„¹ï¸ BLOCK ALL desativado pelo usuÃ¡rio (modo informativo)', 'color: #FFAA00; font-weight: bold;');
                }

                n0ForceWhite = n0EffectiveAction === 'block_all' && n0Result.pred_live === 'W';
                n0SoftBlockActive = n0EffectiveAction === 'soft_block' && n0Result.pred_live === 'W';

                // âœ… Cooldown pÃ³s-WIN (pedido do usuÃ¡rio):
                // Se acabou de ganhar no branco, nÃ£o aplicar SOFT BLOCK nos demais nÃ­veis e evitar reentradas.
                try {
                    const nowMsCooldown = Number.isFinite(parseSpinTimestamp(history && history[0])) ? parseSpinTimestamp(history[0]) : Date.now();
                    n0CooldownInfo = getN0PostWinCooldownGate({ history, nowMs: nowMsCooldown });
                    if (n0CooldownInfo && n0CooldownInfo.ok === false) {
                        // Durante cooldown, deixar os outros nÃ­veis trabalharem sem reduÃ§Ã£o de peso
                        n0SoftBlockActive = false;
                    }
                } catch (_) {
                    n0CooldownInfo = null;
                }

                // âœ… Observadores + gate (evita recomendar branco em cenÃ¡rio "saturado" ou com pouca confirmaÃ§Ã£o)
                const n0NowMsGate = Number.isFinite(parseSpinTimestamp(history && history[0])) ? parseSpinTimestamp(history[0]) : Date.now();
                const softThresholdGate = (() => {
                    try {
                        const t = (n0Result && typeof n0Result.blocking_threshold === 'number') ? clamp01(n0Result.blocking_threshold) : null;
                        const base = (t == null) ? 0.5 : t;
                        return clamp01(base * 0.8);
                    } catch (_) {
                        return 0.5;
                    }
                })();

                n0GateAlert = evaluateN0WhiteSignalGate({
                    history,
                    nowMs: n0NowMsGate,
                    lookaheadSpins: n0Options.lookaheadSpins,
                    baseConfidence: n0WhiteStrength,
                    softThreshold: softThresholdGate,
                    n0Result,
                    mode: 'alert'
                });
                n0GateBlockAll = evaluateN0WhiteSignalGate({
                    history,
                    nowMs: n0NowMsGate,
                    lookaheadSpins: n0Options.lookaheadSpins,
                    baseConfidence: n0WhiteStrength,
                    softThreshold: softThresholdGate,
                    n0Result,
                    mode: 'block_all'
                });

                const cooldownActive = !!(n0CooldownInfo && n0CooldownInfo.ok === false);
                const recentWhiteIdxGate = findMostRecentWhiteIndexForN0(history, 80);
                const consecutiveWhite = recentWhiteIdxGate === 0;
                const canAlert = !!(n0Result && n0Result.pred_live === 'W' && n0GateAlert && n0GateAlert.ok && !cooldownActive && !consecutiveWhite);
                const canBlockAll = !!(n0ForceWhite && n0GateBlockAll && n0GateBlockAll.ok && !cooldownActive && !consecutiveWhite);

                // Se o gate nÃ£o aprovar, nÃ£o aplicar soft-block nos pesos (nÃ£o faz sentido "penalizar" outros nÃ­veis)
                if (!canAlert) {
                    n0SoftBlockActive = false;
                }
                // Se o gate nÃ£o aprovar, nÃ£o permitir BLOCK ALL (alto risco)
                n0ForceWhite = canBlockAll;

                n0UiVoteWhite = canAlert;
                const gateChosen = canBlockAll ? n0GateBlockAll : n0GateAlert;
                n0EffectiveConfidence = (gateChosen && typeof gateChosen.effectiveConfidence === 'number' && Number.isFinite(gateChosen.effectiveConfidence))
                    ? clamp01(gateChosen.effectiveConfidence)
                    : clamp01(n0WhiteStrength);

                const confidencePct = Math.round(n0EffectiveConfidence * 100);
                const thresholdPct = (n0Result && n0Result.blocking_threshold != null)
                    ? Math.round(clamp01(n0Result.blocking_threshold) * 100)
                    : null;

                const actionLabel = (() => {
                    if (!n0Result || n0Result.pred_live !== 'W') return 'NULO';
                    if (canBlockAll) return 'BLOCK ALL';
                    if (canAlert && n0SoftBlockActive) return 'SOFT BLOCK';
                    if (canAlert) return n0ActionSuppressed ? 'ALERTA (info)' : 'ALERTA';
                    return 'EVITAR';
                })();

                const packShort = (gateChosen && gateChosen.pack && typeof gateChosen.pack.short === 'string')
                    ? gateChosen.pack.short
                    : (n0GateAlert && n0GateAlert.pack && typeof n0GateAlert.pack.short === 'string' ? n0GateAlert.pack.short : null);

                const detailsParts = [actionLabel];
                if (thresholdPct !== null) detailsParts.push(`t* ${thresholdPct}%`);
                if (n0Result && n0Result.dominant_nonwhite) {
                    detailsParts.push(`dom ${String(n0Result.dominant_nonwhite).toUpperCase()}`);
                }
                if (holdoutData && holdoutData.enabled) {
                    detailsParts.push(holdoutData.passed ? 'HOK' : 'HF');
                }
                if (packShort) detailsParts.push(packShort);

                // Mostrar motivo do bloqueio quando o N0 detectou WHITE mas o gate rejeitou
                if (n0Result && n0Result.pred_live === 'W' && !canAlert) {
                    const r = cooldownActive
                        ? 'cooldown'
                        : (consecutiveWhite ? 'recent_white_spin' : ((n0GateAlert && typeof n0GateAlert.reason === 'string') ? n0GateAlert.reason : 'bloqueado'));
                    detailsParts.push(`gate ${r}`);
                }
                if (n0CooldownInfo && n0CooldownInfo.ok === false) {
                    detailsParts.push(`cooldown ${n0CooldownInfo.remaining}/${n0CooldownInfo.required}`);
                }
                if (n0ActionSuppressed) detailsParts.push('informativo');

                n0DetailSummary = detailsParts.join(' â€¢ ');

                console.log(`%c   â¤ AÃ§Ã£o sugerida: ${actionRequested.toUpperCase()}${n0ActionSuppressed ? ' (modo informativo)' : ''}`, 'color: #FFFFFF; font-weight: bold;');
                console.log(`%c   â¤ ConfianÃ§a: ${(n0WhiteStrength * 100).toFixed(2)}% | Threshold: ${(n0Result.blocking_threshold * 100 || 0).toFixed(2)}% | Precision*: ${blockMetrics.precision != null ? (blockMetrics.precision * 100).toFixed(1) + '%' : 'n/d'}`, 'color: #FFFFFF; font-weight: bold;');
                if (n0Result.best_config) {
                    console.log('%c   â¤ Melhor configuraÃ§Ã£o:', 'color: #FFFFFF; font-weight: bold;');
                    console.log(n0Result.best_config);
                }
                console.log(`%c   â¤ MÃ©tricas Treino: F1 ${(bestMetrics.f1 != null ? (bestMetrics.f1 * 100).toFixed(1) : 'n/d')}% | Recall ${(bestMetrics.recall != null ? (bestMetrics.recall * 100).toFixed(1) : 'n/d')}% | Precision ${(bestMetrics.precision != null ? (bestMetrics.precision * 100).toFixed(1) : 'n/d')}% | Cobertura ${(bestMetrics.coverage != null ? (bestMetrics.coverage * 100).toFixed(1) : 'n/d')}%`, 'color: #FFFFFF; font-weight: bold;');
                if (Array.isArray(n0Result.top_candidates) && n0Result.top_candidates.length > 0) {
                    console.log(`%c   â¤ Top configs (F1%%): ${n0Result.top_candidates.slice(0, 3).map(c => `${c.id}:${(c.metrics.f1 * 100).toFixed(1)}`).join(' | ')}`, 'color: #AAAAFF; font-weight: bold;');
                }
                if (Array.isArray(n0Result.per_window_log)) {
                    console.log(`%c   â¤ Audit trail disponÃ­vel (${n0Result.per_window_log.length} linhas)`, 'color: #AAAAFF; font-weight: bold;');
                }
                if (Array.isArray(n0Result.warnings) && n0Result.warnings.length > 0) {
                    n0Result.warnings.forEach(warning => {
                        console.log(`%c   âš ï¸ Aviso: ${warning}`, 'color: #FFAA00; font-weight: bold;');
                    });
                }
                if (n0Result.holdout && n0Result.holdout.enabled) {
                    console.log(`%c   â¤ Holdout: ${n0Result.holdout.passed ? 'APROVADO' : 'REPROVADO'}${n0Result.holdout.reason ? ` (${n0Result.holdout.reason})` : ''}`, n0Result.holdout.passed ? 'color: #00FF88; font-weight: bold;' : 'color: #FFAA00; font-weight: bold;');
                }
                if (n0SoftBlockActive) {
                    console.log('%c   âš ï¸ Soft block: pesos reduzidos em 50% para os demais nÃ­veis', 'color: #FFAA00; font-weight: bold;');
                }
                } else if (n0Result) {
                console.log(`%c   â¤ Detector indisponÃ­vel: ${n0Result.reason || 'motivo nÃ£o informado'}`, 'color: #FFAA00; font-weight: bold;');
                n0DetailSummary = n0Result.reason || 'IndisponÃ­vel';
                } else {
                console.log('%c   â¤ Detector indisponÃ­vel: erro desconhecido', 'color: #FFAA00; font-weight: bold;');
                n0DetailSummary = 'IndisponÃ­vel';
                }
            } catch (error) {
                console.error('âŒ Erro ao executar N0 - Detector de Branco:', error);
                n0Result = {
                    enabled: false,
                    reason: 'Erro interno no detector'
                };
                n0DetailSummary = 'Erro interno';
            }
        }

        levelReports.push({
            id: 'N0',
            name: 'Detector de Branco',
            // âœ… SÃ³ marcar WHITE quando o gate aprovar (evita induzir entrada em cenÃ¡rio saturado)
            color: n0UiVoteWhite ? 'white' : null,
            weight: n0Enabled ? levelWeights.whiteDetector : 0,
            strength: (typeof n0EffectiveConfidence === 'number' && Number.isFinite(n0EffectiveConfidence)) ? n0EffectiveConfidence : n0WhiteStrength,
            score: 0,
            details: n0DetailSummary,
            disabled: !n0Enabled
        });

        const n0WeightModifier = (n0Enabled && n0SoftBlockActive) ? N0_DEFAULTS.softBlockFactor : 1;
        const weightFor = (baseWeight) => baseWeight * n0WeightModifier;
        const emitLevelStatuses = async (reports, options = {}) => {
            const { perLevelDelay = 1500, force = false } = options;
            if (diamondSequenceDisplayed && !force) return;
            if (!force) {
                diamondSequenceDisplayed = true;
            }

            const sequence = displayOrder.map(id => {
                const level = Array.isArray(reports) ? reports.find(lvl => lvl.id === id) : null;
                const meta = levelMeta[id] || {};
                const [idLabel, nameLabel] = (meta.label || id).split(' - ');
                const friendlyName = nameLabel ? `${idLabel} ${nameLabel}` : (meta.label || id);
                const enabled = isLevelEnabledLocal(id);

                if (id === 'N0') {
                    if (!enabled) {
                        return { id, message: `${friendlyName}: DESATIVADO` };
                    }
                    if (!level || !n0Result) {
                        return { id, message: `${friendlyName}: NULO` };
                    }
                    if (n0CooldownInfo && n0CooldownInfo.ok === false) {
                        return { id, message: `${friendlyName}: COOLDOWN (${n0CooldownInfo.remaining}/${n0CooldownInfo.required})` };
                    }
                    const confPct = Math.round((n0WhiteStrength || 0) * 100);
                    const thresholdPct = n0Result.blocking_threshold != null
                        ? Math.round(n0Result.blocking_threshold * 100)
                        : null;
                    const suffixThreshold = thresholdPct !== null ? ` â€¢ t* ${thresholdPct}%` : '';
                    if (n0ForceWhite) {
                        const suppressedLabel = n0ActionSuppressed ? ' (informativo)' : '';
                        return {
                            id,
                            message: `${friendlyName}: BLOCK ALL (${confPct}%${suffixThreshold})${suppressedLabel}`
                        };
                    }
                    if (n0SoftBlockActive) {
                        return {
                            id,
                            message: `${friendlyName}: SOFT BLOCK (${confPct}%${suffixThreshold})`
                        };
                    }
                    if (level.color === 'white') {
                        const infoSuffix = n0ActionSuppressed ? ' â€¢ informativo' : '';
                        return {
                            id,
                            message: `${friendlyName}: ALERTA (${confPct}%${suffixThreshold})${infoSuffix}`
                        };
                    }
                    if (n0Result.enabled === false) {
                        return { id, message: `${friendlyName}: ${n0Result.reason || 'INDISPONÃVEL'}` };
                    }
                    return { id, message: `${friendlyName}: NULO` };
                }

                if (id === 'N8') {
                    if (!enabled) {
                        return { id, message: `${friendlyName}: DESATIVADO` };
                    }
                    if (level && level.color) {
                        const pct = Math.round((level.strength || 0) * 100);
                        const extra = level.details ? ` â€¢ ${level.details}` : '';
                        return { id, message: `${friendlyName}: ${level.color.toUpperCase()} (${pct}%${extra})` };
                    }
                    return { id, message: `${friendlyName}: NULO` };
                }

                if (id === 'N9') {
                    if (!enabled) {
                        return { id, message: `${friendlyName}: DESATIVADO` };
                    }
                    const status = barrierResult.allowed ? 'APROVADO' : 'BLOQUEADO';
                    return { id, message: `${friendlyName}: ${status}` };
                }

                if (!enabled) {
                    return { id, message: `${friendlyName}: DESATIVADO` };
                }

                if (level && level.color) {
                    const pct = Math.round((level.strength || 0) * 100);
                    const text = pct > 0
                        ? `${friendlyName}: ${level.color.toUpperCase()} (${pct}%)`
                        : `${friendlyName}: ${level.color.toUpperCase()}`;
                    return { id, message: text };
                }

                return { id, message: `${friendlyName}: NULO` };
            });

            for (const item of sequence) {
                sendAnalysisStatus(item.message);
                await sleep(perLevelDelay);
            }
        };

        // N10 - Walk-forward (votante especializado baseado em janelas nÃ£o-sobrepostas)
        const n8Enabled = isLevelEnabledLocal('N8');
        let n8SummaryText = null;
        if (!n8Enabled) {
            console.log('%câ•‘  ğŸ”Ÿ N8 - Walk-forward DESATIVADO (pelo usuÃ¡rio)          â•‘', 'color: #777777; font-weight: bold; font-size: 14px;');
            levelReports.push({
                id: 'N8',
                name: 'Walk-forward',
                color: null,
                weight: 0,
                strength: 0,
                score: 0,
                details: 'DESATIVADO',
                disabled: true
            });
        } else {
            try {
                const windowsCfg = analyzerConfig.diamondLevelWindows || {};
                const n8WindowCfg = getDiamondWindow('n10Window', N8_DEFAULTS.windowSize);
                const n8HistoryCfg = Number(windowsCfg.n10History) > 0 ? Number(windowsCfg.n10History) : N8_DEFAULTS.historySize;
                const n8AnalysesCfg = Number(windowsCfg.n10Analyses) > 0 ? Number(windowsCfg.n10Analyses) : N8_DEFAULTS.analysesToRun;
                const n8MinWindowsCfg = Number(windowsCfg.n10MinWindows) > 0 ? Number(windowsCfg.n10MinWindows) : N8_DEFAULTS.minWindowsRequired;
                const n8ConfMinPctCfg = Number(windowsCfg.n10ConfMin) > 0 ? Number(windowsCfg.n10ConfMin) : N8_DEFAULTS.confMinLive * 100;
                const n8ConfMinCfg = Math.max(0, Math.min(1, n8ConfMinPctCfg / 100));

                const n8Result = runN8Detector(history, {
                    windowSize: n8WindowCfg,
                    historySize: n8HistoryCfg,
                    analysesToRun: n8AnalysesCfg,
                    minWindows: n8MinWindowsCfg,
                    confMinLive: n8ConfMinCfg,
                    // âœ… Performance: N8 Ã© caro (1000 configs). Cache runtime evita re-treinar em todo giro.
                    cache: true,
                    silent: true,
                    cacheMaxAgeSpins: Math.max(20, Math.min(60, n8WindowCfg))
                });

                if (n8Result && typeof n8Result.summaryText === 'string') {
                    n8SummaryText = n8Result.summaryText.replace(/^N8 - /, '');
                }

                if (n8Result && Array.isArray(n8Result.warnings) && n8Result.warnings.length > 0) {
                    n8Result.warnings.forEach(warn => console.warn('âš ï¸ [N8]', warn));
                }

                if (n8Result && n8Result.enabled && n8Result.color) {
                    const n8Color = n8Result.color;
                    const n8Strength = clamp01(n8Result.confidence || 0);
                    const metrics = n8Result.best_metrics || {};
                    const f1Pct = metrics.f1 != null ? (metrics.f1 * 100).toFixed(1) : null;
                    const precisionPct = metrics.precision != null ? (metrics.precision * 100).toFixed(1) : null;
                    const recallPct = metrics.recall != null ? (metrics.recall * 100).toFixed(1) : null;
                    const coveragePct = metrics.coverage != null ? (metrics.coverage * 100).toFixed(1) : null;
                    const predsInfo = (metrics.n_preds != null && metrics.n_windows != null)
                        ? `${metrics.n_preds}/${metrics.n_windows} janelas`
                        : null;
                    const bestConfigLabel = n8Result.best_config ? n8Result.best_config.family : null;
                    const detailParts = [];
                    if (bestConfigLabel) detailParts.push(bestConfigLabel);
                    if (f1Pct != null) detailParts.push(`F1 ${f1Pct}%`);
                    if (precisionPct != null) detailParts.push(`prec ${precisionPct}%`);
                    if (recallPct != null) detailParts.push(`rec ${recallPct}%`);
                    if (coveragePct != null) detailParts.push(`coverage ${coveragePct}%`);
                    if (predsInfo) detailParts.push(predsInfo);
                    let n8Details = 'Walk-forward diversificado';
                    if (detailParts.length > 0) {
                        n8Details += ' â€¢ ' + detailParts.join(' â€¢ ');
                    }
                    if (n8Result.holdout && n8Result.holdout.enabled && !n8Result.holdout.passed && n8Result.holdout.reason) {
                        n8Details += ` â€¢ Holdout: ${n8Result.holdout.reason}`;
                    }

                    levelReports.push({
                        id: 'N8',
                        name: 'Walk-forward',
                        color: n8Color,
                        weight: weightFor(levelWeights.walkForward),
                        strength: n8Strength,
                        score: directionValue(n8Color) * n8Strength,
                        details: n8Details,
                        disabled: false
                    });
                } else {
                    levelReports.push({
                        id: 'N8',
                        name: 'Walk-forward',
                        color: null,
                        weight: weightFor(levelWeights.walkForward),
                        strength: 0,
                        score: 0,
                        details: n8SummaryText || 'NULO',
                        disabled: false
                    });
                }
            } catch (e) {
                console.error('âŒ Erro em N8 dentro do modo Diamante:', e);
                levelReports.push({
                    id: 'N8',
                    name: 'Walk-forward',
                    color: null,
                    weight: weightFor(levelWeights.walkForward),
                    strength: 0,
                    score: 0,
                    details: 'Erro interno em N8',
                    disabled: false
                });
            }
        }

        // N1 - Zona Segura
        const n1Enabled = isLevelEnabledLocal('N1');
        let patternStrength = 0;
        let patternColor = null;
        let patternDetailsText = n1Enabled ? 'NULO' : 'DESATIVADO';
        if (n1Enabled && safeZoneMeta) {
            if (!safeZoneMeta.zoneActive) {
                patternDetailsText = safeZoneMeta.reason === 'insufficient_history'
                    ? 'HistÃ³rico insuficiente'
                    : 'Requisitos nÃ£o atendidos';
            } else {
                const dominantLabel = safeZoneMeta.dominant
                    ? `${safeZoneMeta.dominant.toUpperCase()} ${safeZoneMeta.counts[safeZoneMeta.dominant]}/${safeZoneMeta.windowSize}`
                    : 'Zona ativa';
                if (safeZoneMeta.signal && safeZoneVote && safeZoneVote.color) {
                    patternColor = safeZoneVote.color;
                    patternStrength = clamp01(safeZoneVote.confidence ?? safeZoneMeta.strength ?? 0.5);
                    const entriesInfo = safeZoneMeta.maxEntries
                        ? `${safeZoneMeta.entriesUsed}/${safeZoneMeta.maxEntries}`
                        : `${safeZoneMeta.entriesUsed || 0}`;
                    patternDetailsText = `DominÃ¢ncia ${dominantLabel} â€¢ entradas ${entriesInfo}`;
                } else {
                    if (safeZoneMeta.reason === 'entry_limit_reached') {
                        patternDetailsText = `DominÃ¢ncia ${dominantLabel} â€¢ limite atingido (${safeZoneMeta.entriesUsed}/${safeZoneMeta.maxEntries})`;
                    } else {
                        patternDetailsText = `DominÃ¢ncia ${dominantLabel} â€¢ aguardando confirmaÃ§Ã£o`;
                    }
                }
            }
        }
        levelReports.push({
            id: 'N1',
            name: 'Zona Segura',
            color: patternColor,
            weight: n1Enabled ? weightFor(levelWeights.patterns) : 0,
            strength: patternStrength,
            score: patternColor ? directionValue(patternColor) * patternStrength : 0,
            details: patternDetailsText,
            disabled: !n1Enabled,
            meta: safeZoneMeta
        });

        // N2 - Ritmo AutÃ´nomo
        const n2Enabled = isLevelEnabledLocal('N2');
        const redMomentum = Number(nivel5.momentum?.red ?? 0);
        const blackMomentum = Number(nivel5.momentum?.black ?? 0);
        const diffMomentum = (isFinite(redMomentum) && isFinite(blackMomentum)) ? Math.abs(redMomentum - blackMomentum) : 0;
        const momentumColor = n2Enabled ? (nivel5 && nivel5.color ? nivel5.color : null) : null;
        // âœ… forÃ§a do N2 deve refletir o quÃ£o "significativo" foi o ritmo (nÃ£o sÃ³ a diferenÃ§a bruta)
        let momentumStrength = (n2Enabled && momentumColor && typeof nivel5?.confidence === 'number')
            ? clamp01(nivel5.confidence)
            : 0;
        const momentumDetailsText = !n2Enabled
            ? 'DESATIVADO'
            : (nivel5 && nivel5.details ? nivel5.details : `Î” ${diffMomentum.toFixed(1)} pp (P2+)`);
        const momentumScore = (n2Enabled && momentumColor) ? directionValue(momentumColor) * momentumStrength : 0;
        levelReports.push({
            id: 'N2',
            name: 'Ritmo AutÃ´nomo',
            color: momentumColor,
            weight: n2Enabled ? weightFor(levelWeights.momentum) : 0,
            strength: n2Enabled ? momentumStrength : 0,
            score: momentumScore,
            details: momentumDetailsText,
            disabled: !n2Enabled
        });

        // N3 - AlternÃ¢ncia
        const n3Enabled = isLevelEnabledLocal('N3');
        const alternanceColor = n3Enabled && nivel7 && nivel7.color ? nivel7.color : null;
        let alternanceStrength = 0;
        let alternanceDetailsText = n3Enabled
            ? (nivel7 && nivel7.details ? nivel7.details : 'NULO')
            : 'DESATIVADO';
        const alternanceOverrideActive = n3Enabled && Boolean(nivel7 && nivel7.override && alternanceColor);
        if (n3Enabled && alternanceColor) {
            const baseConfidence = typeof nivel7.confidence === 'number' ? nivel7.confidence : (nivel7.probability || 0);
            alternanceStrength = alternanceOverrideActive ? 1 : clamp01(baseConfidence);
            const probLabel = nivel7.probabilityPct ? ` ${nivel7.probabilityPct}%` : ` ${Math.round(alternanceStrength * 100)}%`;
            const occLabel = nivel7.occurrences != null ? ` â€¢ ${nivel7.occurrences} ocorr.` : '';
            const windowLabel = nivel7.windowLabel ? ` â€¢ ${nivel7.windowLabel}` : '';
            alternanceDetailsText = `${(nivel7.pattern || 'AlternÃ¢ncia').toUpperCase()}${probLabel}${occLabel}${windowLabel}` +
                (alternanceOverrideActive ? ' â€¢ Override' : '');
        } else if (n3Enabled && nivel7 && nivel7.reason) {
            alternanceDetailsText = nivel7.reason;
        }
        levelReports.push({
            id: 'N3',
            name: 'AlternÃ¢ncia',
            color: alternanceColor,
            weight: n3Enabled ? weightFor(levelWeights.alternance) : 0,
            strength: n3Enabled ? alternanceStrength : 0,
            score: n3Enabled ? directionValue(alternanceColor) * alternanceStrength : 0,
            details: alternanceDetailsText,
            override: alternanceOverrideActive,
            disabled: !n3Enabled
        });

        // N4 - Autointeligente
        const n4Enabled = isLevelEnabledLocal('N4');
        const autoColor = n4Enabled && nivel9 && nivel9.color ? nivel9.color : null;
        let autoStrength = 0;
        let autoDetailsText = n4Enabled ? 'NULO' : 'DESATIVADO';
        if (n4Enabled && autoColor) {
            autoStrength = clamp01(nivel9.confidence ?? 0);
            const p1Label = (typeof nivel9.p1 === 'number') ? `${(nivel9.p1 * 100).toFixed(1)}%` : `${Math.round(autoStrength * 100)}%`;
            const p2Label = (typeof nivel9.p2 === 'number') ? `${(nivel9.p2 * 100).toFixed(1)}%` : 'n/d';
            const p3Label = (typeof nivel9.p3 === 'number') ? `${(nivel9.p3 * 100).toFixed(1)}%` : 'n/d';
            autoDetailsText = `P1 ${p1Label} â€¢ P2 ${p2Label} â€¢ P3 ${p3Label}`;
        } else if (n4Enabled && nivel9 && nivel9.details) {
            autoDetailsText = nivel9.details;
        }
        levelReports.push({
            id: 'N4',
            name: 'Autointeligente',
            color: autoColor,
            weight: n4Enabled ? weightFor(levelWeights.persistence) : 0,
            strength: n4Enabled ? autoStrength : 0,
            score: n4Enabled && autoColor ? directionValue(autoColor) * autoStrength : 0,
            details: autoDetailsText,
            disabled: !n4Enabled
        });

        // N5 - Ritmo por Giro (minuto/posiÃ§Ã£o)
        const n5Enabled = isLevelEnabledLocal('N5');
        const minuteSpinWindow = Math.max(10, Math.min(200, getDiamondWindow('n5MinuteBias', 60)));
        const minuteBiasResult = analyzeMinuteSpinBias(history, targetMinute, nextSpinPosition, minuteSpinWindow);
        const minuteBiasColor = n5Enabled && minuteBiasResult && minuteBiasResult.color ? minuteBiasResult.color : null;
        let minuteBiasStrength = clamp01(minuteBiasResult ? minuteBiasResult.confidence : 0);
        let minuteBiasDetailsText = n5Enabled ? (minuteBiasResult ? minuteBiasResult.details : 'NULO') : 'DESATIVADO';
        if (n5Enabled && minuteBiasResult && minuteBiasResult.totalSamples) {
            minuteBiasDetailsText += ` â€¢ ${minuteBiasResult.totalSamples} amostras`;
        }
		levelReports.push({
			id: 'N5',
			name: 'Ritmo por Giro',
			color: minuteBiasColor,
            weight: n5Enabled ? weightFor(levelWeights.minuteSpin) : 0,
			strength: n5Enabled ? minuteBiasStrength : 0,
			score: n5Enabled ? directionValue(minuteBiasColor) * minuteBiasStrength : 0,
			details: minuteBiasDetailsText,
            disabled: !n5Enabled
		});

		const n6Enabled = isLevelEnabledLocal('N6');
		const retracementWindow = Math.max(30, Math.min(120, getDiamondWindow('n6RetracementWindow', 80)));
		const retracementResult = analyzeHistoricalRetracement(history, retracementWindow, analyzerConfig.signalIntensity || 'aggressive');
		levelReports.push({
			id: 'N6',
			name: 'RetraÃ§Ã£o HistÃ³rica',
			color: n6Enabled ? retracementResult.color : null,
			weight: n6Enabled ? weightFor(levelWeights.retracement) : 0,
			strength: n6Enabled ? (retracementResult.strength || 0) : 0,
			score: n6Enabled ? directionValue(retracementResult.color) * (retracementResult.strength || 0) : 0,
			details: n6Enabled ? retracementResult.details : 'DESATIVADO',
            disabled: !n6Enabled
		});

		const n7Enabled = isLevelEnabledLocal('N7');
		const decisionWindowConfigured = Math.max(10, Math.min(50, getDiamondWindow('n7DecisionWindow', 20)));
		const historyWindowConfigured = Math.max(decisionWindowConfigured, Math.min(200, getDiamondWindow('n7HistoryWindow', 100)));
		const continuityResult = analyzeGlobalContinuity(signalsHistory, decisionWindowConfigured, historyWindowConfigured, analyzerConfig.signalIntensity || 'aggressive');
		levelReports.push({
			id: 'N7',
			name: 'Continuidade Global',
			color: n7Enabled ? continuityResult.color : null,
			weight: n7Enabled ? weightFor(levelWeights.globalContinuity) : 0,
			strength: n7Enabled ? (continuityResult.strength || 0) : 0,
			score: n7Enabled ? directionValue(continuityResult.color) * (continuityResult.strength || 0) : 0,
			details: n7Enabled ? continuityResult.details : 'DESATIVADO',
            disabled: !n7Enabled
		});

        const n10Enabled = isLevelEnabledLocal('N10');
        let bayesResult = null;
        if (!n10Enabled) {
            console.log('%câ•‘  ğŸ§® N10 - CALIBRAÃ‡ÃƒO BAYESIANA DESATIVADA (pelo usuÃ¡rio) â•‘', 'color: #777777; font-weight: bold; font-size: 14px;');
        } else {
            console.log('%câ•‘  ğŸ§® N10 - CALIBRAÃ‡ÃƒO BAYESIANA (PROBABILIDADES)         â•‘', 'color: #1ABC9C; font-weight: bold; font-size: 14px;');
        const bayesHistoryConfigured = Math.max(30, Math.min(400, getDiamondWindow('n9History', 100)));
        const bayesNullThresholdConfigured = Math.max(2, Math.min(20, getDiamondWindow('n9NullThreshold', 8)));
        const bayesPriorStrengthConfigured = Math.max(0.2, Math.min(5, getDiamondWindow('n9PriorStrength', 1)));
        const bayesPriorConfig = {
            red: bayesPriorStrengthConfigured,
            black: bayesPriorStrengthConfigured,
            white: Math.max(0.1, bayesPriorStrengthConfigured * 0.5)
        };
            bayesResult = analyzeBayesianCalibration(
            history,
            bayesHistoryConfigured,
            bayesPriorConfig,
            bayesNullThresholdConfigured / 100
        );

        console.log(`%c   HistÃ³rico base: ${bayesResult.totalSamples}/${bayesHistoryConfigured} giros (cobertura ${(bayesResult.coverage * 100).toFixed(0)}%)`, 'color: #1ABC9C;');
        console.log(`%c   Probabilidades â†’ ğŸ”´ ${(bayesResult.probabilities.red * 100).toFixed(1)}% | âš« ${(bayesResult.probabilities.black * 100).toFixed(1)}% | âšª ${(bayesResult.probabilities.white * 100).toFixed(2)}%`, 'color: #1ABC9C;');
        console.log(`%c   DiferenÃ§a lÃ­der: ${(bayesResult.gap * 100).toFixed(1)}% (limiar ${bayesNullThresholdConfigured.toFixed(1)}%)`, 'color: #1ABC9C;');
        if (!bayesResult.color) {
            console.log('%c   ğŸ›‘ VOTO NULO: Probabilidades prÃ³ximas ou cobertura baixa', 'color: #FFAA00; font-weight: bold;');
        } else {
            console.log(`%c   ğŸ—³ï¸ VOTA: ${bayesResult.color.toUpperCase()} â€¢ ForÃ§a ${(Math.round((bayesResult.strength || 0) * 100))}%`, 'color: #1ABC9C; font-weight: bold;');
            }
        }

        if (n10Enabled && bayesResult && bayesResult.adjustments) {
            levelReports.forEach(level => {
                if (!level.color) return;
                const factor = bayesResult.adjustments[level.color] ?? 1;
                const originalStrength = level.strength;
                const adjustedStrength = clamp01((level.strength || 0) * factor);
                level.strength = adjustedStrength;
                level.score = directionValue(level.color) * adjustedStrength;
                if (level.details) {
                    const factorPct = Math.round(factor * 100);
                    if (factorPct !== 100) {
                        level.details += ` â€¢ N9 ${factorPct}%`;
                    }
                }
                console.log(`%c   â€¢ Ajuste N9 ${level.id}: fator ${(factor * 100).toFixed(0)}% (de ${(originalStrength * 100).toFixed(0)}% â†’ ${(adjustedStrength * 100).toFixed(0)}%)`, 'color: #1ABC9C;');
            });
        }

        // âœ… CORREÃ‡ÃƒO: N10 Ã© apenas calibrador, NÃƒO vota sozinho
        // Ele ajusta a forÃ§a dos outros nÃ­veis, mas nÃ£o gera voto prÃ³prio
        const bayesStrength = clamp01(bayesResult && bayesResult.strength ? bayesResult.strength : 0);
        levelReports.push({
            id: 'N10',
            name: 'CalibraÃ§Ã£o Bayesiana',
            color: null, // âœ… N10 nunca vota, apenas calibra outros nÃ­veis
            weight: 0, // âœ… Peso zero = nÃ£o participa da votaÃ§Ã£o
            strength: 0, // âœ… ForÃ§a zero = nÃ£o influencia diretamente
            score: 0, // âœ… Score zero = nÃ£o vota
            details: n10Enabled ? bayesResult.details : 'DESATIVADO',
            disabled: !n10Enabled
        });

        // ğŸ”¥ NOVA LÃ“GICA: AlternÃ¢ncia precisa de pelo menos 2 outros nÃ­veis concordando
        let alternanceOverride = false;
        let alternanceBlocked = false;
        let alternanceBlockReason = '';
        
        if (alternanceOverrideActive && alternanceColor) {
            // Contar quantos outros nÃ­veis concordam com a cor da alternÃ¢ncia
            const otherLevelsAgreeingCount = levelReports.filter(lvl => 
                lvl.id !== 'N3' && lvl.id !== 'N9' && lvl.color === alternanceColor
            ).length;
            
            console.log('%cğŸ” Validando Override de AlternÃ¢ncia...', 'color: #8E44AD; font-weight: bold;');
            console.log(`   Cor da alternÃ¢ncia: ${alternanceColor.toUpperCase()}`);
			console.log(`   Outros nÃ­veis concordando: ${otherLevelsAgreeingCount}/8 (N1, N2, N4, N5, N6, N7, N9, N10)`);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ğŸ›¡ï¸ CONTROLE DE ENTRADAS: MÃ¡ximo 2 entradas por alternÃ¢ncia
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            const alternanceSignature = `${nivel7.pattern}-${alternanceColor}`;
            const now = Date.now();
            
            // Verificar se Ã© a mesma alternÃ¢ncia que estÃ¡ ativa
            if (alternanceEntryControl.active && alternanceEntryControl.patternSignature === alternanceSignature) {
                console.log('%c   ğŸ“Š AlternÃ¢ncia jÃ¡ ativa:', 'color: #FFAA00; font-weight: bold;');
                console.log(`      Entradas feitas: ${alternanceEntryControl.entryCount}/2`);
                console.log(`      Ãšltimo resultado: ${alternanceEntryControl.lastResult || 'N/A'}`);
                console.log(`      Total: ${alternanceEntryControl.totalWins}W / ${alternanceEntryControl.totalLosses}L`);
                
                // ğŸ”¥ REGRA 1: Se teve LOSS na primeira entrada â†’ BLOQUEAR IMEDIATAMENTE
                if (alternanceEntryControl.lastResult === 'loss' && alternanceEntryControl.entryCount === 1) {
                    alternanceBlocked = true;
                    alternanceBlockReason = 'LOSS na 1Âª entrada â†’ bloqueado';
                    console.log('%c   âŒ BLOQUEADO: LOSS na primeira entrada!', 'color: #FF0000; font-weight: bold;');
                    console.log('%c      Sistema nÃ£o farÃ¡ mais entradas nesta alternÃ¢ncia.', 'color: #FF6666;');
                }
                // ğŸ”¥ REGRA 2: JÃ¡ fez 2 entradas â†’ LIMITE ATINGIDO
                else if (alternanceEntryControl.entryCount >= 2) {
                    alternanceBlocked = true;
                    alternanceBlockReason = `Limite de 2 entradas atingido`;
                    console.log('%c   âŒ BLOQUEADO: Limite de 2 entradas atingido!', 'color: #FF0000; font-weight: bold;');
                }
                // âœ… REGRA 3: WIN na 1Âª + tem entradas consecutivas configuradas â†’ Pode fazer 2Âª
                else if (alternanceEntryControl.lastResult === 'win' && alternanceEntryControl.entryCount === 1) {
                    const { consecutiveMartingale: allowsConsecutiveEntries } = getMartingaleSettings();
                    if (!allowsConsecutiveEntries) {
                        alternanceBlocked = true;
                        alternanceBlockReason = 'Entradas consecutivas desativadas';
                        console.log('%c   â¸ï¸ BLOQUEADO: Entradas consecutivas desativadas pelo usuÃ¡rio', 'color: #FFAA00; font-weight: bold;');
        } else {
                        console.log('%c   âœ… PERMITIDO: WIN na 1Âª entrada + consecutivas ativas â†’ pode fazer 2Âª', 'color: #00FF88; font-weight: bold;');
                    }
                }
            } else {
                // Nova alternÃ¢ncia detectada
                console.log('%c   ğŸ†• Nova alternÃ¢ncia detectada!', 'color: #00AAFF; font-weight: bold;');
            }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            if (alternanceBlocked) {
                console.log('%c   ğŸš« AlternÃ¢ncia BLOQUEADA:', alternanceBlockReason, 'color: #FF6666; font-weight: bold;');
            } else if (otherLevelsAgreeingCount >= 2) {
                alternanceOverride = true;
                console.log('%c   âœ… Override APROVADO! Pelo menos 2 nÃ­veis concordam.', 'color: #00FF88; font-weight: bold;');
                console.log('%c   âš¡ Anulando outros nÃ­veis...', 'color: #8E44AD; font-weight: bold;');
                
                levelReports.forEach(lvl => {
                    if (lvl.id !== 'N3' && lvl.id !== 'N6') {
                        lvl.details += ' â€¢ Anulado (AlternÃ¢ncia)';
                        lvl.score = 0;
                        lvl.strength = 0;
                    }
                });
                
                // ğŸ¯ ATIVAR CONTROLE DE ALTERNÃ‚NCIA (se ainda nÃ£o estiver ativo)
                if (!alternanceEntryControl.active || alternanceEntryControl.patternSignature !== alternanceSignature) {
                    alternanceEntryControl.active = true;
                    alternanceEntryControl.patternSignature = alternanceSignature;
                    alternanceEntryControl.entryColor = alternanceColor;
                    alternanceEntryControl.entryCount = 1; // Primeira entrada
                    alternanceEntryControl.lastResult = null; // Aguardando resultado
                    alternanceEntryControl.lastEntryTimestamp = now;
                    console.log('%c   ğŸ¯ Controle de alternÃ¢ncia ATIVADO (1Âª entrada)', 'color: #00FF88; font-weight: bold;');
        } else {
                    // Incrementar contador para 2Âª entrada
                    alternanceEntryControl.entryCount = 2;
                    alternanceEntryControl.lastEntryTimestamp = now;
                    console.log('%c   ğŸ¯ Controle de alternÃ¢ncia: 2Âª entrada registrada', 'color: #00FF88; font-weight: bold;');
                }
            } else {
                console.log('%c   âŒ Override REJEITADO! Menos de 2 nÃ­veis concordam.', 'color: #FF6666; font-weight: bold;');
                console.log('%c   â¤ AlternÃ¢ncia detectada, mas sem consenso suficiente dos outros nÃ­veis.', 'color: #FFAA00;');
                console.log('%c   â¤ Sistema continuarÃ¡ com votaÃ§Ã£o normal.', 'color: #FFAA00;');
            }
        }

        if (n0ForceWhite) {
            const nowMs = Number.isFinite(parseSpinTimestamp(history && history[0])) ? parseSpinTimestamp(history[0]) : Date.now();
            const cooldownGate = getN0PostWinCooldownGate({ history, nowMs });

            if (cooldownGate && cooldownGate.ok === false) {
                try {
                    const n0Report = Array.isArray(levelReports) ? levelReports.find(l => l && l.id === 'N0') : null;
                    if (n0Report && typeof n0Report.details === 'string') {
                        n0Report.details += ` â€¢ COOLDOWN ${cooldownGate.remaining}/${cooldownGate.required}`;
                    }
                } catch (_) {}
                console.log('%câšª N0 BLOCK ALL suprimido por COOLDOWN pÃ³s-WIN (nÃ£o reentrar imediato)', 'color: #FFAA00; font-weight: bold;');
            } else {
                const recentWhiteIdx = findMostRecentWhiteIndexForN0(history, 80);
                if (recentWhiteIdx === 0) {
                    // Consecutivo de branco Ã© raro no histÃ³rico real; evitar reentrada imediata apÃ³s qualquer WHITE.
                    console.log('%câšª N0 BLOCK ALL suprimido: branco acabou de sair (evitar consecutivo)', 'color: #FFAA00; font-weight: bold;');
                } else {
                // âœ… Budget deve ser "commitado" sÃ³ quando realmente vamos emitir sinal (evita gastar budget em sinal cancelado pelo intervalo).
                const gateBlockAll = (n0GateBlockAll && n0GateBlockAll.ok) ? n0GateBlockAll : null;
                const n0ConfForSignal = clamp01(
                    (gateBlockAll && typeof gateBlockAll.effectiveConfidence === 'number' && Number.isFinite(gateBlockAll.effectiveConfidence))
                        ? gateBlockAll.effectiveConfidence
                        : ((typeof n0EffectiveConfidence === 'number' && Number.isFinite(n0EffectiveConfidence)) ? n0EffectiveConfidence : n0WhiteStrength)
                );
                const preBudget = (() => {
                    try {
                        // Se jÃ¡ passamos pelo gate, reutilizar o check (commit=false) para evitar recalcular.
                        if (gateBlockAll && gateBlockAll.budget && gateBlockAll.budget.ok) return gateBlockAll.budget;
                        return decideN0WhiteSignalEmission({
                            history,
                            nowMs,
                            confidence: n0ConfForSignal,
                            lookaheadSpins: n0Options.lookaheadSpins,
                            override: false,
                            commit: false
                        });
                    } catch (_) {
                        return { ok: false, reason: 'budget_error' };
                    }
                })();

                if (!preBudget || !preBudget.ok) {
                    const reason = preBudget && preBudget.reason ? preBudget.reason : 'budget_block';
                    try {
                        const n0Report = Array.isArray(levelReports) ? levelReports.find(l => l && l.id === 'N0') : null;
                        if (n0Report && typeof n0Report.details === 'string') {
                            n0Report.details += ` â€¢ ${reason}`;
                        }
                    } catch (_) {}
                    console.log(`%câšª N0 BLOCK ALL suprimido pelo budget (${reason})`, 'color: #FFAA00; font-weight: bold;');
                } else {
                    console.log('%câšª N0 FORÃ‡OU BLOQUEIO TOTAL DOS DEMAIS NÃVEIS - SINAL BRANCO!', 'color: #FFFFFF; font-weight: bold; font-size: 16px; background: #000000;');
                    levelReports.sort((a, b) => {
                        const aIndex = displayOrder.indexOf(a.id);
                        const bIndex = displayOrder.indexOf(b.id);
                        const safeA = aIndex === -1 ? displayOrder.length : aIndex;
                        const safeB = bIndex === -1 ? displayOrder.length : bIndex;
                        return safeA - safeB;
                    });

                    if (intervalBlocked) {
                        sendAnalysisStatus(intervalMessage || 'â³ Aguardando intervalo configurado...');
                        await sleep(2000);
                        await restoreIAStatus();
                        console.log('%c   âŒ SINAL CANCELADO PELO INTERVALO!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
                        return null;
                    }

                    const committed = (() => {
                        try {
                            return decideN0WhiteSignalEmission({
                                history,
                                nowMs,
                                confidence: n0ConfForSignal,
                                lookaheadSpins: n0Options.lookaheadSpins,
                                override: false,
                                commit: true
                            });
                        } catch (_) {
                            return { ok: false, reason: 'budget_error' };
                        }
                    })();
                    if (!committed || !committed.ok) {
                        console.log(`%câšª N0 BLOCK ALL cancelado (budget mudou): ${committed && committed.reason ? committed.reason : 'erro'}`, 'color: #FFAA00; font-weight: bold;');
                    } else {
                        const whiteConfidencePct = Math.max(0, Math.min(100, Math.round(n0ConfForSignal * 100)));
                        const thresholdPct = n0Result && n0Result.blocking_threshold != null
                            ? Math.round(n0Result.blocking_threshold * 100)
                            : null;

                        sendAnalysisStatus(`âšª N0 - Detector de Branco: BLOCK ALL (${whiteConfidencePct}%${thresholdPct !== null ? ` â€¢ t* ${thresholdPct}%` : ''})${n0ActionSuppressed ? ' (informativo)' : ''}`);
                        await sleep(2000);
                        if (analyzerConfig.aiMode) {
                            sendAnalysisStatus('Sinal de entrada');
                        } else {
                            sendAnalysisStatus(`âœ… Sinal aprovado: WHITE (${whiteConfidencePct}%)`);
                        }
                        await sleep(2000);

                        const scoreSummary = levelReports.map(level => ({
                            id: level.id,
                            name: level.name,
                            color: level.color,
                            strength: Number((level.strength || 0).toFixed(3)),
                            weight: Number((level.weight || 0).toFixed(3)),
                            contribution: Number(((level.score || 0) * (level.weight || 0)).toFixed(3)),
                            details: level.details
                        }));
                        const diamondSourceLevel = pickDiamondSourceLevel(scoreSummary, 'white');

                        const bestMetrics = n0Result && n0Result.best_metrics ? n0Result.best_metrics : {};
                        const blockMetrics = n0Result && n0Result.blocking_metrics ? n0Result.blocking_metrics : {};
                        const holdoutReasoning = n0Result && n0Result.holdout && n0Result.holdout.enabled
                            ? `Holdout: ${n0Result.holdout.passed ? 'OK' : 'Falhou'}${n0Result.holdout.reason ? ` (${n0Result.holdout.reason})` : ''}\n`
                            : '';
                        const obsPack = (gateBlockAll && gateBlockAll.pack) ? gateBlockAll.pack : null;
                        const obsHour = (obsPack && obsPack.hourStats) ? obsPack.hourStats : null;
                        const obsPos = (obsPack && Array.isArray(obsPack.pos)) ? obsPack.pos : [];
                        const obsNeg = (obsPack && Array.isArray(obsPack.neg)) ? obsPack.neg : [];
                        const obsHourLine = obsHour
                            ? `Hora: ${obsHour.whitesThisHour}/${obsHour.target}${obsHour.avgWhitesPerHour != null ? ` (mÃ©dia ${Number(obsHour.avgWhitesPerHour).toFixed(1)})` : ''}\n`
                            : '';
                        const obsLine = (() => {
                            const posTxt = obsPos.length ? obsPos.slice(0, 8).join(' â€¢ ') : 'â€”';
                            const negTxt = obsNeg.length ? obsNeg.slice(0, 6).join(' â€¢ ') : 'â€”';
                            return `Obs+: ${posTxt}\nObs-: ${negTxt}\n`;
                        })();
                        const reasoning =
                            `${levelReports.map(level => describeLevel(level, { includeEmoji: false })).join('\n')}\n` +
                            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
                            `Detector de Branco (N0)\n` +
                            `ConfianÃ§a: ${whiteConfidencePct}%\n` +
                            obsHourLine +
                            obsLine +
                            `t*: ${thresholdPct !== null ? `${thresholdPct}%` : 'n/d'} â€¢ F1 ${(bestMetrics.f1 != null ? (bestMetrics.f1 * 100).toFixed(1) : 'n/d')}% â€¢ Precision* ${(blockMetrics.precision != null ? (blockMetrics.precision * 100).toFixed(1) : 'n/d')}%\n` +
                            holdoutReasoning +
                            `Configs: ${n0Result && n0Result.effective_configs != null ? `${n0Result.effective_configs}/${n0Result.tested_configs}` : (n0Result && n0Result.tested_configs != null ? n0Result.tested_configs : 'n/d')}\n` +
                            `AÃ§Ã£o: BLOCK ALL${n0ActionSuppressed ? ' (modo informativo)' : ''}`;

                        const diamondN0 = (() => {
                            try {
                                if (!n0Enabled) return null;
                                if (!n0Result || n0Result.enabled === false) return null;
                                const key = (n0Result && typeof n0Result.learning_key === 'string') ? n0Result.learning_key : null;
                                const ctx = (n0Result && typeof n0Result.learning_context === 'string') ? n0Result.learning_context : null;
                                return {
                                    voteColor: 'white',
                                    key,
                                    ctx,
                                    usedInFinal: true,
                                    decision: (n0Result && typeof n0Result.learning_decision === 'string') ? n0Result.learning_decision : 'none',
                                    action: (n0Result && typeof n0Result.blocking_action === 'string') ? n0Result.blocking_action : 'block_all'
                                };
                            } catch (_) {
                                return null;
                            }
                        })();

                        const signal = {
                            timestamp: Date.now(),
                            patternType: 'nivel-diamante',
                            patternName: 'Detector de Branco (N0)',
                            colorRecommended: 'white',
                            normalizedScore: Number(n0ConfForSignal.toFixed(4)),
                            scoreMagnitude: Number(n0ConfForSignal.toFixed(4)),
                            intensityMode: analyzerConfig.signalIntensity || 'aggressive',
                            rawConfidence: whiteConfidencePct,
                            finalConfidence: whiteConfidencePct,
                            levelBreakdown: scoreSummary,
                            sourceLevel: diamondSourceLevel,
                            reasoning,
                            verified: false,
                            colorThatCame: null,
                            hit: null
                        };

                        if (signalsHistory && signalsHistory.signals) {
                            signalsHistory.signals.push(signal);
                            if (signalsHistory.signals.length > 200) {
                                signalsHistory.signals = signalsHistory.signals.slice(-200);
                            }
                            try { snapshotN0WhiteBudgetStateIntoSignalsHistory(); } catch (_) {}
                            await saveSignalsHistory();
                        }

                        if (!memoriaAtiva.inicializada) {
                            memoriaAtiva.inicializada = true;
                            memoriaAtiva.ultimaAtualizacao = Date.now();
                            memoriaAtiva.totalAtualizacoes = 1;
                            memoriaAtiva.giros = history.slice(0, getMemoriaAtivaHistoryCap());
                            console.log('%câœ… MemÃ³ria Ativa marcada como INICIALIZADA!', 'color: #00FF00; font-weight: bold;');
                        } else {
                            memoriaAtiva.totalAtualizacoes++;
                            memoriaAtiva.ultimaAtualizacao = Date.now();
                        }

                        return {
                            color: 'white',
                            confidence: whiteConfidencePct,
                            probability: whiteConfidencePct,
                            reasoning,
                            patternDescription: 'Detector de Branco (N0)',
                            diamondSourceLevel,
                            diamondN0
                        };
                    }
                }
                }
            }
        }

        const anyVotingLevelEnabled = (() => {
            try {
                const votingIds = ['N1','N2','N3','N4','N5','N6','N7','N8'];
                return votingIds.some((id) => isLevelEnabledLocal(id));
            } catch (_) {
                return false;
            }
        })();
        // âœ… "Predicted" agora significa: N0 viu WHITE *e* o gate/observadores aprovaram o cenÃ¡rio.
        const n0PredictedWhite = !!n0UiVoteWhite;

        // âœ… MODO MISTO (N0 + outros nÃ­veis):
        // Se o N0 prever WHITE com confianÃ§a suficiente (>= limiar do SOFT), emitir sinal WHITE
        // mesmo com outros nÃ­veis ativos. Isso evita longos perÃ­odos sem sinal de branco.
        const nowMsForBudget = Number.isFinite(parseSpinTimestamp(history && history[0])) ? parseSpinTimestamp(history[0]) : Date.now();
        const n0CooldownGate = getN0PostWinCooldownGate({ history, nowMs: nowMsForBudget });
        const n0BudgetCheck = (() => {
            if (!n0PredictedWhite) {
                const r = (n0GateAlert && typeof n0GateAlert.reason === 'string') ? n0GateAlert.reason : 'not_predicted';
                return { ok: false, reason: r };
            }
            if (n0CooldownGate && n0CooldownGate.ok === false) {
                return { ok: false, reason: n0CooldownGate.reason || 'cooldown', cooldown: n0CooldownGate };
            }
            // âœ… Evitar consecutivo de branco (histÃ³rico real mostra que Ã© raro)
            const recentWhiteIdx = findMostRecentWhiteIndexForN0(history, 80);
            if (recentWhiteIdx === 0) {
                return { ok: false, reason: 'recent_white_spin' };
            }

            const eff = clamp01(
                (typeof n0EffectiveConfidence === 'number' && Number.isFinite(n0EffectiveConfidence))
                    ? n0EffectiveConfidence
                    : n0WhiteStrength
            );
            const pack = (n0GateAlert && n0GateAlert.pack) ? n0GateAlert.pack : null;
            try {
                const base = (n0GateAlert && n0GateAlert.ok && n0GateAlert.budget && n0GateAlert.budget.ok)
                    ? n0GateAlert.budget
                    : decideN0WhiteSignalEmission({
                        history,
                        nowMs: nowMsForBudget,
                        confidence: eff,
                        lookaheadSpins: n0Options.lookaheadSpins,
                        override: false,
                        commit: false
                    });
                if (!base || !base.ok) {
                    return { ...(base || {}), ok: false, reason: base && base.reason ? base.reason : 'budget_block', effectiveConfidence: eff, pack };
                }
                return { ...base, ok: true, effectiveConfidence: eff, pack };
            } catch (_) {
                return { ok: false, reason: 'budget_error', effectiveConfidence: eff, pack };
            }
        })();

        if (anyVotingLevelEnabled && n0BudgetCheck && n0BudgetCheck.ok) {
            levelReports.sort((a, b) => {
                const aIndex = displayOrder.indexOf(a.id);
                const bIndex = displayOrder.indexOf(b.id);
                const safeA = aIndex === -1 ? displayOrder.length : aIndex;
                const safeB = bIndex === -1 ? displayOrder.length : bIndex;
                return safeA - safeB;
            });

            if (intervalBlocked) {
                sendAnalysisStatus(intervalMessage || 'â³ Aguardando intervalo configurado...');
                await sleep(2000);
                await restoreIAStatus();
                console.log('%c   âŒ SINAL CANCELADO PELO INTERVALO!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
                return null;
            }

            const committed = (() => {
                try {
                    return decideN0WhiteSignalEmission({
                        history,
                        nowMs: nowMsForBudget,
                        confidence: (n0BudgetCheck && typeof n0BudgetCheck.effectiveConfidence === 'number' && Number.isFinite(n0BudgetCheck.effectiveConfidence))
                            ? n0BudgetCheck.effectiveConfidence
                            : n0WhiteStrength,
                        lookaheadSpins: n0Options.lookaheadSpins,
                        override: false,
                        commit: true
                    });
                } catch (_) {
                    return { ok: false, reason: 'budget_error' };
                }
            })();
            if (!committed || !committed.ok) {
                console.log(`%câšª N0 cancelado (budget mudou): ${committed && committed.reason ? committed.reason : 'erro'}`, 'color: #FFAA00; font-weight: bold;');
            } else {
            const whiteConfidencePct = Math.max(0, Math.min(100, Math.round(
                ((n0BudgetCheck && typeof n0BudgetCheck.effectiveConfidence === 'number' && Number.isFinite(n0BudgetCheck.effectiveConfidence))
                    ? n0BudgetCheck.effectiveConfidence
                    : n0WhiteStrength) * 100
            )));
            const thresholdPct = n0Result && n0Result.blocking_threshold != null
                ? Math.round(n0Result.blocking_threshold * 100)
                : null;
            const actionLabel =
                n0SoftBlockActive ? 'SOFT BLOCK'
                : (n0ActionSuppressed ? 'ALERTA (informativo)' : 'ALERTA');

            console.log('%câšª N0 PREVIU WHITE (modo misto) â€” emitindo sinal WHITE', 'color: #FFFFFF; font-weight: bold; font-size: 15px; background: #000000;');
            sendAnalysisStatus(`âšª N0 - Detector de Branco: ${actionLabel} (${whiteConfidencePct}%${thresholdPct !== null ? ` â€¢ t* ${thresholdPct}%` : ''})`);
            await sleep(1500);
            sendAnalysisStatus('Sinal de entrada');
            await sleep(1500);

            const scoreSummary = levelReports.map(level => ({
                id: level.id,
                name: level.name,
                color: level.color,
                strength: Number((level.strength || 0).toFixed(3)),
                weight: Number((level.weight || 0).toFixed(3)),
                contribution: Number(((level.score || 0) * (level.weight || 0)).toFixed(3)),
                details: level.details
            }));
            const diamondSourceLevel = pickDiamondSourceLevel(scoreSummary, 'white');

            const holdoutReasoning = n0Result && n0Result.holdout && n0Result.holdout.enabled
                ? `Holdout: ${n0Result.holdout.passed ? 'OK' : 'Falhou'}${n0Result.holdout.reason ? ` (${n0Result.holdout.reason})` : ''}\n`
                : '';
            const obsPack = (n0BudgetCheck && n0BudgetCheck.pack) ? n0BudgetCheck.pack : ((n0GateAlert && n0GateAlert.pack) ? n0GateAlert.pack : null);
            const obsHour = (obsPack && obsPack.hourStats) ? obsPack.hourStats : null;
            const obsPos = (obsPack && Array.isArray(obsPack.pos)) ? obsPack.pos : [];
            const obsNeg = (obsPack && Array.isArray(obsPack.neg)) ? obsPack.neg : [];
            const obsHourLine = obsHour
                ? `Hora: ${obsHour.whitesThisHour}/${obsHour.target}${obsHour.avgWhitesPerHour != null ? ` (mÃ©dia ${Number(obsHour.avgWhitesPerHour).toFixed(1)})` : ''}\n`
                : '';
            const obsLine = (() => {
                const posTxt = obsPos.length ? obsPos.slice(0, 8).join(' â€¢ ') : 'â€”';
                const negTxt = obsNeg.length ? obsNeg.slice(0, 6).join(' â€¢ ') : 'â€”';
                return `Obs+: ${posTxt}\nObs-: ${negTxt}\n`;
            })();
            const reasoning =
                `${levelReports.map(level => describeLevel(level, { includeEmoji: false })).join('\n')}\n` +
                `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
                `Detector de Branco (N0)\n` +
                `Modo: misto (N0 + outros nÃ­veis)\n` +
                `ConfianÃ§a: ${whiteConfidencePct}%\n` +
                obsHourLine +
                obsLine +
                `t*: ${thresholdPct !== null ? `${thresholdPct}%` : 'n/d'}\n` +
                holdoutReasoning +
                `AÃ§Ã£o: ${actionLabel}`;

            const diamondN0 = (() => {
                try {
                    const key = (n0Result && typeof n0Result.learning_key === 'string') ? n0Result.learning_key : null;
                    const ctx = (n0Result && typeof n0Result.learning_context === 'string') ? n0Result.learning_context : null;
                    return {
                        voteColor: 'white',
                        key,
                        ctx,
                        usedInFinal: true,
                        decision: (n0Result && typeof n0Result.learning_decision === 'string') ? n0Result.learning_decision : 'none',
                        action: (n0Result && typeof n0Result.blocking_action === 'string') ? n0Result.blocking_action : 'no_block'
                    };
                } catch (_) {
                    return null;
                }
            })();

            const signal = {
                timestamp: Date.now(),
                patternType: 'nivel-diamante',
                patternName: 'Detector de Branco (N0)',
                colorRecommended: 'white',
                normalizedScore: Number((
                    (n0BudgetCheck && typeof n0BudgetCheck.effectiveConfidence === 'number' && Number.isFinite(n0BudgetCheck.effectiveConfidence))
                        ? n0BudgetCheck.effectiveConfidence
                        : n0WhiteStrength
                ).toFixed(4)),
                scoreMagnitude: Number((
                    (n0BudgetCheck && typeof n0BudgetCheck.effectiveConfidence === 'number' && Number.isFinite(n0BudgetCheck.effectiveConfidence))
                        ? n0BudgetCheck.effectiveConfidence
                        : n0WhiteStrength
                ).toFixed(4)),
                intensityMode: analyzerConfig.signalIntensity || 'aggressive',
                rawConfidence: whiteConfidencePct,
                finalConfidence: whiteConfidencePct,
                levelBreakdown: scoreSummary,
                sourceLevel: diamondSourceLevel,
                reasoning,
                verified: false,
                colorThatCame: null,
                hit: null
            };

            if (signalsHistory && signalsHistory.signals) {
                signalsHistory.signals.push(signal);
                if (signalsHistory.signals.length > 200) {
                    signalsHistory.signals = signalsHistory.signals.slice(-200);
                }
                try { snapshotN0WhiteBudgetStateIntoSignalsHistory(); } catch (_) {}
                await saveSignalsHistory();
            }

            if (!memoriaAtiva.inicializada) {
                memoriaAtiva.inicializada = true;
                memoriaAtiva.ultimaAtualizacao = Date.now();
                memoriaAtiva.totalAtualizacoes = 1;
                memoriaAtiva.giros = history.slice(0, getMemoriaAtivaHistoryCap());
                console.log('%câœ… MemÃ³ria Ativa marcada como INICIALIZADA!', 'color: #00FF00; font-weight: bold;');
            } else {
                memoriaAtiva.totalAtualizacoes++;
                memoriaAtiva.ultimaAtualizacao = Date.now();
            }

            return {
                color: 'white',
                confidence: whiteConfidencePct,
                probability: whiteConfidencePct,
                reasoning,
                patternDescription: 'Detector de Branco (N0)',
                diamondSourceLevel,
                diamondN0
            };
            }
        }

        // âœ… MODO "SOMENTE N0":
        // Se NÃƒO houver nenhum nÃ­vel votante (N1â€“N8) ativo, o N0 deve conseguir operar de forma independente.
        // Antes: o sistema ficava mudo porque o N0 sÃ³ gerava sinal quando era BLOCK ALL (n0ForceWhite).
        // Agora: se o N0 prever WHITE (mesmo em ALERTA/SOFT BLOCK/informativo), emitimos sinal WHITE.
        if (!anyVotingLevelEnabled && n0BudgetCheck && n0BudgetCheck.ok) {
            levelReports.sort((a, b) => {
                const aIndex = displayOrder.indexOf(a.id);
                const bIndex = displayOrder.indexOf(b.id);
                const safeA = aIndex === -1 ? displayOrder.length : aIndex;
                const safeB = bIndex === -1 ? displayOrder.length : bIndex;
                return safeA - safeB;
            });

            if (intervalBlocked) {
                sendAnalysisStatus(intervalMessage || 'â³ Aguardando intervalo configurado...');
                await sleep(2000);
                await restoreIAStatus();
                console.log('%c   âŒ SINAL CANCELADO PELO INTERVALO!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
                return null;
            }

            const committed = (() => {
                try {
                    return decideN0WhiteSignalEmission({
                        history,
                        nowMs: nowMsForBudget,
                        confidence: (n0BudgetCheck && typeof n0BudgetCheck.effectiveConfidence === 'number' && Number.isFinite(n0BudgetCheck.effectiveConfidence))
                            ? n0BudgetCheck.effectiveConfidence
                            : n0WhiteStrength,
                        lookaheadSpins: n0Options.lookaheadSpins,
                        override: false,
                        commit: true
                    });
                } catch (_) {
                    return { ok: false, reason: 'budget_error' };
                }
            })();
            if (!committed || !committed.ok) {
                console.log(`%câšª N0 (somente) cancelado (budget mudou): ${committed && committed.reason ? committed.reason : 'erro'}`, 'color: #FFAA00; font-weight: bold;');
            } else {
            const whiteConfidencePct = Math.max(0, Math.min(100, Math.round(
                ((n0BudgetCheck && typeof n0BudgetCheck.effectiveConfidence === 'number' && Number.isFinite(n0BudgetCheck.effectiveConfidence))
                    ? n0BudgetCheck.effectiveConfidence
                    : n0WhiteStrength) * 100
            )));
            const thresholdPct = n0Result && n0Result.blocking_threshold != null
                ? Math.round(n0Result.blocking_threshold * 100)
                : null;
            const actionLabel =
                n0SoftBlockActive ? 'SOFT BLOCK'
                : (n0ActionSuppressed ? 'ALERTA (informativo)' : 'ALERTA');

            console.log('%câšª N0 (somente) PREVIU WHITE â€” emitindo sinal independente', 'color: #FFFFFF; font-weight: bold; font-size: 15px; background: #000000;');
            sendAnalysisStatus(`âšª N0 - Detector de Branco: ${actionLabel} (${whiteConfidencePct}%${thresholdPct !== null ? ` â€¢ t* ${thresholdPct}%` : ''})`);
            await sleep(1500);
            sendAnalysisStatus('Sinal de entrada');
            await sleep(1500);

            const scoreSummary = levelReports.map(level => ({
                id: level.id,
                name: level.name,
                color: level.color,
                strength: Number((level.strength || 0).toFixed(3)),
                weight: Number((level.weight || 0).toFixed(3)),
                contribution: Number(((level.score || 0) * (level.weight || 0)).toFixed(3)),
                details: level.details
            }));
            const diamondSourceLevel = pickDiamondSourceLevel(scoreSummary, 'white');

            const holdoutReasoning = n0Result && n0Result.holdout && n0Result.holdout.enabled
                ? `Holdout: ${n0Result.holdout.passed ? 'OK' : 'Falhou'}${n0Result.holdout.reason ? ` (${n0Result.holdout.reason})` : ''}\n`
                : '';
            const obsPack = (n0BudgetCheck && n0BudgetCheck.pack) ? n0BudgetCheck.pack : ((n0GateAlert && n0GateAlert.pack) ? n0GateAlert.pack : null);
            const obsHour = (obsPack && obsPack.hourStats) ? obsPack.hourStats : null;
            const obsPos = (obsPack && Array.isArray(obsPack.pos)) ? obsPack.pos : [];
            const obsNeg = (obsPack && Array.isArray(obsPack.neg)) ? obsPack.neg : [];
            const obsHourLine = obsHour
                ? `Hora: ${obsHour.whitesThisHour}/${obsHour.target}${obsHour.avgWhitesPerHour != null ? ` (mÃ©dia ${Number(obsHour.avgWhitesPerHour).toFixed(1)})` : ''}\n`
                : '';
            const obsLine = (() => {
                const posTxt = obsPos.length ? obsPos.slice(0, 8).join(' â€¢ ') : 'â€”';
                const negTxt = obsNeg.length ? obsNeg.slice(0, 6).join(' â€¢ ') : 'â€”';
                return `Obs+: ${posTxt}\nObs-: ${negTxt}\n`;
            })();
            const reasoning =
                `${levelReports.map(level => describeLevel(level, { includeEmoji: false })).join('\n')}\n` +
                `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
                `Detector de Branco (N0)\n` +
                `Modo: somente N0\n` +
                `ConfianÃ§a: ${whiteConfidencePct}%\n` +
                obsHourLine +
                obsLine +
                `t*: ${thresholdPct !== null ? `${thresholdPct}%` : 'n/d'}\n` +
                holdoutReasoning +
                `AÃ§Ã£o: ${actionLabel}`;

            const diamondN0 = (() => {
                try {
                    const key = (n0Result && typeof n0Result.learning_key === 'string') ? n0Result.learning_key : null;
                    const ctx = (n0Result && typeof n0Result.learning_context === 'string') ? n0Result.learning_context : null;
                    return {
                        voteColor: 'white',
                        key,
                        ctx,
                        usedInFinal: true,
                        decision: (n0Result && typeof n0Result.learning_decision === 'string') ? n0Result.learning_decision : 'none',
                        action: (n0Result && typeof n0Result.blocking_action === 'string') ? n0Result.blocking_action : 'no_block'
                    };
                } catch (_) {
                    return null;
                }
            })();

            const signal = {
                timestamp: Date.now(),
                patternType: 'nivel-diamante',
                patternName: 'Detector de Branco (N0)',
                colorRecommended: 'white',
                normalizedScore: Number((
                    (n0BudgetCheck && typeof n0BudgetCheck.effectiveConfidence === 'number' && Number.isFinite(n0BudgetCheck.effectiveConfidence))
                        ? n0BudgetCheck.effectiveConfidence
                        : n0WhiteStrength
                ).toFixed(4)),
                scoreMagnitude: Number((
                    (n0BudgetCheck && typeof n0BudgetCheck.effectiveConfidence === 'number' && Number.isFinite(n0BudgetCheck.effectiveConfidence))
                        ? n0BudgetCheck.effectiveConfidence
                        : n0WhiteStrength
                ).toFixed(4)),
                intensityMode: analyzerConfig.signalIntensity || 'aggressive',
                rawConfidence: whiteConfidencePct,
                finalConfidence: whiteConfidencePct,
                levelBreakdown: scoreSummary,
                sourceLevel: diamondSourceLevel,
                reasoning,
                verified: false,
                colorThatCame: null,
                hit: null
            };

            if (signalsHistory && signalsHistory.signals) {
                signalsHistory.signals.push(signal);
                if (signalsHistory.signals.length > 200) {
                    signalsHistory.signals = signalsHistory.signals.slice(-200);
                }
                try { snapshotN0WhiteBudgetStateIntoSignalsHistory(); } catch (_) {}
                await saveSignalsHistory();
            }

            if (!memoriaAtiva.inicializada) {
                memoriaAtiva.inicializada = true;
                memoriaAtiva.ultimaAtualizacao = Date.now();
                memoriaAtiva.totalAtualizacoes = 1;
                memoriaAtiva.giros = history.slice(0, getMemoriaAtivaHistoryCap());
                console.log('%câœ… MemÃ³ria Ativa marcada como INICIALIZADA!', 'color: #00FF00; font-weight: bold;');
            } else {
                memoriaAtiva.totalAtualizacoes++;
                memoriaAtiva.ultimaAtualizacao = Date.now();
            }

            return {
                color: 'white',
                confidence: whiteConfidencePct,
                probability: whiteConfidencePct,
                reasoning,
                patternDescription: 'Detector de Branco (N0)',
                diamondSourceLevel,
                diamondN0
            };
            }
        }

        const scoreWithoutBarrier = levelReports.reduce((sum, lvl) => sum + (lvl.score * lvl.weight), 0);
        if (n0SoftBlockActive) {
            console.log('%câš ï¸ Soft block ativo: pesos dos nÃ­veis reduzidos em 50% para este giro', 'color: #FFAA00; font-weight: bold;');
        }

        // âœ… Para a Barreira (N9), usar a cor lÃ­der da votaÃ§Ã£o (incluindo WHITE) quando houver lideranÃ§a clara.
        // Isso evita validar RED/BLACK quando o N4 estiver votando WHITE sozinho.
        const preVoteCounts = { red: 0, black: 0, white: 0 };
        levelReports.forEach(lvl => {
            if (!lvl || lvl.disabled) return;
            if (lvl.id === 'N0' || lvl.id === 'N9' || lvl.id === 'N10') return;
            if (!lvl.color || (lvl.strength || 0) <= 0) return;
            if (lvl.color === 'red') preVoteCounts.red++;
            if (lvl.color === 'black') preVoteCounts.black++;
            if (lvl.color === 'white') preVoteCounts.white++;
        });
        const orderedPreVotes = Object.entries(preVoteCounts).sort(([, a], [, b]) => b - a);
        const preLeader = orderedPreVotes[0] || ['red', 0];
        const preSecond = orderedPreVotes[1] || ['black', 0];
        const hasPreLeader = preLeader[1] > 0 && preLeader[1] !== preSecond[1];

        let predictedColor = hasPreLeader
            ? preLeader[0]
            : (scoreWithoutBarrier === 0
            ? (minuteBiasColor || momentumColor || patternColor || 'red')
                : (scoreWithoutBarrier >= 0 ? 'red' : 'black'));

        if (alternanceOverride) {
            predictedColor = alternanceColor;
        }
        const n9Enabled = isLevelEnabledLocal('N9');
        let barrierResult = {
            allowed: true,
            currentStreak: 0,
            targetStreak: 0,
            maxStreakFound: 0,
            reason: 'Desativado pelo usuÃ¡rio',
            alternanceBlocked: false
        };
        let barrierDetailsText = 'DESATIVADO';
        let barrierStrength = 0;

        if (!n9Enabled) {
            console.log('%câ•‘  ğŸ›‘ N9 - BARREIRA FINAL DESATIVADA (pelo usuÃ¡rio)       â•‘', 'color: #777777; font-weight: bold; font-size: 14px;');
        } else {
        console.log('%câ•‘  ğŸ›‘ NÃVEL 6: BARREIRA/FREIO (VALIDAÃ‡ÃƒO FINAL)          â•‘', 'color: #FF0000; font-weight: bold; font-size: 14px;');
        console.log(`%cğŸ¯ Cor candidata antes da barreira: ${predictedColor.toUpperCase()}`, `color: ${predictedColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
        console.log(`%cğŸ“Š ConfiguraÃ§Ã£o: ${historySize} giros para anÃ¡lise`, 'color: #FF0000;');

            barrierResult = validateSequenceBarrier(history, predictedColor, getDiamondWindow('n8Barrier', historySize), {
            override: alternanceOverrideActive,
            targetRuns: nivel7 ? nivel7.alternanceTargetRuns : null,
            maxRuns: nivel7 ? nivel7.alternanceMaxRuns : null
        });
            const alternanceSummaryText = nivel7 && nivel7.details ? nivel7.details : 'AlternÃ¢ncia em anÃ¡lise';
            barrierDetailsText = barrierResult.alternanceBlocked
            ? `AlternÃ¢ncia bloqueada â€¢ ${alternanceSummaryText}`
            : `Atual ${barrierResult.currentStreak} â€¢ alvo ${barrierResult.targetStreak} â€¢ mÃ¡x ${barrierResult.maxStreakFound}` +
                (barrierResult.gapRuleBlocked ? ' (sem folga)' : '');

        // ğŸ”¥ VERIFICAR SE ALTERNÃ‚NCIA ESTÃ BLOQUEADA
        if (alternanceBlocked && alternanceOverrideActive) {
            console.log('%cğŸš«ğŸš«ğŸš« SINAL BLOQUEADO - CONTROLE DE ALTERNÃ‚NCIA! ğŸš«ğŸš«ğŸš«', 'color: #FFFFFF; font-weight: bold; font-size: 16px; background: #FF0000;');
            console.log(`%c   Motivo: ${alternanceBlockReason}`, 'color: #FF6666; font-weight: bold;');
            await emitLevelStatuses(levelReports, { force: true });
            sendAnalysisStatus(`ğŸ›‘ N3 - AlternÃ¢ncia â†’ âŒ BLOQUEADO (${alternanceBlockReason})`);
            await sleep(1500);
            sendAnalysisStatus('âŒ Sinal rejeitado: limite de entradas de alternÃ¢ncia');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }
        const streakGap = barrierResult.maxStreakFound - barrierResult.targetStreak;
        if (barrierResult.allowed) {
            barrierStrength = 0.4;
        if (streakGap >= 2) {
            barrierStrength = 0.6;
        } else if (streakGap === 1) {
            barrierStrength = 0.5;
        }
        }
        }
        const barrierStatusLabel = barrierResult.allowed ? 'APROVADO' : 'BLOQUEADO';
        
        // âœ… CORREÃ‡ÃƒO: N9 Ã© apenas validador, NÃƒO vota
        // Verificar se hÃ¡ votos de outros nÃ­veis (excluindo N0, N9 e N10)
        const otherLevelsVoting = levelReports.filter(lvl => 
            lvl.id !== 'N0' && lvl.id !== 'N9' && lvl.id !== 'N10' && 
            !lvl.disabled && lvl.color && (lvl.strength || 0) > 0
        );
        const hasOtherVotes = otherLevelsVoting.length > 0;
        
        levelReports.push({
            id: 'N9',
            name: 'Barreira Final',
            color: null, // âœ… N9 nunca vota, apenas valida
            weight: 0, // âœ… Peso zero = nÃ£o participa da votaÃ§Ã£o
            strength: 0, // âœ… ForÃ§a zero = nÃ£o influencia
            score: 0, // âœ… Score zero = nÃ£o vota
            details: n9Enabled ? `${barrierStatusLabel} â€¢ ${barrierDetailsText}` : 'DESATIVADO',
            disabled: !n9Enabled
        });

        levelReports.sort((a, b) => {
            const aIndex = displayOrder.indexOf(a.id);
            const bIndex = displayOrder.indexOf(b.id);
            const safeA = aIndex === -1 ? displayOrder.length : aIndex;
            const safeB = bIndex === -1 ? displayOrder.length : bIndex;
            return safeA - safeB;
        });

        const summaryStyle = 'color: #00FFFF; font-weight: bold;';
        console.log('%câ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—', summaryStyle);
        console.log('%câ•‘  ğŸ’ NÃVEIS DIAMANTE - CONSOLIDADO                         â•‘', summaryStyle);
        displayOrder.forEach(id => {
            const level = levelReports.find(lvl => lvl.id === id);
            let description;
            if (level) {
                description = describeLevel(level);
            } else {
                const meta = levelMeta[id] || { emoji: 'â–«ï¸', label: `${id}` };
                description = `${meta.emoji} ${meta.label} â†’ N/A`;
            }
            console.log(`%câ•‘  ${description}`, summaryStyle);
        });
        console.log('%câ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•', summaryStyle);

        if (!barrierResult.allowed) {
            console.log('%cğŸš«ğŸš«ğŸš« SINAL BLOQUEADO PELA BARREIRA! ğŸš«ğŸš«ğŸš«', 'color: #FFFFFF; font-weight: bold; font-size: 16px; background: #FF0000;');
            console.log('%c   SequÃªncia sem precedente histÃ³rico!', 'color: #FF6666; font-weight: bold;');
        await emitLevelStatuses(levelReports, { force: true });
        sendAnalysisStatus(`N9 - Barreira Final: BLOQUEADO (${barrierDetailsText})`);
        await sleep(2000);
            await restoreIAStatus();
            console.log('%c   âŒ SINAL CANCELADO!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
            return null;
        }

        console.log('%câœ… BARREIRA LIBERADA! SequÃªncia Ã© viÃ¡vel.', 'color: #00FF88; font-weight: bold; font-size: 14px;');
        
        // âœ… VERIFICAÃ‡ÃƒO CRÃTICA:
        // Se nÃ£o houver nenhum voto vindo dos nÃ­veis "votantes" (N1..N8), cancelar o sinal.
        // - N9/N10 sÃ£o validadores/veto (nÃ£o sÃ£o voto).
        // - N0 Ã© detector de branco (sÃ³ vira "sinal" quando FORÃ‡A WHITE via BLOCK ALL).
        const votingLevelsOnly = levelReports.filter(lvl => 
            lvl.id !== 'N0' && lvl.id !== 'N9' && lvl.id !== 'N10' && 
            !lvl.disabled && lvl.color && (lvl.strength || 0) > 0
        );
        
        if (votingLevelsOnly.length === 0) {
            const n0EnabledNow = !!diamondLevelEnabledMap['N0'];
            const activeEnabledIds = DIAMOND_LEVEL_IDS.filter(id => !!diamondLevelEnabledMap[id]);
            const activeEnabledLabel = activeEnabledIds.length > 0 ? activeEnabledIds.join(', ') : 'nenhum';
            const hint = n0EnabledNow
                ? 'Dica: com sÃ³ N0 (Detector de Branco) ativo, sinais podem ficar horas sem aparecer â€” ele sÃ³ dispara quando prevÃª WHITE com confianÃ§a suficiente.'
                : 'Dica: ative pelo menos um nÃ­vel votante (N1â€“N8) para gerar sinais.';

            console.log('%cğŸš« NENHUM VOTO DOS NÃVEIS VOTANTES (N1â€“N8)', 'color: #FF6666; font-weight: bold; font-size: 16px;');
            console.log(`%c   NÃ­veis ativos: ${activeEnabledLabel}`, 'color: #FF6666; font-weight: bold;');
            console.log('%c   âŒ SINAL CANCELADO - sem votos vÃ¡lidos (N1â€“N8)', 'color: #FF0000; font-weight: bold;');
            sendAnalysisStatus(`âŒ Sem votos (N1â€“N8). Ativos: ${activeEnabledLabel}. ${hint}`);
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }
        
        const totalWeight = levelReports.reduce((sum, lvl) => sum + lvl.weight, 0);
        let weightedScore = totalWeight ? levelReports.reduce((sum, lvl) => sum + (lvl.score * lvl.weight), 0) : 0;
        if (alternanceOverride) {
            weightedScore = directionValue(alternanceColor) * totalWeight;
        }
        let normalizedScore = totalWeight ? weightedScore / totalWeight : 0;
        if (alternanceOverride) {
            normalizedScore = directionValue(alternanceColor);
        }
        let scoreMagnitude = Math.abs(normalizedScore);

        // âœ… Intensidade removida (por enquanto): travar sempre em "aggressive"
        let signalIntensity = 'aggressive';
        const votingLevelIds = ['N1','N2','N3','N4','N5','N6','N7','N8'];
        const allVotingLevelsEnabled = votingLevelIds.every(id => diamondLevelEnabledMap[id]);

        console.log('%câ•‘  ğŸšï¸ INTENSIDADE / CONSENSO                              â•‘', 'color: #9C27B0; font-weight: bold; font-size: 14px;');
        console.log(`%c   Modo selecionado: ${signalIntensity === 'conservative' ? 'Conservador' : 'Agressivo'}`, 'color: #9C27B0; font-weight: bold;');

        if (signalIntensity === 'conservative' && !allVotingLevelsEnabled) {
            console.log('%câš ï¸ Conservador indisponÃ­vel: nem todos os nÃ­veis N1-N8 estÃ£o ativos. Revertendo para Agressivo.', 'color: #FFAA00; font-weight: bold;');
            signalIntensity = 'aggressive';
        }

        if (intervalBlocked) {
            sendAnalysisStatus(intervalMessage || 'â³ Aguardando intervalo configurado...');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }

		const votingLevelsList = levelReports.filter(lvl => lvl.id !== 'N6' && lvl.id !== 'N0' && !lvl.disabled);
		const positiveVotingLevels = votingLevelsList.filter(lvl => lvl.color && (lvl.strength || 0) > 0);
		const negativeVotingLevels = votingLevelsList.filter(lvl => lvl.color && (lvl.strength || 0) < 0);
		const neutralVotingLevels = votingLevelsList.filter(lvl => !lvl.color || (lvl.strength || 0) === 0);

        const voteCounts = { red: 0, black: 0, white: 0 };
        positiveVotingLevels.forEach(lvl => {
            if (lvl.color === 'red') voteCounts.red++;
            if (lvl.color === 'black') voteCounts.black++;
            if (lvl.color === 'white') voteCounts.white++;
        });

        const totalVotes = voteCounts.red + voteCounts.black + voteCounts.white;
        if (totalVotes === 0) {
            console.log('%câŒ Nenhum voto vÃ¡lido dos nÃ­veis votantes. Sinal cancelado.', 'color: #FF6666; font-weight: bold;');
            sendAnalysisStatus('âŒ Sem votos vÃ¡lidos (N1-N8)');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }

        const orderedVotes = Object.entries(voteCounts).sort(([, a], [, b]) => b - a);
        const consensusColor = orderedVotes[0] ? orderedVotes[0][0] : null;
        const consensusVotes = orderedVotes[0] ? orderedVotes[0][1] : 0;
        const secondVotes = orderedVotes[1] ? orderedVotes[1][1] : 0;

        if (!consensusColor || consensusVotes === 0) {
            console.log('%câŒ Nenhum voto vÃ¡lido (contagem zerada). Sinal cancelado.', 'color: #FF6666; font-weight: bold;');
            sendAnalysisStatus('âŒ Sem votos vÃ¡lidos (N1-N8)');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }

        if (consensusVotes === secondVotes) {
            console.log('%câš ï¸ Empate entre as cores. Sinal anulado.', 'color: #FFAA00; font-weight: bold;');
            sendAnalysisStatus('âŒ Empate entre cores');
            await sleep(2000);
            await restoreIAStatus();
            return null;
        }

        if (signalIntensity === 'conservative') {
            if (voteCounts[consensusColor] < 5) {
                console.log(`%câŒ Conservador: apenas ${voteCounts[consensusColor]}/5 votos para ${consensusColor.toUpperCase()}.`, 'color: #FF6666; font-weight: bold;');
                sendAnalysisStatus(`âŒ Conservador: mÃ­nimo 5 votos (${voteCounts[consensusColor]}/5)`);
                await sleep(2000);
                await restoreIAStatus();
                return null;
            }

            if (!n9Enabled) {
                console.log('%câŒ Conservador: Barreira Final (N9) precisa estar ativa.', 'color: #FF6666; font-weight: bold;');
                sendAnalysisStatus('âŒ Conservador: ative a Barreira Final (N9)');
                await sleep(2000);
                await restoreIAStatus();
                return null;
            }

            if (!barrierResult.allowed) {
                console.log('%câŒ Conservador: Barreira Final bloqueou o sinal.', 'color: #FF6666; font-weight: bold;');
                sendAnalysisStatus('âŒ Conservador: Barreira Final bloqueou');
                await sleep(2000);
                await restoreIAStatus();
                return null;
            }

            const bayesApproves = n10Enabled && bayesResult && bayesResult.color && bayesResult.color === consensusColor;
            if (!n10Enabled || !bayesApproves) {
                console.log('%câŒ Conservador: CalibraÃ§Ã£o Bayesiana (N10) nÃ£o autorizou.', 'color: #FF6666; font-weight: bold;');
                sendAnalysisStatus('âŒ Conservador: N10 nÃ£o autorizou');
                await sleep(2000);
                await restoreIAStatus();
                return null;
            }
        }

        finalColor = consensusColor;
        predictedColor = finalColor;

        const maxVotingSlots = votingLevelsList.length;
        const winningVotes = voteCounts[finalColor] || 0;

        // âœ… WHITE nÃ£o cabe no eixo red(+)/black(-). Para WHITE, usamos "magnitude" baseada no consenso (votos).
        if (finalColor === 'white') {
            normalizedScore = 0;
            scoreMagnitude = maxVotingSlots > 0 ? (winningVotes / maxVotingSlots) : 0;
        } else {
            scoreMagnitude = Math.abs(normalizedScore);
        }
        const scoreCombinedLabel = finalColor === 'white'
            ? (scoreMagnitude * 100).toFixed(1)
            : (normalizedScore * 100).toFixed(1);
        const voteTotals = {
            red: voteCounts.red,
            black: voteCounts.black,
            white: voteCounts.white,
            neutral: neutralVotingLevels.length,
            negative: negativeVotingLevels.length
        };

        console.log(`%cğŸ—³ï¸ Contagem de votos â†’ ğŸ”´ ${voteCounts.red} | âš« ${voteCounts.black} | âšª ${voteCounts.white}`, 'color: #9C27B0; font-weight: bold;');

        let rawConfidence = Math.round((winningVotes / Math.max(1, maxVotingSlots)) * 100);
        rawConfidence = Math.max(0, Math.min(100, rawConfidence));
        let finalConfidence = applyCalibratedConfidence(rawConfidence);
        finalConfidence = Math.max(0, Math.min(100, Math.round(finalConfidence)));

        console.log('%cğŸ“Š SCORE DOS NÃVEIS ATIVOS:', 'color: #FFD700; font-weight: bold; font-size: 16px;');
        levelReports.forEach(level => {
            const contribution = (level.score * level.weight);
            console.log(`%c${describeLevel(level)} â€¢ contribuiÃ§Ã£o ${(contribution >= 0 ? '+' : '')}${contribution.toFixed(3)}`, 'color: #FFD700;');
        });
        console.log(`%cğŸ¯ COR FINAL: ${finalColor.toUpperCase()}`, `color: ${finalColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 16px;`);
        console.log(`%cğŸ“ˆ Score combinado: ${scoreCombinedLabel}%`, 'color: #00FFFF; font-weight: bold;');
        console.log(`%cğŸ“Š ConfianÃ§a bruta: ${rawConfidence}% â€¢ calibrada: ${finalConfidence}%`, 'color: #FFD700; font-weight: bold;');

        if (analyzerConfig.aiMode) {
            sendAnalysisStatus('Sinal de entrada');
        } else {
            sendAnalysisStatus(`âœ… Sinal aprovado: ${finalColor.toUpperCase()} (score ${(scoreMagnitude * 100).toFixed(1)}%)`);
        }

        const scoreSummary = levelReports.map(level => ({
            id: level.id,
            name: level.name,
            color: level.color,
            strength: Number(level.strength.toFixed(3)),
            weight: Number(level.weight.toFixed(3)),
            contribution: Number((level.score * level.weight).toFixed(3)),
            details: level.details
        }));
        const diamondSourceLevel = pickDiamondSourceLevel(scoreSummary, finalColor);
        const diamondN4 = (() => {
            try {
                if (!n4Enabled) return null;
                const voteColor = (nivel9 && nivel9.color) ? String(nivel9.color).toLowerCase() : null;
                const key = (nivel9 && typeof nivel9.learningKey === 'string') ? nivel9.learningKey : null;
                const ctx = (nivel9 && typeof nivel9.learningContext === 'string') ? nivel9.learningContext : null;
                if (!voteColor) return null;
                return {
                    voteColor,
                    key,
                    ctx,
                    usedInFinal: voteColor === String(finalColor || '').toLowerCase(),
                    decision: (nivel9 && typeof nivel9.learningDecision === 'string') ? nivel9.learningDecision : 'none'
                };
            } catch (_) {
                return null;
            }
        })();
        const diamondN0 = (() => {
            try {
                if (!n0Enabled) return null;
                if (!n0Result || n0Result.enabled === false) return null;
                const pred = (n0Result && n0Result.pred_live === 'W') ? 'white' : null;
                if (!pred) return null;
                const key = (n0Result && typeof n0Result.learning_key === 'string') ? n0Result.learning_key : null;
                const ctx = (n0Result && typeof n0Result.learning_context === 'string') ? n0Result.learning_context : null;
                return {
                    voteColor: 'white',
                    key,
                    ctx,
                    usedInFinal: String(finalColor || '').toLowerCase() === 'white',
                    decision: (n0Result && typeof n0Result.learning_decision === 'string') ? n0Result.learning_decision : 'none',
                    action: (n0Result && typeof n0Result.blocking_action === 'string') ? n0Result.blocking_action : 'no_block'
                };
            } catch (_) {
                return null;
            }
        })();

        const intensityLabel = signalIntensity === 'conservative' ? 'Conservador' : 'Agressivo';
        const reasoning =
            `${levelReports.map(level => describeLevel(level, { includeEmoji: false })).join('\n')}\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `Modo: ${intensityLabel}\n` +
            `Score combinado: ${scoreCombinedLabel}%\n` +
            `DECISÃƒO: ${finalColor.toUpperCase()}\n` +
            `ConfianÃ§a: ${finalConfidence}%`;

        console.log('%cğŸ§  RACIOCÃNIO COMPLETO:', 'color: #00FFFF; font-weight: bold; font-size: 14px;');
        console.log(`%c${reasoning}`, 'color: #00FFFF;');
        
        const signal = {
            timestamp: Date.now(),
            patternType: 'nivel-diamante',
            patternName: patternDescription,
            colorRecommended: finalColor,
            normalizedScore: Number(normalizedScore.toFixed(4)),
            scoreMagnitude: Number(scoreMagnitude.toFixed(4)),
            intensityMode: signalIntensity,
            rawConfidence,
            finalConfidence,
            levelBreakdown: scoreSummary,
            sourceLevel: diamondSourceLevel,
            reasoning,
            verified: false,
            colorThatCame: null,
            hit: null
        };

        if (signalsHistory && signalsHistory.signals) {
            signalsHistory.signals.push(signal);
            if (signalsHistory.signals.length > 200) {
                signalsHistory.signals = signalsHistory.signals.slice(-200);
            }
            await saveSignalsHistory();
        }

        if (!memoriaAtiva.inicializada) {
            memoriaAtiva.inicializada = true;
            memoriaAtiva.ultimaAtualizacao = Date.now();
            memoriaAtiva.totalAtualizacoes = 1;
            memoriaAtiva.giros = history.slice(0, getMemoriaAtivaHistoryCap());
            console.log('%câœ… MemÃ³ria Ativa marcada como INICIALIZADA!', 'color: #00FF00; font-weight: bold;');
        } else {
            memoriaAtiva.totalAtualizacoes++;
            memoriaAtiva.ultimaAtualizacao = Date.now();
        }

        return {
            color: finalColor,
            confidence: finalConfidence,
            probability: finalConfidence,
            reasoning: reasoning,
            patternDescription: patternDescription,
            safeZone: safeZoneMeta,
            diamondSourceLevel,
            diamondN4,
            diamondN0
        };

        /* LEGACY VOTING BLOCK (COMENTADO)
        
        console.log(`%cğŸ¯ Cor vencedora da votaÃ§Ã£o: ${finalColor.toUpperCase()}`, `color: ${finalColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold;`);
        console.log(`%cğŸ“Š ConfiguraÃ§Ã£o: ${historySize} giros para anÃ¡lise`, 'color: #FF0000;');
        
        const barrierResult = validateSequenceBarrier(history, finalColor, getDiamondWindow('n8Barrier', historySize), {
            override: alternanceOverrideActive,
            targetRuns: nivel7 ? nivel7.alternanceTargetRuns : null,
            maxRuns: nivel7 ? nivel7.alternanceMaxRuns : null
        });
        
        console.log(`%c   SequÃªncia atual: ${barrierResult.currentStreak} ${finalColor} consecutivos`, 'color: #FF0000;');
        console.log(`%c   PrÃ³xima: ${barrierResult.targetStreak} ${finalColor} consecutivos`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c   MÃ¡ximo histÃ³rico: ${barrierResult.maxStreakFound} ${finalColor} consecutivos`, 'color: #FF0000;');
        console.log(`%c${barrierResult.reason}`, barrierResult.allowed ? 'color: #00FF88; font-weight: bold;' : 'color: #FF6666; font-weight: bold;');
        
    // âš¡ VERIFICAÃ‡ÃƒO: Se NÃ­vel 6 bloqueou, MOSTRAR FASES COM DELAY antes de rejeitar
    if (!barrierResult.allowed) {
        console.log('%cğŸš«ğŸš«ğŸš« SINAL BLOQUEADO PELA BARREIRA! ğŸš«ğŸš«ğŸš«', 'color: #FFFFFF; font-weight: bold; font-size: 16px; background: #FF0000;');
        console.log('%c   SequÃªncia sem precedente histÃ³rico!', 'color: #FF6666; font-weight: bold;');
        console.log('%c   âŒ SINAL SERÃ REJEITADO - Mostrando anÃ¡lise ao usuÃ¡rio...', 'color: #FF0000; font-weight: bold; font-size: 14px;');
        
        // âœ… MOSTRAR AS 6 FASES COM DELAY (para o usuÃ¡rio ver o processo)
        // âŒ NÃ­veis 1, 2, 3 removidos (nÃ£o mostrar mais)
        
        if (!safeZoneMeta || !safeZoneMeta.zoneActive) {
            sendAnalysisStatus(`ğŸ¯ N1 - Zona Segura â†’ NULO`);
        } else if (!analyzerConfig.aiMode) {
            const statusLabel = safeZoneMeta.signal && safeZoneVote && safeZoneVote.color
                ? `${safeZoneMeta.dominant?.toUpperCase() || '-'}` 
                : 'Ativa â€¢ aguardando';
            sendAnalysisStatus(`ğŸ¯ N1 - Zona Segura â†’ ${statusLabel}`);
        }
        await sleep(1500);
        
        const trendLabel = nivel5.trending === 'accelerating_red' ? 'Acelerando' : nivel5.trending === 'accelerating_black' ? 'Acelerando' : 'EstÃ¡vel';
            if (!analyzerConfig.aiMode) {
                sendAnalysisStatus(`âš¡ N2 - Ritmo AutÃ´nomo â†’ ${nivel5.color ? nivel5.color.toUpperCase() : 'NULO'} (${nivel5.details || nivel5.reason || 'sem sinal'})`);
            }
        await sleep(1500);
        
        if (nivel7 && nivel7.color) {
            const overrideLabel = nivel7.override ? ' (override)' : '';
            if (!analyzerConfig.aiMode) {
                sendAnalysisStatus(`ğŸ”· N3 - AlternÃ¢ncia${overrideLabel} â†’ ${nivel7.color.toUpperCase()}`);
            }
        } else {
            if (!analyzerConfig.aiMode) {
                sendAnalysisStatus(`ğŸ”· N3 - AlternÃ¢ncia â†’ NULO`);
            }
        }
        await sleep(1500);
        
            if (!analyzerConfig.aiMode) {
            if (!n4Enabled) {
                sendAnalysisStatus(`ğŸ”· N4 - Autointeligente â†’ DESATIVADO`);
            } else if (nivel9 && nivel9.color) {
                sendAnalysisStatus(`ğŸ”· N4 - Autointeligente â†’ ${nivel9.color.toUpperCase()}`);
        } else {
                sendAnalysisStatus(`ğŸ”· N4 - Autointeligente â†’ NULO`);
            }
        }
        await sleep(1500);
        
            if (!analyzerConfig.aiMode) {
            if (!n5Enabled) {
                sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ DESATIVADO`);
            } else if (minuteBiasColor) {
                sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ ${minuteBiasColor.toUpperCase()}`);
        } else {
                sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ NULO`);
            }
        } else if (!minuteBiasColor) {
            sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ NULO`);
        }
        await sleep(1500);
        
        if (!n9Enabled) {
            sendAnalysisStatus(`ğŸ›‘ N9 - Barreira Final â†’ DESATIVADO`);
        } else {
        const barrierStatusText = barrierResult.alternanceBlocked
            ? 'ğŸš« BLOQUEADO (AlternÃ¢ncia)'
            : 'âŒ BLOQUEADO';
            sendAnalysisStatus(`ğŸ›‘ N9 - Barreira Final â†’ ${barrierStatusText}`);
        }
        await sleep(1500);
        
        // âœ… Mostrar motivo do bloqueio
        sendAnalysisStatus(`âŒ Sinal rejeitado: Sem precedente histÃ³rico`);
        await sleep(2000);
        
        // âœ… Restaurar status "IA ativada"
        await restoreIAStatus();
        
        console.log('%c   âŒ SINAL CANCELADO!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
        return null;
    }
    
    // âš¡ Barreira aprovada - NÃƒO EXIBIR ainda (anÃ¡lise rÃ¡pida, mostraremos depois se for rejeitado depois)
        
        console.log('%câœ… BARREIRA LIBERADA! SequÃªncia Ã© viÃ¡vel.', 'color: #00FF88; font-weight: bold; font-size: 14px;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			const prefix = continuityResult.strength > 0 ? 'ReforÃ§o' : 'ReduÃ§Ã£o';
			sendAnalysisStatus(`ğŸ“ˆ N7 - Continuidade Global â†’ ${continuityResult.color.toUpperCase()} (${prefix})`);
		} else {
			sendAnalysisStatus(`ğŸ“ˆ N7 - Continuidade Global â†’ NULO`);
		}
		await sleep(1500);

        if (!n9Enabled) {
            sendAnalysisStatus('ğŸ›‘ N9 - Barreira Final â†’ DESATIVADO');
        } else {
        const barrierStatusText2 = barrierResult.alternanceBlocked
            ? 'ğŸš« BLOQUEADO (AlternÃ¢ncia)'
            : barrierResult.allowed ? 'âœ… APROVADO' : 'ğŸš« BLOQUEADO';
            sendAnalysisStatus(`ğŸ›‘ N9 - Barreira Final â†’ ${barrierStatusText2}`);
        }
        await sleep(1500);
        
        console.log('%câœ… CONSENSO ATINGIDO! Intensidade aprovada.', 'color: #00FF88; font-weight: bold; font-size: 14px;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â±ï¸ VERIFICAÃ‡ÃƒO FINAL: INTERVALO BLOQUEADO?
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (intervalBlocked) {
        console.log('%câ•‘  ğŸš« SINAL BLOQUEADO - INTERVALO INSUFICIENTE!            â•‘', 'color: #FFAA00; font-weight: bold; font-size: 14px;');
        console.log(`%câ•‘  âœ… AnÃ¡lise dos ${activeLevelsSummary} nÃ­veis ativos foi executada com sucesso      â•‘`, 'color: #00FF88;');
        console.log('%câ•‘  âœ… Sistema recomendaria: ' + finalColor.toUpperCase().padEnd(34) + 'â•‘', 'color: #FFD700;');
        console.log('%câ•‘  ğŸš« MAS sinal nÃ£o serÃ¡ enviado (aguarde intervalo)       â•‘', 'color: #FFAA00;');
        
        // âœ… MOSTRAR AS 6 FASES COM DELAY (para o usuÃ¡rio ver o processo)
        // âŒ NÃ­veis 1, 2, 3 removidos (nÃ£o mostrar mais)
        
        if (!safeZoneMeta || !safeZoneMeta.zoneActive) {
            sendAnalysisStatus(`ğŸ¯ N1 - Zona Segura â†’ NULO`);
        } else {
            const statusLabel = safeZoneMeta.signal && safeZoneVote && safeZoneVote.color
                ? `${safeZoneMeta.dominant?.toUpperCase() || '-'}` 
                : 'Ativa â€¢ aguardando';
            sendAnalysisStatus(`ğŸ¯ N1 - Zona Segura â†’ ${statusLabel}`);
        }
        await sleep(1500);
        
        const n2Detail = nivel5 && nivel5.details ? nivel5.details : (nivel5 && nivel5.reason ? nivel5.reason : 'sem sinal');
        sendAnalysisStatus(`âš¡ N2 - Ritmo AutÃ´nomo â†’ ${nivel5 && nivel5.color ? nivel5.color.toUpperCase() : 'NULO'} (${n2Detail})`);
        await sleep(1500);
        
        if (nivel7 && nivel7.color) {
            const overrideLabel = nivel7.override ? ' (override)' : '';
            sendAnalysisStatus(`ğŸ”· N3 - AlternÃ¢ncia${overrideLabel} â†’ ${nivel7.color.toUpperCase()}`);
        } else {
            sendAnalysisStatus(`ğŸ”· N3 - AlternÃ¢ncia â†’ NULO`);
        }
        await sleep(1500);
        
        if (nivel9 && nivel9.color) {
            sendAnalysisStatus(`ğŸ”· N4 - Autointeligente â†’ ${nivel9.color.toUpperCase()}`);
        } else {
            sendAnalysisStatus(`ğŸ”· N4 - Autointeligente â†’ NULO`);
        }
        await sleep(1500);
        
        if (minuteBiasColor) {
            sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ ${minuteBiasColor.toUpperCase()}`);
        } else {
            sendAnalysisStatus(`ğŸ•‘ N5 - Ritmo por Giro â†’ NULO`);
        }
        await sleep(1500);
        
        if (retracementResult && retracementResult.color) {
            sendAnalysisStatus(`ğŸ“‰ N6 - RetraÃ§Ã£o HistÃ³rica â†’ ${retracementResult.color.toUpperCase()}`);
        } else {
            sendAnalysisStatus(`ğŸ“‰ N6 - RetraÃ§Ã£o HistÃ³rica â†’ NULO`);
        }
        await sleep(1500);

        if (continuityResult && continuityResult.color && (continuityResult.strength || 0) !== 0) {
            const prefix2 = continuityResult.strength > 0 ? 'ReforÃ§o' : 'ReduÃ§Ã£o';
            sendAnalysisStatus(`ğŸ“ˆ N7 - Continuidade Global â†’ ${continuityResult.color.toUpperCase()} (${prefix2})`);
        } else {
            sendAnalysisStatus(`ğŸ“ˆ N7 - Continuidade Global â†’ NULO`);
        }
        await sleep(1500);
        
        const barrierStatusText3 = barrierResult.alternanceBlocked
            ? 'ğŸš« BLOQUEADO (AlternÃ¢ncia)'
            : barrierResult.allowed ? 'âœ… APROVADO' : 'ğŸš« BLOQUEADO';
        sendAnalysisStatus(`ğŸ›‘ N9 - Barreira Final â†’ ${barrierStatusText3}`);
        await sleep(1500);
        
        // âœ… Mostrar resultado da anÃ¡lise (MODO DIAMANTE: mensagem fixa) e depois o motivo do bloqueio
        if (analyzerConfig.aiMode) {
            sendAnalysisStatus(`Sinal de entrada`);
        } else {
			sendAnalysisStatus(`âœ… AnÃ¡lise: ${finalColor.toUpperCase()} (${winningVotes} de ${maxVotingSlots} votos)`);
        }
        await sleep(2000);
        
		if (intervalMessage) {
        sendAnalysisStatus(intervalMessage);
        await sleep(2000);
		}
        
        // âœ… Restaurar status "IA ativada"
        await restoreIAStatus();
        
        return null;
    }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ“Š CÃLCULO DE CONFIANÃ‡A (BASEADO NA VOTAÃ‡ÃƒO)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
	const totalVotantes = maxVotingSlots;
	const consensusPercent = totalVotantes > 0 ? (winningVotes / totalVotantes) * 100 : 0;
	
    let rawConfidence = Math.round(consensusPercent);
    rawConfidence = Math.max(50, Math.min(100, rawConfidence));
        
		console.log('%cğŸ“Š RESUMO COMPLETO DOS NÃVEIS ATIVOS:', 'color: #FFD700; font-weight: bold; font-size: 16px;');
		levelReports
			.filter(level => level.id !== 'N9')
			.forEach(level => console.log(`   ${describeLevel(level)}`));
		const barrierReport = levelReports.find(level => level.id === 'N9');
		if (barrierReport) {
			console.log(`   ${describeLevel(barrierReport)}`);
		}
		
		const voteSegments = [
			`${voteTotals.red} VERMELHO`,
			`${voteTotals.black} PRETO`
		];
		if (voteTotals.neutral > 0) voteSegments.push(`${voteTotals.neutral} NEUTRO`);
		if (voteTotals.negative > 0) voteSegments.push(`${voteTotals.negative} REDUÃ‡ÃƒO`);
		
        console.log(`%câ•‘  ğŸ¯ DECISÃƒO FINAL: ${finalColor.toUpperCase().padEnd(33)}â•‘`, 'color: #00FF00; font-weight: bold; font-size: 16px;');
		console.log(`%câ•‘  ğŸ—³ï¸ Votos: ${voteSegments.join(' | ').padEnd(42)}â•‘`, 'color: #00FF88;');
        console.log(`%câ•‘  ğŸ“Š Consenso: ${consensusPercent.toFixed(1)}%${''.padEnd(33)}â•‘`, 'color: #00FFFF;');
        console.log(`%câ•‘  ğŸ“ ConfianÃ§a Calculada: ${rawConfidence}%${''.padEnd(28)}â•‘`, 'color: #00FFFF;');
        console.log(`%câ•‘  âœ… SISTEMA DEMOCRÃTICO DE VOTAÃ‡ÃƒO                       â•‘`, 'color: #00FF00; font-weight: bold;');
        console.log(`%câ•‘  âœ… BARREIRA VALIDOU VIABILIDADE HISTÃ“RICA              â•‘`, 'color: #00FF00; font-weight: bold;');
        console.log('%câ•‘  ğŸ”§ APLICANDO CALIBRADOR AUTOMÃTICO...                   â•‘', 'color: #FFD700; font-weight: bold;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”§ APLICAR CALIBRADOR AUTOMÃTICO DE PORCENTAGEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let finalConfidence = applyCalibratedConfidence(rawConfidence);
        
        console.log(`%câ•‘  âœ… CONFIANÃ‡A FINAL (CALIBRADA): ${finalConfidence}%${''.padEnd(19)}â•‘`, 'color: #FFD700; font-weight: bold; font-size: 16px;');
        
        console.log('%câœ… SINAL APROVADO!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		// ğŸ“ MONTAR RACIOCÃNIO DETALHADO (NÃVEIS ATIVOS + VOTAÃ‡ÃƒO)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
		let nivel1Description = '';
        if (!n1Enabled) {
			nivel1Description = `N1 - Zona Segura: DESATIVADO`;
        } else if (!safeZoneMeta || !safeZoneMeta.zoneActive) {
			nivel1Description = `N1 - Zona Segura: NULO`;
        } else if (safeZoneMeta.signal && safeZoneVote && safeZoneVote.color) {
			nivel1Description = `N1 - Zona Segura: ${safeZoneVote.color.toUpperCase()} (${safeZoneMeta.counts[safeZoneMeta.dominant]}/${safeZoneMeta.windowSize})`;
        } else {
			nivel1Description = `N1 - Zona Segura: Ativa â€¢ aguardando confirmaÃ§Ã£o`;
		}
		
		const nivel2Description = !n2Enabled
            ? `N2 - Ritmo AutÃ´nomo: DESATIVADO`
            : `N2 - Ritmo AutÃ´nomo: ${nivel5 && nivel5.color ? nivel5.color.toUpperCase() : 'NULO'} (${nivel5 && nivel5.details ? nivel5.details : (nivel5 && nivel5.reason ? nivel5.reason : 'sem sinal')})`;
		
		const nivel3Description = !n3Enabled
            ? `N3 - AlternÃ¢ncia: DESATIVADO`
			: nivel7 && nivel7.color
			? `N3 - AlternÃ¢ncia${nivel7.override ? ' (override)' : ''}: ${nivel7.color.toUpperCase()} (${nivel7.details || nivel7.pattern})`
			: `N3 - AlternÃ¢ncia: ${nivel7 && nivel7.details ? nivel7.details : 'NULO'}`;
		
		const nivel4Description = !n4Enabled
            ? `N4 - Autointeligente: DESATIVADO`
            : (nivel9 && nivel9.color)
                ? `N4 - Autointeligente: ${nivel9.color.toUpperCase()} (${nivel9.details || 'ok'})`
                : `N4 - Autointeligente: ${nivel9 && nivel9.details ? nivel9.details : 'NULO'}`;
		
		const nivel5Description = !n5Enabled
            ? `N5 - Ritmo por Giro: DESATIVADO`
			: minuteBiasColor
			? `N5 - Ritmo por Giro: ${minuteBiasColor.toUpperCase()} (${Math.round((minuteBiasResult?.confidence || 0) * 100)}% confianÃ§a)`
			: `N5 - Ritmo por Giro: NULO`;

		const retracementDescription = !n6Enabled
            ? `N6 - RetraÃ§Ã£o HistÃ³rica: DESATIVADO`
			: retracementResult && retracementResult.details
			? `N6 - RetraÃ§Ã£o HistÃ³rica: ${retracementResult.details}`
			: `N6 - RetraÃ§Ã£o HistÃ³rica: NULO`;

		const continuityDescription = !n7Enabled
            ? `N7 - Continuidade Global: DESATIVADO`
			: continuityResult && continuityResult.details
			? `N7 - Continuidade Global: ${continuityResult.details}`
			: `N7 - Continuidade Global: NULO`;

		const walkForwardReport = levelReports.find(level => level.id === 'N8');
		const walkForwardDescription = !n8Enabled
            ? `N8 - Walk-forward: DESATIVADO`
			: walkForwardReport && walkForwardReport.color
			? `N8 - Walk-forward: ${walkForwardReport.color.toUpperCase()} (${Math.round((walkForwardReport.strength || 0) * 100)}% â€¢ ${walkForwardReport.details || 'sem detalhes'})`
			: `N8 - Walk-forward: NULO`;

		const barrierDescription = !n9Enabled
            ? `N9 - Barreira Final: DESATIVADO`
			: barrierResult.allowed
			? `N9 - Barreira Final: LIBERADO`
			: `N9 - Barreira Final: BLOQUEADO`;

		const bayesReport = levelReports.find(level => level.id === 'N10');
		const bayesDescription = !n10Enabled
            ? `N10 - CalibraÃ§Ã£o Bayesiana: DESATIVADO`
			: bayesReport && bayesReport.color
			? `N10 - CalibraÃ§Ã£o Bayesiana: ${bayesReport.color.toUpperCase()} (${Math.round((bayesReport.strength || 0) * 100)}% â€¢ ${bayesReport.details || 'sem detalhes'})`
			: `N10 - CalibraÃ§Ã£o Bayesiana: NULO`;
        
		const votingDescription = (() => {
			const segments = [
			`${voteTotals.red} VERMELHO`,
			`${voteTotals.black} PRETO`
			];
			if (voteTotals.neutral > 0) segments.push(`${voteTotals.neutral} NEUTRO`);
			if (voteTotals.negative > 0) segments.push(`${voteTotals.negative} REDUÃ‡ÃƒO`);
			return `Votos: ${segments.join(' | ')}`;
		})();
        
        const reasoning = `${nivel1Description}\n` +
            `${nivel2Description}\n` +
            `${nivel3Description}\n` +
            `${nivel4Description}\n` +
            `${nivel5Description}\n` +
			`${retracementDescription}\n` +
			`${continuityDescription}\n` +
			`${walkForwardDescription}\n` +
			`${barrierDescription}\n` +
			`${bayesDescription}\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `${votingDescription}\n` +
			`Resultado: ${finalColor.toUpperCase()} (${winningVotes}/${totalVotantes} votos = ${consensusPercent.toFixed(1)}%)\n` +
			`Intensidade: ${intensityLabel} (${signalIntensity === 'conservative' ? 'mÃ­n 5 votos + barreiras' : 'maioria simples'})\n` +
            `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
            `DECISÃƒO: ${finalColor.toUpperCase()}\n` +
            `ConfianÃ§a: ${finalConfidence}%`;
        
        // Registrar sinal para verificaÃ§Ã£o futura
        const signal = {
            timestamp: Date.now(),
            patternType: 'nivel-diamante',
            patternName: patternDescription,
            colorRecommended: finalColor,
			votesRed: voteTotals.red,
			votesBlack: voteTotals.black,
			votesNeutral: voteTotals.neutral,
			votesNegative: voteTotals.negative,
            consensusPercent: consensusPercent,
            rawConfidence: rawConfidence,        // ConfianÃ§a antes da calibraÃ§Ã£o
            finalConfidence: finalConfidence,    // ConfianÃ§a apÃ³s calibraÃ§Ã£o
            reasoning: reasoning,
            verified: false,
            colorThatCame: null,
            hit: null
        };
        
        if (signalsHistory && signalsHistory.signals) {
            signalsHistory.signals.push(signal);
            if (signalsHistory.signals.length > 200) {
                signalsHistory.signals = signalsHistory.signals.slice(-200);
            }
            await saveSignalsHistory();
        }
        
        // âœ… MARCAR MEMÃ“RIA ATIVA COMO INICIALIZADA (para UI)
        if (!memoriaAtiva.inicializada) {
            memoriaAtiva.inicializada = true;
            memoriaAtiva.ultimaAtualizacao = Date.now();
            memoriaAtiva.totalAtualizacoes = 1;
            memoriaAtiva.giros = history.slice(0, getMemoriaAtivaHistoryCap());
            console.log('%câœ… MemÃ³ria Ativa marcada como INICIALIZADA!', 'color: #00FF00; font-weight: bold;');
        } else {
            memoriaAtiva.totalAtualizacoes++;
            memoriaAtiva.ultimaAtualizacao = Date.now();
        }
        
    console.log('%cğŸ§  RACIOCÃNIO COMPLETO:', 'color: #00FFFF; font-weight: bold; font-size: 14px;');
    console.log(`%c${reasoning}`, 'color: #00FFFF;');
    
    // âš¡âš¡âš¡ SINAL APROVADO! MOSTRAR IMEDIATAMENTE! âš¡âš¡âš¡
    console.log('%câš¡âš¡âš¡ SINAL APROVADO! ENVIANDO IMEDIATAMENTE! âš¡âš¡âš¡', 'color: #00FF00; font-weight: bold; font-size: 16px;');
    
    // âœ… NO MODO DIAMANTE: Mensagem FIXA ("Sinal de entrada")
    // âœ… OUTROS MODOS: Mensagem com votos (comportamento antigo)
    if (analyzerConfig.aiMode) {
        sendAnalysisStatus(`Sinal de entrada`);
    } else {
        sendAnalysisStatus(`âœ… Sinal aprovado: ${finalColor.toUpperCase()} (${winningVotes} de 5 votos)`);
    }
    // âš¡ NÃƒO AGUARDAR! UsuÃ¡rio vÃª a cor IMEDIATAMENTE
        
        console.log('%câœ… SINAL APROVADO E PRONTO PARA ENVIO', 'color: #00FF00; font-weight: bold; font-size: 18px;');
        console.log('%cğŸ“Š ANÃLISE COMPLETA:', 'color: #00FFFF; font-weight: bold; font-size: 16px;');
        console.log(`%c   ğŸ¯ Cor Recomendada: ${finalColor.toUpperCase()}`, `color: ${finalColor === 'red' ? '#FF0000' : '#FFFFFF'}; font-weight: bold; font-size: 18px;`);
        console.log(`%c   ğŸ“ˆ ConfianÃ§a Final: ${finalConfidence}%`, 'color: #FFD700; font-weight: bold; font-size: 16px;');
		console.log(`%c   ğŸ—³ï¸ VotaÃ§Ã£o: ${voteTotals.red} vermelho | ${voteTotals.black} preto${voteTotals.neutral > 0 ? ' | ' + voteTotals.neutral + ' neutro' : ''}${voteTotals.negative > 0 ? ' | ' + voteTotals.negative + ' reduÃ§Ã£o' : ''}`, 'color: #FFD700; font-weight: bold;');
        console.log(`%c   ğŸ” PadrÃ£o: ${patternDescription}`, 'color: #FFD700; font-weight: bold;');
        console.log('%cğŸ“‹ ORIGEM DOS DADOS:', 'color: #00FFFF; font-weight: bold;');
        console.log(`%c   âœ… HistÃ³rico analisado: ${history.length} giros REAIS`, 'color: #00FF88;');
        if (safeZoneMeta && safeZoneMeta.zoneActive) {
            const detail = safeZoneMeta.signal && safeZoneVote && safeZoneVote.color
                ? `${safeZoneMeta.dominant?.toUpperCase() || '-'} confirmado`
                : 'Ativa â€¢ aguardando';
            console.log(`%c   âœ… Zona Segura: ${detail} (${safeZoneMeta.counts[safeZoneMeta.dominant] || 0}/${safeZoneMeta.windowSize})`, 'color: #FF6B35; font-weight: bold;');
        } else {
            console.log(`%c   âœ… Zona Segura: NULO`, 'color: #888;');
        }
        console.log(`%c   âœ… Barreira Validada: ${barrierResult.allowed ? 'SIM (liberado)' : 'BLOQUEADO'}`, barrierResult.allowed ? 'color: #00FF88;' : 'color: #FF6666;');
        console.log('%câœ… GARANTIAS:', 'color: #00FF00; font-weight: bold;');
        console.log('%c   âœ“ Todos os dados vÃªm do histÃ³rico REAL da Blaze', 'color: #00FF88;');
        console.log('%c   âœ“ Nenhum valor foi inventado ou simulado', 'color: #00FF88;');
        console.log(`%c   âœ“ NÃ­veis ativos analisados: ${activeLevelsSummary}`, 'color: #00FF88;');
        console.log('%c   âœ“ Sistema democrÃ¡tico de votaÃ§Ã£o aplicado', 'color: #00FF88;');
        console.log('%c   âœ“ Barreira validou viabilidade histÃ³rica', 'color: #00FF88;');
        console.log('%c   âœ“ PadrÃµes customizados do usuÃ¡rio foram respeitados', 'color: #00FF88;');
        
        return {
            color: finalColor,
            confidence: finalConfidence,
            probability: finalConfidence,
            reasoning: reasoning,
            patternDescription: patternDescription
        };
        
        */
        
    } catch (error) {
        console.error('');
        console.error('âŒâŒâŒ ERRO CRÃTICO EM analyzeWithPatternSystem! âŒâŒâŒ');
        console.error('Erro:', error);
        console.error('Mensagem:', error.message);
        console.error('Stack:', error.stack);
        console.error('Nome:', error.name);
        console.error('');
        return null;
    } finally {
        try {
            const dt = Date.now() - __fastStartMs;
            if (dt > 2500) {
                console.warn(`âš ï¸ Diamante: anÃ¡lise levou ${dt}ms (ideal: <= 5000ms para dar tempo de apostar).`);
            }
        } catch (_) {}
        fastLiveAnalysisDepth = Math.max(0, fastLiveAnalysisDepth - 1);
    }
}

/**
 * âŒ REMOVIDO: CÃ³digo de API externa (Groq, OpenAI, etc.) nÃ£o utilizado
 * O sistema usa apenas Modo PadrÃ£o e Modo Diamante (anÃ¡lise local)
 * 
 * Mantido comentado para referÃªncia histÃ³rica
 */
/*
async function analyzeWithAI(history) {
    const startTime = Date.now();
    const timeout = 5000; // âš¡ 5 segundos MÃXIMO para APIs externas
    
    try {
        console.log('%câ•‘  ğŸ¤– INICIANDO ANÃLISE POR INTELIGÃŠNCIA ARTIFICIAL        â•‘', 'color: #00FF00; font-weight: bold; font-size: 14px;');
        
        // Verificar chave API
        if (!analyzerConfig.aiApiKey || analyzerConfig.aiApiKey.trim() === '') {
            console.error('%câŒ ERRO: Chave da IA invÃ¡lida ou ausente!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
            console.error('%c   Configure a chave nas ConfiguraÃ§Ãµes da extensÃ£o', 'color: #FF6666;');
            sendAnalysisStatus('âŒ Chave da IA ausente');
            return null;
        }
        console.log('%câœ… Chave API encontrada: ' + analyzerConfig.aiApiKey.substring(0, 15) + '...', 'color: #00FF88;');
        
        // Detectar qual API estÃ¡ sendo usada pela chave
        const apiKey = analyzerConfig.aiApiKey.trim();
        let apiType = 'unknown';
        
        if (apiKey.startsWith('gsk_')) {
            apiType = 'groq';
            console.log('%cğŸ” API Detectada: GROQ (Ultra RÃ¡pido) âš¡', 'color: #00FF00; font-weight: bold; font-size: 14px;');
            console.log('%c   Modelo: Llama 3.3 70B Versatile', 'color: #00FF88;');
        } else if (apiKey.startsWith('sk-or-')) {
            apiType = 'openrouter';
            console.log('%cğŸ” API Detectada: OpenRouter (agregador de IAs)', 'color: #00FF00; font-weight: bold;');
        } else if (apiKey.startsWith('AIzaSy')) {
            apiType = 'gemini';
            console.log('%cğŸ” API Detectada: Google Gemini', 'color: #00FF00; font-weight: bold;');
        } else if (apiKey.startsWith('sk-ant-')) {
            apiType = 'claude';
            console.log('%cğŸ” API Detectada: Anthropic Claude', 'color: #00FF00; font-weight: bold;');
        } else if (apiKey.startsWith('sk-')) {
            apiType = 'openai';
            console.log('%cğŸ” API Detectada: OpenAI GPT', 'color: #00FF00; font-weight: bold;');
        } else {
            // Tentar OpenRouter como padrÃ£o
            console.log('%câš ï¸ Tipo de API nÃ£o detectado. Tentando OpenRouter...', 'color: #FFAA00; font-weight: bold;');
            apiType = 'openrouter';
        }
        
        // âœ… Preparar dados do histÃ³rico para enviar Ã  IA (usar tamanho REAL disponÃ­vel)
        const aiHistorySizeConfigured = Math.min(Math.max(analyzerConfig.aiHistorySize || 50, 20), 2000); // Min: 20, Max: 2000
        const aiHistorySize = Math.min(aiHistorySizeConfigured, history.length); // âœ… Usar o menor entre configurado e disponÃ­vel
        const recentHistory = history.slice(0, aiHistorySize);
        
        // âœ… CRÃTICO: Enviar os Ãºltimos 20 giros em DESTAQUE para a IA
        const last20Spins = history.slice(0, 20);
        
        // Log de debug removido: reduÃ§Ã£o de verbosidade
        
        // Criar texto com DESTAQUE para os Ãºltimos 20 giros
        const last20Text = last20Spins.map((spin, idx) => 
            `${idx + 1}. ${spin.color} (${spin.number})`
        ).join(', ');
        
        const historyText = recentHistory.map((spin, idx) => 
            `${idx + 1}. ${spin.color} (${spin.number})`
        ).join(', ');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ” DETECTAR PADRÃ•ES NO HISTÃ“RICO (ANÃLISE ESTATÃSTICA REAL)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let patternsReport = [];
        try {
            patternsReport = detectPatternsInHistory(recentHistory);
        } catch (patternError) {
            console.error('%câŒ ERRO ao detectar padrÃµes:', 'color: #FF0000; font-weight: bold;', patternError);
            console.log('%câš ï¸ Continuando anÃ¡lise SEM padrÃµes detectados...', 'color: #FFAA00;');
        }
        
        // Montar texto do relatÃ³rio de padrÃµes para enviar Ã  IA
        let patternsText = '';
        if (patternsReport && patternsReport.length > 0) {
            patternsText = 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n';
            patternsText += 'ğŸ“Š PADRÃ•ES DETECTADOS NO HISTÃ“RICO (ESTATÃSTICAS REAIS):\n';
            patternsText += 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n';
            
            patternsReport.forEach((p, index) => {
                patternsText += `PADRÃƒO ${index + 1}: ${p.name}\n`;
                patternsText += `- OcorrÃªncias: ${p.occurrences} vezes no histÃ³rico\n`;
                patternsText += `- ApÃ³s esse padrÃ£o:\n`;
                patternsText += `  â†’ VERMELHO: ${p.afterRed} vezes (${p.redPercent}%)\n`;
                patternsText += `  â†’ PRETO: ${p.afterBlack} vezes (${p.blackPercent}%)\n`;
                patternsText += `  â†’ BRANCO: ${p.afterWhite} vezes (${p.whitePercent}%)\n`;
                patternsText += `\n`;
            });
            
            patternsText += 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n';
        } else {
            patternsText = 'âš ï¸ Nenhum padrÃ£o claro foi detectado no histÃ³rico.\n';
            patternsText += 'Analise os Ãºltimos 20 giros de forma mais livre.\n\n';
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ¤– PREPARAR PROMPT (customizado ou padrÃ£o)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let prompt;
        
        if (analyzerConfig.customPrompt && analyzerConfig.customPrompt.trim() !== '') {
            // ğŸ”§ USAR PROMPT CUSTOMIZADO DO USUÃRIO
            console.log('%cğŸ”§ MODO AVANÃ‡ADO: Usando prompt customizado', 'color: #FF00FF; font-weight: bold;');
            
            // Substituir placeholders no prompt customizado
            prompt = analyzerConfig.customPrompt
                .replace(/\$\{recentHistory\.length\}/g, recentHistory.length)
                .replace(/\$\{historyLength\}/g, recentHistory.length)
                .replace(/\$\{historyText\}/g, historyText)
                .replace(/\$\{patternsText\}/g, patternsText);
            
            console.log('%c   Tamanho do prompt: ' + prompt.length + ' caracteres', 'color: #FF00FF;');
            
            // Validar palavras-chave crÃ­ticas
            const requiredKeywords = ['color', 'confidence', 'JSON'];
            const missingKeywords = requiredKeywords.filter(keyword => !prompt.toLowerCase().includes(keyword.toLowerCase()));
            
            if (missingKeywords.length > 0) {
                console.warn('%câš ï¸ AVISO: Prompt customizado pode estar faltando elementos crÃ­ticos:', 'color: #FFAA00; font-weight: bold;');
                console.warn('%c   Palavras-chave ausentes: ' + missingKeywords.join(', '), 'color: #FFAA00;');
                console.warn('%c   Isso pode causar respostas invÃ¡lidas da IA!', 'color: #FFAA00;');
            }
        } else {
            // âœ… USAR PROMPT PADRÃƒO (COM PADRÃ•ES DETECTADOS E ÃšLTIMOS 20 GIROS)
            console.log('%câœ… Usando prompt padrÃ£o com padrÃµes detectados + Ãºltimos 20 giros', 'color: #00FF88;');
            prompt = DEFAULT_AI_PROMPT(recentHistory.length, historyText, patternsText, last20Text);
        }

        console.log('%cğŸ“¤ Enviando dados para API da IA...', 'color: #00FFFF; font-weight: bold; font-size: 13px;');
        console.log('%c   HistÃ³rico: ' + recentHistory.length + ' giros', 'color: #00FFFF;');
        console.log('%c   âš¡ Timeout: 5 segundos MÃXIMO', 'color: #00FFFF; font-weight: bold;');
        sendAnalysisStatus('ğŸ¤– Consultando IA...');
        
        // Fazer chamada REAL para a API
        let aiResponse;
        
        try {
            switch (apiType) {
                case 'groq':
                    aiResponse = await callGroqAPI(apiKey, prompt, timeout);
                    break;
                case 'openrouter':
                    aiResponse = await callOpenRouterAPI(apiKey, prompt, timeout);
                    break;
                case 'gemini':
                    aiResponse = await callGeminiAPI(apiKey, prompt, timeout);
                    break;
                case 'openai':
                    aiResponse = await callOpenAI_API(apiKey, prompt, timeout);
                    break;
                case 'claude':
                    aiResponse = await callClaudeAPI(apiKey, prompt, timeout);
                    break;
                default:
                    throw new Error('Tipo de API nÃ£o suportado');
            }
        } catch (apiError) {
            console.error('%câŒ ERRO AO CHAMAR API!', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #330000; padding: 5px;');
            console.error('%c   Mensagem: ' + apiError.message, 'color: #FF6666; font-weight: bold;');
            sendAnalysisStatus('âŒ API invÃ¡lida');
            return null;
        }
        
        // Validar resposta
        if (!aiResponse || !aiResponse.color) {
            console.error('%câŒ RESPOSTA DA IA INVÃLIDA!', 'color: #FF0000; font-weight: bold; font-size: 14px;');
            console.error('%c   A API nÃ£o retornou dados no formato esperado', 'color: #FF6666;');
            return null;
        }
        
        // Verificar timeout
        const elapsed = Date.now() - startTime;
        if (elapsed > timeout) {
            console.error('â±ï¸ Timeout: AnÃ¡lise IA excedeu o tempo limite');
            return null;
        }
        
        // âœ… VALIDAR CONFIANÃ‡A MÃNIMA (respeitar configuraÃ§Ã£o do usuÃ¡rio)
        const aiConfidence = aiResponse.confidence || 0;
        const minConfidence = analyzerConfig.minOccurrences || 60; // minOccurrences Ã© usado como confianÃ§a mÃ­nima no modo IA
        
        // âš ï¸ ESPECIAL: Se IA retornar confidence: 0, significa que nÃ£o encontrou padrÃ£o confiÃ¡vel
        if (aiConfidence === 0) {
            console.log('%câ•‘  âš ï¸ IA: NENHUM PADRÃƒO CONFIÃVEL DETECTADO                 â•‘', 'color: #FFAA00; font-weight: bold;');
            console.log('%câ•‘  ğŸ” RaciocÃ­nio: ' + (aiResponse.reasoning || 'Sem padrÃ£o com 85%+ de confianÃ§a').substring(0, 48).padEnd(48) + 'â•‘', 'color: #FFAA00;');
            console.log('%câ•‘  â³ Aguardando formaÃ§Ã£o de padrÃ£o claro...                â•‘', 'color: #FFAA00;');
            sendAnalysisStatus('â³ IA aguardando padrÃ£o confiÃ¡vel...');
            return null;
        }
        
        // Validar se atinge confianÃ§a mÃ­nima configurada
        if (aiConfidence < minConfidence) {
            console.log('%câ•‘  âš ï¸ SINAL IA REJEITADO: CONFIANÃ‡A INSUFICIENTE            â•‘', 'color: #FFAA00; font-weight: bold;');
            console.log('%câ•‘  ğŸ“Š ConfianÃ§a da IA: ' + aiConfidence.toFixed(1) + '%                                â•‘', 'color: #FFAA00;');
            console.log('%câ•‘  ğŸ¯ ConfianÃ§a mÃ­nima configurada: ' + minConfidence + '%                    â•‘', 'color: #FFAA00;');
            console.log('%câ•‘  â³ Aguardando prÃ³ximo giro com maior confianÃ§a...        â•‘', 'color: #FFAA00;');
            sendAnalysisStatus('â³ IA aguardando confianÃ§a maior...');
            return null;
        }
        
        // ğŸ“Š RASTREAMENTO DE CORES (detectar viÃ©s)
        const recommendedColor = aiResponse.color.toLowerCase();
        aiColorCounter[recommendedColor] = (aiColorCounter[recommendedColor] || 0) + 1;
        aiColorCounter.total++;
        
        // Alertar se houver viÃ©s evidente (mais de 70% de uma Ãºnica cor apÃ³s 10+ recomendaÃ§Ãµes)
        if (aiColorCounter.total >= 10) {
            const redPercent = (aiColorCounter.red / aiColorCounter.total) * 100;
            const blackPercent = (aiColorCounter.black / aiColorCounter.total) * 100;
            const whitePercent = (aiColorCounter.white / aiColorCounter.total) * 100;
            
            console.log('%cğŸ“Š ESTATÃSTICAS DA IA (Ãºltimas ' + aiColorCounter.total + ' recomendaÃ§Ãµes):', 'color: #00FFFF; font-weight: bold;');
            console.log('%c   ğŸ”´ VERMELHO: ' + aiColorCounter.red + ' (' + redPercent.toFixed(1) + '%)', 
                'color: ' + (redPercent > 70 ? '#FF0000' : '#00FFFF') + '; font-weight: ' + (redPercent > 70 ? 'bold' : 'normal') + ';');
            console.log('%c   âš« PRETO: ' + aiColorCounter.black + ' (' + blackPercent.toFixed(1) + '%)', 
                'color: ' + (blackPercent > 70 ? '#FF0000' : '#00FFFF') + '; font-weight: ' + (blackPercent > 70 ? 'bold' : 'normal') + ';');
            console.log('%c   âšª BRANCO: ' + aiColorCounter.white + ' (' + whitePercent.toFixed(1) + '%)', 
                'color: ' + (whitePercent > 70 ? '#FF0000' : '#00FFFF') + '; font-weight: ' + (whitePercent > 70 ? 'bold' : 'normal') + ';');
            
            if (redPercent > 70 || blackPercent > 70 || whitePercent > 70) {
                console.log('%câš ï¸âš ï¸âš ï¸ ALERTA DE VIÃ‰S DETECTADO! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #330000; padding: 5px;');
                console.log('%c   A IA estÃ¡ recomendando a MESMA cor mais de 70% das vezes!', 'color: #FF6666; font-weight: bold;');
                console.log('%c   Isso pode indicar um problema no modelo ou no prompt.', 'color: #FF6666;');
            }
        }
        
        // ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: SEMPRE usar dados REAIS do histÃ³rico
        // A IA frequentemente INVENTA os dados em last10Spins, entÃ£o IGNORAMOS completamente
        // e SEMPRE usamos os dados reais do histÃ³rico que foram coletados
        console.log('%cğŸ” USANDO DADOS REAIS DO HISTÃ“RICO (ignorando resposta da IA)', 'color: #FFFF00; font-weight: bold;');
        console.log('%câš ï¸ MOTIVO: A IA frequentemente INVENTA dados no campo last10Spins', 'color: #FFAA00; font-weight: bold;');
        console.log('%câœ… SOLUÃ‡ÃƒO: Sempre extrair do histÃ³rico REAL coletado do site', 'color: #00FF88; font-weight: bold;');
        
        // SEMPRE extrair do histÃ³rico real (ignorar o que a IA retornou)
        const last10SpinsData = recentHistory.slice(0, 10).map(spin => ({
            color: spin.color,
            number: spin.number,
            timestamp: spin.timestamp
        }));
        
        console.log('%cğŸ“Š ÃšLTIMOS 10 GIROS (REAIS do histÃ³rico):', 'color: #00FF88; font-weight: bold;');
        last10SpinsData.forEach((spin, idx) => {
            console.log(`%c   ${idx + 1}. ${spin.color.toUpperCase()} (${spin.number})`, 
                `color: ${spin.color === 'red' ? '#FF0000' : spin.color === 'black' ? '#FFFFFF' : '#00FF00'}; font-weight: bold;`);
        });
        
        // âš ï¸ VALIDAÃ‡ÃƒO: Verificar se a IA retornou dados DIFERENTES dos reais
        if (aiResponse.last10Spins && aiResponse.last10Spins.length > 0) {
            console.log('%cğŸ” VALIDAÃ‡ÃƒO: Comparando dados da IA com histÃ³rico real', 'color: #FFAA00; font-weight: bold;');
            
            let mismatchFound = false;
            for (let i = 0; i < Math.min(5, aiResponse.last10Spins.length); i++) {
                const aiSpin = aiResponse.last10Spins[i];
                const realSpin = last10SpinsData[i];
                
                if (aiSpin.number !== realSpin.number || aiSpin.color !== realSpin.color) {
                    mismatchFound = true;
                    console.log(`%c   âŒ DIVERGÃŠNCIA no giro ${i + 1}:`, 'color: #FF0000; font-weight: bold;');
                    console.log(`%c      IA disse: ${aiSpin.color} (${aiSpin.number})`, 'color: #FF6666;');
                    console.log(`%c      Real Ã©:   ${realSpin.color} (${realSpin.number})`, 'color: #00FF88;');
                }
            }
            
            if (mismatchFound) {
                console.log('%câš ï¸âš ï¸âš ï¸ A IA RETORNOU DADOS FALSOS! âš ï¸âš ï¸âš ï¸', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #330000; padding: 5px;');
                console.log('%c   Os dados exibidos ao usuÃ¡rio sÃ£o os REAIS do histÃ³rico', 'color: #00FF88; font-weight: bold;');
                console.log('%c   (Ignoramos os dados inventados pela IA)', 'color: #00FF88;');
            } else {
                console.log('%c   âœ… Dados da IA conferem com o histÃ³rico real', 'color: #00FF88; font-weight: bold;');
            }
        }
        
        // Criar objeto de anÃ¡lise no formato esperado
        const analysis = {
            color: aiResponse.color,
            confidence: aiResponse.confidence,
            probability: aiResponse.probability || 50,
            suggestion: `IA recomenda: ${aiResponse.color === 'red' ? 'ğŸ”´ VERMELHO' : aiResponse.color === 'black' ? 'âš« PRETO' : 'âšª BRANCO'}`,
            patternDescription: aiResponse.reasoning || 'AnÃ¡lise baseada em IA',
            last10Spins: last10SpinsData, // âœ… INCLUIR OS 10 GIROS
            last5Spins: last10SpinsData ? last10SpinsData.slice(0, 10) : [], // âœ… Mostrando Ãºltimos 10 giros
            source: 'AI-REAL',
            apiType: apiType,
            timestamp: Date.now(),
            createdOnTimestamp: history[0]?.timestamp || Date.now(),
            predictedFor: null // SerÃ¡ preenchido pelo prÃ³ximo giro
        };
        
        console.log('%câœ… RESPOSTA DA IA RECEBIDA COM SUCESSO!', 'color: #00FF00; font-weight: bold; font-size: 14px; background: #003300; padding: 5px;');
        console.log('%c   ğŸ¯ Cor prevista: ' + analysis.color.toUpperCase(), 'color: #00FF00; font-weight: bold; font-size: 13px;');
        console.log('%c   ğŸ“Š ConfianÃ§a: ' + analysis.confidence + '%', 'color: #00FF88; font-weight: bold;');
        console.log('%c   ğŸ’­ RaciocÃ­nio (primeiros 200 chars): ' + (aiResponse.reasoning || '').substring(0, 200) + '...', 'color: #00FF88;');
        console.log('%c   âš¡ Tempo de resposta: ' + elapsed + 'ms', 'color: #00FFFF;');
        
        // ğŸ” VALIDAÃ‡ÃƒO: Verificar se a IA analisou os giros corretos
        console.log('%cğŸ” VALIDAÃ‡ÃƒO: Comparando resposta da IA com histÃ³rico real', 'color: #FFFF00; font-weight: bold;');
        console.log('%cğŸ“Š Ãšltimos 10 giros REAIS (do histÃ³rico):', 'color: #FFFF00; font-weight: bold;');
        for (let i = 0; i < Math.min(10, recentHistory.length); i++) {
            const spin = recentHistory[i];
            console.log(`%c   ${i + 1}. ${spin.color.toUpperCase()} (nÃºmero ${spin.number})`, 
                `color: ${spin.color === 'red' ? '#FF0000' : spin.color === 'black' ? '#FFFFFF' : '#00FF00'}; font-weight: bold;`);
        }
        console.log('%cğŸ’­ O que a IA disse sobre os Ãºltimos giros:', 'color: #FFFF00; font-weight: bold;');
        const reasoningSnippet = (aiResponse.reasoning || '').substring(0, 300);
        console.log('%c   ' + reasoningSnippet, 'color: #FFAA00;');
        
        return analysis;
        
    } catch (error) {
        console.error('%câŒ ERRO GERAL NA ANÃLISE IA!', 'color: #FF0000; font-weight: bold; font-size: 14px; background: #330000; padding: 5px;');
        console.error('%c   ' + error.message, 'color: #FF6666; font-weight: bold;');
        console.error('%c   Stack:', error.stack, 'color: #FF3333;');
        sendAnalysisStatus('âŒ Erro na IA');
        return null;
    }
}

/**
 * Chama a API do Groq (Ultra RÃ¡pido)
 */
async function callGroqAPI(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: 'llama-3.3-70b-versatile', // Modelo mais recente e eficiente do Groq
                messages: [
                    { 
                        role: 'system', 
                        content: 'VocÃª Ã© um especialista em anÃ¡lise de padrÃµes do jogo Double da Blaze. Responda APENAS com JSON vÃ¡lido, sem markdown ou texto adicional.' 
                    },
                    { role: 'user', content: prompt }
                ],
                temperature: 0.7,
                max_tokens: 800,
                top_p: 1
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API Groq retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.choices?.[0]?.message?.content;
        
        if (!text) {
            throw new Error('Resposta da API Groq estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta (remover markdown se houver)
        let jsonText = text.trim();
        
        // Remover blocos de cÃ³digo markdown se existirem
        jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');
        
        // Extrair JSON
        const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API Groq');
        }
        throw error;
    }
}

/**
 * Chama a API do OpenRouter (agregador de mÃºltiplas IAs)
 */
async function callOpenRouterAPI(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`,
                'HTTP-Referer': 'https://blaze.com',
                'X-Title': 'Blaze Double Analyzer'
            },
            body: JSON.stringify({
                model: 'anthropic/claude-3.5-sonnet', // Melhor modelo disponÃ­vel
                messages: [
                    { 
                        role: 'system', 
                        content: 'VocÃª Ã© um especialista em anÃ¡lise de padrÃµes do jogo Double da Blaze. Responda APENAS com JSON vÃ¡lido, sem markdown ou texto adicional.' 
                    },
                    { role: 'user', content: prompt }
                ],
                temperature: 0.7,
                max_tokens: 800,
                top_p: 1,
                frequency_penalty: 0,
                presence_penalty: 0
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API OpenRouter retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.choices?.[0]?.message?.content;
        
        if (!text) {
            throw new Error('Resposta da API OpenRouter estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta (remover markdown se houver)
        let jsonText = text.trim();
        
        // Remover blocos de cÃ³digo markdown se existirem
        jsonText = jsonText.replace(/```json\s*/g, '').replace(/```\s*/g, '');
        
        // Extrair JSON
        const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API OpenRouter');
        }
        throw error;
    }
}

/**
 * Chama a API do Google Gemini
 */
async function callGeminiAPI(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 1024,
                }
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API Gemini retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (!text) {
            throw new Error('Resposta da API Gemini estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API Gemini');
        }
        throw error;
    }
}

/**
 * Chama a API da OpenAI (GPT)
 */
async function callOpenAI_API(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: 'gpt-3.5-turbo',
                messages: [
                    { role: 'system', content: 'VocÃª Ã© um especialista em anÃ¡lise de padrÃµes. Responda APENAS com JSON.' },
                    { role: 'user', content: prompt }
                ],
                temperature: 0.7,
                max_tokens: 500
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API OpenAI retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.choices?.[0]?.message?.content;
        
        if (!text) {
            throw new Error('Resposta da API OpenAI estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API OpenAI');
        }
        throw error;
    }
}

/**
 * Chama a API da Anthropic (Claude)
 */
async function callClaudeAPI(apiKey, prompt, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
                model: 'claude-3-sonnet-20240229',
                max_tokens: 1024,
                messages: [
                    { role: 'user', content: prompt }
                ]
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API Claude retornou erro ${response.status}: ${errorText}`);
        }
        
        const data = await response.json();
        const text = data.content?.[0]?.text;
        
        if (!text) {
            throw new Error('Resposta da API Claude estÃ¡ vazia');
        }
        
        // Extrair JSON da resposta
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('IA nÃ£o retornou JSON vÃ¡lido');
        }
        
        return JSON.parse(jsonMatch[0]);
        
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Timeout ao conectar com API Claude');
        }
        throw error;
    }
}
// */

// UtilitÃ¡rio central para garantir que nenhuma anÃ¡lise rode quando o toggle estiver desligado
async function runAnalysisIfEnabled(history, contextLabel = 'general') {
    if (!analysisEnabled) {
        console.log(`â¸ï¸ [${contextLabel}] AnÃ¡lises pausadas â€“ runAnalysisController() nÃ£o serÃ¡ executado.`);
        return false;
    }

    if (!history || !Array.isArray(history) || history.length === 0) {
        console.log(`âš ï¸ [${contextLabel}] HistÃ³rico indisponÃ­vel para anÃ¡lise.`);
        return false;
    }

    console.log(`â–¶ï¸ [${contextLabel}] Executando runAnalysisController() com ${history.length} giros.`);
    await runAnalysisController(history);
    return true;
}

async function clearActiveAnalysisState(reason = 'manual-toggle') {
    console.log(`ğŸ§¹ [${reason}] Limpando estado de anÃ¡lise e Martingale devido Ã  pausa.`);
    resetMartingaleState();

    try {
        await chrome.storage.local.set({
            analysis: null,
            pattern: null,
            lastBet: null,
            martingaleState
        });
    } catch (error) {
        console.error('âŒ Falha ao sincronizar limpeza de anÃ¡lise no storage:', error);
    }

    sendMessageToContent('CLEAR_ANALYSIS');
}

// NOVO CONTROLADOR: Orquestra VerificaÃ§Ã£o (padrÃµes salvos) + Descoberta (173+ anÃ¡lises) em â‰¤5s
async function runAnalysisController(history) {
	const startTs = Date.now();
	const budgetMs = 5000; // 5s totais

	try {
		if (!history || !Array.isArray(history) || history.length === 0) {
			console.error('âŒ history invÃ¡lido na anÃ¡lise avanÃ§ada.');
			return null;
		}

		logSection('[Controller] Iniciando anÃ¡lise avanÃ§ada');
		logInfo('HistÃ³rico recebido', `${history.length} giros`);

		const storageResult = await chrome.storage.local.get(['analyzerConfig']);
		if (storageResult && storageResult.analyzerConfig) {
			mergeAnalyzerConfig(storageResult.analyzerConfig);
			logInfo('ConfiguraÃ§Ã£o', 'Recarregada do storage');
		}

        // âœ… Respeitar profundidade configurada no modo padrÃ£o:
        // ter 10k "disponÃ­vel" nÃ£o significa varrer 10k quando o usuÃ¡rio pediu 100/500.
        if (!analyzerConfig.aiMode) {
            const configuredDepth = clampInt(
                analyzerConfig.historyDepth ?? DEFAULT_ANALYZER_CONFIG.historyDepth,
                50,
                REALTIME_HISTORY_CAP
            );
            const effectiveDepth = Math.min(configuredDepth, history.length);
            if (effectiveDepth > 0 && effectiveDepth < history.length) {
                history = history.slice(0, effectiveDepth);
            }
        }

		emitModeSnapshotToContent('AnÃ¡lise em andamento', history.length);

        // ğŸ›Ÿ RECUPERAÃ‡ÃƒO (manual):
        // A fase 1 continua rodando "silenciosa" para alimentar o histÃ³rico interno.
        // A decisÃ£o de exibir (ou nÃ£o) o sinal fica centralizada em `emitAnalysisToContent`.
		
		// âš ï¸ CRÃTICO: Em gales consecutivos (atÃ© o limite configurado), nÃ£o gerar novo sinal.
		// âœ… CorreÃ§Ã£o: se o martingale estiver ativo mas NÃƒO houver analysis pendente correspondente (ou estiver stale),
		// isso significa estado travado apÃ³s refresh/erro â†’ auto-reset para destravar.
		const { consecutiveGales } = getMartingaleSettingsForEntryColor(martingaleState && martingaleState.entryColor);
		if (martingaleState.active && isMartingaleStageConsecutive(martingaleState.stage, consecutiveGales)) {
			let shouldBlock = true;
			try {
				const latestSpin = history && history.length > 0 ? history[0] : null;
				const latestMs = Number.isFinite(parseSpinTimestamp(latestSpin)) ? parseSpinTimestamp(latestSpin) : 0;
				const stored = await chrome.storage.local.get(['analysis']);
				const a = stored && stored.analysis ? stored.analysis : null;
				const parseMs = (v) => {
					try {
						if (v == null) return 0;
						if (typeof v === 'number') return Number.isFinite(v) ? v : 0;
						const n = Number(v);
						if (Number.isFinite(n)) return n;
						const ms = Date.parse(String(v));
						return Number.isFinite(ms) ? ms : 0;
					} catch (_) { return 0; }
				};
				const aMs = parseMs(a && a.createdOnTimestamp);
				const entryMs = parseMs(martingaleState.entryTimestamp || (martingaleState.analysisData && martingaleState.analysisData.createdOnTimestamp));
				const STALE_MS = 3 * 60 * 1000;
				const stale = !!(
					latestMs > 0 &&
					((aMs > 0 && latestMs > aMs && (latestMs - aMs) > STALE_MS) ||
					 ((aMs <= 0) && entryMs > 0 && latestMs > entryMs && (latestMs - entryMs) > STALE_MS) ||
					 ((aMs <= 0) && (entryMs <= 0)))
				);
				const missingAnalysis = !(a && a.createdOnTimestamp);
				if (missingAnalysis || stale) {
					shouldBlock = false;
					console.warn('ğŸ§¯ [AUTO-HEAL] Martingale consecutivo travado (sem analysis pendente ou stale). Limpando para destravar.', {
						stage: martingaleState.stage,
						entryTimestamp: martingaleState.entryTimestamp,
						analysisCreatedOnTimestamp: a && a.createdOnTimestamp,
						latestMs
					});
					resetMartingaleState();
					await chrome.storage.local.set({
						analysis: null,
						pattern: null,
						lastBet: { status: 'loss', phase: 'G0', resolvedAtTimestamp: (latestSpin && (latestSpin.timestamp ?? latestSpin.created_at)) || Date.now(), clearedReason: missingAnalysis ? 'martingale_missing_analysis_controller' : 'martingale_stale_controller' },
						martingaleState
					});
					sendMessageToContent('CLEAR_ANALYSIS');
				}
			} catch (e) {
				console.warn('âš ï¸ Falha ao tentar auto-heal do martingale consecutivo no controller:', e);
			}

			if (shouldBlock) {
				logSection('â›” Martingale ativo (modo consecutivo)');
				logInfo('EstÃ¡gio', martingaleState.stage);
				logInfo('Cor', martingaleState.entryColor);
				logInfo('AÃ§Ã£o', 'Aguardando resultado anterior');
				try {
					sendAnalysisStatus(`â³ Ciclo em andamento: ${String(martingaleState.stage || 'ENTRADA')} â€¢ aguardando resultado`);
				} catch (_) {}
				return; // âœ… NÃƒO executar nova anÃ¡lise em modo consecutivo com Martingale ativo
			}
		}
		// Log removido: reduÃ§Ã£o de verbosidade
		
		// âœ… VERIFICAR SE JÃ EXISTE UMA ANÃLISE PENDENTE (que ainda nÃ£o foi avaliada)
		const existingAnalysisResult = await chrome.storage.local.get(['analysis']);
		const existingAnalysis = existingAnalysisResult['analysis'];
		
		if (existingAnalysis && existingAnalysis.createdOnTimestamp && history && history.length > 0) {
			const latestSpinTimestamp = parseSpinTimestamp(history[0]);
			const analysisTs = parseSpinTimestamp({ timestamp: existingAnalysis.createdOnTimestamp, created_at: existingAnalysis.createdOnTimestamp });
			const isAnalysisPending = (Number.isFinite(latestSpinTimestamp) && Number.isFinite(analysisTs))
				? (analysisTs !== latestSpinTimestamp)
				: (String(existingAnalysis.createdOnTimestamp) !== String(history[0].timestamp ?? history[0].created_at ?? ''));
			
			if (isAnalysisPending) {
			console.log('%câš ï¸ AnÃ¡lise pendente | ' + existingAnalysis.color + ' (' + existingAnalysis.confidence + '%)', 'color: #FF9900; font-weight: bold; background: #332200; padding: 4px 8px; border-radius: 4px;');
				try {
					sendAnalysisStatus(`â³ Aguardando resultado do prÃ³ximo giro â€¢ ${String(existingAnalysis.phase || 'G0').toUpperCase()}`);
				} catch (_) {}
				return; // âœ… NÃƒO executar nova anÃ¡lise se jÃ¡ hÃ¡ uma pendente
			}
		}
	// Log removido: reduÃ§Ã£o de verbosidade
		
		// 1) VerificaÃ§Ã£o com padrÃµes salvos (rÃ¡pido) - PRIORIDADE MÃXIMA
		// âš ï¸ CRÃTICO: PULAR VERIFICAÃ‡ÃƒO DE PADRÃ•ES SALVOS SE MODO IA ESTIVER ATIVO
		let verifyResult = null;
		if (!analyzerConfig.aiMode) {
			console.log('%cğŸ” Analisando padrÃµes...', 'color: #00AAFF; font-weight: bold; background: #003366; padding: 4px 8px; border-radius: 4px;');
			sendAnalysisStatus('ğŸ” Verificando padrÃµes salvos...');
			verifyResult = await verifyWithSavedPatterns(history);
		} else {
			console.log('%cğŸ¤– Modo IA ativo | Analisando...', 'color: #00FF88; font-weight: bold; background: #003300; padding: 4px 8px; border-radius: 4px;');
		}
		
		if (verifyResult) {
		console.log('%câœ… PadrÃ£o encontrado | ' + verifyResult.color + ' (' + verifyResult.confidence + '%)', 'color: #00FF88; font-weight: bold; background: #003322; padding: 4px 8px; border-radius: 4px;');
			
			// âš ï¸ Martingale ativo:
			// - enquanto estiver dentro do "consecutivo atÃ©", mantÃ©m a cor do ciclo
			// - quando estiver no modo "prÃ³ximo sinal", NÃƒO mantÃ©m a cor (usa a cor do novo sinal)
			if (martingaleState.active) {
				const { consecutiveGales } = getMartingaleSettingsForEntryColor(martingaleState && martingaleState.entryColor);
				console.log('â•‘  ğŸ”„ MARTINGALE ATIVO DETECTADO!                          â•‘');
				console.log(`â•‘  Cor do novo padrÃ£o: ${verifyResult.color}                           â•‘`);
				console.log(`â•‘  Cor da entrada original: ${martingaleState.entryColor}                    â•‘`);
				console.log(`â•‘  EstÃ¡gio atual: ${martingaleState.stage}                              â•‘`);
				
				// âœ… Sempre marcar o estÃ¡gio (stake) do Martingale
				verifyResult.phase = martingaleState.stage;

				// âœ… SÃ³ forÃ§a a cor se este estÃ¡gio for consecutivo
				if (martingaleState.entryColor && isMartingaleStageConsecutive(martingaleState.stage, consecutiveGales)) {
					console.log('â•‘  âœ… COR FORÃ‡ADA (estÃ¡gio consecutivo)                     â•‘');
					verifyResult.color = martingaleState.entryColor;
				} else {
					console.log('â•‘  âœ… COR LIVRE (prÃ³ximo sinal)                             â•‘');
				}

                // âœ… NÃ£o sobrescrever a confianÃ§a exibida do sinal; guardar apenas a confianÃ§a condicional do GALE (interno)
                verifyResult.galeConfidence = calculateGaleConfidenceValue(verifyResult.confidence, verifyResult);
			}
			
			console.log('%câ•‘  ğŸ’¾ SALVANDO SINAL/ENTRADA EM CHROME.STORAGE.LOCAL                         â•‘', 'color: #FFD700; font-weight: bold; font-size: 16px;');
			console.log('%cğŸ“Š DADOS COMPLETOS DO SINAL:', 'color: #FFD700; font-weight: bold;');
			console.log('   â¤ Cor:', verifyResult.color);
			console.log('   â¤ ConfianÃ§a:', verifyResult.confidence + '%');
			console.log('   â¤ Fase:', verifyResult.phase || 'G0');
			console.log('   â¤ CreatedOn (timestamp):', verifyResult.createdOnTimestamp);
			console.log('   â¤ PredictedFor:', verifyResult.predictedFor);
			console.log('   â¤ PatternDescription:', verifyResult.patternDescription);
			console.log('   â¤ Modo:', analyzerConfig.aiMode ? 'NÃVEL DIAMANTE (IA)' : 'ANÃLISE PADRÃƒO');
		console.log('%cğŸ’¾ Salvando objeto analysis no storage...', 'color: #00FFFF; font-weight: bold;');
		
		// âš¡âš¡âš¡ CRÃTICO: VERIFICAR SE O MODO AINDA Ã‰ PADRÃƒO âš¡âš¡âš¡
		// O usuÃ¡rio pode ter ativado o modo Diamante durante a anÃ¡lise de padrÃµes salvos
		const currentConfigPadrao = await chrome.storage.local.get(['analyzerConfig']);
		if (currentConfigPadrao && currentConfigPadrao.analyzerConfig) {
			const currentAiModePadrao = currentConfigPadrao.analyzerConfig.aiMode;
			
			if (currentAiModePadrao) {
				console.log('%câ•‘  ğŸš« MODO FOI ALTERADO PARA DIAMANTE DURANTE ANÃLISE!     â•‘', 'color: #FF0000; font-weight: bold; font-size: 14px;');
				console.log('%câ•‘  âš ï¸ AnÃ¡lise de padrÃ£o salvo foi concluÃ­da                â•‘', 'color: #FFAA00;');
				console.log('%câ•‘  ğŸš« MAS modo agora Ã© Diamante                            â•‘', 'color: #FF0000; font-weight: bold;');
				console.log('%câ•‘  âŒ CANCELANDO envio de sinal do Modo PadrÃ£o             â•‘', 'color: #FF0000; font-weight: bold;');
				console.log('%câŒ SINAL CANCELADO! UsuÃ¡rio ativou Modo Diamante.', 'color: #FF0000; font-weight: bold; font-size: 16px;');
				
				// âœ… Atualizar config global para refletir mudanÃ§a
				analyzerConfig.aiMode = true;
				
				return; // âŒ CANCELAR - nÃ£o enviar sinal de modo diferente
			}
			
			console.log('%câœ… Modo PadrÃ£o ainda ativo - continuando com envio do sinal...', 'color: #00FF88; font-weight: bold;');
		}
		
		// Se RecuperaÃ§Ã£o estiver ativa, este sinal entra como "silencioso" por padrÃ£o.
		// `emitAnalysisToContent` decide se libera (recoveryMode=true) ou mantÃ©m oculto.
		if (recoveryModeEnabled) {
			try { verifyResult.hiddenInternal = true; } catch (_) {}
		}

		await chrome.storage.local.set({
			analysis: verifyResult,
			pattern: { description: verifyResult.patternDescription, confidence: verifyResult.confidence },
			lastBet: { status: 'pending', phase: verifyResult.phase || 'G0', createdOnTimestamp: verifyResult.createdOnTimestamp }
		});
			
			console.log('%câœ… SINAL SALVO COM SUCESSO NO STORAGE!', 'color: #00FF00; font-weight: bold; font-size: 14px;');
			console.log('%c   â¤ Agora aguardando prÃ³ximo giro para verificar WIN/LOSS...', 'color: #00FF88;');
			
			// âœ… ENVIAR SINAIS PARA AMBOS OS CANAIS (INDEPENDENTES)
			const sendResults = {
				extensao: false,
				telegram: false
			};
			
			// 1. Enviar para extensÃ£o (UI)
			try {
				sendResults.extensao = await emitAnalysisToContent(verifyResult, 'standard');
			} catch (e) {
				console.error('âŒ Erro crÃ­tico ao enviar para extensÃ£o:', e);
			}
			
			// 2. Enviar para Telegram (INDEPENDENTE)
			try {
			if (history && history.length > 0 && !(verifyResult && verifyResult.hiddenInternal)) {
					// âœ… NÃ£o bloquear o sinal por IO externo (Telegram pode demorar)
					detachPromise(
						sendTelegramEntrySignal(verifyResult.color, history[0], verifyResult.confidence, verifyResult),
						'telegram-entry-signal'
					);
					sendResults.telegram = true; // queued
				}
			} catch (e) {
				console.error('âŒ Erro crÃ­tico ao enviar para Telegram:', e);
			}
			
			// 3. Log de resultado consolidado
			console.log('â•‘  ğŸ“Š RESULTADO DO ENVIO DE SINAIS                          â•‘');
			console.log('â•‘  ğŸ’¾ Sistema usado: PADRÃƒO SALVO (BANCO)                   â•‘');
			console.log(`â•‘  ğŸ“± ExtensÃ£o: ${sendResults.extensao ? 'âœ… ENVIADO' : 'âŒ FALHOU'.padEnd(11)}                        â•‘`);
			console.log(`â•‘  ğŸ“² Telegram: ${sendResults.telegram ? 'âœ… ENVIADO' : 'âŒ FALHOU'.padEnd(11)}                        â•‘`);
			
			// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
			displaySystemFooter();
			
			// âœ… RETURN apÃ³s enviar sinal para evitar fallback (que causaria mensagem duplicada)
			return;
		}
		
		// âœ… MODO AVANÃ‡ADO: Se ativado e nÃ£o achou padrÃ£o salvo, usar anÃ¡lise avanÃ§ada
		if (analyzerConfig.aiMode && !verifyResult) {
			logSection('AnÃ¡lise avanÃ§ada (modo Diamante)');
			logInfo('HistÃ³rico disponÃ­vel', `${history.length} giros`);
			logInfo('AÃ§Ã£o', 'Executando analyzeWithPatternSystem');
			
		const aiResult = await analyzeWithPatternSystem(history);
		
		logInfo('Resultado IA', aiResult ? 'Retornou com dados' : 'Sem sinal');
		console.log('   Resultado:', aiResult ? 'ENCONTROU SINAL' : 'NÃƒO ENCONTROU');
		
		if (aiResult) {
			// âš¡âš¡âš¡ CRÃTICO: VERIFICAR SE O MODO AINDA ESTÃ ATIVO âš¡âš¡âš¡
			// A anÃ¡lise pode ter demorado e o usuÃ¡rio pode ter desativado o modo durante a execuÃ§Ã£o
			const currentConfig = await chrome.storage.local.get(['analyzerConfig']);
			if (currentConfig && currentConfig.analyzerConfig) {
				const currentAiMode = currentConfig.analyzerConfig.aiMode;
				
				if (!currentAiMode) {
					console.log('%câ•‘  ğŸš« MODO DIAMANTE FOI DESATIVADO DURANTE A ANÃLISE!      â•‘', 'color: #FF0000; font-weight: bold; font-size: 14px;');
					console.log('%câ•‘  âš ï¸ AnÃ¡lise foi concluÃ­da mas modo jÃ¡ mudou              â•‘', 'color: #FFAA00;');
					console.log('%câ•‘  ğŸš« CANCELANDO envio de sinal                            â•‘', 'color: #FF0000; font-weight: bold;');
					console.log('%câ•‘  âœ… Sistema agora estÃ¡ em Modo PadrÃ£o                    â•‘', 'color: #00FF88;');
					console.log('%câŒ SINAL CANCELADO! Modo foi alterado pelo usuÃ¡rio.', 'color: #FF0000; font-weight: bold; font-size: 16px;');
					
					// âœ… Atualizar config global para refletir mudanÃ§a
					analyzerConfig.aiMode = false;
					
					return; // âŒ CANCELAR - nÃ£o enviar sinal de modo diferente
				}
				
				console.log('%câœ… Modo Diamante ainda ativo - continuando com envio do sinal...', 'color: #00FF88; font-weight: bold;');
			}
			
			// âš ï¸ VERIFICAR SE Ã‰ A PRIMEIRA ANÃLISE APÃ“S ATIVAR MODO AVANÃ‡ADO
			if (aiModeJustActivated) {
					console.log('%câ•‘  â³ MODO AVANÃ‡ADO RECÃ‰M-ATIVADO                           â•‘', 'color: #FFAA00; font-weight: bold; font-size: 14px;');
					console.log('%câ•‘  ğŸ¯ Sistema analisou e encontrou padrÃ£o!                  â•‘', 'color: #FFAA00; font-weight: bold;');
					console.log('%câ•‘  ğŸ¯ Cor prevista: ' + aiResult.color.toUpperCase() + '                                     â•‘', 'color: #FFAA00;');
					console.log('%câ•‘  ğŸ“Š ConfianÃ§a: ' + aiResult.confidence + '%                                   â•‘', 'color: #FFAA00;');
					console.log('%câ•‘  â³ AGUARDANDO 1 GIRO antes de enviar sinal...            â•‘', 'color: #FFAA00; font-weight: bold;');
					console.log('%câ•‘  ğŸš« Sinal NÃƒO serÃ¡ enviado neste momento                  â•‘', 'color: #FFAA00; font-weight: bold;');
					console.log('%câ•‘  âœ… PrÃ³ximo giro: sinal serÃ¡ enviado normalmente          â•‘', 'color: #FFAA00; font-weight: bold;');
					
				// Desabilitar flag para permitir prÃ³ximo sinal
				aiModeJustActivated = false;
				console.log('%câœ… Flag aiModeJustActivated = false (prÃ³ximos sinais serÃ£o enviados)', 'color: #00FF88; font-weight: bold;');
				
				// âœ… SALVAR o giro atual como "Ãºltimo sinal" para respeitar intervalo mÃ­nimo configurado
                const latestSpin = history[0] || null;
				await chrome.storage.local.set({
					lastSignalSpinNumber: latestSpin ? latestSpin.number : null,
					lastSignalSpinId: latestSpin ? latestSpin.id || null : null,
					lastSignalSpinTimestamp: latestSpin ? latestSpin.timestamp || null : null,
					lastSignalTimestamp: Date.now()
				});
				console.log('%cğŸ“ Giro atual salvo como "Ãºltimo sinal" para respeitar intervalo mÃ­nimo de ' + analyzerConfig.minIntervalSpins + ' giros', 'color: #FFD700; font-weight: bold;');
				
				// Enviar status para UI informando que estÃ¡ aguardando
				sendAnalysisStatus('â³ Aguardando prÃ³ximo giro para enviar sinal...');
				
				// RETURN - nÃ£o enviar sinal
				return;
				}
				
				// âš ï¸ VERIFICAR SE HÃ MARTINGALE ATIVO
				let aiColor = aiResult.color;
				let aiPhase = 'G0';
				
				if (martingaleState.active) {
					const { consecutiveGales } = getMartingaleSettingsForEntryColor(martingaleState && martingaleState.entryColor);
					console.log('â•‘  ğŸ”„ MARTINGALE ATIVO DETECTADO! (MODO IA)                â•‘');
					console.log(`â•‘  Cor da IA: ${aiColor}                                         â•‘`);
					console.log(`â•‘  Cor da entrada original: ${martingaleState.entryColor}                    â•‘`);
					console.log(`â•‘  EstÃ¡gio atual: ${martingaleState.stage}                              â•‘`);
					aiPhase = martingaleState.stage;
					
					// âœ… SÃ³ forÃ§a a cor se este estÃ¡gio for consecutivo
					const forcedColor = martingaleState.currentColor || martingaleState.entryColor;
					if (forcedColor && isMartingaleStageConsecutive(martingaleState.stage, consecutiveGales)) {
						console.log('â•‘  âœ… COR FORÃ‡ADA (estÃ¡gio consecutivo)                     â•‘');
					aiColor = forcedColor;
					} else {
						console.log('â•‘  âœ… COR LIVRE (prÃ³ximo sinal)                             â•‘');
					}
				}
				
				// ğŸ”¥ CORREÃ‡ÃƒO CRÃTICA: SEMPRE usar dados REAIS do histÃ³rico
				// NUNCA confiar no que a IA retorna, pois ela frequentemente inventa dados
				console.log('%cğŸ”¥ FORÃ‡ANDO uso de dados REAIS para descriÃ§Ã£o/exibiÃ§Ã£o', 'color: #FF6600; font-weight: bold;');
				
				// âœ… Definir tamanho do histÃ³rico usado
				const aiHistorySizeUsed = Math.min(Math.max(analyzerConfig.aiHistorySize || 50, 20), history.length);
				
				const last10SpinsForDescription = history.slice(0, 10).map(spin => ({
					color: spin.color,
					number: spin.number,
					timestamp: spin.timestamp
				}));
				console.log('%câœ… ExtraÃ­do do histÃ³rico REAL:', 'color: #00FF88;', last10SpinsForDescription.slice(0, 10));
				
				const aiDescriptionData = {
					type: 'AI_ANALYSIS',
					color: aiColor,
					confidence: aiResult.confidence,
                    diamondSourceLevel: aiResult.diamondSourceLevel || null,
                    // ğŸ’ N4: meta do auto-aprendizado (para auditoria/debug; nÃ£o afeta UI se nÃ£o usado)
                    diamondN4: aiResult.diamondN4 || null,
                    // âšª N0: meta do auto-aprendizado (para auditoria/debug; nÃ£o afeta UI se nÃ£o usado)
                    diamondN0: aiResult.diamondN0 || null,
					last10Spins: last10SpinsForDescription,
					last5Spins: last10SpinsForDescription ? last10SpinsForDescription.slice(0, 10) : [], // âœ… Mostrando Ãºltimos 10 giros
					reasoning: aiResult.reasoning || aiResult.patternDescription || 'AnÃ¡lise baseada nos Ãºltimos ' + aiHistorySizeUsed + ' giros do histÃ³rico.',
					historySize: aiHistorySizeUsed
				};
				
				console.log('%cğŸ“¦ DADOS ESTRUTURADOS DA IA (para renderizaÃ§Ã£o):', 'color: #00FFFF; font-weight: bold;');
				console.log('%c   ğŸ¨ Tipo:', 'color: #00FFFF;', aiDescriptionData.type);
				console.log('%c   ğŸ¯ Cor:', 'color: #00FFFF;', aiDescriptionData.color);
				console.log('%c   ğŸ“Š ConfianÃ§a:', 'color: #00FFFF;', aiDescriptionData.confidence + '%');
				console.log('%c   ğŸ² Ãšltimos 10 giros:', 'color: #00FFFF;', aiDescriptionData.last10Spins);
				console.log('%c   ğŸ’­ RaciocÃ­nio (200 chars):', 'color: #00FFFF;', (aiDescriptionData.reasoning || '').substring(0, 200) + '...');
				
				// Serializar para JSON para armazenamento
				const aiDescription = JSON.stringify(aiDescriptionData);
				
				// Criar objeto de anÃ¡lise no formato esperado (com padrÃ£o para futura comparaÃ§Ã£o)
				const analysis = {
					color: aiColor,
					confidence: aiResult.confidence,
                    diamondSourceLevel: aiResult.diamondSourceLevel || null,
                    diamondN4: aiResult.diamondN4 || null,
                    diamondN0: aiResult.diamondN0 || null,
					patternDescription: aiDescription,
					last10Spins: last10SpinsForDescription, // âœ… INCLUIR DIRETAMENTE para facilitar acesso
					last5Spins: last10SpinsForDescription ? last10SpinsForDescription.slice(0, 10) : [], // âœ… Mostrando Ãºltimos 10 giros
					patternType: 'ai-analysis',
					phase: aiPhase,
					predictedFor: 'next',
					// âœ… Padronizar timestamp do sinal (evita comparar `timestamp` vs `created_at` e avaliar no mesmo giro)
					createdOnTimestamp: (history[0] && (history[0].created_at ?? history[0].timestamp)) || Date.now(),
					aiPattern: null // âœ… Novo fluxo nÃ£o usa currentPattern
				};
				if (analysis.phase && analysis.phase !== 'G0' && analysis.phase !== 'ENTRADA') {
					// âœ… NÃ£o sobrescrever a confianÃ§a exibida do sinal; guardar apenas a confianÃ§a condicional do GALE (interno)
					analysis.galeConfidence = calculateGaleConfidenceValue(analysis.confidence, analysis);
				}
				
				console.log('%câ•‘  ğŸ’¾ SALVANDO ANÃLISE IA EM CHROME.STORAGE.LOCAL          â•‘', 'color: #00FF00; font-weight: bold;');
				console.log('%cğŸ“Š Dados da anÃ¡lise IA:', 'color: #00FF88; font-weight: bold;');
				console.log('%c   ğŸ¯ Cor: ' + analysis.color.toUpperCase(), 'color: #00FF88;');
				console.log('%c   ğŸ“Š ConfianÃ§a: ' + analysis.confidence + '%', 'color: #00FF88;');
				console.log('%c   ğŸ² Fase: ' + analysis.phase, 'color: #00FF88;');
				console.log(`%c   ğŸ“ NÃºmero do giro: #${history[0].number}`, 'color: #00FF88;');
				
				// ğŸ›Ÿ RecuperaÃ§Ã£o ativa: este sinal entra como "silencioso" (fase 1) por padrÃ£o.
				// `emitAnalysisToContent` decide se vira um sinal de recuperaÃ§Ã£o (recoveryMode=true).
				if (recoveryModeEnabled) {
					try { analysis.hiddenInternal = true; } catch (_) {}
				}

				// Salvar anÃ¡lise E nÃºmero do giro do Ãºltimo sinal
				await chrome.storage.local.set({
					analysis: analysis,
					pattern: { description: analysis.patternDescription, confidence: analysis.confidence },
					lastBet: { status: 'pending', phase: aiPhase, createdOnTimestamp: analysis.createdOnTimestamp },
					lastSignalSpinNumber: history[0].number, // âœ… CRÃTICO: Salvar nÃºmero do giro para validaÃ§Ã£o de intervalo
					lastSignalSpinId: history[0].id || null,
					lastSignalSpinTimestamp: history[0].timestamp || null,
					lastSignalTimestamp: Date.now() // âœ… Timestamp para debug
				});
				
				console.log('%câœ… AnÃ¡lise IA salva em chrome.storage.local!', 'color: #00FF00; font-weight: bold; font-size: 13px;');
				console.log(`%cğŸ“ NÃºmero do giro registrado: #${history[0].number}`, 'color: #00D4FF; font-weight: bold;');
				console.log(`%câ° Timestamp registrado: ${new Date().toLocaleTimeString()}`, 'color: #00D4FF; font-weight: bold;');
				console.log('%câ•‘  ğŸ“‹ DESCRIÃ‡ÃƒO DO PADRÃƒO (ENVIADA PARA O USUÃRIO):        â•‘', 'color: #00FF00; font-weight: bold;');
				console.log('%c' + aiDescription, 'color: #00FF88;');
				
				// âœ… ENVIAR SINAIS PARA AMBOS OS CANAIS (INDEPENDENTES)
				const sendResults = {
					extensao: false,
					telegram: false
				};
				
				// 1. Enviar para extensÃ£o (UI)
				// âœ… Premium (Modo PadrÃ£o): emitir como 'standard' (nÃ£o como 'diamond')
				try {
					sendResults.extensao = await emitAnalysisToContent(analysis, 'standard');
				} catch (e) {
					console.error('âŒ Erro crÃ­tico ao enviar para extensÃ£o:', e);
				}
				
				// 2. Enviar para Telegram (INDEPENDENTE)
				try {
					if (history && history.length > 0 && !(analysis && analysis.hiddenInternal)) {
						// âœ… NÃ£o bloquear o sinal por IO externo (Telegram pode demorar)
						detachPromise(
							sendTelegramEntrySignal(analysis.color, history[0], analysis.confidence, analysis),
							'telegram-entry-signal'
						);
						sendResults.telegram = true; // queued
					}
				} catch (e) {
					console.error('âŒ Erro crÃ­tico ao enviar para Telegram:', e);
				}
				
				// 3. Log de resultado consolidado
				console.log('%câ•‘  âœ… SINAL ENVIADO COM SUCESSO!                           â•‘', 'color: #00FF00; font-weight: bold; font-size: 14px; background: #003300; padding: 2px;');
			
			// ğŸ§  Status dinÃ¢mico da memÃ³ria
			const statusMemoria = memoriaAtiva.inicializada ? 
				`âš¡ CACHE RAM ATIVO (${memoriaAtiva.totalAtualizacoes} updates)` : 
				'ğŸ”„ INICIALIZANDO...';
			
			console.log(`%câ•‘  ğŸ¤– Sistema: ANÃLISE IA | ${statusMemoria}              â•‘`, 'color: #00FF00; font-weight: bold; background: #003300; padding: 2px;');
			console.log('%câ•‘  ğŸ“± ExtensÃ£o: ' + (sendResults.extensao ? 'âœ… ENVIADO' : 'âŒ FALHOU') + '                                    â•‘', 'color: #00FF88; background: #003300; padding: 2px;');
				console.log('%câ•‘  ğŸ“² Telegram: ' + (sendResults.telegram ? 'âœ… ENVIADO' : 'âŒ FALHOU') + '                                    â•‘', 'color: #00FF88; background: #003300; padding: 2px;');
				
				// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
				displaySystemFooter();
				
				// âœ… RETURN apÃ³s enviar sinal IA
				return;
			} else {
				// âš ï¸ CRÃTICO: Se IA nÃ£o encontrou resultado, PARAR AQUI (nÃ£o executar anÃ¡lise padrÃ£o)
				console.log('%câ•‘  âš ï¸ MODO DIAMANTE: Nenhum nÃ­vel liberou sinal neste giro  â•‘', 'color: #FFAA00; font-weight: bold;');
				console.log('%câ•‘  PossÃ­veis motivos:                                       â•‘', 'color: #FFAA00; font-weight: bold;');
				console.log('%câ•‘    â€¢ Barreira final (N9) bloqueou a entrada               â•‘', 'color: #FFAA00;');
				console.log('%câ•‘    â€¢ Falta de consenso entre os nÃ­veis                    â•‘', 'color: #FFAA00;');
				console.log('%câ•‘    â€¢ Todos os nÃ­veis reportaram NULO                      â•‘', 'color: #FFAA00;');
				console.log('%câ•‘  â³ Aguardando prÃ³ximo giro para nova tentativa...        â•‘', 'color: #FFAA00; font-weight: bold;');
				console.log('%câ•‘  ğŸš« AnÃ¡lise padrÃ£o BLOQUEADA (modo Diamante permanece)    â•‘', 'color: #FFAA00; font-weight: bold;');
				sendAnalysisStatus('â³ IA aguardando novo giro...');
				
				// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
				displaySystemFooter();
				
				return; // âœ… PARAR AQUI - NÃƒO executar anÃ¡lise padrÃ£o quando modo IA estÃ¡ ativo
			}
		}

		// 2) Descoberta: 173+ anÃ¡lises e persistÃªncia (sem repetir o que jÃ¡ temos)
		// âš ï¸ SÃ“ EXECUTA SE MODO IA NÃƒO ESTIVER ATIVO
		const timeLeftAfterVerify = budgetMs - (Date.now() - startTs);
		if (!analyzerConfig.aiMode && timeLeftAfterVerify > 100) {
			sendAnalysisStatus('ğŸ§  Descobrindo novos padrÃµes...');
			await discoverAndPersistPatterns(history, startTs, budgetMs);
		}

		// 3) Se verificaÃ§Ã£o nÃ£o deu sinal E modo IA nÃ£o ativo, usar anÃ¡lise existente como fallback
		const timeLeftForFallback = budgetMs - (Date.now() - startTs);
		if (!verifyResult && !analyzerConfig.aiMode && timeLeftForFallback > 200) {
			console.log('â•‘  ğŸ“Š EXECUTANDO: ANÃLISE PADRÃƒO (DESCOBERTA)              â•‘');
			console.log('â•‘  âœ… PadrÃµes salvos: NÃ£o encontrado                       â•‘');
			console.log('â•‘  ğŸ”„ Buscando padrÃ£o atual em 173+ anÃ¡lises...            â•‘');
			
			sendAnalysisStatus('ğŸ¤– Buscando padrÃ£o atual...');
			const analysis = await performPatternAnalysis(history);
			if (analysis) {
				// âš ï¸ CRÃTICO: VERIFICAR SE HÃ MARTINGALE ATIVO
				const forcedColor = martingaleState.currentColor || martingaleState.entryColor;
				if (martingaleState.active && forcedColor) {
					console.log('â•‘  ğŸ”„ MARTINGALE ATIVO DETECTADO! (DESCOBERTA)             â•‘');
					console.log(`â•‘  Cor do novo padrÃ£o: ${analysis.color}                           â•‘`);
					console.log(`â•‘  Cor atual do ciclo: ${forcedColor}                    â•‘`);
					console.log(`â•‘  EstÃ¡gio atual: ${martingaleState.stage}                              â•‘`);
					console.log('â•‘  âœ… SOBRESCREVENDO COR PARA MANTER ENTRADA ORIGINAL      â•‘');
					
					// âœ… SOBRESCREVER A COR PARA USAR A COR ATUAL DO CICLO
					analysis.color = forcedColor;
					analysis.phase = martingaleState.stage;
					// âœ… NÃ£o sobrescrever a confianÃ§a exibida do sinal; guardar apenas a confianÃ§a condicional do GALE (interno)
					analysis.galeConfidence = calculateGaleConfidenceValue(analysis.confidence, analysis);
				}
				
				console.log('â•‘  ğŸ’¾ SALVANDO ANÃLISE EM CHROME.STORAGE.LOCAL (DESCOBERTA)â•‘');
				console.log('ğŸ“Š Dados da anÃ¡lise:');
				console.log('   Cor:', analysis.color);
				console.log('   ConfianÃ§a:', analysis.confidence);
				console.log('   Fase:', analysis.phase || 'G0');
				console.log('   CreatedOn:', analysis.createdOnTimestamp);
				console.log('   PredictedFor:', analysis.predictedFor);
				
				await chrome.storage.local.set({
					analysis: analysis,
					pattern: { description: analysis.patternDescription, confidence: analysis.confidence },
					lastBet: { status: 'pending', phase: analysis.phase || 'G0', createdOnTimestamp: analysis.createdOnTimestamp }
				});
				
				console.log('âœ… AnÃ¡lise salva em chrome.storage.local!');
				
				// âœ… ENVIAR SINAIS PARA AMBOS OS CANAIS (INDEPENDENTES)
				const sendResults = {
					extensao: false,
					telegram: false
				};
				
				// 1. Enviar para extensÃ£o (UI)
				// âœ… Premium (Modo PadrÃ£o): emitir como 'standard' (nÃ£o como 'diamond')
				try {
					sendResults.extensao = await emitAnalysisToContent(analysis, 'standard');
				} catch (e) {
					console.error('âŒ Erro crÃ­tico ao enviar para extensÃ£o:', e);
				}
				
				// 2. Enviar para Telegram (INDEPENDENTE)
				try {
					if (history && history.length > 0 && !(analysis && analysis.hiddenInternal)) {
						// âœ… NÃ£o bloquear o sinal por IO externo (Telegram pode demorar)
						detachPromise(
							sendTelegramEntrySignal(analysis.color, history[0], analysis.confidence, analysis),
							'telegram-entry-signal'
						);
						sendResults.telegram = true; // queued
					}
				} catch (e) {
					console.error('âŒ Erro crÃ­tico ao enviar para Telegram:', e);
				}
				
				// 3. Log de resultado consolidado
				console.log('â•‘  ğŸ“Š RESULTADO DO ENVIO DE SINAIS                          â•‘');
				console.log('â•‘  ğŸ“Š Sistema usado: ANÃLISE PADRÃƒO (DESCOBERTA)            â•‘');
				console.log(`â•‘  ğŸ“± ExtensÃ£o: ${sendResults.extensao ? 'âœ… ENVIADO' : 'âŒ FALHOU'.padEnd(11)}                        â•‘`);
				console.log(`â•‘  ğŸ“² Telegram: ${sendResults.telegram ? 'âœ… ENVIADO' : 'âŒ FALHOU'.padEnd(11)}                        â•‘`);
				
				// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
				displaySystemFooter();
			} else {
				console.log('%câ•‘  âš ï¸ NENHUM SINAL ENCONTRADO NESTE GIRO                   â•‘', 'color: #FFAA00; font-weight: bold;');
				console.log('%câ•‘  ğŸ“Š Modo ativo:', 'color: #FFAA00;', analyzerConfig.aiMode ? 'DIAMANTE' : 'PADRÃƒO');
				console.log('%câ•‘  ğŸ“Š Verificou banco de padrÃµes?', 'color: #FFAA00;', verifyResult ? 'SIM (nÃ£o encontrou)' : 'NÃƒO');
				console.log('%câ•‘  ğŸ“Š Executou anÃ¡lise avanÃ§ada?', 'color: #FFAA00;', analyzerConfig.aiMode ? 'SIM' : 'NÃƒO');
				console.log('%câ•‘  âœ… Aguardando prÃ³ximo giro...                           â•‘', 'color: #00FF88;');
				
				await chrome.storage.local.set({ analysis: null, pattern: null });
				sendMessageToContent('CLEAR_ANALYSIS');
				sendAnalysisStatus('â³ Aguardando novo giro...');
				
				// âœ… EXIBIR RODAPÃ‰ FIXO COM SISTEMA ATIVO
				displaySystemFooter();
			
			// âœ… LOG RESUMIDO DO CICLO
			logAnalysisCycle({
				serverStatus: 'ativo',
				patternsFound: [],
				searchingNewSpin: true,
				rejectedPatterns: [],
				telegramSent: null,
				displayedPatternsCount: 0,
				spinsAvailable: { server: history.length, app: cachedHistory.length }
			});
			}
		} else {
			console.log('%câŒ [DEBUG] NÃƒO ENTROU NO if (analyzerConfig.aiMode && !verifyResult)!', 'color: #FF0000; font-weight: bold;');
			console.log('   Motivo: analyzerConfig.aiMode =', analyzerConfig.aiMode, ' | verifyResult =', verifyResult ? 'ENCONTROU' : 'null/false');
		}
	} catch (e) {
		console.error('');
		console.error('%câŒ ERRO NO CONTROLADOR DE ANÃLISE!', 'color: #FF0000; font-weight: bold; font-size: 16px;');
		console.error('Detalhes do erro:', e);
		console.error('Stack:', e.stack);
		console.error('');
	}
}

// FunÃ§Ã£o helper para exibir estatÃ­sticas do banco de padrÃµes
function logPatternDBStats(db, action = 'load') {
	const total = db.patterns_found ? db.patterns_found.length : 0;
	const limit = 5000;
	const percentage = total > 0 ? ((total / limit) * 100).toFixed(1) : 0;
	
	// Agrupar por tipo
	const byType = {};
	const byConfidence = { high: 0, medium: 0, low: 0 };
	
	if (db.patterns_found) {
		db.patterns_found.forEach(p => {
			const type = p.type || 'desconhecido';
			byType[type] = (byType[type] || 0) + 1;
			
			const conf = p.confidence || 0;
			if (conf >= 80) byConfidence.high++;
			else if (conf >= 60) byConfidence.medium++;
			else byConfidence.low++;
		});
	}
	
	const emoji = action === 'load' ? 'ğŸ“‚' : action === 'save' ? 'ğŸ’¾' : 'ğŸ”';
	const actionText = action === 'load' ? 'CARREGADO' : action === 'save' ? 'SALVO' : 'DESCOBERTA';
	
	console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ${emoji} BANCO DE PADRÃ•ES ${actionText}                              
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“Š TOTAL DE PADRÃ•ES: ${total.toString().padEnd(4)} / ${limit} (${percentage}%)          
â•‘  âš¡ Capacidade: ${'â–ˆ'.repeat(Math.floor(percentage / 5))}${'â–‘'.repeat(20 - Math.floor(percentage / 5))}
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ¯ POR CONFIANÃ‡A:                                        
â•‘     â”œâ”€ ğŸŸ¢ Alta (â‰¥80%):   ${byConfidence.high.toString().padEnd(4)} padrÃµes
â•‘     â”œâ”€ ğŸŸ¡ MÃ©dia (60-79%): ${byConfidence.medium.toString().padEnd(4)} padrÃµes
â•‘     â””â”€ ğŸ”´ Baixa (<60%):   ${byConfidence.low.toString().padEnd(4)} padrÃµes
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“ POR TIPO:                                             
${Object.entries(byType).slice(0, 10).map(([type, count]) => 
`â•‘     â€¢ ${type.padEnd(20)}: ${count.toString().padEnd(4)} padrÃµes`).join('\n')}
${Object.keys(byType).length > 10 ? `â•‘     â€¢ ... e mais ${Object.keys(byType).length - 10} tipos` : ''}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	`.trim());
}

// Carrega o banco de padrÃµes salvos
// âœ… Cache em memÃ³ria: evita chrome.storage.get a cada giro (hot-path do sinal)
let __patternDBCache = null;
let __patternDBCacheAt = 0;
async function loadPatternDB(silent = false) {
	// Cache simples (o banco sÃ³ muda via savePatternDB/clearAllPatterns nesta sessÃ£o)
	if (__patternDBCache && __patternDBCache.patterns_found) {
		return __patternDBCache;
	}
	const res = await chrome.storage.local.get(['patternDB']);
	const db = res.patternDB && Array.isArray(res.patternDB.patterns_found)
		? res.patternDB
		: { patterns_found: [], version: 1 };
	
	// ğŸ”¥ LIMPEZA: Remover padrÃµes com trigger invÃ¡lida do banco
	// âœ… Respeitar config do usuÃ¡rio: sÃ³ limpar triggers invÃ¡lidas quando "Exigir cor de disparo" estiver ATIVO.
	const requireTrigger = !!(analyzerConfig && analyzerConfig.requireTrigger);
	if (requireTrigger && db.patterns_found && db.patterns_found.length > 0) {
		const beforeCount = db.patterns_found.length;
		db.patterns_found = db.patterns_found.filter(pat => {
			// Se nÃ£o tem padrÃ£o ou trigger, manter (serÃ¡ validado depois)
			if (!Array.isArray(pat.pattern) || pat.pattern.length === 0 || !pat.triggerColor) {
				return true;
			}
			
			// Validar trigger
			const firstColorNorm = normalizeColorName(getInitialPatternColor(pat.pattern));
			const triggerNorm = normalizeColorName(pat.triggerColor);
			const validation = validateDisparoColor(firstColorNorm, triggerNorm);
			
			if (!validation.valid) {
				console.log(`ğŸ—‘ï¸ Removendo padrÃ£o invÃ¡lido do banco:`, {
					pattern: pat.pattern.join('-'),
					firstColor: firstColorNorm,
					trigger: triggerNorm,
					reason: validation.reason
				});
				return false; // âŒ Remover do banco
			}
			
			return true; // âœ… Manter no banco
		});
		
		const removedCount = beforeCount - db.patterns_found.length;
		if (removedCount > 0) {
			console.log(`ğŸ§¹ Limpeza do banco: ${removedCount} padrÃ£o(Ãµes) invÃ¡lido(s) removido(s)`);
			// Salvar banco limpo
			await savePatternDB(db);
		}
	}
	
	// âœ… Log visual das estatÃ­sticas (DESABILITAR durante busca ativa para performance)
	if (!silent && !initialSearchActive) {
		logPatternDBStats(db, 'load');
	}

	// Persistir no cache em memÃ³ria
	__patternDBCache = db;
	__patternDBCacheAt = Date.now();
	return db;
}

// Salva o banco de padrÃµes (APENAS LOCALMENTE)
async function savePatternDB(db) {
	// Atualizar cache em memÃ³ria imediatamente
	__patternDBCache = db;
	__patternDBCacheAt = Date.now();

	// Salvar APENAS localmente (nÃ£o envia para servidor)
	await chrome.storage.local.set({ patternDB: db });
	
	// Log visual das estatÃ­sticas
	logPatternDBStats(db, 'save');
	
	// Notificar content script para atualizar UI
	sendMessageToContent('PATTERN_BANK_UPDATE', { total: db.patterns_found ? db.patterns_found.length : 0 });
}

// Limpa APENAS padrÃµes (usado ao abrir extensÃ£o - preserva anÃ¡lise pendente)
async function clearAllPatterns() {
	console.log('â•‘  ğŸ—‘ï¸ LIMPANDO BANCO DE PADRÃ•ES                            â•‘');
	
	// 1. Limpar banco de padrÃµes
	console.log('ğŸ—‘ï¸ Limpando banco de padrÃµes...');
	const emptyDB = { patterns_found: [], version: 1 };
	await chrome.storage.local.set({ patternDB: emptyDB });
	// âœ… Cache em memÃ³ria: invalidar imediatamente (evita usar padrÃµes antigos no hot-path)
	try { __patternDBCache = emptyDB; __patternDBCacheAt = Date.now(); } catch (_) {}
	
	// 2. âœ… NÃƒO LIMPAR anÃ¡lise pendente (ela deve persistir se estiver aguardando resultado)
	// A anÃ¡lise sÃ³ deve ser limpa quando:
	// - O resultado for confirmado (WIN/LOSS)
	// - O usuÃ¡rio clicar explicitamente em "Resetar PadrÃµes"
	console.log('â•‘  âœ… ANÃLISE PENDENTE PRESERVADA                          â•‘');
	console.log('â•‘  (Aguardando resultado - nÃ£o serÃ¡ limpa)                 â•‘');
	
	// 3. âœ… NÃƒO LIMPAR histÃ³rico de entradas (deve persistir apÃ³s reload)
	// Se o usuÃ¡rio quiser limpar entradas, deve usar o botÃ£o "Limpar HistÃ³rico" na interface
	console.log('â•‘  âœ… HISTÃ“RICO DE ENTRADAS PRESERVADO                    â•‘');
	console.log('â•‘  (NÃ£o serÃ¡ limpo - persiste apÃ³s recarregar pÃ¡gina)     â•‘');
	console.log('â•‘  Para limpar: use botÃ£o "Limpar HistÃ³rico" na UI        â•‘');
	
	// 4. âœ… NÃƒO RESETAR calibrador de porcentagens (ele Ã© sincronizado automaticamente com entriesHistory)
	// O calibrador Ã© persistente e serÃ¡ reconstruÃ­do pela sincronizaÃ§Ã£o em loadObserverDataAtStartup()
	console.log('â•‘  âœ… CALIBRADOR DE PORCENTAGENS PRESERVADO                â•‘');
	console.log('â•‘  (Sincronizado automaticamente com entriesHistory)       â•‘');
	
	// 5. âœ… NÃƒO enviar mensagens aqui - deixar para o fluxo de busca controlar
	// O `startPatternSearch` enviarÃ¡ as mensagens apropriadas
	
	console.log('â•‘  âœ… RESET PARCIAL - PADRÃ•ES ZERADOS                      â•‘');
	console.log('â•‘  ğŸ“Š PadrÃµes: Limpos (serÃ£o recalculados)                  â•‘');
	console.log('â•‘  ğŸ¯ AnÃ¡lise Pendente: Preservada                          â•‘');
	console.log('â•‘  ğŸ“ˆ Entradas: Preservadas                                 â•‘');
	console.log('â•‘  Calibrador: Preservado (sincronizado)                    â•‘');
	console.log('â•‘  ğŸ’¾ Cache: SerÃ¡ recarregado do servidor                   â•‘');
}

// Limpa TUDO: padrÃµes E anÃ¡lise pendente (usado quando o usuÃ¡rio clica em "Resetar PadrÃµes")
async function clearAllPatternsAndAnalysis() {
	console.log('â•‘  ğŸ—‘ï¸ RESET COMPLETO - LIMPANDO TUDO                       â•‘');
	
	// 1. Limpar banco de padrÃµes
	console.log('ğŸ—‘ï¸ Limpando banco de padrÃµes...');
	const emptyDB = { patterns_found: [], version: 1 };
	await chrome.storage.local.set({ patternDB: emptyDB });
	// âœ… Cache em memÃ³ria: invalidar imediatamente (evita usar padrÃµes antigos no hot-path)
	try { __patternDBCache = emptyDB; __patternDBCacheAt = Date.now(); } catch (_) {}
	
	// 2. âœ… LIMPAR anÃ¡lise e padrÃ£o atual (incluindo anÃ¡lise pendente)
	console.log('ğŸ—‘ï¸ Limpando anÃ¡lise pendente e padrÃ£o atual...');
	await chrome.storage.local.set({ 
		analysis: null, 
		pattern: null,
		lastBet: null
	});
	
	// 3. Enviar atualizaÃ§Ãµes para UI
	sendMessageToContent('PATTERN_BANK_UPDATE', { total: 0 });
	sendMessageToContent('CLEAR_ANALYSIS');
	sendAnalysisStatus('ğŸ”„ Reset completo - Aguardando nova anÃ¡lise...');
	await setPatternDiscoveryCutoffFlag(Date.now());
	
	console.log('â•‘  âœ… RESET COMPLETO - TUDO ZERADO                         â•‘');
	console.log('â•‘  ğŸ“Š PadrÃµes: Limpos                                       â•‘');
	console.log('â•‘  ğŸ¯ AnÃ¡lise Pendente: Limpa                               â•‘');
	console.log('â•‘  ğŸ“ˆ Entradas: Preservadas                                 â•‘');
	console.log('â•‘  Calibrador: Preservado                                   â•‘');
}

// Busca de padrÃµes (Banco de PadrÃµes): deve encerrar quando completar a varredura (tempo Ã© sÃ³ fail-safe)
let initialSearchActive = false;
let initialSearchInterval = null;
let initialSearchRunnerBusy = false;
let initialSearchTasksState = null; // { tasks, nextIdx, totalTasks, startedAt, historyLen }

async function startInitialPatternSearch(history) {
	if (!history || history.length < 50) {
		console.log('âš ï¸ HistÃ³rico insuficiente para busca inicial (<50 giros). Aguardando...');
		return;
	}
	
	if (initialSearchActive) {
		console.log('âš ï¸ Busca inicial jÃ¡ estÃ¡ em andamento.');
		return;
	}
	
	initialSearchActive = true;

	const startedAt = Date.now();
	initialSearchTasksState = {
		tasks: buildPatternDiscoveryTasks(),
		nextIdx: 0,
		totalTasks: 0,
		startedAt,
		historyLen: Array.isArray(history) ? history.length : 0
	};
	initialSearchTasksState.totalTasks = initialSearchTasksState.tasks.length;

	console.log('%cğŸ” Busca de padrÃµes iniciada | varredura | ' + initialSearchTasksState.historyLen + ' giros', 'color: #00D4FF; font-weight: bold; background: #002244; padding: 4px 8px; border-radius: 4px;');

	sendMessageToContent('INITIAL_SEARCH_START', {
		progress01: 0,
		processedTasks: 0,
		totalTasks: initialSearchTasksState.totalTasks
	});

	// Rodar em background atÃ© completar a varredura (sem depender de 30s).
	if (!initialSearchRunnerBusy) {
		initialSearchRunnerBusy = true;
		runInitialPatternSearchLoop(history).finally(() => { initialSearchRunnerBusy = false; });
	}
}

// Para a busca inicial (se necessÃ¡rio)
function stopInitialPatternSearch() {
	if (initialSearchInterval) {
		clearInterval(initialSearchInterval);
		initialSearchActive = false;
		console.log('%câ¸ï¸ Busca interrompida', 'color: #FF9900; font-weight: bold;');
	}
	initialSearchActive = false;
	initialSearchTasksState = null;
}

function buildPatternDiscoveryTasks() {
	const tasks = [];
	// âœ… Respeitar tamanhos configurados pelo usuÃ¡rio no Premium (com teto de seguranÃ§a p/ performance)
	const HARD_MAX_COLOR_PATTERN_SIZE = 20;
	const minSizeCfg = clampInt(
		analyzerConfig?.minPatternSize ?? DEFAULT_ANALYZER_CONFIG.minPatternSize,
		2,
		HARD_MAX_COLOR_PATTERN_SIZE
	);
	const rawMaxSizeCfg = Number(analyzerConfig?.maxPatternSize ?? DEFAULT_ANALYZER_CONFIG.maxPatternSize);
	const maxSizeCfg = Number.isFinite(rawMaxSizeCfg) ? Math.floor(rawMaxSizeCfg) : 0;
	const maxSizeEffective = maxSizeCfg > 0
		? clampInt(maxSizeCfg, minSizeCfg, HARD_MAX_COLOR_PATTERN_SIZE)
		: HARD_MAX_COLOR_PATTERN_SIZE;

	for (let size = minSizeCfg; size <= maxSizeEffective; size++) {
		for (let offset = 0; offset < 10; offset++) {
			tasks.push({ kind: 'color-window', size, offset });
		}
	}
	for (let len = 3; len <= 8; len++) {
		for (let offset = 0; offset < 5; offset++) {
			tasks.push({ kind: 'number-correlation-lite', len, offset });
		}
	}
	tasks.push({ kind: 'white-intervals' });
	tasks.push({ kind: 'night-white' });
	tasks.push({ kind: 'time-repetition' });
	tasks.push({ kind: 'temporal-reversal' });
	tasks.push({ kind: 'white-break' });
	tasks.push({ kind: 'white-after-dominance' });
	tasks.push({ kind: 'complete-cycle' });
	tasks.push({ kind: 'post-white-peak' });
	tasks.push({ kind: 'post-white-recovery' });
	tasks.push({ kind: 'total-correction' });
	tasks.push({ kind: 'microcycle' });
	tasks.push({ kind: 'night-stability' });
	tasks.push({ kind: 'day-oscillation' });
	return tasks;
}

async function discoverAndPersistPatternsBatch(history, tasks, startIdx, startTs, budgetMs) {
	if (patternDiscoveryCutoff) {
		history = filterHistoryByResetCutoff(history);
	}
	if (!history || history.length < 50) {
		return { nextIdx: startIdx, totalPatterns: 0, added: 0 };
	}
	const requireTrigger = !!(analyzerConfig && analyzerConfig.requireTrigger);
	const db = await loadPatternDB(true);
	const existingKeys = new Set((db.patterns_found || []).map(patternKeyOf));
	const colors = history.map(s => s.color);
	let discovered = [];
	let idx = startIdx;

	for (; idx < tasks.length; idx++) {
		if ((Date.now() - startTs) > budgetMs) break;
		const t = tasks[idx];
		let results = [];
		if (t.kind === 'color-window') {
			results = discoverColorPatternsFast(colors, t.size, t.offset);
		} else if (t.kind === 'number-correlation-lite') {
			results = discoverNumberCorrelationsFast(history.map(s => s.number), colors, t.len, t.offset);
		} else if (t.kind === 'white-intervals') {
			const pattern = analyzeWhiteIntervals(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'night-white') {
			const pattern = analyzeNightWhitePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'time-repetition') {
			const pattern = analyzeTimeRepetitionPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'temporal-reversal') {
			const pattern = analyzeTemporalReversalPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'white-break') {
			const pattern = analyzeWhiteBreakPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'white-after-dominance') {
			const pattern = analyzeWhiteAfterDominancePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'complete-cycle') {
			const pattern = analyzeCompleteCyclePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'post-white-peak') {
			const pattern = analyzePostWhitePeakPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'post-white-recovery') {
			const pattern = analyzePostWhiteRecoveryPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'total-correction') {
			const pattern = analyzeTotalCorrectionPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'microcycle') {
			const pattern = analyzeMicrocyclePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'night-stability') {
			const pattern = analyzeNightStabilityPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'day-oscillation') {
			const pattern = analyzeDayOscillationPattern(history);
			if (pattern) results = [pattern];
		}

		for (const r of results) {
			if (r.suggestedColor && !r.expected_next) {
				r.expected_next = r.suggestedColor;
			}
			if (typeof r.pattern === 'string' && !Array.isArray(r.pattern)) {
				r.pattern = [r.pattern];
			} else if (!Array.isArray(r.pattern) && Array.isArray(r.patternArr)) {
				r.pattern = r.patternArr;
			} else if (!Array.isArray(r.pattern)) {
				r.pattern = r.pattern ? [String(r.pattern)] : [];
			}
			if (!r.type && r.patternType) {
				r.type = r.patternType;
			}
			const key = patternKeyOf(r);
			if (existingKeys.has(key)) continue;
			existingKeys.add(key);
			discovered.push(r);
		}
	}

	if (discovered.length > 0) {
		const nowIso = new Date().toISOString();
		let idCounter = 0;
		for (const p of discovered) {
			if (!p.id) {
				const timestamp = Date.now();
				const counter = idCounter++;
				const random = Math.floor(Math.random() * 10000);
				p.id = `${timestamp}-${counter}-${random}`;
			}
			p.found_at = p.found_at || nowIso;
			if (!p.expected_next && p.suggestedColor) {
				p.expected_next = p.suggestedColor;
			}
			if (typeof p.confidence !== 'number') {
				p.confidence = 70;
			}
			if (!Array.isArray(p.pattern)) {
				if (Array.isArray(p.patternArr)) p.pattern = p.patternArr;
				else if (typeof p.pattern === 'string') p.pattern = [p.pattern];
				else p.pattern = [];
			}
			if (typeof p.total_wins !== 'number') p.total_wins = 0;
			if (typeof p.total_losses !== 'number') p.total_losses = 0;

			if (requireTrigger && Array.isArray(p.pattern) && p.pattern.length > 0 && p.triggerColor) {
				const firstColorNormalized = normalizeColorName(getInitialPatternColor(p.pattern));
				const triggerNormalized = normalizeColorName(p.triggerColor);
				const triggerValidation = validateDisparoColor(firstColorNormalized, triggerNormalized);
				if (!triggerValidation.valid) {
					continue;
				}
			}

			db.patterns_found.unshift({
				id: p.id,
				pattern: p.pattern,
				expected_next: p.expected_next,
				confidence: p.confidence,
				found_at: p.found_at,
				type: p.type || p.patternType || 'discovery',
				occurrences: p.occurrences || 0,
				triggerColor: p.triggerColor || null,
				total_wins: p.total_wins,
				total_losses: p.total_losses
			});
		}
		db.patterns_found = db.patterns_found.slice(0, 5000);
		await savePatternDB(db);
	}

	const totalPatterns = db.patterns_found ? db.patterns_found.length : 0;
	return { nextIdx: idx, totalPatterns, added: discovered.length };
}

async function runInitialPatternSearchLoop(history) {
	try {
		const MAX_WALL_MS = 180000; // 3min fail-safe (nÃ£o deve bater em uso normal)
		let lastUiSentAt = 0;
		while (initialSearchActive && initialSearchTasksState && initialSearchTasksState.nextIdx < initialSearchTasksState.totalTasks) {
			const now = Date.now();
			const elapsed = now - initialSearchTasksState.startedAt;
			if (elapsed > MAX_WALL_MS) {
				console.warn('âš ï¸ Busca de padrÃµes excedeu o tempo mÃ¡ximo. Encerrando por seguranÃ§a.');
				break;
			}

			const batchStart = Date.now();
			const { nextIdx, totalPatterns } = await discoverAndPersistPatternsBatch(
				history,
				initialSearchTasksState.tasks,
				initialSearchTasksState.nextIdx,
				batchStart,
				900
			);
			initialSearchTasksState.nextIdx = nextIdx;

			const progress01 = initialSearchTasksState.totalTasks > 0
				? Math.min(1, Math.max(0, initialSearchTasksState.nextIdx / initialSearchTasksState.totalTasks))
				: 1;

			// Throttle UI messages
			if ((Date.now() - lastUiSentAt) > 250) {
				lastUiSentAt = Date.now();
				sendMessageToContent('INITIAL_SEARCH_PROGRESS', {
					total: totalPatterns,
					progress01,
					processedTasks: initialSearchTasksState.nextIdx,
					totalTasks: initialSearchTasksState.totalTasks
				});
			}

			// Se atingiu o limite, parar
			if (totalPatterns >= 5000) {
				break;
			}

			// Yield (evita travar o background em loops longos)
			await new Promise(r => setTimeout(r, 0));
		}
	} catch (e) {
		console.error('âŒ Erro na busca de padrÃµes:', e);
	} finally {
		if (initialSearchActive) {
			initialSearchActive = false;
		}
		const db = await loadPatternDB(true);
		const total = db.patterns_found ? db.patterns_found.length : 0;
		sendMessageToContent('INITIAL_SEARCH_COMPLETE', {
			total,
			duration: Date.now() - (initialSearchTasksState && initialSearchTasksState.startedAt ? initialSearchTasksState.startedAt : Date.now())
		});
		initialSearchTasksState = null;
	}
}

// Gera assinatura Ãºnica para evitar duplicidade de padrÃ£o (RIGOROSA)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GERAR CHAVE ÃšNICA PARA PADRÃƒO - REFATORADO 100% (Anti-duplicaÃ§Ã£o)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function patternKeyOf(p) {
	// âœ… VALIDAÃ‡ÃƒO DE ENTRADA
	if (!p || typeof p !== 'object') {
		console.warn('âš ï¸ PadrÃ£o invÃ¡lido para geraÃ§Ã£o de chave:', p);
		return 'invalid-pattern';
	}
	
	// âœ… NORMALIZAR PADRÃƒO (string â†’ array para consistÃªncia)
	let normalizedPattern;
	if (Array.isArray(p.pattern)) {
		normalizedPattern = p.pattern;
	} else if (typeof p.pattern === 'string') {
		// âœ… Converter string para array de 1 elemento
		normalizedPattern = [p.pattern];
	} else {
		console.warn('âš ï¸ Formato de padrÃ£o desconhecido:', p.pattern);
		normalizedPattern = [];
	}
	
	// âœ… GERAR STRING DO PADRÃƒO
	const core = normalizedPattern.join('-');
	
	// âœ… EXTRAIR TIPO
	const type = p.type || p.patternType || 'generic';
	
	// âœ… EXTRAIR PRÃ“XIMA COR ESPERADA
	const expect = p.expected_next || p.suggestedColor || '';
	
	// âœ… CALCULAR TAMANHO REAL DO PADRÃƒO
	const size = normalizedPattern.length;
	
	// âœ… ASSINATURA ÃšNICA: tipo + tamanho + sequÃªncia + prÃ³xima cor
	// âš ï¸ NÃƒO incluir triggerColor (pode variar entre ocorrÃªncias)
	const uniqueKey = `${type}|s:${size}|p:${core}|e:${expect}`;
	
	return uniqueKey;
}

// Verifica se padrÃ£o jÃ¡ existe no banco (por assinatura)
function isDuplicatePattern(newPattern, existingPatterns) {
	const newKey = patternKeyOf(newPattern);
	return existingPatterns.some(p => patternKeyOf(p) === newKey);
}

// VerificaÃ§Ã£o: compara head do histÃ³rico com padrÃµes salvos e retorna melhor sinal
// âœ… Aceita db opcional para simulaÃ§Ãµes/otimizaÃ§Ãµes (evita loadPatternDB a cada giro)
// âœ… Premium: manter o algoritmo LEGACY como padrÃ£o (idÃªntico ao comportamento anterior),
// porque o modo FAST pode alterar confianÃ§a/seleÃ§Ã£o em alguns cenÃ¡rios.
async function verifyWithSavedPatterns(history, dbOverride = null) {
	return verifyWithSavedPatternsLegacy(history, dbOverride);
}

// FAST (tempo real) â€” opcional (nÃ£o usado por padrÃ£o)
async function verifyWithSavedPatternsFast(history, dbOverride = null) {
	try {
		if (!history || !Array.isArray(history) || history.length < 3) return null;

		// Banco de padrÃµes (cache em memÃ³ria via loadPatternDB)
		const db = dbOverride || await loadPatternDB(true);
		const patterns = db && Array.isArray(db.patterns_found) ? db.patterns_found : [];
		if (!patterns.length) return null;

		const requireTrigger = !!(analyzerConfig && analyzerConfig.requireTrigger);
		const minPatternSizeGate = clampInt(
			analyzerConfig?.minPatternSize ?? DEFAULT_ANALYZER_CONFIG.minPatternSize,
			2,
			50
		);
		const minWinsGate = Math.max(analyzerConfig?.minOccurrences || 1, 1);
		const winPercentOthersThreshold = Number(analyzerConfig?.winPercentOthers || 0) || 0;

		const createdOnTimestamp = (history[0] && (history[0].created_at ?? history[0].timestamp)) || new Date().toISOString();

		let best = null;
		let bestOcc = -1;
		let bestWins = -1;

		for (const pat of patterns) {
			if (!pat || !Array.isArray(pat.pattern) || pat.pattern.length === 0) continue;
			const need = pat.pattern.length;
			if (need < minPatternSizeGate) continue;
			if (history.length < need) continue;

			// Match do HEAD sem slice/map (zero alocaÃ§Ã£o)
			let headMatch = true;
			for (let j = 0; j < need; j++) {
				const c = history[j] ? history[j].color : null;
				if (c !== pat.pattern[j]) { headMatch = false; break; }
			}
			if (!headMatch) continue;

			let suggested = pat.expected_next || pat.suggestedColor;
			if (!suggested) continue;
			suggested = normalizeColorName(suggested) || suggested;

			// Cor de disparo atual (antes do padrÃ£o head)
			const currentTrigger = (history[need] && history[need].color) ? history[need].color : null;
			const currentTriggerNorm = normalizeColorName(currentTrigger);
			const firstPatternNorm = normalizeColorName(getInitialPatternColor(pat.pattern));
			if (!firstPatternNorm) continue;

			if (requireTrigger) {
				if (!currentTriggerNorm) continue;
				const validation = validateDisparoColor(firstPatternNorm, currentTriggerNorm);
				if (!validation.valid) continue;
			}

			// EstatÃ­sticas prÃ©-computadas do banco (evita varrer 10k giros no hot-path)
			const wins = Number.isFinite(Number(pat.total_wins)) ? Number(pat.total_wins) : 0;
			const losses = Number.isFinite(Number(pat.total_losses)) ? Number(pat.total_losses) : 0;
			const total = wins + losses;
			const occ = Math.max(Number(pat.occurrences) || total || 0, 0);
			const balance = total > 0 ? (wins - losses) : null;
			const winPct = total > 0 ? (wins / total) * 100 : null;

			if (total > 0 && wins < minWinsGate) continue;
			if (total > 0 && balance !== null && balance <= 0) continue;

			// Gate por WIN% (aproximaÃ§Ã£o robusta pelo winPct global do padrÃ£o)
			if (winPercentOthersThreshold > 0) {
				if (winPct !== null) {
					if (winPct < winPercentOthersThreshold) continue;
				} else {
					const rawFallback = typeof pat.confidence === 'number' ? pat.confidence : 0;
					if (rawFallback < winPercentOthersThreshold) continue;
				}
			}

			const patternName = identifyPatternType(pat.pattern, null);
			const rawPatternConfidence = typeof pat.confidence === 'number' ? pat.confidence : 70;
			const patternConfidence = applyCalibratedConfidence(rawPatternConfidence);

			const patternDesc = {
				colorAnalysis: {
					pattern: pat.pattern,
					occurrences: occ,
					patternType: patternName,
					triggerColor: currentTrigger || null,
					summary: {
						occurrences: occ,
						wins,
						losses,
						winPct,
						lossPct: (winPct !== null) ? Math.max(0, 100 - winPct) : null,
						balance,
						sampleMin: minWinsGate,
						patternLength: need
					}
				},
				patternType: patternName,
				expected_next: suggested,
				id: pat.id,
				found_at: pat.found_at
			};

			const candidate = {
				color: suggested,
				suggestion: 'PadrÃ£o salvo',
				confidence: patternConfidence,
				patternDescription: JSON.stringify(patternDesc),
				createdOnTimestamp,
				predictedFor: 'next',
				phase: 'G0'
			};

			if (
				!best ||
				(candidate.confidence > best.confidence) ||
				(candidate.confidence === best.confidence && occ > bestOcc) ||
				(candidate.confidence === best.confidence && occ === bestOcc && wins > bestWins)
			) {
				best = candidate;
				bestOcc = occ;
				bestWins = wins;
			}
		}

		return best;
	} catch (e) {
		console.warn('âš ï¸ verifyWithSavedPatterns(fast) falhou - retornando null:', e && e.message ? e.message : e);
		return null;
	}
}

// Legacy (mantido para auditoria / comparaÃ§Ãµes)
async function verifyWithSavedPatternsLegacy(history, dbOverride = null) {
	if (!history || history.length < 3) return null;
	const db = dbOverride || await loadPatternDB();
	if (!db.patterns_found || db.patterns_found.length === 0) return null;

	const headColors = history.map(s => s.color);
	const maxTrackedStage = MAX_GALE_STAGE_TRACKED;
	// âœ… Config do usuÃ¡rio (Modo Premium): respeitar "Exigir cor de disparo" e tamanho mÃ­nimo configurado
	const requireTrigger = !!(analyzerConfig && analyzerConfig.requireTrigger);
	const minPatternSizeGate = clampInt(
		analyzerConfig?.minPatternSize ?? DEFAULT_ANALYZER_CONFIG.minPatternSize,
		2,
		50
	);
	let best = null;
	for (const pat of db.patterns_found) {
		const galeStageTotals = Array(maxTrackedStage + 1).fill(0);
		const galeStageWins = Array(maxTrackedStage + 1).fill(0);
		const galeStageLosses = Array(maxTrackedStage + 1).fill(0);
		const galeCoverageAvailable = Array(maxTrackedStage + 1).fill(0);
		const galeSuccessCumulative = Array(maxTrackedStage + 1).fill(0);
		if (!Array.isArray(pat.pattern) || pat.pattern.length === 0) continue;
		const need = pat.pattern.length;
		// âœ… Respeitar o tamanho mÃ­nimo configurado pelo usuÃ¡rio (evita hardcode 3)
		if (need < minPatternSizeGate) continue;
		if (headColors.length < need) continue;
		const currentSeq = headColors.slice(0, need);
		const isMatch = currentSeq.every((c, i) => c === pat.pattern[i]);
		if (!isMatch) continue;
		let suggested = pat.expected_next || pat.suggestedColor; // âœ… Mudado para 'let' para permitir reatribuiÃ§Ã£o
		if (!suggested) continue;

	// Obter cor de disparo atual (serÃ¡ usada depois para referÃªncia)
		const currentTrigger = headColors[need]; // cor imediatamente anterior ao padrÃ£o no histÃ³rico
	
	const currentTriggerNormalized = normalizeColorName(currentTrigger);
	const firstPatternNormalized = normalizeColorName(getInitialPatternColor(pat.pattern));

	if (!firstPatternNormalized) {
		console.warn('âš ï¸ PadrÃ£o salvo com cor inicial invÃ¡lida (nÃ£o conseguiu normalizar):', pat.pattern);
		continue;
	}

	// âœ… Se o usuÃ¡rio desativar "Exigir cor de disparo", NÃƒO bloquear o padrÃ£o por trigger.
	if (requireTrigger) {
		if (!currentTriggerNormalized) {
			console.log('âŒ PadrÃ£o salvo rejeitado: sem cor de disparo atual disponÃ­vel', {
				pattern: pat.pattern,
				firstPatternColor: getInitialPatternColor(pat.pattern)
			});
			continue;
		}
		const validation = validateDisparoColor(firstPatternNormalized, currentTriggerNormalized);
		if (!validation.valid) {
			console.log('âŒ PadrÃ£o salvo rejeitado: cor de disparo atual invÃ¡lida', {
					pattern: pat.pattern,
					currentTrigger: currentTrigger,
				currentTriggerNormalized,
				firstPatternColor: getInitialPatternColor(pat.pattern),
				firstPatternNormalized,
				motivo: validation.reason || 'Cor de disparo igual ou invÃ¡lida'
			});
			continue;
		}
	}
		// NÃƒO exigir que a trigger seja igual Ã  salva; triggers podem variar por ocorrÃªncia

		// Reconstruir ocorrÃªncias com nÃºmeros e horÃ¡rios a partir do histÃ³rico
	// âœ… APLICAR PROFUNDIDADE DE ANÃLISE CONFIGURADA PELO USUÃRIO
	const configuredDepth = clampInt(
		analyzerConfig.historyDepth ?? DEFAULT_ANALYZER_CONFIG.historyDepth,
		50,
		REALTIME_HISTORY_CAP
	);
	const searchDepth = Math.min(configuredDepth, history.length);
	const minIntervalSpins = analyzerConfig.minIntervalSpins || 0;
	
		const occNumbers = [];
		const occTimestamps = [];
		const trigNumbers = [];
		const trigTimestamps = [];
	const occurrenceDetails = [];
		let occCount = 0;
		let lastAcceptedIndexForDetails = null;
	for (let i = need; i < searchDepth; i++) {
			const seq = history.slice(i, i + need);
			if (seq.length < need) break;
			const seqColors = seq.map(s => s.color);
			const match = seqColors.every((c, idx) => c === pat.pattern[idx]);
			if (match) {
			// â±ï¸ INTERVALO ENTRE PADRÃ•ES (ocorrÃªncias detalhadas do MESMO padrÃ£o)
			if (minIntervalSpins > 0 && lastAcceptedIndexForDetails !== null) {
				const diff = i - lastAcceptedIndexForDetails;
				if (diff < minIntervalSpins) {
					continue; // ocorrÃªncia muito prÃ³xima da Ãºltima deste padrÃ£o
				}
			}
			
			const trigSpin = history[i + need];
			const trigColorRaw = trigSpin ? trigSpin.color : null;
			
			const trigNormalized = normalizeColorName(trigColorRaw);
			let triggerValid = true;
			// âœ… Respeitar "Exigir cor de disparo": se desativado, nÃ£o validar disparo aqui.
			if (requireTrigger) {
				if (!trigNormalized) {
					triggerValid = false;
				} else {
					triggerValid = validateDisparoColor(firstPatternNormalized, trigNormalized).valid;
				}
			}
			if (!triggerValid) continue;

			const resultColor = history[i - 1] ? history[i - 1].color : null;
			const occurrenceRecord = createOccurrenceRecord(pat.pattern, trigColorRaw, resultColor, seq, trigSpin, occCount + 1);
			occurrenceRecord.gale_results = evaluateGaleStagesForOccurrence(history, i, suggested, maxTrackedStage);

			if (occurrenceRecord.flag_invalid_disparo) {
				continue;
			}

				occCount++;
				occNumbers.push(seq.map(s => s.number));
				occTimestamps.push(seq.map(s => s.timestamp));
				trigNumbers.push(trigSpin ? trigSpin.number : null);
				trigTimestamps.push(trigSpin ? trigSpin.timestamp : null);
			occurrenceDetails.push(occurrenceRecord);
			lastAcceptedIndexForDetails = i;
			}
		}

	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// NOVA LÃ“GICA DE VALIDAÃ‡ÃƒO: HÃ­brida (Antiga + Nova)
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	const minOccurrences = Math.max(analyzerConfig.minOccurrences || 1, 1);
	
	// Contar todas as ocorrÃªncias do padrÃ£o no histÃ³rico
	const colorResults = { red: 0, black: 0, white: 0 };
	let totalOccurrences = 0;
	let lastAcceptedIndexForStats = null;
	
		for (let i = need; i < searchDepth; i++) {
			const seq = history.slice(i, i + need);
			if (seq.length < need) break;
			const seqColors = seq.map(s => s.color);
			const match = seqColors.every((c, idx) => c === pat.pattern[idx]);
			if (!match) continue;
		
		// â±ï¸ INTERVALO ENTRE PADRÃ•ES (contagem estatÃ­stica do MESMO padrÃ£o)
		if (minIntervalSpins > 0 && lastAcceptedIndexForStats !== null) {
			const diff = i - lastAcceptedIndexForStats;
			if (diff < minIntervalSpins) {
				continue;
			}
		}
		
		const trigEntry = history[i + need] ? history[i + need].color : null;
		const trigNormalized = normalizeColorName(trigEntry);
		// âœ… Respeitar "Exigir cor de disparo": se desativado, nÃ£o validar disparo aqui.
		if (requireTrigger) {
			if (!trigNormalized) continue;
			if (!validateDisparoColor(firstPatternNormalized, trigNormalized).valid) continue;
		}
		
		totalOccurrences++;
		lastAcceptedIndexForStats = i;
		const resultColor = history[i - 1] ? history[i - 1].color : null;
		if (resultColor) {
			colorResults[resultColor]++;
		}
		const stageAvailable = Math.min(maxTrackedStage, i - 1);
		for (let stage = 0; stage <= stageAvailable; stage++) {
			galeCoverageAvailable[stage]++;
		}
		const galeResults = evaluateGaleStagesForOccurrence(history, i, suggested, maxTrackedStage);
		let successStageValue = null;
		galeResults.forEach(result => {
			galeStageTotals[result.stage]++;
			if (result.win) {
				galeStageWins[result.stage]++;
				if (successStageValue === null) {
					successStageValue = result.stage;
				}
			} else {
				galeStageLosses[result.stage]++;
			}
		});
		if (successStageValue !== null) {
			for (let stage = successStageValue; stage < galeSuccessCumulative.length; stage++) {
				galeSuccessCumulative[stage]++;
			}
		}
	}
	
	// âœ… VALIDAR QUANTIDADE MÃNIMA DE OCORRÃŠNCIAS
	if (totalOccurrences < minOccurrences) {
		console.log('âŒ PadrÃ£o salvo rejeitado: ocorrÃªncias insuficientes:', {
				pattern: pat.pattern,
				suggested,
			totalOccurrences,
			minOccurrences
		});
		continue;
	}
	
	// âœ… VALIDAR QUANTIDADE MÃXIMA DE OCORRÃŠNCIAS (0 = sem limite)
	// âš ï¸ MODO IA: Ignora validaÃ§Ã£o de mÃ¡ximo de ocorrÃªncias (configuraÃ§Ã£o exclusiva do modo padrÃ£o)
	if (!analyzerConfig.aiMode) {
		const maxOccurrences = analyzerConfig.maxOccurrences || 0;
		if (maxOccurrences > 0 && totalOccurrences > maxOccurrences) {
			console.log('âŒ PadrÃ£o salvo rejeitado: excede ocorrÃªncias mÃ¡ximas:', {
				pattern: pat.pattern,
				suggested,
				totalOccurrences,
				maxOccurrences,
				limite: `mÃ¡x ${maxOccurrences}`
			});
			continue;
		}
	}
	
	// âœ… VALIDAR TAMANHO MÃNIMO E MÃXIMO DO PADRÃƒO
	// âš ï¸ MODO IA: Ignora validaÃ§Ãµes de tamanho (configuraÃ§Ãµes exclusivas do modo padrÃ£o)
	if (!analyzerConfig.aiMode) {
		const patternSize = pat.pattern.length;
		const minPatternSize = analyzerConfig.minPatternSize || 2;
		if (patternSize < minPatternSize) {
			console.log('âŒ PadrÃ£o salvo rejeitado: tamanho abaixo do mÃ­nimo:', {
				pattern: pat.pattern,
				patternSize,
				minPatternSize,
				limite: `mÃ­n ${minPatternSize} giros`
			});
			continue;
		}
		
		// âœ… VALIDAR TAMANHO MÃXIMO DO PADRÃƒO (0 = sem limite)
		const maxPatternSize = analyzerConfig.maxPatternSize || 0;
		if (maxPatternSize > 0 && patternSize > maxPatternSize) {
			console.log('âŒ PadrÃ£o salvo rejeitado: tamanho acima do mÃ¡ximo:', {
				pattern: pat.pattern,
				patternSize,
				maxPatternSize,
				limite: `mÃ¡x ${maxPatternSize} giros`
			});
			continue;
		}
	}
	
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// DECISÃƒO: Qual lÃ³gica usar?
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	let isValid = false;
	
	if (totalOccurrences === minOccurrences) {
		// âœ… LÃ“GICA ANTIGA: Exige 100% WIN
		console.log(`ğŸ“Š PadrÃ£o ${pat.pattern.join('-')}: ${totalOccurrences} ocorrÃªncias (= mÃ­nimo)`);
		console.log('   Aplicando LÃ“GICA ANTIGA (100% WIN)');
		
		const winsInSuggested = colorResults[suggested] || 0;
		isValid = (winsInSuggested === minOccurrences);
		
		if (!isValid) {
			console.log('   âŒ Rejeitado: NÃ£o tem 100% WIN na cor sugerida');
			console.log(`      ${suggested}: ${winsInSuggested}/${minOccurrences} WINS`);
		} else {
			console.log('   âœ… Aprovado: 100% WIN na cor sugerida');
		}
		
	} else {
		// âœ… LÃ“GICA NOVA: Cor que aparece mais
		const redCount = colorResults.red || 0;
		const blackCount = colorResults.black || 0;
		const whiteCount = colorResults.white || 0;
		
		// Ignorar branco se < 5%
		const whitePct = (whiteCount / totalOccurrences) * 100;
		const shouldIgnoreWhite = whitePct < 5;
		
		// Determinar cor vencedora (SEM VIÃ‰S - IMPARCIAL)
		let winningColor = null;
		let winningCount = 0;
		
		// âœ… CORREÃ‡ÃƒO: Usar >= para evitar viÃ©s em empates
		// Ordem: BLACK â†’ RED â†’ WHITE
		
		if (blackCount > winningCount) {
			winningColor = 'black';
			winningCount = blackCount;
		}
		
		if (redCount >= winningCount && redCount > 0) {
			winningColor = 'red';
			winningCount = redCount;
		}
		
		if (!shouldIgnoreWhite && whiteCount >= winningCount && whiteCount > 0) {
			winningColor = 'white';
			winningCount = whiteCount;
		}
		
		if (!winningColor) {
			continue; // Sem cor vencedora, ignorar silenciosamente
		}
		
		// Calcular WINS e LOSS
		const totalWins = winningCount;
		const totalLoss = totalOccurrences - winningCount;
		const balance = totalWins - totalLoss;
		
		// âœ… FILTRAR PADRÃ•ES FRACOS SILENCIOSAMENTE
		if (totalWins < minOccurrences) {
			continue; // NÃ£o atende mÃ­nimo de WINS
		}
		
		if (balance <= 0) {
			continue; // Saldo nÃ£o positivo
		}
		
		// Verificar se cor vencedora Ã© a sugerida
		if (winningColor !== suggested) {
			console.log(`   âš ï¸ Cor vencedora (${winningColor}) difere da sugerida (${suggested})`);
			console.log('   Atualizando sugerida para cor vencedora');
			suggested = winningColor; // Atualizar para usar cor vencedora
		}
		
		isValid = true;
		console.log('   âœ… Aprovado pela NOVA LÃ“GICA');
	}
	
	// Se nÃ£o passou na validaÃ§Ã£o, pular este padrÃ£o
	if (!isValid) {
		continue;
		}

		const patternName = identifyPatternType(pat.pattern, null);
		// Calcular assertividade inteligente baseada no histÃ³rico e contexto recente
		const assertCalc = computeAssertivenessForColorPattern(pat.pattern, suggested, history);
		const patternDesc = {
			colorAnalysis: {
				pattern: pat.pattern,
				occurrences: occCount || pat.occurrences || 1,
				allOccurrenceNumbers: occNumbers,
				allOccurrenceTimestamps: occTimestamps,
				patternType: patternName,
			triggerColor: currentTrigger || null, // SEMPRE usar trigger ATUAL, nÃ£o o salvo
				allTriggerNumbers: trigNumbers,
                allTriggerTimestamps: trigTimestamps,
                occurrenceDetails: occurrenceDetails, // Detalhes por ocorrÃªncia (append-only)
                summary: (function(){
                    // Recomputar wins/losses exatamente com as mesmas regras de ocorrÃªncia (inclui trigger)
                    let w = 0, l = 0, occ = 0;
                    for (let i = need; i < history.length; i++) {
                        const seq = history.slice(i, i + need);
                        if (seq.length < need) break;
                        const seqColors = seq.map(s => s.color);
                        const match = seqColors.every((c,ix) => c === pat.pattern[ix]);
                        if (!match) continue;
						
						// SÃ³ validar trigger se requireTrigger estiver ativo
						if (analyzerConfig.requireTrigger) {
						const trig = history[i + need] ? history[i + need].color : null;
						if (!trig || !isValidTrigger(trig, pat.pattern)) continue;
						}
						// triggers podem variar; nÃ£o exigir igualdade Ã  trigger salva
                        occ++;
                        const out = history[i-1] ? history[i-1].color : null;
                        if (out === suggested) w++; else l++;
                    }
                    const winPct = (w + l) > 0 ? (w/(w+l))*100 : 0;
                    // Calcular rigor baseado na configuraÃ§Ã£o atual
                    const sampleMin = Math.max(analyzerConfig.minOccurrences || 1, 1);
                    let othersWins = 0, othersLosses = 0;
                    let counted = 0;
                    for (let i = need; i < history.length && counted < occ; i++) {
                        const seq = history.slice(i, i + need);
                        if (seq.length < need) break;
                        const seqColors = seq.map(s => s.color);
                        const match = seqColors.every((c,ix) => c === pat.pattern[ix]);
                        if (!match) continue;
                        
                        // SÃ³ validar trigger se requireTrigger estiver ativo
                        if (analyzerConfig.requireTrigger) {
                        const trig = history[i + need] ? history[i + need].color : null;
                        if (!trig || !isValidTrigger(trig, pat.pattern)) continue;
                            // NÃƒO filtrar por cor de disparo especÃ­fica - triggers podem variar entre ocorrÃªncias
                        }
                        counted++;
                        const out = history[i-1] ? history[i-1].color : null;
                        if (counted <= sampleMin) {
                            // amostra mÃ­nima (deveria ser 100% win pela seleÃ§Ã£o); nÃ£o entra no rigor
                            continue;
                        }
                        if (out === suggested) othersWins++; else othersLosses++;
                    }
                    const othersCount = Math.max((occ - sampleMin), 0);
                    const rigorWinPct = othersCount > 0 ? (othersWins / othersCount) * 100 : 100;
                    // CORREÃ‡ÃƒO: Retornar wins/losses TOTAIS, nÃ£o apenas "others"
                    const stageSummaries = galeStageTotals.map((total, stage) => {
                        const wins = galeStageWins[stage];
                        const losses = galeStageLosses[stage];
                        return {
                            stage: stage === 0 ? 'G0' : `G${stage}`,
                            wins,
                            losses,
                            total,
                            winPct: total > 0 ? (wins / total) * 100 : null
                        };
                    });
                    const coverageSummaries = galeCoverageAvailable.map((attempts, stage) => {
                        const wins = galeSuccessCumulative[stage];
                        return {
                            stage: stage === 0 ? 'G0' : `G${stage}`,
                            wins,
                            attempts,
                            coveragePct: attempts > 0 ? (wins / attempts) * 100 : null
                        };
                    });
                    return {
                        occurrences: occ,
                        wins: w,  // Total de wins (inclui rigor + demais)
                        losses: l,  // Total de losses (inclui rigor + demais)
                        winPct: winPct,  // Porcentagem total
                        lossPct: Math.max(0, 100 - winPct),
                        othersCount,
                        othersWins,  // Wins apenas das "demais" (excluindo rigor)
                        othersLosses,  // Losses apenas das "demais" (excluindo rigor)
                        rigorWinPct,  // Porcentagem apenas das "demais"
                        sampleMin,
                        sampleMinWins100: true,
                        patternLength: Array.isArray(pat.pattern) ? pat.pattern.length : null,
                        galeStats: {
                            maxStageTracked: MAX_GALE_STAGE_TRACKED,
                            stages: stageSummaries,
                            coverage: coverageSummaries
                        }
                    };
                })()
			},
			patternType: patternName,
			expected_next: suggested,
			id: pat.id,
			found_at: pat.found_at,
			assertiveness: assertCalc && assertCalc.explain ? assertCalc.explain : undefined
		};
		
		// âœ… VALIDAÃ‡ÃƒO CRÃTICA: Verificar WIN% das ocorrÃªncias "Demais"
		const summary = patternDesc.colorAnalysis.summary;
		if (summary && summary.rigorWinPct !== undefined) {
			const threshold = analyzerConfig.winPercentOthers || 0;
			if (threshold > 0 && summary.rigorWinPct < threshold) {
				// âŒ REJEITAR: WIN% das "Demais" estÃ¡ abaixo do threshold configurado
				logRejectedPattern(
					`${pat.pattern.join('-')} (salvo)`,
					`WIN% Demais = ${summary.rigorWinPct.toFixed(1)}% < ${threshold}% (config)`
				);
				console.log(`   ğŸ“Š Detalhes: ${summary.othersWins}W/${summary.othersLosses}L em ${summary.othersCount} ocorrÃªncias`);
				console.log(`   ğŸ¯ ConfiguraÃ§Ã£o exige: mÃ­nimo ${threshold}% de WIN nas demais ocorrÃªncias`);
				continue;
			}
		}

		// ğŸ”¥ VALIDAÃ‡ÃƒO FINAL DE TRIGGER: somente se o usuÃ¡rio exigir cor de disparo
		if (requireTrigger) {
			// Verificar se a cor de disparo ATUAL (antes do padrÃ£o head) Ã© diferente da primeira cor do padrÃ£o
			const finalTriggerNormalized = normalizeColorName(currentTrigger);
			const firstFinalNormalized = normalizeColorName(getInitialPatternColor(pat.pattern));

			if (!firstFinalNormalized) {
				console.warn('âš ï¸ PadrÃ£o salvo rejeitado no sinal final: cor inicial invÃ¡lida', pat.pattern);
				continue;
			}

			if (!finalTriggerNormalized) {
				console.log(`âŒ PadrÃ£o salvo rejeitado no sinal final: sem cor de disparo atual`);
				continue;
			}

			const finalValidation = validateDisparoColor(firstFinalNormalized, finalTriggerNormalized);
			if (!finalValidation.valid) {
				console.log(`âŒ PadrÃ£o salvo rejeitado no sinal final: cor de disparo atual INVÃLIDA`, {
					pattern: pat.pattern.join('-'),
					currentTrigger: currentTrigger,
					triggerNormalized: finalTriggerNormalized,
					firstPatternColor: getInitialPatternColor(pat.pattern),
					firstNormalized: firstFinalNormalized,
					motivo: finalValidation.reason || 'Cor de disparo IGUAL ou invÃ¡lida - corromperia o padrÃ£o!'
				});
				continue;
			}

			console.log(`âœ… ValidaÃ§Ã£o final de trigger: APROVADA`, {
				currentTrigger: finalTriggerNormalized,
				firstPatternColor: firstFinalNormalized,
				isOpposite: finalTriggerNormalized === 'white' || (finalTriggerNormalized === 'red' && firstFinalNormalized === 'black') || (finalTriggerNormalized === 'black' && firstFinalNormalized === 'red')
			});
		}

		// Se assertCalc existe, jÃ¡ vem calibrado; senÃ£o, calibrar a confidence salva
		const rawPatternConfidence = typeof pat.confidence === 'number' ? pat.confidence : 70;
		const patternConfidence = assertCalc ? assertCalc.finalConfidence : applyCalibratedConfidence(rawPatternConfidence);
		
		// âœ… Premium (Modo PadrÃ£o): remover filtro oculto de risco P(3 LOSS).
		// Esse filtro nÃ£o Ã© configurÃ¡vel na UI e deixava o modo Premium com volume muito baixo.
		// Mantido apenas para Modo IA (se algum dia esse fluxo for usado lÃ¡).
		if (analyzerConfig.aiMode) {
			// Usamos preferencialmente o winPct real calculado em summary; se nÃ£o existir, usamos a confidence do padrÃ£o.
			let estimatedWinProb = null;
			if (summary && typeof summary.winPct === 'number') {
				estimatedWinProb = summary.winPct / 100;
			} else {
				estimatedWinProb = (typeof patternConfidence === 'number' ? patternConfidence : rawPatternConfidence) / 100;
			}
			estimatedWinProb = Math.min(Math.max(estimatedWinProb, 0.01), 0.99);
			const probThreeLossSaved = Math.pow(1 - estimatedWinProb, 3);
			const maxThreeLossProbSaved = 0.02;
			if (probThreeLossSaved > maxThreeLossProbSaved) {
				console.log('âŒ PadrÃ£o salvo rejeitado pelo filtro de risco de sequÃªncia (P(3 LOSS) acima do limite)', {
					pattern: pat.pattern,
					suggested,
					estimatedWinProb: (estimatedWinProb * 100).toFixed(2) + '%',
					probThreeLoss: (probThreeLossSaved * 100).toFixed(2) + '%',
					maxAllowed: (maxThreeLossProbSaved * 100).toFixed(2) + '%'
				});
				continue;
			}
		}

		const candidate = {
			color: suggested,
			suggestion: 'PadrÃ£o salvo',
			confidence: patternConfidence,
			patternDescription: JSON.stringify(patternDesc),
			createdOnTimestamp: history[0] ? history[0].timestamp : new Date().toISOString(),
			predictedFor: 'next',
			phase: 'G0'
		};
		if (!best || candidate.confidence > best.confidence) best = candidate;
	}
	return best;
}

// Descoberta: executa 50+ anÃ¡lises em atÃ© 5s, evita repetir padrÃµes jÃ¡ salvos
async function discoverAndPersistPatterns(history, startTs, budgetMs) {
	if (patternDiscoveryCutoff) {
		history = filterHistoryByResetCutoff(history);
	}
	if (!history || history.length < 50) return; // respeita regra mÃ­nima existente
	const requireTrigger = !!(analyzerConfig && analyzerConfig.requireTrigger);
	const db = await loadPatternDB();
	const existingKeys = new Set(db.patterns_found.map(patternKeyOf));

	const colors = history.map(s => s.color);
	const tasks = [];
	// Planejar 173+ anÃ¡lises diversificadas (cores, nÃºmeros, temporais e brancos)
	// âœ… Respeitar tamanhos configurados pelo usuÃ¡rio no Premium (com teto de seguranÃ§a p/ performance)
	const HARD_MAX_COLOR_PATTERN_SIZE = 20;
	const minSizeCfg = clampInt(
		analyzerConfig?.minPatternSize ?? DEFAULT_ANALYZER_CONFIG.minPatternSize,
		2,
		HARD_MAX_COLOR_PATTERN_SIZE
	);
	const rawMaxSizeCfg = Number(analyzerConfig?.maxPatternSize ?? DEFAULT_ANALYZER_CONFIG.maxPatternSize);
	const maxSizeCfg = Number.isFinite(rawMaxSizeCfg) ? Math.floor(rawMaxSizeCfg) : 0;
	const maxSizeEffective = maxSizeCfg > 0
		? clampInt(maxSizeCfg, minSizeCfg, HARD_MAX_COLOR_PATTERN_SIZE)
		: HARD_MAX_COLOR_PATTERN_SIZE;

    for (let size = minSizeCfg; size <= maxSizeEffective; size++) {
		for (let offset = 0; offset < 10; offset++) { // 10 offsets para maior cobertura
			tasks.push({ kind: 'color-window', size, offset });
		}
	}
    for (let len = 3; len <= 8; len++) { // correlaÃ§Ãµes numÃ©ricas atÃ© 8 giros
		for (let offset = 0; offset < 5; offset++) { // 5 offsets
			tasks.push({ kind: 'number-correlation-lite', len, offset });
		}
	}
	// Adicionar anÃ¡lises temporais e de brancos
	tasks.push({ kind: 'white-intervals' });
	tasks.push({ kind: 'night-white' });
	tasks.push({ kind: 'time-repetition' });
	tasks.push({ kind: 'temporal-reversal' });
	tasks.push({ kind: 'white-break' });
	tasks.push({ kind: 'white-after-dominance' });
	tasks.push({ kind: 'complete-cycle' });
	tasks.push({ kind: 'post-white-peak' });
	tasks.push({ kind: 'post-white-recovery' });
	tasks.push({ kind: 'total-correction' });
	tasks.push({ kind: 'microcycle' });
	tasks.push({ kind: 'night-stability' });
	tasks.push({ kind: 'day-oscillation' });

	let discovered = [];
	let duplicatesCount = 0; // âœ… CONTADOR DE DUPLICATAS
	let rejectedByInvalidTriggerCount = 0; // âœ… CONTADOR DE PADRÃ•ES REJEITADOS POR TRIGGER INVÃLIDA
	
	for (let idx = 0; idx < tasks.length; idx++) {
		// OrÃ§amento de tempo
		if ((Date.now() - startTs) > budgetMs) break;
		const t = tasks[idx];
		let results = [];
		if (t.kind === 'color-window') {
			results = discoverColorPatternsFast(colors, t.size, t.offset);
		} else if (t.kind === 'number-correlation-lite') {
			results = discoverNumberCorrelationsFast(history.map(s => s.number), colors, t.len, t.offset);
		} else if (t.kind === 'white-intervals') {
			const pattern = analyzeWhiteIntervals(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'night-white') {
			const pattern = analyzeNightWhitePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'time-repetition') {
			const pattern = analyzeTimeRepetitionPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'temporal-reversal') {
			const pattern = analyzeTemporalReversalPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'white-break') {
			const pattern = analyzeWhiteBreakPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'white-after-dominance') {
			const pattern = analyzeWhiteAfterDominancePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'complete-cycle') {
			const pattern = analyzeCompleteCyclePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'post-white-peak') {
			const pattern = analyzePostWhitePeakPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'post-white-recovery') {
			const pattern = analyzePostWhiteRecoveryPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'total-correction') {
			const pattern = analyzeTotalCorrectionPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'microcycle') {
			const pattern = analyzeMicrocyclePattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'night-stability') {
			const pattern = analyzeNightStabilityPattern(history);
			if (pattern) results = [pattern];
		} else if (t.kind === 'day-oscillation') {
			const pattern = analyzeDayOscillationPattern(history);
			if (pattern) results = [pattern];
		}
		for (const r of results) {
			// âœ… NORMALIZAR FORMATO DE PADRÃ•ES (CRÃTICO PARA ANTI-DUPLICAÃ‡ÃƒO!)
			
			// 1. Normalizar prÃ³xima cor esperada
			if (r.suggestedColor && !r.expected_next) {
				r.expected_next = r.suggestedColor;
			}
			
			// 2. âœ… NORMALIZAR PADRÃƒO (string â†’ array) ANTES de gerar chave
			if (typeof r.pattern === 'string' && !Array.isArray(r.pattern)) {
				// âœ… Converter string para array diretamente
				r.pattern = [r.pattern];
			} else if (!Array.isArray(r.pattern) && Array.isArray(r.patternArr)) {
				// âœ… Usar patternArr se pattern nÃ£o for array
				r.pattern = r.patternArr;
			} else if (!Array.isArray(r.pattern)) {
				// âœ… Fallback para array vazio
				console.warn('âš ï¸ PadrÃ£o sem formato vÃ¡lido, convertendo para array:', r);
				r.pattern = r.pattern ? [String(r.pattern)] : [];
			}
			
			// 3. Normalizar tipo
			if (!r.type && r.patternType) {
				r.type = r.patternType;
			}
			
			// âœ… GERAR CHAVE ÃšNICA (agora com padrÃ£o normalizado)
			const key = patternKeyOf(r);
			
			// âœ… VERIFICAR DUPLICATA
			if (existingKeys.has(key)) {
				duplicatesCount++; // âœ… INCREMENTAR CONTADOR
				continue; // âœ… Pular duplicata
			}
			
			// âœ… ADICIONAR CHAVE AO SET
			existingKeys.add(key);
			
			// âœ… ADICIONAR AO ARRAY DE DESCOBERTOS
			discovered.push(r);
		}
	}

	// Log resumido: apenas se encontrou novos padrÃµes
	if (discovered.length === 0) {
		// Silencioso: nÃ£o precisa logar quando nÃ£o encontra nada novo
		return;
	}

	// Log compacto de novos padrÃµes
	const timeElapsed = ((Date.now() - startTs) / 1000).toFixed(2);
	console.log(`%cğŸ¯ +${discovered.length} padrÃ£o(Ãµes) | â±ï¸ ${timeElapsed}s`, 'color: #00FF88; font-weight: bold; background: #003322; padding: 4px 8px; border-radius: 4px;');

	// âœ… UPSERT NO DB - REFATORADO COM ANTI-DUPLICAÃ‡ÃƒO
	const nowIso = new Date().toISOString();
	let idCounter = 0; // âœ… Contador para garantir IDs Ãºnicos
	
	for (const p of discovered) {
		// âœ… GERAR ID ÃšNICO (timestamp + contador + random)
		if (!p.id) {
			const timestamp = Date.now();
			const counter = idCounter++;
			const random = Math.floor(Math.random() * 10000);
			p.id = `${timestamp}-${counter}-${random}`;
		}
		
		// âœ… NORMALIZAR DATA DE DESCOBERTA
		p.found_at = p.found_at || nowIso;
		
		// âœ… NORMALIZAR NOME DA PRÃ“XIMA COR ESPERADA
		if (!p.expected_next && p.suggestedColor) {
			p.expected_next = p.suggestedColor;
		}
		
		// âœ… NORMALIZAR CONFIANÃ‡A
		if (typeof p.confidence !== 'number') {
			p.confidence = 70;
		}
		
		// âœ… NORMALIZAR PADRÃƒO (CRÃTICO PARA ANTI-DUPLICAÃ‡ÃƒO!)
		if (!Array.isArray(p.pattern)) {
			if (Array.isArray(p.patternArr)) {
				p.pattern = p.patternArr;
			} else if (typeof p.pattern === 'string') {
				// âœ… Converter string para array de 1 elemento
				p.pattern = [p.pattern];
			} else {
				// âœ… Fallback para array vazio
				p.pattern = [];
				console.warn('âš ï¸ PadrÃ£o sem formato vÃ¡lido:', p);
			}
		}
		
		// âœ… INICIALIZAR CONTADORES DE DESEMPENHO
		if (typeof p.total_wins !== 'number') p.total_wins = 0;
		if (typeof p.total_losses !== 'number') p.total_losses = 0;
		
		// ğŸ”¥ ValidaÃ§Ã£o de trigger antes de salvar no banco
		// âœ… Respeitar config: sÃ³ validar trigger se o usuÃ¡rio exigir cor de disparo.
		if (requireTrigger && Array.isArray(p.pattern) && p.pattern.length > 0 && p.triggerColor) {
			const firstColorNormalized = normalizeColorName(getInitialPatternColor(p.pattern));
			const triggerNormalized = normalizeColorName(p.triggerColor);
			const triggerValidation = validateDisparoColor(firstColorNormalized, triggerNormalized);
			
			if (!triggerValidation.valid) {
				rejectedByInvalidTriggerCount++; // Incrementar contador
				// Log removido: nÃ£o Ã© necessÃ¡rio logar padrÃµes rejeitados individualmente
				continue; // âŒ NÃƒO SALVAR este padrÃ£o no banco
			}
		}
		
		// âœ… ADICIONAR AO BANCO (JÃ VALIDADO COMO NÃƒO DUPLICADO E TRIGGER VÃLIDA)
		db.patterns_found.unshift({
			id: p.id,
			pattern: p.pattern, // âœ… Sempre array apÃ³s normalizaÃ§Ã£o
			expected_next: p.expected_next,
			confidence: p.confidence,
			found_at: p.found_at,
			type: p.type || p.patternType || 'discovery',
			occurrences: p.occurrences || 0,
			triggerColor: p.triggerColor || null,
			total_wins: p.total_wins,
			total_losses: p.total_losses
		});
	}
	// Limitar para nÃ£o crescer indefinidamente
	db.patterns_found = db.patterns_found.slice(0, 5000);
	await savePatternDB(db);
	
	// Log removido: resumo jÃ¡ foi mostrado acima (compacto)
}

// Varredura rÃ¡pida por padrÃµes de cores (sem exigir match atual, apenas descoberta)
function discoverColorPatternsFast(colors, size, strideOffset) {
	const out = [];
	if (!Array.isArray(colors) || colors.length < size + 1) return out;
	// âœ… Respeitar configuraÃ§Ã£o do usuÃ¡rio (Premium): mÃ­nimo do padrÃ£o pode ser 2
	if (size < 2) return out;
	const requireTrigger = !!(analyzerConfig && analyzerConfig.requireTrigger);
	const minOccurrences = clampInt(
		analyzerConfig?.minOccurrences ?? DEFAULT_ANALYZER_CONFIG.minOccurrences,
		1,
		1000
	);
	
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// ğŸ”¥ NOVA LÃ“GICA: Agrupar por PADRÃƒO + TRIGGER (nÃ£o sÃ³ padrÃ£o)
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// Isso garante que TODAS as ocorrÃªncias tenham a MESMA cor de disparo!
	
	const outcomesMap = new Map(); // Chave: "padrÃ£o|trigger"
	
	for (let i = size; i < colors.length - 1; i++) {
		if (((i - size) % 5) !== strideOffset) continue; // espaÃ§ar varredura
		const seq = colors.slice(i, i + size);
		const nextColor = colors[i - 1];
		const triggerColor = colors[i + size]; // cor imediatamente antes do padrÃ£o
		
		if (!triggerColor) continue;
		// âœ… Respeitar "Exigir cor de disparo": sÃ³ validar trigger quando ativo
		if (requireTrigger && !isValidTrigger(triggerColor, seq)) continue;
		
		const normalizedTrigger = normalizeColorName(triggerColor);
		if (!normalizedTrigger) continue;
		
		// âœ… CHAVE ÃšNICA: padrÃ£o + trigger (ex: "red-black-red|black")
		// Isso separa ocorrÃªncias com triggers diferentes em grupos distintos!
		const key = `${seq.join('-')}|${normalizedTrigger}`;
		
		let bag = outcomesMap.get(key);
		if (!bag) { 
			bag = { 
				seq, 
				trigger: normalizedTrigger, // âœ… Trigger ÃšNICA deste grupo
				outcomes: [], 
				count: 0 
			}; 
			outcomesMap.set(key, bag); 
		}
		
		bag.outcomes.push(nextColor);
		bag.count++;
	}
	
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	// âœ… PROCESSAR CADA GRUPO (padrÃ£o + trigger especÃ­fica)
	// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	for (const bag of outcomesMap.values()) {
		// âœ… Respeitar OcorrÃªncias mÃ­nima configurada pelo usuÃ¡rio
		if (bag.count < minOccurrences) continue;
		
		const cnt = {};
		for (const c of bag.outcomes) cnt[c] = (cnt[c] || 0) + 1;
		
		const keys = Object.keys(cnt);
		if (keys.length === 0) continue;
		
		const winner = keys.reduce((a, b) => cnt[a] >= cnt[b] ? a : b);
		const acc = (cnt[winner] / bag.outcomes.length) * 100;
		
		if (acc >= 68) { // um pouco abaixo de 75 para descobrir mais padrÃµes
			const signif = cnt[winner] / (bag.outcomes.length / 3);
			if (signif >= 1.6) {
			// âœ… VALIDAÃ‡ÃƒO FINAL: Garantir que trigger Ã© vÃ¡lida para o padrÃ£o
			const firstPatternColorNormalized = normalizeColorName(bag.seq[0]);
			const triggerValidation = validateDisparoColor(firstPatternColorNormalized, bag.trigger);
			
			if (!triggerValidation.valid) {
				// Log removido: nÃ£o Ã© necessÃ¡rio mostrar padrÃµes rejeitados individualmente
				continue;
			}
			
			// âœ… PADRÃƒO VÃLIDO: Todas as ocorrÃªncias tÃªm a MESMA trigger!
			// Log removido: resumo serÃ¡ mostrado no final
				
				out.push({
					type: 'color-discovery',
					pattern: bag.seq,
					triggerColor: bag.trigger,
					expected_next: winner,
					confidence: acc,
					occurrences: bag.count
				});
			}
		}
	}
	
	return out;
}

// Descoberta leve de correlaÃ§Ã£o numÃ©rica
function discoverNumberCorrelationsFast(numbers, colors, len, strideOffset) {
	const out = [];
	if (!Array.isArray(numbers) || numbers.length < len + 1) return out;
	if (len < 3) return out; // nÃ£o considerar padrÃµes com menos de 3 nÃºmeros
	const map = new Map();
	for (let i = len; i < numbers.length - 1; i++) {
		if (((i - len) % 3) !== strideOffset) continue;
		const seq = [];
		for (let k = 0; k < len; k++) seq.push(numbers[i + (len - 1 - k)]);
		const key = seq.join('â†’');
		const outcome = colors[i - 1];
		let bag = map.get(key);
		if (!bag) { bag = { seq, outcomes: [], count: 0 }; map.set(key, bag); }
		bag.outcomes.push(outcome);
		bag.count++;
	}
	for (const bag of map.values()) {
		if (bag.count < 3) continue;
		const cnt = {};
		for (const c of bag.outcomes) cnt[c] = (cnt[c] || 0) + 1;
		// âœ… CORREÃ‡ÃƒO: Usar primeira chave disponÃ­vel em vez de 'red' como padrÃ£o
		const keys = Object.keys(cnt);
		if (keys.length === 0) continue;
		const winner = keys.reduce((a, b) => cnt[a] >= cnt[b] ? a : b);
		const acc = (cnt[winner] / bag.outcomes.length) * 100;
		const signif = cnt[winner] / (bag.outcomes.length / 3);
		if (acc >= 70 && signif >= 1.8) {
			out.push({
				type: 'number-corr-discovery',
				pattern: bag.seq.map(n => (typeof n === 'number' ? String(n) : n)).join('â†’'),
				patternArr: colorsForNumberSeq(bag.seq),
				expected_next: winner,
				confidence: acc,
				occurrences: bag.count
			});
		}
	}
	return out;
}

function colorsForNumberSeq(seq) {
	return seq.map(n => getColorFromNumber(n));
}

// AI Pattern Analysis System - MULTIDIMENSIONAL
async function performPatternAnalysis(history) {
    // âœ… VALIDAÃ‡ÃƒO INICIAL DO HISTÃ“RICO
    console.log('ğŸ” Iniciando anÃ¡lise multidimensional de IA com', history ? history.length : 'N/A', 'giros', '| Rigor:', rigorLogString());

    if (!history || !Array.isArray(history) || history.length === 0) {
        console.log('âš ï¸ HistÃ³rico invÃ¡lido ou vazio recebido em performPatternAnalysis');
        return null;
    }

    // âœ… APLICAR PROFUNDIDADE DE ANÃLISE CONFIGURADA (historyDepth) PARA O MODO PADRÃƒO
    // ğŸ”¹ IMPORTANTE: performPatternAnalysis sÃ³ Ã© chamado quando aiMode = false (Modo PadrÃ£o)
    const configuredDepth = analyzerConfig && typeof analyzerConfig.historyDepth === 'number'
        ? analyzerConfig.historyDepth
        : 2000;
    const effectiveDepth = Math.min(Math.max(50, configuredDepth), history.length);
    const limitedHistory = history.slice(0, effectiveDepth);

    console.log(`ğŸ“Š HistÃ³rico total disponÃ­vel: ${history.length} giros`);
    console.log(`âš™ï¸ Profundidade configurada (historyDepth): ${configuredDepth} giros`);
    console.log(`âœ… performPatternAnalysis vai usar apenas os Ãºltimos: ${effectiveDepth} giros (respeitando historyDepth)`);
    
    // âœ… BLOQUEAR ANÃLISES DURANTE A BUSCA DE PADRÃ•ES (30s)
    if (initialSearchActive) {
        console.log('%cğŸš« ANÃLISE BLOQUEADA - Busca de padrÃµes em andamento (30s)', 'color: #FFA500; font-weight: bold;');
        return null; // NÃ£o enviar sinais durante a busca
    }
    
    // Verificar se hÃ¡ dados suficientes para anÃ¡lise
    if (limitedHistory.length < 50) {
        console.log('âš ï¸ Dados insuficientes para anÃ¡lise multidimensional:', limitedHistory.length, '/ 50 giros necessÃ¡rios');
        sendAnalysisStatus(`Coletando dados... ${limitedHistory.length}/50 giros`);
        return null;
    }
    
    // Enviar status inicial com quantidade de giros (APÃ“S aplicar historyDepth)
    sendAnalysisStatus(`ğŸ” Iniciando anÃ¡lise multidimensional de IA com ${limitedHistory.length} giros (limite historyDepth)`);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ANÃLISE PADRÃƒO (CONTINUA NORMALMENTE SE NÃƒO HOUVER PADRÃƒO CUSTOMIZADO)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // 1. ANÃLISE DE PADRÃ•ES DE COR COM COR DE DISPARO (baseada nos exemplos)
    const colorAnalysis = analyzeColorPatternsWithTrigger(limitedHistory);
    if (colorAnalysis) {
        console.log(`ğŸ“Š PadrÃ£o de cores: ${colorAnalysis.pattern.join('-')} â†’ ${colorAnalysis.suggestedColor} (${colorAnalysis.confidence.toFixed(1)}%, ${colorAnalysis.occurrences}x)`);
    }
    
    // Enviar status para anÃ¡lise numÃ©rica
    sendAnalysisStatus('ğŸ§® Verificando padrÃµes numÃ©ricos...');
    
    // 2. ANÃLISE DE PADRÃ•ES NUMÃ‰RICOS
    const numberAnalysis = analyzeNumberPatterns(limitedHistory);
    if (numberAnalysis) {
        console.log(`ğŸ”¢ PadrÃ£o numÃ©rico: ${numberAnalysis.pattern} â†’ ${numberAnalysis.suggestedNumber} (${numberAnalysis.confidence.toFixed(1)}%)`);
    }
    
    // Enviar status para anÃ¡lise temporal
    sendAnalysisStatus('â° Analisando tendÃªncias temporais...');
    
    // 3. ANÃLISE TEMPORAL E MISTA AVANÃ‡ADA (baseada nos exemplos 21-33)
    const timeAnalysis = analyzeTemporalAndMixedPatterns(limitedHistory);
    if (timeAnalysis) {
        console.log(`â° PadrÃ£o temporal/misto: ${timeAnalysis.pattern} â†’ ${timeAnalysis.suggestedColor} (${timeAnalysis.confidence.toFixed(1)}%)`);
    }
    
    // Enviar status para anÃ¡lise de correlaÃ§Ãµes
    sendAnalysisStatus('ğŸ”— Calculando correlaÃ§Ãµes...');
    
    // 4. ANÃLISE DE CORRELAÃ‡Ã•ES
    const correlationAnalysis = analyzeCorrelations(limitedHistory);
    if (correlationAnalysis) {
        console.log(`ğŸ”— CorrelaÃ§Ã£o: ${correlationAnalysis.pattern} â†’ ${correlationAnalysis.suggestedColor} (${correlationAnalysis.confidence.toFixed(1)}%)`);
    }
    
    // Enviar status para anÃ¡lise de frequÃªncia
    sendAnalysisStatus('ğŸ“Š Avaliando frequÃªncias...');
    
    // 5. ANÃLISE DE FREQUÃŠNCIA MULTIDIMENSIONAL
    const frequencyAnalysis = analyzeMultidimensionalFrequency(limitedHistory);
    if (frequencyAnalysis) {
        console.log(`ğŸ“ˆ FrequÃªncia multidimensional: ${frequencyAnalysis.pattern} â†’ ${frequencyAnalysis.suggestedColor} (${frequencyAnalysis.confidence.toFixed(1)}%)`);
    }
    
    // Enviar status para combinaÃ§Ã£o final
    sendAnalysisStatus('ğŸ¯ Combinando anÃ¡lises...');
    
    // 6. COMBINAR TODAS AS ANÃLISES MULTIDIMENSIONAIS
    const finalAnalysis = await combineMultidimensionalAnalyses(
        colorAnalysis, 
        numberAnalysis, 
        timeAnalysis, 
        correlationAnalysis, 
        frequencyAnalysis
    );
    
    if (finalAnalysis) {
        console.log(`âœ… ANÃLISE MULTIDIMENSIONAL APROVADA: ${finalAnalysis.color} (${finalAnalysis.confidence.toFixed(1)}%)`, '| Rigor:', rigorLogString());
        console.log(`ğŸ“Š ContribuiÃ§Ãµes: Cor=${finalAnalysis.contributions.color}%, NÃºm=${finalAnalysis.contributions.number}%, Tempo=${finalAnalysis.contributions.time}%, Corr=${finalAnalysis.contributions.correlation}%, Freq=${finalAnalysis.contributions.frequency}%`);
        // Enviar status de conclusÃ£o
        sendAnalysisStatus('âœ… PadrÃ£o encontrado!');
    } else {
        console.log('âŒ AnÃ¡lise multidimensional rejeitada - critÃ©rios nÃ£o atendidos');
        // Enviar status de aguardando novo giro apÃ³s anÃ¡lise completa
        sendAnalysisStatus('â³ Aguardando novo giro...');
    }
    
    return finalAnalysis;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANÃLISE DE PADRÃ•ES DE CORES - CORREÃ‡ÃƒO CRÃTICA
// IDENTIFICA SEQUÃŠNCIAS COMPLETAS DE CORES (DO INÃCIO AO FIM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ğŸ”§ FUNÃ‡ÃƒO AUXILIAR: Identificar sequÃªncia completa de cores mais recente
function identifyCompleteColorSequence(colors, maxLength = 20) {
    if (!colors || colors.length < 2) return null;
    
    // Agrupar cores consecutivas iguais em blocos
    const blocks = [];
    let currentColor = colors[0];
    let currentCount = 1;
    
    for (let i = 1; i < Math.min(colors.length, maxLength); i++) {
        if (colors[i] === currentColor) {
            currentCount++;
        } else {
            blocks.push({ color: currentColor, count: currentCount });
            currentColor = colors[i];
            currentCount = 1;
        }
    }
    blocks.push({ color: currentColor, count: currentCount });
    
    // Converter blocos em sequÃªncia completa
    const sequence = [];
    for (const block of blocks) {
        for (let i = 0; i < block.count; i++) {
            sequence.push(block.color);
        }
    }
    
    return {
        sequence: sequence,
        blocks: blocks,
        length: sequence.length
    };
}

function analyzeColorPatternsWithTrigger(history) {
    // âœ… VALIDAÃ‡ÃƒO INICIAL
    if (!history || !Array.isArray(history) || history.length < 50) {
        console.log('âš ï¸ HistÃ³rico insuficiente para anÃ¡lise de cores:', history?.length || 0, '/ 50 giros necessÃ¡rios');
        return null;
    }
    
    // âœ… APLICAR PROFUNDIDADE DE ANÃLISE CONFIGURADA PELO USUÃRIO (historyDepth)
    const configuredDepth = clampInt(
        analyzerConfig.historyDepth ?? DEFAULT_ANALYZER_CONFIG.historyDepth,
        50,
        REALTIME_HISTORY_CAP
    );
    const effectiveDepth = Math.min(configuredDepth, history.length);
    const limitedHistory = history.slice(0, effectiveDepth);
    
    console.log(`ğŸ” Iniciando anÃ¡lise de padrÃµes de cores`);
    console.log(`ğŸ“Š HistÃ³rico total disponÃ­vel: ${history.length} giros`);
    console.log(`âš™ï¸ Profundidade configurada pelo usuÃ¡rio: ${configuredDepth} giros`);
    console.log(`âœ… Analisando apenas os Ãºltimos: ${effectiveDepth} giros (respeitando historyDepth)`);
    console.log('ğŸš¨ CORREÃ‡ÃƒO ATIVADA: Identificando SEQUÃŠNCIAS COMPLETAS de cores');
    
    // âœ… EXTRAÃ‡ÃƒO DE CORES (usando histÃ³rico limitado)
    const colors = limitedHistory.map(s => {
        if (!s || !s.color) {
            console.warn('âš ï¸ Giro invÃ¡lido detectado:', s);
            return 'red'; // Fallback seguro
        }
        return s.color;
    });
    
    // âœ… CONFIGURAÃ‡ÃƒO DO USUÃRIO
    // (nÃ£o usar fallback rÃ­gido; respeitar o valor configurado + default real do sistema)
    const minOccurrences = Math.max(
        1,
        Math.floor(Number(analyzerConfig.minOccurrences ?? DEFAULT_ANALYZER_CONFIG.minOccurrences))
    );
    
    console.log(`ğŸ“Š Config: minOccurrences=${minOccurrences}`);
    
    // ğŸ” PASSO 1: IDENTIFICAR SEQUÃŠNCIA COMPLETA MAIS RECENTE
    const currentPattern = identifyCompleteColorSequence(colors, 20);
    
    if (!currentPattern || currentPattern.length < 2) {
        console.log('âŒ NÃ£o foi possÃ­vel identificar sequÃªncia completa nos giros recentes');
        return null;
    }
    
    console.log('ğŸ“ SEQUÃŠNCIA COMPLETA IDENTIFICADA:');
    console.log(`   Giros: ${currentPattern.sequence.join('-')}`);
    console.log(`   Blocos: ${currentPattern.blocks.map(b => `${b.count}x${b.color.toUpperCase()}`).join(' + ')}`);
    console.log(`   Tamanho total: ${currentPattern.length} giros`);
    
    // ğŸ” PASSO 2: BUSCAR ESSA SEQUÃŠNCIA COMPLETA NO HISTÃ“RICO (LIMITADO)
    const patternToFind = currentPattern.sequence;
    const patternLength = patternToFind.length;
    
    const occurrences = [];
    const minIntervalSpins = analyzerConfig.minIntervalSpins || 0;
    
    // Guardar Ãºltimo Ã­ndice aceito para o MESMO padrÃ£o (intervalo entre ocorrÃªncias)
    let lastAcceptedIndex = null;
    
    // Varrer histÃ³rico LIMITADO procurando a SEQUÃŠNCIA COMPLETA
    // âœ… CORREÃ‡ÃƒO: Usar limitedHistory.length em vez de history.length
    for (let i = patternLength; i < limitedHistory.length - 1; i++) {
        const historicalSequence = colors.slice(i, i + patternLength);
        
        // Verificar se a sequÃªncia completa Ã© igual
        const isMatch = historicalSequence.every((c, idx) => c === patternToFind[idx]);
        
        if (isMatch) {
            // â±ï¸ INTERVALO ENTRE PADRÃ•ES (somente MESMO padrÃ£o)
            if (minIntervalSpins > 0 && lastAcceptedIndex !== null) {
                const diff = i - lastAcceptedIndex;
                if (diff < minIntervalSpins) {
                    continue; // muito prÃ³ximo da Ãºltima ocorrÃªncia do MESMO padrÃ£o
                }
            }
            
            const triggerColor = colors[i + patternLength]; // Cor antes da sequÃªncia
            const resultColor = colors[i - 1]; // Cor que saiu APÃ“S a sequÃªncia completa
            
            // âœ… VALIDAR TRIGGER (se configurado)
            if (analyzerConfig.requireTrigger && triggerColor) {
                if (!isValidTrigger(triggerColor, patternToFind)) {
                    continue; // Trigger invÃ¡lida, pular
                }
            }
            
            occurrences.push({
                index: i,
                trigger: triggerColor,
                result: resultColor,
                number: limitedHistory[i - 1]?.number,
                timestamp: limitedHistory[i - 1]?.timestamp
            });
            
            // Atualizar Ãºltimo Ã­ndice aceito para este padrÃ£o
            lastAcceptedIndex = i;
        }
    }
    
    console.log(`\nğŸ” Buscando sequÃªncia completa no histÃ³rico...`);
    console.log(`   SequÃªncia procurada: ${patternToFind.join('-')}`);
    console.log(`   Tamanho: ${patternLength} giros (COMPLETOS)`);
    console.log(`   OcorrÃªncias encontradas: ${occurrences.length}`);
    
    // âœ… VALIDAR: OcorrÃªncias suficientes?
    if (occurrences.length < minOccurrences) {
        console.log(`âŒ OcorrÃªncias insuficientes: ${occurrences.length} < ${minOccurrences} (mÃ­nimo)`);
        return null;
    }
    
    // ğŸ” PASSO 3: ANALISAR RESULTADOS APÃ“S A SEQUÃŠNCIA COMPLETA
    const colorResults = {
        red: [],
        black: [],
        white: []
    };
    
    occurrences.forEach(occ => {
        if (occ.result) {
            colorResults[occ.result].push(occ);
        }
    });
    
    const redCount = colorResults.red.length;
    const blackCount = colorResults.black.length;
    const whiteCount = colorResults.white.length;
    const totalOccurrences = occurrences.length;
    
    console.log(`\nğŸ“Š RESULTADOS APÃ“S A SEQUÃŠNCIA COMPLETA:`);
    console.log(`   VERMELHO: ${redCount} vezes (${((redCount/totalOccurrences)*100).toFixed(1)}%)`);
    console.log(`   PRETO: ${blackCount} vezes (${((blackCount/totalOccurrences)*100).toFixed(1)}%)`);
    console.log(`   BRANCO: ${whiteCount} vezes (${((whiteCount/totalOccurrences)*100).toFixed(1)}%)`);
    
    // âœ… Ignorar branco se < 5%
    const whitePct = (whiteCount / totalOccurrences) * 100;
    const shouldIgnoreWhite = whitePct < 5;
    
    // ğŸ” PASSO 4: DETERMINAR COR VENCEDORA (SEM VIÃ‰S - IMPARCIAL)
    let winningColor = null;
    let winningCount = 0;
    
    // âœ… CORREÃ‡ÃƒO: Usar >= para garantir que em caso de empate, a ÃšLTIMA cor verificada ganha
    // Ordem: BLACK â†’ RED â†’ WHITE (para nÃ£o favorecer nenhuma cor especÃ­fica)
    
    if (blackCount > winningCount) {
        winningColor = 'black';
        winningCount = blackCount;
    }
    
    if (redCount >= winningCount && redCount > 0) {
        winningColor = 'red';
        winningCount = redCount;
    }
    
    if (!shouldIgnoreWhite && whiteCount >= winningCount && whiteCount > 0) {
        winningColor = 'white';
        winningCount = whiteCount;
    }
    
    if (!winningColor) {
        console.log('âŒ Nenhuma cor vencedora identificada');
        return null;
    }
    
    // âœ… CALCULAR WINS E LOSS DA COR VENCEDORA
    const totalWins = winningCount;
    const totalLoss = totalOccurrences - winningCount;
    const balance = totalWins - totalLoss;
    
    console.log(`\nğŸ¯ COR VENCEDORA: ${winningColor.toUpperCase()}`);
    console.log(`   WINS: ${totalWins}`);
    console.log(`   LOSS: ${totalLoss}`);
    console.log(`   Saldo: ${balance > 0 ? '+' : ''}${balance}`);
    
    // âœ… RECONSTRUIR NÃšMEROS E TIMESTAMPS DE CADA OCORRÃŠNCIA
    // Isso alimenta a UI para desenhar cada ocorrÃªncia completa (igual ao histÃ³rico de giros)
    const allOccurrenceNumbers = [];
    const allOccurrenceTimestamps = [];
    const allTriggerNumbers = [];
    const allTriggerTimestamps = [];
    const allTriggerColors = [];

    occurrences.forEach(occ => {
        const seqStart = occ.index;
        const seqSpins = limitedHistory.slice(seqStart, seqStart + patternLength);
        const triggerSpin = limitedHistory[seqStart + patternLength];

        allOccurrenceNumbers.push(seqSpins.map(s => s?.number ?? null));
        allOccurrenceTimestamps.push(seqSpins.map(s => s?.timestamp ?? null));
        allTriggerNumbers.push(triggerSpin ? triggerSpin.number : null);
        allTriggerTimestamps.push(triggerSpin ? triggerSpin.timestamp : null);
        allTriggerColors.push(triggerSpin ? triggerSpin.color : null);
    });
    
    // âœ… FILTRAR PADRÃ•ES FRACOS
    if (totalWins < minOccurrences) {
        console.log(`âŒ WINS insuficientes: ${totalWins} < ${minOccurrences} (mÃ­nimo)`);
        return null;
    }
    
    if (balance <= 0) {
        console.log(`âŒ Saldo nÃ£o positivo: ${balance}`);
        return null;
    }
    
    // âœ… CALCULAR CONFIANÃ‡A
    const confidence = (totalWins / totalOccurrences) * 100;
    
    console.log(`   ConfianÃ§a: ${confidence.toFixed(1)}%`);
    
    // ğŸ” PASSO 5: VERIFICAR SE PADRÃƒO ATUAL CORRESPONDE
    const currentSequence = colors.slice(0, patternLength);
    const isCurrentMatch = currentSequence.every((c, idx) => c === patternToFind[idx]);
    
    if (!isCurrentMatch) {
        console.log('âŒ SequÃªncia atual nÃ£o corresponde ao padrÃ£o encontrado');
        return null;
    }
    
    // âœ… VALIDAR TRIGGER ATUAL (se configurado)
    const currentTriggerColor = colors[patternLength];
    if (analyzerConfig.requireTrigger) {
        if (!isValidTrigger(currentTriggerColor, patternToFind)) {
            console.log('âŒ Cor de disparo atual invÃ¡lida');
            return null;
        }
    }
    
    // âœ… CONSTRUIR RESULTADO FINAL (incluindo detalhes das ocorrÃªncias para a UI)
    const bestPattern = {
        pattern: patternToFind,
        blocks: currentPattern.blocks, // ğŸ†• InformaÃ§Ã£o dos blocos (ex: 7xPRETO + 7xVERMELHO)
        suggestedColor: winningColor,
        confidence: confidence,
        occurrences: totalOccurrences,
        wins: totalWins,
        loss: totalLoss,
        balance: balance,
        triggerColor: currentTriggerColor,
        colorResults: colorResults,
        type: 'color-pattern',
        patternType: identifyPatternType(patternToFind, currentTriggerColor),
        isCurrentMatch: true,
        currentTriggerValid: true,
        createdOnTimestamp: limitedHistory[0]?.timestamp || null,
        // Arrays usados pela UI para desenhar as ocorrÃªncias
        allOccurrenceNumbers,
        allOccurrenceTimestamps,
        allTriggerNumbers,
        allTriggerTimestamps,
        allTriggerColors,
        summary: {
            occurrences: totalOccurrences,
            wins: totalWins,
            losses: totalLoss,
            winPct: confidence,
            lossPct: Math.max(0, 100 - confidence),
            patternLength: patternLength
        }
    };
    
    console.log(`âœ… PADRÃƒO COMPLETO VALIDADO!`);
    console.log(`   SequÃªncia: ${bestPattern.blocks.map(b => `${b.count}x${b.color.toUpperCase()}`).join(' + ')}`);
    console.log(`   SugestÃ£o: ${bestPattern.suggestedColor.toUpperCase()}`);
    console.log(`   WINS: ${bestPattern.wins} | LOSS: ${bestPattern.loss} | Saldo: +${bestPattern.balance}`);
    console.log(`   ConfianÃ§a: ${bestPattern.confidence.toFixed(1)}%`);
    
    return bestPattern;
}



// Verificar se a Cor de Disparo Ã© vÃ¡lida para o padrÃ£o
function normalizeColorName(color) {
	if (!color) return null;
	const c = color.toString().trim().toLowerCase();
	switch (c) {
		case 'red':
		case 'r':
		case 'vermelho':
		case 'v':
			return 'red';
		case 'black':
		case 'b':
		case 'preto':
		case 'p':
			return 'black';
		case 'white':
		case 'w':
		case 'branco':
		case 'branca':
		case '0':
			return 'white';
		default:
			return null;
	}
}

function getInitialPatternColor(patternArray) {
	if (!Array.isArray(patternArray) || patternArray.length === 0) {
		return null;
	}
	// Os padrÃµes sÃ£o armazenados do mais recente para o mais antigo.
	// A primeira cor imediatamente apÃ³s a cor de disparo Ã© o Ãºltimo elemento.
	return patternArray[patternArray.length - 1];
}

function isValidTrigger(triggerColor, patternSequence) {
    if (!patternSequence || patternSequence.length === 0) return false;
    
	const firstPatternColor = normalizeColorName(getInitialPatternColor(patternSequence));
    const trigger = normalizeColorName(triggerColor);
    
    if (!firstPatternColor || !trigger) return false;
    
    return validateDisparoColor(firstPatternColor, trigger).valid;
}

// Validar se cor de disparo Ã© OPOSTA Ã  cor inicial (regra estrita)
function validateDisparoColor(corInicial, corDisparo) {
    const initial = normalizeColorName(corInicial);
    const trigger = normalizeColorName(corDisparo);
    
    const mapping = {
        'red': ['black', 'white'],
        'black': ['red', 'white'],
        'white': ['red', 'black']
    };
    
    if (!initial || !trigger) {
        return { valid: false, reason: 'missing_color' };
    }
    
    if (initial === trigger) {
        return { valid: false, reason: 'same_as_initial' };
    }
    
    if (!mapping[initial] || !mapping[initial].includes(trigger)) {
        return { valid: false, reason: 'invalid_opposite' };
    }
    
    return { valid: true };
}

// Criar objeto de ocorrÃªncia individual (append-only)
const MAX_GALE_STAGE_TRACKED = 3;

function evaluateGaleStagesForOccurrence(history, startIndex, suggestedColor, maxStage = MAX_GALE_STAGE_TRACKED) {
	const normalizedTarget = normalizeColorName(suggestedColor);
	if (!normalizedTarget || !history) return [];
	const stages = [];
	for (let stage = 0; stage <= maxStage; stage++) {
		const resultIndex = startIndex - 1 - stage;
		if (resultIndex < 0) break;
		const spin = history[resultIndex];
		if (!spin || !spin.color) break;
		const normalizedColor = normalizeColorName(spin.color);
		if (!normalizedColor) break;
		const isWin = normalizedColor === normalizedTarget;
		stages.push({
			stage,
			stageLabel: stage === 0 ? 'G0' : `G${stage}`,
			color: normalizedColor,
			win: isWin,
			number: spin.number ?? null,
			timestamp: spin.timestamp || spin.created_at || null
		});
		if (isWin) break;
	}
	return stages;
}

function createOccurrenceRecord(patternSequence, triggerColor, resultColor, sequenceSpins, triggerSpin, index) {
	const corInicial = normalizeColorName(getInitialPatternColor(patternSequence));
    const triggerNormalized = normalizeColorName(triggerColor);
    const resultNormalized = normalizeColorName(resultColor);
	// âœ… Respeitar configuraÃ§Ã£o do usuÃ¡rio: se "Exigir cor de disparo" estiver desativado,
	// NÃƒO marcar ocorrÃªncia como invÃ¡lida sÃ³ por trigger "incompatÃ­vel".
	const requireTrigger = !!(analyzerConfig && analyzerConfig.requireTrigger);
	const validation = requireTrigger ? validateDisparoColor(corInicial, triggerNormalized) : { valid: true };

	const spinsArray = Array.isArray(sequenceSpins) ? sequenceSpins : [];
	const sequenceNumbers = spinsArray.map(spin => spin.number ?? null);
	const sequenceColors = spinsArray.map(spin => normalizeColorName(spin.color));
	const sequenceTimestamps = spinsArray.map(spin => spin.timestamp || spin.created_at || null);

	const triggerNumber = triggerSpin ? triggerSpin.number ?? null : null;
	const triggerTimestamp = triggerSpin ? (triggerSpin.timestamp || triggerSpin.created_at || null) : null;

	const occurrenceTimestamp = sequenceTimestamps[0] || triggerTimestamp || new Date().toISOString();
    
    return {
        occurrence_id: triggerSpin ? (triggerSpin.created_at || triggerSpin.timestamp || `${Date.now()}_${index}`) : `${Date.now()}_${index}`,
        index: index,
        cor_inicial: corInicial,
        cor_disparo: triggerNormalized,
        resultado: resultNormalized,
        timestamp: occurrenceTimestamp,
		sequence_numbers: sequenceNumbers,
		sequence_colors: sequenceColors,
		sequence_timestamps: sequenceTimestamps,
		trigger_number: triggerNumber,
		trigger_timestamp: triggerTimestamp,
        giro_numbers: triggerNumber != null ? [triggerNumber] : [],
        flag_invalid_disparo: requireTrigger ? !validation.valid : false,
        invalid_reason: (requireTrigger && !validation.valid) ? validation.reason : null,
        raw_trigger_color: (requireTrigger && !validation.valid) ? triggerColor : null
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IDENTIFICAR TIPO DE PADRÃƒO - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function identifyPatternType(pattern, triggerColor) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern) || pattern.length === 0) {
        console.warn('âš ï¸ PadrÃ£o invÃ¡lido para identificaÃ§Ã£o:', pattern);
        return 'PadrÃ£o Desconhecido';
    }
    
    const patternStr = pattern.join('-');
    const patternLength = pattern.length;
    
    // âœ… PADRÃƒO 1-2: REPETIÃ‡ÃƒO (todos da mesma cor)
    const isAllSameColor = pattern.every(color => color === pattern[0]);
    if (isAllSameColor) {
        if (pattern[0] === 'red') return 'RepetiÃ§Ã£o Vermelha';
        if (pattern[0] === 'black') return 'RepetiÃ§Ã£o Preta';
        if (pattern[0] === 'white') return 'RepetiÃ§Ã£o Branca';
    }
    
    // âœ… PADRÃƒO 3-5: ALTERNÃ‚NCIA (cores alternadas)
    if (isAlternatingPattern(pattern)) {
        if (patternLength === 4) return 'AlternÃ¢ncia Curta (4 giros)';
        if (patternLength === 5) return 'AlternÃ¢ncia Longa (5 giros)';
        if (patternLength > 5) return `AlternÃ¢ncia Extendida (${patternLength} giros)`;
        return 'AlternÃ¢ncia Quebrada';
    }
    
    // âœ… PADRÃƒO 6: DUPLA ALTERNÃ‚NCIA (pares alternados)
    if (isDoubleAlternatingPattern(pattern)) {
        return 'Dupla AlternÃ¢ncia';
    }
    
    // âœ… PADRÃƒO 7: INVERSÃƒO RÃPIDA (2 iguais + mudanÃ§a)
    if (patternLength >= 4) {
        const hasQuickInversion = pattern[0] === pattern[1] && pattern[1] !== pattern[2];
        if (hasQuickInversion) {
        return 'InversÃ£o RÃ¡pida';
        }
    }
    
    // âœ… PADRÃƒO 8-9: DOMINÃ‚NCIA (5+ cores da mesma)
    if (patternLength >= 5 && isAllSameColor) {
        const dominantColor = pattern[0];
        if (dominantColor === 'red') return `DominÃ¢ncia Vermelha (${patternLength} giros)`;
        if (dominantColor === 'black') return `DominÃ¢ncia Preta (${patternLength} giros)`;
        if (dominantColor === 'white') return `DominÃ¢ncia Branca (${patternLength} giros)`;
    }
    
    // âœ… PADRÃƒO 10: CORREÃ‡ÃƒO DE COR (metade de uma cor, metade de outra)
    if (isCorrectionPattern(pattern)) {
        return 'CorreÃ§Ã£o de Cor';
    }
    
    // âœ… PADRÃ•ES COM BRANCO
    const hasWhite = pattern.includes('white');
    if (hasWhite) {
        return identifyWhitePattern(pattern);
    }
    
    // âœ… PADRÃƒO GENÃ‰RICO
    return `PadrÃ£o Personalizado (${patternLength} giros)`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERIFICAR PADRÃƒO DE ALTERNÃ‚NCIA - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function isAlternatingPattern(pattern) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern)) {
        return false;
    }
    
    // âœ… MÃNIMO 4 CORES NECESSÃRIO
    if (pattern.length < 4) {
        return false;
    }
    
    // âœ… VERIFICAR SE CADA COR Ã‰ DIFERENTE DA ANTERIOR
    for (let i = 1; i < pattern.length; i++) {
        // Se encontrar duas cores iguais consecutivas, nÃ£o Ã© alternÃ¢ncia
        if (pattern[i] === pattern[i - 1]) {
            return false;
    }
    }
    
    // âœ… TODAS AS CORES ALTERNADAS
    return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERIFICAR DUPLA ALTERNÃ‚NCIA - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function isDoubleAlternatingPattern(pattern) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern)) {
        return false;
    }
    
    // âœ… MÃNIMO 4 CORES NECESSÃRIO (2 pares)
    if (pattern.length < 4) {
        return false;
    }
    
    // âœ… VERIFICAR SE CADA PAR Ã‰ IDÃŠNTICO
    // PadrÃ£o: AA BB AA BB (cada par de cores iguais, pares alternados)
    for (let i = 0; i < pattern.length - 1; i += 2) {
        // Verificar se hÃ¡ Ã­ndice suficiente
        if (i + 1 >= pattern.length) {
            break;
        }
        
        // Par atual deve ter cores iguais
        if (pattern[i] !== pattern[i + 1]) {
            return false;
        }
    }
    
    // âœ… TODOS OS PARES SÃƒO VÃLIDOS
    return true;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERIFICAR PADRÃƒO DE CORREÃ‡ÃƒO - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function isCorrectionPattern(pattern) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern)) {
        return false;
    }
    
    // âœ… MÃNIMO 5 CORES NECESSÃRIO
    if (pattern.length < 5) {
        return false;
    }
    
    // âœ… DIVIDIR EM DUAS METADES
    const midPoint = Math.floor(pattern.length / 2);
    const firstHalf = pattern.slice(0, midPoint);
    const secondHalf = pattern.slice(midPoint);
    
    // âœ… VALIDAR METADES
    if (firstHalf.length === 0 || secondHalf.length === 0) {
        return false;
    }
    
    // âœ… PRIMEIRA METADE: TODAS DA MESMA COR
    const firstHalfSameColor = firstHalf.every(color => color === firstHalf[0]);
    
    // âœ… SEGUNDA METADE: TODAS DA MESMA COR
    const secondHalfSameColor = secondHalf.every(color => color === secondHalf[0]);
    
    // âœ… AS DUAS METADES DEVEM TER CORES DIFERENTES
    const differentColors = firstHalf[0] !== secondHalf[0];
    
    return firstHalfSameColor && secondHalfSameColor && differentColors;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IDENTIFICAR PADRÃ•ES COM BRANCO - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function identifyWhitePattern(pattern) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA
    if (!pattern || !Array.isArray(pattern)) {
        console.warn('âš ï¸ PadrÃ£o invÃ¡lido para identificaÃ§Ã£o de branco:', pattern);
        return 'PadrÃ£o Desconhecido';
    }
    
    // âœ… CONTAR QUANTOS BRANCOS
    const whiteCount = pattern.filter(color => color === 'white').length;
    
    // âœ… IDENTIFICAR TIPO BASEADO NA QUANTIDADE
    if (whiteCount === 0) {
        return 'Sem Branco';
    } else if (whiteCount === 1) {
        // Verificar posiÃ§Ã£o do branco
        const whiteIndex = pattern.indexOf('white');
        if (whiteIndex === 0) {
            return 'Branco Inicial';
        } else if (whiteIndex === pattern.length - 1) {
            return 'Branco Final';
        } else {
            return 'Branco Isolado (meio)';
        }
    } else if (whiteCount === 2) {
        // Verificar se sÃ£o consecutivos
        const firstWhiteIndex = pattern.indexOf('white');
        const lastWhiteIndex = pattern.lastIndexOf('white');
        
        if (lastWhiteIndex - firstWhiteIndex === 1) {
            return 'Duplo Branco Consecutivo';
        } else {
            return 'Duplo Branco EspaÃ§ado';
        }
    } else if (whiteCount === 3) {
        return 'Triplo Branco';
    } else if (whiteCount >= pattern.length / 2) {
        return `DominÃ¢ncia Branca (${whiteCount}/${pattern.length})`;
    } else {
        return `PadrÃ£o Misto com Branco (${whiteCount}x)`;
    }
}

// Analisar sequÃªncias recorrentes no histÃ³rico (funÃ§Ã£o antiga mantida para compatibilidade)
function analyzeRecurrentSequences(history) {
    const currentCreatedOn = history[0] ? history[0].timestamp : null;

    // Procura padrÃµes exatos de tamanhos 5 a 8 (mais confiÃ¡veis)
    const bestCandidates = [];
    for (let win = 5; win <= 8; win++) {
        if (history.length < win + 2) continue; // Precisa de pelo menos win + 2 para analisar o prÃ³ximo
        
        // CORRIGIDO: Verificar se o padrÃ£o atual estÃ¡ QUASE COMPLETO (faltando 1 giro)
        const currentSequence = history.slice(0, win).map(s => s.color); // PadrÃ£o completo atual
        const sequences = {};

        for (let i = win; i < history.length - 1; i++) {
            // Buscar padrÃµes que estÃ£o QUASE COMPLETOS (faltando 1 giro)
            const windowSlice = history.slice(i, i + win); // PadrÃ£o completo
            const pastSequence = windowSlice.map(s => s.color);
            const isExactMatch = pastSequence.every((c, idx) => c === currentSequence[idx]);
            if (!isExactMatch) continue;

            // Analisar o giro que COMPLETOU o padrÃ£o (o giro seguinte)
            const completingColor = history[i - 1].color; // O giro que completou o padrÃ£o
            const sequenceKey = pastSequence.join('-');
            if (!sequences[sequenceKey]) {
                sequences[sequenceKey] = {
                    pattern: pastSequence,
                    outcomes: [],
                    count: 0,
                    occurrenceTimes: [],
                    lastOccurrenceTimestamps: [],
                    lastOccurrenceNumbers: []
                };
            }
            sequences[sequenceKey].outcomes.push(completingColor);
            sequences[sequenceKey].count++;
            const occurrenceEndTimestamp = history[i - 1] && history[i - 1].timestamp ? history[i - 1].timestamp : (history[i] && history[i].timestamp);
            if (occurrenceEndTimestamp) sequences[sequenceKey].occurrenceTimes.push(occurrenceEndTimestamp);
            sequences[sequenceKey].lastOccurrenceTimestamps = windowSlice.map(s => s.timestamp);
            sequences[sequenceKey].lastOccurrenceNumbers = windowSlice.map(s => s.number);
        }

        const analyzed = Object.values(sequences).map(seq => {
            const colorCounts = {};
            seq.outcomes.forEach(color => { colorCounts[color] = (colorCounts[color] || 0) + 1; });
            // âœ… CORREÃ‡ÃƒO: Usar primeira chave disponÃ­vel em vez de 'red' como padrÃ£o
            const keys = Object.keys(colorCounts);
            if (keys.length === 0) return null;
            const mostFrequentColor = keys.reduce((a, b) => colorCounts[a] >= colorCounts[b] ? a : b);
            const accuracy = (colorCounts[mostFrequentColor] / seq.outcomes.length) * 100;
            
            // ValidaÃ§Ã£o estatÃ­stica: verificar se nÃ£o Ã© distribuiÃ§Ã£o aleatÃ³ria
            const totalOutcomes = seq.outcomes.length;
            const expectedRandom = totalOutcomes / 3; // Esperado se fosse aleatÃ³rio (3 cores)
            const actualCount = colorCounts[mostFrequentColor];
            const statisticalSignificance = actualCount / expectedRandom;
            
            // SÃ³ aceitar se for estatisticamente significativo (pelo menos 2.0x o esperado para 80%+ acertividade)
            if (statisticalSignificance < 2.0) {
                return null;
            }
            
            return {
                type: 'sequence',
                pattern: seq.pattern,
                window: win,
                suggestedColor: mostFrequentColor, // Cor que mais frequentemente COMPLETOU o padrÃ£o
                accuracy: accuracy,
                occurrences: seq.count,
                occurrenceTimes: seq.occurrenceTimes.sort((a,b) => new Date(b) - new Date(a)),
                lastOccurrenceTimestamps: Array.isArray(seq.lastOccurrenceTimestamps) ? seq.lastOccurrenceTimestamps : [],
                lastOccurrenceNumbers: Array.isArray(seq.lastOccurrenceNumbers) ? seq.lastOccurrenceNumbers : [],
                confidence: accuracy,
                statisticalSignificance: statisticalSignificance,
                createdOnTimestamp: currentCreatedOn
            };
        }).filter(analysis => analysis !== null);

        if (analyzed.length > 0) {
            analyzed.sort((a, b) => (b.confidence - a.confidence) || (b.occurrences - a.occurrences));
            bestCandidates.push(analyzed[0]);
        }
    }

    if (bestCandidates.length === 0) return null;
    bestCandidates.sort((a, b) => (b.confidence - a.confidence) || (b.occurrences - a.occurrences) || (b.window - a.window));
    return bestCandidates[0];
}

// ANÃLISE DE PADRÃ•ES NUMÃ‰RICOS E CORRELATIVOS (baseada nos exemplos 34-50)
function analyzeNumberPatterns(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    const numbers = history.map(s => s.number);
    const colors = history.map(s => s.color);
    const bestPatterns = [];
    
    // 0. NOVO: PadrÃµes nÃºmero+cor â†’ prÃ³xima cor (ex.: 1 vermelho + 14 preto â†’ preto)
    const numberColorPair = analyzeNumberColorPairs(history);
    if (numberColorPair) bestPatterns.push(numberColorPair);
    
    // 1. PADRÃƒO NUMÃ‰RICO 1-4: CorrelaÃ§Ãµes Simples e Estendidas
    const correlationPatterns = analyzeNumberCorrelations(numbers, colors);
    if (correlationPatterns) bestPatterns.push(correlationPatterns);
    
    // 2. PADRÃƒO NUMÃ‰RICO 5-7: SequÃªncias Especiais
    const sequencePatterns = analyzeSpecialSequences(numbers, colors);
    if (sequencePatterns) bestPatterns.push(sequencePatterns);
    
    // 3. (DESATIVADO) PadrÃµes MatemÃ¡ticos por soma â€“ removido para evitar falso positivo de soma
    // const mathPatterns = analyzeMathematicalPatterns(numbers, colors);
    // if (mathPatterns) bestPatterns.push(mathPatterns);
    
    // 4. PADRÃƒO NUMÃ‰RICO 13-17: PadrÃµes AvanÃ§ados
    const advancedPatterns = analyzeAdvancedPatterns(numbers, colors);
    if (advancedPatterns) bestPatterns.push(advancedPatterns);
    
    if (bestPatterns.length === 0) return null;
    
    // Selecionar melhor padrÃ£o dentre os candidatos
    const bestPattern = bestPatterns.sort((a, b) => (b.confidence - a.confidence) || (b.occurrences - a.occurrences))[0];
    
    // VerificaÃ§Ã£o por tipo
    if (bestPattern.type === 'number-color-pair') {
        // Checar se o head atual bate com o par nÃºmero+cor
        if (history.length < 2) return null;
        const headPair = [history[1], history[0]]; // mais antigo â†’ mais recente
        const p = bestPattern.pair; // [{number,color},{number,color}]
        const isMatch = p && p.length === 2 &&
                        headPair[0].number === p[0].number && headPair[0].color === p[0].color &&
                        headPair[1].number === p[1].number && headPair[1].color === p[1].color;
        if (!isMatch) {
            console.log('âŒ Par nÃºmero+cor nÃ£o corresponde ao head atual:', { pair: p, head: [{n: headPair[0].number, c: headPair[0].color},{n: headPair[1].number, c: headPair[1].color}] });
            return null;
        }
        console.log('âœ… Par nÃºmero+cor confirma o padrÃ£o encontrado:', { pair: p, suggested: bestPattern.suggestedColor, conf: bestPattern.confidence.toFixed(1)+'%' });
        return bestPattern;
    }
    
    // Demais padrÃµes numÃ©ricos: manter verificaÃ§Ã£o por nÃºmeros puros
    const patternNumbers = bestPattern.pattern.split('â†’').map(n => parseInt(n));
    const currentNumbers = numbers.slice(0, patternNumbers.length);
    const isCurrentPatternMatch = currentNumbers.every((num, index) => num === patternNumbers[index]);
    if (!isCurrentPatternMatch) {
        console.log('âŒ PadrÃ£o numÃ©rico encontrado nÃ£o corresponde ao padrÃ£o atual:', {
            foundPattern: patternNumbers,
            currentNumbers: currentNumbers,
            isMatch: isCurrentPatternMatch
        });
        return null;
    }
    console.log('âœ… PadrÃ£o numÃ©rico atual confirma o padrÃ£o encontrado:', { foundPattern: patternNumbers, currentNumbers: currentNumbers, isMatch: isCurrentPatternMatch });
    return bestPattern;
}

// Analisar correlaÃ§Ãµes numÃ©ricas (PadrÃµes 1-4)
function analyzeNumberCorrelations(numbers, colors) {
    const correlations = {};
    
    // Buscar sequÃªncias de 2-3 nÃºmeros e suas correlaÃ§Ãµes
    for (let i = 2; i < numbers.length - 1; i++) {
        // PadrÃ£o 1: CorrelaÃ§Ã£o Simples (5â†’11)
        const seq2 = [numbers[i+1], numbers[i]];
        const seq2Key = seq2.join('â†’');
        const resultColor = colors[i-1];
        
        if (!correlations[seq2Key]) {
            correlations[seq2Key] = {
                pattern: seq2,
                outcomes: [],
                count: 0,
                occurrenceTimes: [],
                lastOccurrenceNumbers: []
            };
        }
        
        correlations[seq2Key].outcomes.push(resultColor);
        correlations[seq2Key].count++;
        correlations[seq2Key].occurrenceTimes.push(new Date().toISOString());
        correlations[seq2Key].lastOccurrenceNumbers = seq2;
        
        // PadrÃ£o 2: CorrelaÃ§Ã£o Estendida (10â†’1â†’6)
        if (i >= 2) {
            const seq3 = [numbers[i+2], numbers[i+1], numbers[i]];
            const seq3Key = seq3.join('â†’');
            
            if (!correlations[seq3Key]) {
                correlations[seq3Key] = {
                    pattern: seq3,
                    outcomes: [],
                    count: 0,
                    occurrenceTimes: [],
                    lastOccurrenceNumbers: []
                };
            }
            
            correlations[seq3Key].outcomes.push(resultColor);
            correlations[seq3Key].count++;
            correlations[seq3Key].occurrenceTimes.push(new Date().toISOString());
            correlations[seq3Key].lastOccurrenceNumbers = seq3;
        }
    }
    
    // Analisar correlaÃ§Ãµes encontradas
    const validPatterns = [];
    Object.values(correlations).forEach(pattern => {
        if (pattern.count < 3) return; // MÃ­nimo 3 ocorrÃªncias
        
        const colorCounts = {};
        pattern.outcomes.forEach(color => {
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        });
        
        const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
            colorCounts[a] > colorCounts[b] ? a : b, 'red');
        
        const accuracy = (colorCounts[mostFrequentColor] / pattern.outcomes.length) * 100;
        const statisticalSignificance = colorCounts[mostFrequentColor] / (pattern.outcomes.length / 3);
        
        // âœ… Calcular WINS e LOSSES
        const wins = colorCounts[mostFrequentColor] || 0;
        const losses = pattern.outcomes.length - wins;
        
        if (accuracy >= 75 && statisticalSignificance >= 2.0) {
            validPatterns.push({
                type: 'number-correlation',
                pattern: pattern.pattern.join('â†’'),
                suggestedColor: mostFrequentColor,
                confidence: accuracy,
                occurrences: pattern.count,
                wins: wins,  // âœ… ADICIONADO
                losses: losses,  // âœ… ADICIONADO
                occurrenceTimes: pattern.occurrenceTimes,
                lastOccurrenceNumbers: pattern.lastOccurrenceNumbers,
                statisticalSignificance: statisticalSignificance,
                patternType: pattern.pattern.length === 2 ? 'CorrelaÃ§Ã£o Simples' : 'CorrelaÃ§Ã£o Estendida'
            });
        }
    });
    
    return validPatterns.length > 0 ? validPatterns[0] : null;
}

// NOVO: analisar pares de nÃºmero+cor consecutivos que levam a prÃ³xima cor
function analyzeNumberColorPairs(history) {
    if (!history || history.length < 3) return null;
    const pairMap = new Map();
    // Percorre janelas de 3 giros: [i+2, i+1] determinam o par, outcome Ã© i (giro seguinte)
    for (let i = 1; i < history.length - 1; i++) {
        const a = history[i+1]; // mais antigo no par
        const b = history[i];   // mais recente no par
        const outcome = history[i-1]; // prÃ³xima cor apÃ³s o par
        if (!a || !b || !outcome) continue;
        const key = `${a.number}-${a.color}|${b.number}-${b.color}`;
        let rec = pairMap.get(key);
        if (!rec) {
            rec = { pair: [{ number: a.number, color: a.color }, { number: b.number, color: b.color }], outcomes: [], count: 0 };
            pairMap.set(key, rec);
        }
        rec.outcomes.push(outcome.color);
        rec.count++;
    }
    // Avaliar pares
    const candidates = [];
    pairMap.forEach(rec => {
        if (rec.count < 3) return; // mÃ­nimo 3 ocorrÃªncias do par
        const counts = {};
        rec.outcomes.forEach(c => counts[c] = (counts[c] || 0) + 1);
        // âœ… CORREÃ‡ÃƒO: Usar primeira chave disponÃ­vel em vez de 'red' como padrÃ£o
        const keys = Object.keys(counts);
        if (keys.length === 0) return;
        const winner = keys.reduce((a, b) => counts[a] >= counts[b] ? a : b);
        const acc = (counts[winner] / rec.outcomes.length) * 100;
        const signif = counts[winner] / (rec.outcomes.length / 3);
        if (acc >= 70 && signif >= 1.8) {
            candidates.push({
                type: 'number-color-pair',
                pair: rec.pair,
                suggestedColor: winner,
                confidence: acc,
                occurrences: rec.count,
                statisticalSignificance: signif,
                pattern: `${rec.pair[0].number}-${rec.pair[0].color} + ${rec.pair[1].number}-${rec.pair[1].color}`
            });
        }
    });
    if (candidates.length === 0) return null;
    candidates.sort((a,b)=> (b.confidence - a.confidence) || (b.occurrences - a.occurrences));
    return candidates[0];
}

// Analisar sequÃªncias especiais (PadrÃµes 5-7)
function analyzeSpecialSequences(numbers, colors) {
    const specialPatterns = [];
    
    for (let i = 2; i < numbers.length - 1; i++) {
        const currentNumbers = [numbers[i+2], numbers[i+1], numbers[i]];
        const resultColor = colors[i-1];
        
        // PadrÃ£o 5: Pares Crescentes (2â†’4â†’6)
        if (isAscendingEvenSequence(currentNumbers)) {
            specialPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'Pares Crescentes'
            });
        }
        
        // PadrÃ£o 6: Ãmpares Decrescentes (13â†’11â†’9)
        if (isDescendingOddSequence(currentNumbers)) {
            specialPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'Ãmpares Decrescentes'
            });
        }
        
        // PadrÃ£o 7: Retorno ao MÃºltiplo de 5 (5â†’10â†’0)
        if (isMultipleOfFiveSequence(currentNumbers)) {
            specialPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'MÃºltiplos de 5'
            });
        }
    }
    
    // Analisar padrÃµes especiais encontrados
    const analyzedPatterns = {};
    specialPatterns.forEach(pattern => {
        const key = `${pattern.type}-${pattern.pattern}`;
        if (!analyzedPatterns[key]) {
            analyzedPatterns[key] = {
                pattern: pattern.pattern,
                type: pattern.type,
                outcomes: [],
                count: 0
            };
        }
        analyzedPatterns[key].outcomes.push(pattern.outcome);
        analyzedPatterns[key].count++;
    });
    
    // Retornar o melhor padrÃ£o especial
    const validSpecialPatterns = [];
    Object.values(analyzedPatterns).forEach(pattern => {
        if (pattern.count < 3) return;
        
        const colorCounts = {};
        pattern.outcomes.forEach(color => {
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        });
        
        const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
            colorCounts[a] > colorCounts[b] ? a : b, 'red');
        
        const accuracy = (colorCounts[mostFrequentColor] / pattern.outcomes.length) * 100;
        const statisticalSignificance = colorCounts[mostFrequentColor] / (pattern.outcomes.length / 3);
        
        if (accuracy >= 75 && statisticalSignificance >= 2.0) {
            validSpecialPatterns.push({
                type: 'number-sequence',
                pattern: pattern.pattern,
                suggestedColor: mostFrequentColor,
                confidence: accuracy,
                occurrences: pattern.count,
                statisticalSignificance: statisticalSignificance,
                patternType: pattern.type
            });
        }
    });
    
    return validSpecialPatterns.length > 0 ? validSpecialPatterns[0] : null;
}

// Analisar padrÃµes matemÃ¡ticos (PadrÃµes 8-12)
function analyzeMathematicalPatterns(numbers, colors) {
    const mathPatterns = [];
    
    for (let i = 1; i < numbers.length - 1; i++) {
        const num1 = numbers[i+1];
        const num2 = numbers[i];
        const resultColor = colors[i-1];
        
        // PadrÃ£o 8: DuplicaÃ§Ã£o Reversa
        if (num1 === num2) {
            mathPatterns.push({
                pattern: `${num1}â†’${num2}`,
                outcome: resultColor,
                type: 'DuplicaÃ§Ã£o Reversa'
            });
        }
        
        // PadrÃ£o 9: SequÃªncia de extremos (1â†’14 ou 14â†’1)
        if ((num1 === 1 && num2 === 14) || (num1 === 14 && num2 === 1)) {
            mathPatterns.push({
                pattern: `${num1}â†’${num2}`,
                outcome: resultColor,
                type: 'Extremos Consecutivos'
            });
        }
        
        // PadrÃ£o 10: Soma mÃºltipla de 5
        if ((num1 + num2) % 5 === 0) {
            mathPatterns.push({
                pattern: `${num1}+${num2}=${num1+num2}`,
                outcome: resultColor,
                type: 'Soma MÃºltipla de 5'
            });
        }
        
        // PadrÃ£o 11: AlternÃ¢ncia Ãmpar/Par
        if ((num1 % 2 !== num2 % 2) && getColorFromNumber(num1) === getColorFromNumber(num2)) {
            mathPatterns.push({
                pattern: `${num1}â†’${num2}`,
                outcome: resultColor,
                type: 'AlternÃ¢ncia Ãmpar/Par'
            });
        }
        
        // PadrÃ£o 12: InversÃ£o de Extremidade
        if ((num1 >= 12 && num2 <= 3) || (num1 <= 3 && num2 >= 12)) {
            mathPatterns.push({
                pattern: `${num1}â†’${num2}`,
                outcome: resultColor,
                type: 'InversÃ£o de Extremidade'
            });
        }
    }
    
    // Analisar padrÃµes matemÃ¡ticos encontrados
    const analyzedMathPatterns = {};
    mathPatterns.forEach(pattern => {
        const key = `${pattern.type}-${pattern.pattern}`;
        if (!analyzedMathPatterns[key]) {
            analyzedMathPatterns[key] = {
                pattern: pattern.pattern,
                type: pattern.type,
                outcomes: [],
                count: 0
            };
        }
        analyzedMathPatterns[key].outcomes.push(pattern.outcome);
        analyzedMathPatterns[key].count++;
    });
    
    // Retornar o melhor padrÃ£o matemÃ¡tico
    const validMathPatterns = [];
    Object.values(analyzedMathPatterns).forEach(pattern => {
        if (pattern.count < 3) return;
        
        const colorCounts = {};
        pattern.outcomes.forEach(color => {
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        });
        
        const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
            colorCounts[a] > colorCounts[b] ? a : b, 'red');
        
        const accuracy = (colorCounts[mostFrequentColor] / pattern.outcomes.length) * 100;
        const statisticalSignificance = colorCounts[mostFrequentColor] / (pattern.outcomes.length / 3);
        
        if (accuracy >= 75 && statisticalSignificance >= 2.0) {
            validMathPatterns.push({
                type: 'number-math',
                pattern: pattern.pattern,
                suggestedColor: mostFrequentColor,
                confidence: accuracy,
                occurrences: pattern.count,
                statisticalSignificance: statisticalSignificance,
                patternType: pattern.type
            });
        }
    });
    
    return validMathPatterns.length > 0 ? validMathPatterns[0] : null;
}

// Analisar padrÃµes avanÃ§ados (PadrÃµes 13-17)
function analyzeAdvancedPatterns(numbers, colors) {
    const advancedPatterns = [];
    
    for (let i = 2; i < numbers.length - 1; i++) {
        const currentNumbers = [numbers[i+2], numbers[i+1], numbers[i]];
        const resultColor = colors[i-1];
        
        // PadrÃ£o 13: RepetiÃ§Ã£o de Bloco
        if (isSameColorBlock(currentNumbers)) {
            advancedPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'RepetiÃ§Ã£o de Bloco'
            });
        }
        
        // PadrÃ£o 14: Branco em Intervalo Fixo (simulado)
        if (currentNumbers.includes(0)) {
            advancedPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'Branco em Intervalo'
            });
        }
        
        // PadrÃ£o 15: RepetiÃ§Ã£o por HorÃ¡rio (simulado)
        const hour = new Date().getHours();
        if (hour >= 22 || hour <= 2) { // HorÃ¡rio noturno
            advancedPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'PadrÃ£o Noturno'
            });
        }
        
        // PadrÃ£o 16: Tripla CorrelaÃ§Ã£o Inversa
        if (isTripleSameColor(currentNumbers)) {
            advancedPatterns.push({
                pattern: currentNumbers.join('â†’'),
                outcome: resultColor,
                type: 'Tripla CorrelaÃ§Ã£o Inversa'
            });
        }
        
        // PadrÃ£o 17: Espelhamento de Intervalo
        if (i >= 10) {
            const mirrorNumbers = [numbers[i+12], numbers[i+11], numbers[i+10]];
            if (isMirrorSequence(currentNumbers, mirrorNumbers)) {
                advancedPatterns.push({
                    pattern: currentNumbers.join('â†’'),
                    outcome: resultColor,
                    type: 'Espelhamento de Intervalo'
                });
            }
        }
    }
    
    // Analisar padrÃµes avanÃ§ados encontrados
    const analyzedAdvancedPatterns = {};
    advancedPatterns.forEach(pattern => {
        const key = `${pattern.type}-${pattern.pattern}`;
        if (!analyzedAdvancedPatterns[key]) {
            analyzedAdvancedPatterns[key] = {
                pattern: pattern.pattern,
                type: pattern.type,
                outcomes: [],
                count: 0
            };
        }
        analyzedAdvancedPatterns[key].outcomes.push(pattern.outcome);
        analyzedAdvancedPatterns[key].count++;
    });
    
    // Retornar o melhor padrÃ£o avanÃ§ado
    const validAdvancedPatterns = [];
    Object.values(analyzedAdvancedPatterns).forEach(pattern => {
        if (pattern.count < 3) return;
        
        const colorCounts = {};
        pattern.outcomes.forEach(color => {
            colorCounts[color] = (colorCounts[color] || 0) + 1;
        });
        
        const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
            colorCounts[a] > colorCounts[b] ? a : b, 'red');
        
        const accuracy = (colorCounts[mostFrequentColor] / pattern.outcomes.length) * 100;
        const statisticalSignificance = colorCounts[mostFrequentColor] / (pattern.outcomes.length / 3);
        
        if (accuracy >= 75 && statisticalSignificance >= 2.0) {
            validAdvancedPatterns.push({
                type: 'number-advanced',
                pattern: pattern.pattern,
                suggestedColor: mostFrequentColor,
                confidence: accuracy,
                occurrences: pattern.count,
                statisticalSignificance: statisticalSignificance,
                patternType: pattern.type
            });
        }
    });
    
    return validAdvancedPatterns.length > 0 ? validAdvancedPatterns[0] : null;
}

// FunÃ§Ãµes auxiliares para anÃ¡lise numÃ©rica
function isAscendingEvenSequence(numbers) {
    return numbers.every(num => num % 2 === 0) && 
           numbers[0] < numbers[1] && numbers[1] < numbers[2];
}

function isDescendingOddSequence(numbers) {
    return numbers.every(num => num % 2 === 1) && 
           numbers[0] > numbers[1] && numbers[1] > numbers[2];
}

function isMultipleOfFiveSequence(numbers) {
    return numbers.every(num => num % 5 === 0);
}

function isSameColorBlock(numbers) {
    // âœ… VALIDAR se todos os nÃºmeros sÃ£o vÃ¡lidos
    if (!numbers || numbers.some(num => num === undefined || num === null)) {
        return false;
    }
    const colors = numbers.map(num => getColorFromNumber(num));
    return colors.every(color => color === colors[0] && color !== 'unknown');
}

function isTripleSameColor(numbers) {
    // âœ… VALIDAR se todos os nÃºmeros sÃ£o vÃ¡lidos
    if (!numbers || numbers.some(num => num === undefined || num === null)) {
        return false;
    }
    const colors = numbers.map(num => getColorFromNumber(num));
    return colors.every(color => color === colors[0] && color !== 'unknown');
}

function isMirrorSequence(seq1, seq2) {
    if (seq1.length !== seq2.length) return false;
    for (let i = 0; i < seq1.length; i++) {
        if (seq1[i] !== seq2[seq2.length - 1 - i]) return false;
    }
    return true;
}

// ANÃLISE DE PADRÃ•ES NUMÃ‰RICOS MULTIDIMENSIONAL (funÃ§Ã£o antiga mantida para compatibilidade)
function analyzeNumberPatternsOld(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const numbers = history.map(s => s.number);
    const colors = history.map(s => s.color);
    
    // 1. ANÃLISE DE SEQUÃŠNCIAS NUMÃ‰RICAS
    const sequencePattern = analyzeNumberSequences(numbers);
    
    // 2. ANÃLISE DE PARIDADE
    const parityPattern = analyzeParityPatterns(numbers, colors);
    
    // 3. ANÃLISE DE FAIXAS NUMÃ‰RICAS
    const rangePattern = analyzeNumberRanges(numbers, colors);
    
    // 4. ANÃLISE DE DÃGITOS
    const digitPattern = analyzeDigitPatterns(numbers, colors);
    
    // 5. ANÃLISE DE PROGRESSÃ•ES MATEMÃTICAS
    const mathPattern = analyzeMathProgressions(numbers, colors);
    
    // Combinar todas as anÃ¡lises numÃ©ricas
    const patterns = [sequencePattern, parityPattern, rangePattern, digitPattern, mathPattern].filter(p => p !== null);
    
    if (patterns.length === 0) return null;
    
    // Encontrar o padrÃ£o com maior confianÃ§a
    const bestPattern = patterns.sort((a, b) => b.confidence - a.confidence)[0];
    
    return {
        type: 'number',
        pattern: bestPattern.pattern,
        suggestedNumber: bestPattern.suggestedNumber,
        suggestedColor: bestPattern.suggestedColor,
        confidence: bestPattern.confidence,
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.statisticalSignificance,
        subPatterns: patterns.map(p => ({ type: p.type, confidence: p.confidence }))
    };
}

// Analisar sequÃªncias numÃ©ricas (1-2-3-4-5, 10-20-30-40-50)
function analyzeNumberSequences(numbers) {
    const sequences = {};
    
    // Procurar sequÃªncias de 2-5 nÃºmeros
    for (let len = 2; len <= 5; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            const key = sequence.join('-');
            
            if (!sequences[key]) {
                sequences[key] = {
                    pattern: sequence,
                    occurrences: 0,
                    nextNumbers: [],
                    nextColors: []
                };
            }
            
            sequences[key].occurrences++;
            
            // Se nÃ£o Ã© a Ãºltima sequÃªncia, pegar o prÃ³ximo nÃºmero
            if (i > 0) {
                sequences[key].nextNumbers.push(numbers[i - 1]);
                // Assumir cor baseada no nÃºmero (serÃ¡ refinado depois)
                sequences[key].nextColors.push(getColorFromNumber(numbers[i - 1]));
            }
        }
    }
    
    // Encontrar sequÃªncias mais frequentes
    const frequentSequences = Object.values(sequences).filter(s => s.occurrences >= 2);
    if (frequentSequences.length === 0) return null;
    
    const bestSequence = frequentSequences.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³xima cor mais provÃ¡vel
    const colorCounts = {};
    bestSequence.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestSequence.nextColors.length) * 100;
    
    return {
        type: 'sequence',
        pattern: `SequÃªncia: ${bestSequence.pattern.join('-')}`,
        suggestedNumber: bestSequence.pattern[bestSequence.pattern.length - 1] + 1, // PrÃ³ximo na sequÃªncia
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 85),
        occurrences: bestSequence.occurrences,
        statisticalSignificance: bestSequence.occurrences / 2 // Normalizar
    };
}

// Analisar padrÃµes de paridade (pares/Ã­mpares)
function analyzeParityPatterns(numbers, colors) {
    const parityPatterns = {};
    
    // Procurar padrÃµes de paridade de 2-5 giros
    for (let len = 2; len <= 5; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            const parity = sequence.map(n => n % 2 === 0 ? 'par' : 'Ã­mpar');
            const key = parity.join('-');
            
            if (!parityPatterns[key]) {
                parityPatterns[key] = {
                    pattern: parity,
                    occurrences: 0,
                    nextParity: [],
                    nextColors: []
                };
            }
            
            parityPatterns[key].occurrences++;
            
            if (i > 0) {
                parityPatterns[key].nextParity.push(numbers[i - 1] % 2 === 0 ? 'par' : 'Ã­mpar');
                parityPatterns[key].nextColors.push(colors[i - 1]);
            }
        }
    }
    
    const frequentPatterns = Object.values(parityPatterns).filter(p => p.occurrences >= 2);
    if (frequentPatterns.length === 0) return null;
    
    const bestPattern = frequentPatterns.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³xima paridade e cor
    const colorCounts = {};
    bestPattern.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestPattern.nextColors.length) * 100;
    
    return {
        type: 'parity',
        pattern: `Paridade: ${bestPattern.pattern.join('-')}`,
        suggestedNumber: bestPattern.pattern[bestPattern.pattern.length - 1] === 'par' ? 'Ã­mpar' : 'par',
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 80),
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.occurrences / 2
    };
}

// Analisar faixas numÃ©ricas (1-7, 8-14, 0)
function analyzeNumberRanges(numbers, colors) {
    const rangePatterns = {};
    
    // Procurar padrÃµes de faixas de 2-5 giros
    for (let len = 2; len <= 5; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            const ranges = sequence.map(n => {
                if (n === 0) return 'branco';
                if (n >= 1 && n <= 7) return 'vermelho';
                if (n >= 8 && n <= 14) return 'preto';
                return 'outro';
            });
            const key = ranges.join('-');
            
            if (!rangePatterns[key]) {
                rangePatterns[key] = {
                    pattern: ranges,
                    occurrences: 0,
                    nextRanges: [],
                    nextColors: []
                };
            }
            
            rangePatterns[key].occurrences++;
            
            if (i > 0) {
                const nextNum = numbers[i - 1];
                const nextRange = nextNum === 0 ? 'branco' : 
                                 (nextNum >= 1 && nextNum <= 7) ? 'vermelho' : 
                                 (nextNum >= 8 && nextNum <= 14) ? 'preto' : 'outro';
                rangePatterns[key].nextRanges.push(nextRange);
                rangePatterns[key].nextColors.push(colors[i - 1]);
            }
        }
    }
    
    const frequentPatterns = Object.values(rangePatterns).filter(p => p.occurrences >= 2);
    if (frequentPatterns.length === 0) return null;
    
    const bestPattern = frequentPatterns.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³xima faixa e cor
    const colorCounts = {};
    bestPattern.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestPattern.nextColors.length) * 100;
    
    return {
        type: 'range',
        pattern: `Faixa: ${bestPattern.pattern.join('-')}`,
        suggestedNumber: bestPattern.pattern[bestPattern.pattern.length - 1] === 'vermelho' ? 'preto' : 
                        bestPattern.pattern[bestPattern.pattern.length - 1] === 'preto' ? 'vermelho' : 'branco',
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 75),
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.occurrences / 2
    };
}

// Analisar padrÃµes de dÃ­gitos (terminaÃ§Ãµes)
function analyzeDigitPatterns(numbers, colors) {
    const digitPatterns = {};
    
    // Procurar padrÃµes de dÃ­gitos finais de 2-5 giros
    for (let len = 2; len <= 5; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            const digits = sequence.map(n => n % 10); // Ãšltimo dÃ­gito
            const key = digits.join('-');
            
            if (!digitPatterns[key]) {
                digitPatterns[key] = {
                    pattern: digits,
                    occurrences: 0,
                    nextDigits: [],
                    nextColors: []
                };
            }
            
            digitPatterns[key].occurrences++;
            
            if (i > 0) {
                digitPatterns[key].nextDigits.push(numbers[i - 1] % 10);
                digitPatterns[key].nextColors.push(colors[i - 1]);
            }
        }
    }
    
    const frequentPatterns = Object.values(digitPatterns).filter(p => p.occurrences >= 2);
    if (frequentPatterns.length === 0) return null;
    
    const bestPattern = frequentPatterns.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³ximo dÃ­gito e cor
    const colorCounts = {};
    bestPattern.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestPattern.nextColors.length) * 100;
    
    return {
        type: 'digit',
        pattern: `DÃ­gitos: ${bestPattern.pattern.join('-')}`,
        suggestedNumber: bestPattern.pattern[bestPattern.pattern.length - 1],
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 70),
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.occurrences / 2
    };
}

// Analisar progressÃµes matemÃ¡ticas (Fibonacci, aritmÃ©ticas)
function analyzeMathProgressions(numbers, colors) {
    const progressions = {};
    
    // Procurar progressÃµes aritmÃ©ticas de 2-4 nÃºmeros
    for (let len = 2; len <= 4; len++) {
        for (let i = 0; i <= numbers.length - len; i++) {
            const sequence = numbers.slice(i, i + len);
            
            // Verificar se Ã© progressÃ£o aritmÃ©tica
            const diffs = [];
            for (let j = 1; j < sequence.length; j++) {
                diffs.push(sequence[j] - sequence[j - 1]);
            }
            
            if (diffs.every(d => d === diffs[0])) {
                const key = `PA-${diffs[0]}-${sequence.join('-')}`;
                
                if (!progressions[key]) {
                    progressions[key] = {
                        pattern: sequence,
                        difference: diffs[0],
                        occurrences: 0,
                        nextNumbers: [],
                        nextColors: []
                    };
                }
                
                progressions[key].occurrences++;
                
                if (i > 0) {
                    progressions[key].nextNumbers.push(numbers[i - 1]);
                    progressions[key].nextColors.push(colors[i - 1]);
                }
            }
        }
    }
    
    const frequentProgressions = Object.values(progressions).filter(p => p.occurrences >= 2);
    if (frequentProgressions.length === 0) return null;
    
    const bestProgression = frequentProgressions.sort((a, b) => b.occurrences - a.occurrences)[0];
    
    // Calcular prÃ³ximo nÃºmero na progressÃ£o e cor
    const colorCounts = {};
    bestProgression.nextColors.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / bestProgression.nextColors.length) * 100;
    
    return {
        type: 'progression',
        pattern: `PA(${bestProgression.difference}): ${bestProgression.pattern.join('-')}`,
        suggestedNumber: bestProgression.pattern[bestProgression.pattern.length - 1] + bestProgression.difference,
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 80),
        occurrences: bestProgression.occurrences,
        statisticalSignificance: bestProgression.occurrences / 2
    };
}

// ANÃLISE DE PADRÃ•ES TEMPORAIS E MISTOS (baseada nos exemplos 21-33)
function analyzeTemporalAndMixedPatterns(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    const colors = history.map(s => s.color);
    const timestamps = history.map(s => s.timestamp);
    const bestPatterns = [];
    
    // 1. PADRÃ•ES DE TEMPO E HORÃRIO (21-25)
    const timePatterns = analyzeTimePatterns(history, colors, timestamps);
    if (timePatterns) bestPatterns.push(timePatterns);
    
    // 2. PADRÃ•ES MISTOS COR + TEMPO (26-33)
    const mixedPatterns = analyzeMixedPatterns(history, colors, timestamps);
    if (mixedPatterns) bestPatterns.push(mixedPatterns);
    
    if (bestPatterns.length === 0) return null;
    
    // CRÃTICO: Verificar se o padrÃ£o atual realmente corresponde ao padrÃ£o encontrado
    const bestPattern = bestPatterns.sort((a, b) => (b.confidence - a.confidence) || (b.occurrences - a.occurrences))[0];
    
    // Para padrÃµes temporais, verificar se o contexto atual Ã© vÃ¡lido
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    const recentSpins = colors.slice(0, 10); // Ãšltimos 10 giros
    
    // Verificar se o padrÃ£o temporal Ã© aplicÃ¡vel ao momento atual
    if (bestPattern.type === 'time-pattern') {
        // Verificar se estamos no horÃ¡rio correto para o padrÃ£o
        if (bestPattern.pattern.includes('Noturno') && (currentHour < 22 || currentHour > 2)) {
            console.log('âŒ PadrÃ£o temporal nÃ£o aplicÃ¡vel ao horÃ¡rio atual:', {
                pattern: bestPattern.pattern,
                currentHour: currentHour
            });
            return null;
        }
        
        if (bestPattern.pattern.includes('Diurno') && (currentHour >= 22 || currentHour <= 2)) {
            console.log('âŒ PadrÃ£o temporal nÃ£o aplicÃ¡vel ao horÃ¡rio atual:', {
                pattern: bestPattern.pattern,
                currentHour: currentHour
            });
            return null;
        }
    }
    
    console.log('âœ… PadrÃ£o temporal/misto atual confirma o padrÃ£o encontrado:', {
        foundPattern: bestPattern.pattern,
        currentHour: currentHour,
        recentSpins: recentSpins.slice(0, 10)
    });
    
    return bestPattern;
}

// Analisar padrÃµes de tempo e horÃ¡rio (21-25)
function analyzeTimePatterns(history, colors, timestamps) {
    const timePatterns = [];
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    
    // PadrÃ£o 21: Branco Intervalado (a cada 70-100 giros)
    const whiteIntervals = analyzeWhiteIntervals(history);
    if (whiteIntervals) timePatterns.push(whiteIntervals);
    
    // PadrÃ£o 22: Pico Noturno de Brancos (22h-02h)
    if (currentHour >= 22 || currentHour <= 2) {
        const nightWhitePattern = analyzeNightWhitePattern(history);
        if (nightWhitePattern) timePatterns.push(nightWhitePattern);
    }
    
    // PadrÃ£o 23: Estabilidade Noturna (sequÃªncias longas Ã  noite)
    if (currentHour >= 22 || currentHour <= 2) {
        const nightStabilityPattern = analyzeNightStabilityPattern(history);
        if (nightStabilityPattern) timePatterns.push(nightStabilityPattern);
    }
    
    // PadrÃ£o 24: OscilaÃ§Ã£o Diurna (alternÃ¢ncias curtas durante o dia)
    if (currentHour >= 6 && currentHour <= 18) {
        const dayOscillationPattern = analyzeDayOscillationPattern(history);
        if (dayOscillationPattern) timePatterns.push(dayOscillationPattern);
    }
    
    // PadrÃ£o 25: PÃ³s-Pico de Branco
    const postWhitePeakPattern = analyzePostWhitePeakPattern(history);
    if (postWhitePeakPattern) timePatterns.push(postWhitePeakPattern);
    
    return timePatterns.length > 0 ? timePatterns[0] : null;
}

// Analisar padrÃµes mistos cor + tempo (26-33)
function analyzeMixedPatterns(history, colors, timestamps) {
    const mixedPatterns = [];
    
    // PadrÃ£o 26: RecuperaÃ§Ã£o PÃ³s-Branco
    const recoveryPattern = analyzePostWhiteRecoveryPattern(history);
    if (recoveryPattern) mixedPatterns.push(recoveryPattern);
    
    // PadrÃ£o 27: Branco na Quebra de AlternÃ¢ncia
    const whiteBreakPattern = analyzeWhiteBreakPattern(history);
    if (whiteBreakPattern) mixedPatterns.push(whiteBreakPattern);
    
    // PadrÃ£o 28: Branco ApÃ³s DominÃ¢ncia Longa
    const whiteAfterDominancePattern = analyzeWhiteAfterDominancePattern(history);
    if (whiteAfterDominancePattern) mixedPatterns.push(whiteAfterDominancePattern);
    
    // PadrÃ£o 29: CorreÃ§Ã£o Total
    const totalCorrectionPattern = analyzeTotalCorrectionPattern(history);
    if (totalCorrectionPattern) mixedPatterns.push(totalCorrectionPattern);
    
    // PadrÃ£o 30: Ciclo Completo
    const completeCyclePattern = analyzeCompleteCyclePattern(history);
    if (completeCyclePattern) mixedPatterns.push(completeCyclePattern);
    
    // PadrÃ£o 31: RepetiÃ§Ã£o em Mesmo HorÃ¡rio
    const timeRepetitionPattern = analyzeTimeRepetitionPattern(history);
    if (timeRepetitionPattern) mixedPatterns.push(timeRepetitionPattern);
    
    // PadrÃ£o 32: ReversÃ£o Temporal
    const temporalReversalPattern = analyzeTemporalReversalPattern(history);
    if (temporalReversalPattern) mixedPatterns.push(temporalReversalPattern);
    
    // PadrÃ£o 33: Microciclos Repetidos
    const microcyclePattern = analyzeMicrocyclePattern(history);
    if (microcyclePattern) mixedPatterns.push(microcyclePattern);
    
    return mixedPatterns.length > 0 ? mixedPatterns[0] : null;
}

// FunÃ§Ãµes especÃ­ficas para cada padrÃ£o temporal
function analyzeWhiteIntervals(history) {
    const whitePositions = [];
    history.forEach((spin, index) => {
        if (spin.color === 'white') {
            whitePositions.push(index);
        }
    });
    
    if (whitePositions.length < 3) return null;
    
    // Calcular intervalos entre brancos
    const intervals = [];
    for (let i = 1; i < whitePositions.length; i++) {
        intervals.push(whitePositions[i] - whitePositions[i-1]);
    }
    
    // Verificar se hÃ¡ padrÃ£o de intervalo (70-100 giros)
    const validIntervals = intervals.filter(interval => interval >= 70 && interval <= 100);
    
    if (validIntervals.length >= 3) {
        const lastWhiteIndex = whitePositions[whitePositions.length - 1];
        const spinsSinceLastWhite = history.length - lastWhiteIndex;
        
        if (spinsSinceLastWhite >= 70) {
            return {
                type: 'time-pattern',
                pattern: 'Branco Intervalado',
                suggestedColor: 'white',
                confidence: 80,
                occurrences: validIntervals.length,
                statisticalSignificance: 2.5,
                patternType: 'Branco Intervalado'
            };
        }
    }
    
    return null;
}

function analyzeNightWhitePattern(history) {
    const recentSpins = history.slice(0, 60);
    const whiteCount = recentSpins.filter(spin => spin.color === 'white').length;
    
    if (whiteCount === 0 && recentSpins.length >= 60) {
        return {
            type: 'time-pattern',
            pattern: 'Pico Noturno de Brancos',
            suggestedColor: 'white',
            confidence: 75,
            occurrences: 1,
            statisticalSignificance: 2.0,
            patternType: 'Pico Noturno de Brancos'
        };
    }
    
    return null;
}

function analyzeNightStabilityPattern(history) {
    // Procurar sequÃªncias longas (8+ da mesma cor)
    for (let i = 0; i < history.length - 8; i++) {
        const sequence = history.slice(i, i + 8);
        const colors = sequence.map(s => s.color);
        
        if (colors.every(color => color === colors[0])) {
            return {
                type: 'time-pattern',
                pattern: 'Estabilidade Noturna',
                suggestedColor: colors[0] === 'red' ? 'black' : 'red',
                confidence: 78,
                occurrences: 1,
                statisticalSignificance: 2.2,
                patternType: 'Estabilidade Noturna'
            };
        }
    }
    
    return null;
}

function analyzeDayOscillationPattern(history) {
    // Procurar alternÃ¢ncias curtas durante o dia
    const recentSpins = history.slice(0, 6);
    const colors = recentSpins.map(s => s.color);
    
    if (isAlternatingPattern(colors.slice(0, 4))) {
        return {
            type: 'time-pattern',
            pattern: 'OscilaÃ§Ã£o Diurna',
            suggestedColor: colors[0] === 'red' ? 'black' : 'red',
            confidence: 76,
            occurrences: 1,
            statisticalSignificance: 2.1,
            patternType: 'OscilaÃ§Ã£o Diurna'
        };
    }
    
    return null;
}

function analyzePostWhitePeakPattern(history) {
    // Procurar muitos brancos em sequÃªncia curta
    const recentSpins = history.slice(0, 10);
    const whiteCount = recentSpins.filter(spin => spin.color === 'white').length;
    
    if (whiteCount >= 3) {
        return {
            type: 'time-pattern',
            pattern: 'PÃ³s-Pico de Branco',
            suggestedColor: 'red', // Apostar 2x (vermelho ou preto)
            confidence: 77,
            occurrences: 1,
            statisticalSignificance: 2.3,
            patternType: 'PÃ³s-Pico de Branco'
        };
    }
    
    return null;
}

// FunÃ§Ãµes especÃ­ficas para padrÃµes mistos
function analyzePostWhiteRecoveryPattern(history) {
    const recentSpins = history.slice(0, 10);
    const colors = recentSpins.map(s => s.color);
    
    // PadrÃ£o: Branco, Vermelho, Vermelho, Preto, Preto
    if (colors[0] === 'white' && colors[1] === 'red' && colors[2] === 'red' && 
        colors[3] === 'black' && colors[4] === 'black') {
        return {
            type: 'mixed-pattern',
            pattern: 'RecuperaÃ§Ã£o PÃ³s-Branco',
            suggestedColor: 'red',
            confidence: 80,
            occurrences: 1,
            statisticalSignificance: 2.4,
            patternType: 'RecuperaÃ§Ã£o PÃ³s-Branco'
        };
    }
    
    return null;
}

function analyzeWhiteBreakPattern(history) {
    const recentSpins = history.slice(0, 10);
    const colors = recentSpins.map(s => s.color);
    
    // PadrÃ£o: Vermelho, Preto, Vermelho, Preto, Branco
    if (colors[0] === 'red' && colors[1] === 'black' && colors[2] === 'red' && 
        colors[3] === 'black' && colors[4] === 'white') {
        return {
            type: 'mixed-pattern',
            pattern: 'Branco na Quebra de AlternÃ¢ncia',
            suggestedColor: 'black',
            confidence: 79,
            occurrences: 1,
            statisticalSignificance: 2.2,
            patternType: 'Branco na Quebra de AlternÃ¢ncia'
        };
    }
    
    return null;
}

function analyzeWhiteAfterDominancePattern(history) {
    // Procurar 8+ repetiÃ§Ãµes da mesma cor seguida de branco
    for (let i = 0; i < history.length - 9; i++) {
        const sequence = history.slice(i, i + 9);
        const colors = sequence.map(s => s.color);
        
        if (colors.slice(0, 8).every(color => color === colors[0]) && colors[8] === 'white') {
            return {
                type: 'mixed-pattern',
                pattern: 'Branco ApÃ³s DominÃ¢ncia Longa',
                suggestedColor: 'white',
                confidence: 82,
                occurrences: 1,
                statisticalSignificance: 2.6,
                patternType: 'Branco ApÃ³s DominÃ¢ncia Longa'
            };
        }
    }
    
    return null;
}

function analyzeTotalCorrectionPattern(history) {
    const recentSpins = history.slice(0, 6);
    const colors = recentSpins.map(s => s.color);
    
    // PadrÃ£o: Vermelho, Vermelho, Vermelho, Branco, Preto, Preto
    if (colors[0] === 'red' && colors[1] === 'red' && colors[2] === 'red' && 
        colors[3] === 'white' && colors[4] === 'black' && colors[5] === 'black') {
        return {
            type: 'mixed-pattern',
            pattern: 'CorreÃ§Ã£o Total',
            suggestedColor: 'black',
            confidence: 81,
            occurrences: 1,
            statisticalSignificance: 2.5,
            patternType: 'CorreÃ§Ã£o Total'
        };
    }
    
    return null;
}

function analyzeCompleteCyclePattern(history) {
    // Procurar ciclo completo em 50-70 giros
    const cycleWindow = Math.min(70, history.length);
    const cycleSpins = history.slice(0, cycleWindow);
    
    // Verificar se hÃ¡ alternÃ¢ncia â†’ branco â†’ repetiÃ§Ã£o â†’ equilÃ­brio
    const hasAlternation = checkForAlternation(cycleSpins.slice(0, 20));
    const hasWhite = cycleSpins.some(spin => spin.color === 'white');
    const hasRepetition = checkForRepetition(cycleSpins.slice(20, 40));
    
    if (hasAlternation && hasWhite && hasRepetition) {
        const mostRepeatedColor = getMostRepeatedColorAfterWhite(cycleSpins);
        return {
            type: 'mixed-pattern',
            pattern: 'Ciclo Completo',
            suggestedColor: mostRepeatedColor,
            confidence: 78,
            occurrences: 1,
            statisticalSignificance: 2.3,
            patternType: 'Ciclo Completo'
        };
    }
    
    return null;
}

function analyzeTimeRepetitionPattern(history) {
    const currentHour = new Date().getHours();
    const currentMinute = new Date().getMinutes();
    
    // Simular busca por sequÃªncia igual no mesmo horÃ¡rio de dias diferentes
    // (implementaÃ§Ã£o simplificada)
    const recentSpins = history.slice(0, 10);
    const colors = recentSpins.map(s => s.color);
    
    if (currentMinute % 15 === 0) { // A cada 15 minutos
        return {
            type: 'mixed-pattern',
            pattern: 'RepetiÃ§Ã£o em Mesmo HorÃ¡rio',
            suggestedColor: colors[colors.length - 1],
            confidence: 77,
            occurrences: 1,
            statisticalSignificance: 2.1,
            patternType: 'RepetiÃ§Ã£o em Mesmo HorÃ¡rio'
        };
    }
    
    return null;
}

function analyzeTemporalReversalPattern(history) {
    // Procurar 1h de dominÃ¢ncia de uma cor (simulado com 60 giros)
    const recentSpins = history.slice(0, 60);
    const colors = recentSpins.map(s => s.color);
    
    const redCount = colors.filter(c => c === 'red').length;
    const blackCount = colors.filter(c => c === 'black').length;
    
    if (redCount >= 40 || blackCount >= 40) {
        const dominantColor = redCount > blackCount ? 'red' : 'black';
        return {
            type: 'mixed-pattern',
            pattern: 'ReversÃ£o Temporal',
            suggestedColor: dominantColor === 'red' ? 'black' : 'red',
            confidence: 79,
            occurrences: 1,
            statisticalSignificance: 2.4,
            patternType: 'ReversÃ£o Temporal'
        };
    }
    
    return null;
}

function analyzeMicrocyclePattern(history) {
    // Procurar padrÃµes curtos de 5-10 giros se repetindo
    for (let cycleSize = 5; cycleSize <= 10; cycleSize++) {
        if (history.length < cycleSize * 2) continue;
        
        const recentCycle = history.slice(0, cycleSize);
        const previousCycle = history.slice(cycleSize, cycleSize * 2);
        
        const recentColors = recentCycle.map(s => s.color);
        const previousColors = previousCycle.map(s => s.color);
        
        if (JSON.stringify(recentColors) === JSON.stringify(previousColors)) {
            return {
                type: 'mixed-pattern',
                pattern: 'Microciclos Repetidos',
                suggestedColor: recentColors[recentColors.length - 1],
                confidence: 80,
                occurrences: 1,
                statisticalSignificance: 2.5,
                patternType: 'Microciclos Repetidos'
            };
        }
    }
    
    return null;
}

// FunÃ§Ãµes auxiliares para anÃ¡lise temporal
function checkForAlternation(spins) {
    const colors = spins.map(s => s.color);
    for (let i = 1; i < colors.length; i++) {
        if (colors[i] === colors[i-1]) return false;
    }
    return colors.length >= 4;
}

function checkForRepetition(spins) {
    const colors = spins.map(s => s.color);
    return colors.every(color => color === colors[0]) && colors.length >= 3;
}

function getMostRepeatedColorAfterWhite(spins) {
    const whiteIndex = spins.findIndex(s => s.color === 'white');
    if (whiteIndex === -1) return 'red';
    
    const afterWhite = spins.slice(0, whiteIndex);
    const colorCounts = {};
    afterWhite.forEach(spin => {
        colorCounts[spin.color] = (colorCounts[spin.color] || 0) + 1;
    });
    
    return Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red');
}

// ANÃLISE TEMPORAL AVANÃ‡ADA MULTIDIMENSIONAL (funÃ§Ã£o antiga mantida para compatibilidade)
function analyzeTemporalPatternsAdvancedOld(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o temporal
    const recentSpins = history; // Todo o histÃ³rico
    
    // 1. ANÃLISE POR MINUTOS (quartos de hora)
    const minutePattern = analyzeMinutePatterns(recentSpins);
    
    // 2. ANÃLISE POR HORAS (perÃ­odos do dia)
    const hourPattern = analyzeHourPatterns(recentSpins);
    
    // 3. ANÃLISE POR DIA DA SEMANA
    const dayPattern = analyzeDayPatterns(recentSpins);
    
    // 4. ANÃLISE POR PERÃODOS (manhÃ£, tarde, noite, madrugada)
    const periodPattern = analyzePeriodPatterns(recentSpins);
    
    // 5. ANÃLISE DE CICLOS TEMPORAIS
    const cyclePattern = analyzeTemporalCycles(recentSpins);
    
    // Combinar todas as anÃ¡lises temporais
    const patterns = [minutePattern, hourPattern, dayPattern, periodPattern, cyclePattern].filter(p => p !== null);
    
    if (patterns.length === 0) return null;
    
    // Encontrar o padrÃ£o temporal com maior confianÃ§a
    const bestPattern = patterns.sort((a, b) => b.confidence - a.confidence)[0];
    
    return {
        type: 'temporal',
        pattern: bestPattern.pattern,
        suggestedColor: bestPattern.suggestedColor,
        confidence: bestPattern.confidence,
        occurrences: bestPattern.occurrences,
        statisticalSignificance: bestPattern.statisticalSignificance,
        subPatterns: patterns.map(p => ({ type: p.type, confidence: p.confidence }))
    };
}

// Analisar padrÃµes por minutos (00, 15, 30, 45)
function analyzeMinutePatterns(spins) {
    const minutePatterns = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const minute = spinTime.getMinutes();
        const quarter = Math.floor(minute / 15) * 15; // 0, 15, 30, 45
        const key = `${quarter}-${spin.color}`;
        
        if (!minutePatterns[key]) {
            minutePatterns[key] = {
                quarter: quarter,
                color: spin.color,
                count: 0,
                totalInQuarter: 0
            };
        }
        
        minutePatterns[key].count++;
    });
    
    // Calcular total por quarto
    const quarterTotals = {};
    Object.values(minutePatterns).forEach(p => {
        if (!quarterTotals[p.quarter]) quarterTotals[p.quarter] = 0;
        quarterTotals[p.quarter] += p.count;
    });
    
    // Encontrar padrÃµes mais frequentes
    const currentTime = new Date();
    const currentQuarter = Math.floor(currentTime.getMinutes() / 15) * 15;
    
    const currentQuarterPatterns = Object.values(minutePatterns).filter(p => p.quarter === currentQuarter);
    if (currentQuarterPatterns.length === 0) return null;
    
    const bestPattern = currentQuarterPatterns.sort((a, b) => b.count - a.count)[0];
    const totalInCurrentQuarter = quarterTotals[currentQuarter] || 1;
    const confidence = (bestPattern.count / totalInCurrentQuarter) * 100;
    
    if (confidence < 60) return null;
    
    return {
        type: 'minute',
        pattern: `Minuto ${currentQuarter}: ${bestPattern.color} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestPattern.color,
        confidence: Math.min(confidence, 85),
        occurrences: bestPattern.count,
        statisticalSignificance: bestPattern.count / 2
    };
}

// Analisar padrÃµes por horas (perÃ­odos do dia)
function analyzeHourPatterns(spins) {
    const hourPatterns = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const period = hour < 6 ? 'madrugada' : 
                      hour < 12 ? 'manhÃ£' : 
                      hour < 18 ? 'tarde' : 'noite';
        const key = `${period}-${spin.color}`;
        
        if (!hourPatterns[key]) {
            hourPatterns[key] = {
                period: period,
                color: spin.color,
                count: 0,
                totalInPeriod: 0
            };
        }
        
        hourPatterns[key].count++;
    });
    
    // Calcular total por perÃ­odo
    const periodTotals = {};
    Object.values(hourPatterns).forEach(p => {
        if (!periodTotals[p.period]) periodTotals[p.period] = 0;
        periodTotals[p.period] += p.count;
    });
    
    // Encontrar padrÃ£o do perÃ­odo atual
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    const currentPeriod = currentHour < 6 ? 'madrugada' : 
                         currentHour < 12 ? 'manhÃ£' : 
                         currentHour < 18 ? 'tarde' : 'noite';
    
    const currentPeriodPatterns = Object.values(hourPatterns).filter(p => p.period === currentPeriod);
    if (currentPeriodPatterns.length === 0) return null;
    
    const bestPattern = currentPeriodPatterns.sort((a, b) => b.count - a.count)[0];
    const totalInCurrentPeriod = periodTotals[currentPeriod] || 1;
    const confidence = (bestPattern.count / totalInCurrentPeriod) * 100;
    
    if (confidence < 60) return null;
    
    return {
        type: 'hour',
        pattern: `${currentPeriod}: ${bestPattern.color} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestPattern.color,
        confidence: Math.min(confidence, 80),
        occurrences: bestPattern.count,
        statisticalSignificance: bestPattern.count / 2
    };
}

// Analisar padrÃµes por dia da semana
function analyzeDayPatterns(spins) {
    const dayPatterns = {};
    const dayNames = ['domingo', 'segunda', 'terÃ§a', 'quarta', 'quinta', 'sexta', 'sÃ¡bado'];
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const dayOfWeek = spinTime.getDay();
        const dayName = dayNames[dayOfWeek];
        const key = `${dayName}-${spin.color}`;
        
        if (!dayPatterns[key]) {
            dayPatterns[key] = {
                day: dayName,
                color: spin.color,
                count: 0,
                totalInDay: 0
            };
        }
        
        dayPatterns[key].count++;
    });
    
    // Calcular total por dia
    const dayTotals = {};
    Object.values(dayPatterns).forEach(p => {
        if (!dayTotals[p.day]) dayTotals[p.day] = 0;
        dayTotals[p.day] += p.count;
    });
    
    // Encontrar padrÃ£o do dia atual
    const currentTime = new Date();
    const currentDay = dayNames[currentTime.getDay()];
    
    const currentDayPatterns = Object.values(dayPatterns).filter(p => p.day === currentDay);
    if (currentDayPatterns.length === 0) return null;
    
    const bestPattern = currentDayPatterns.sort((a, b) => b.count - a.count)[0];
    const totalInCurrentDay = dayTotals[currentDay] || 1;
    const confidence = (bestPattern.count / totalInCurrentDay) * 100;
    
    if (confidence < 60) return null;
    
    return {
        type: 'day',
        pattern: `${currentDay}: ${bestPattern.color} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestPattern.color,
        confidence: Math.min(confidence, 75),
        occurrences: bestPattern.count,
        statisticalSignificance: bestPattern.count / 2
    };
}

// Analisar padrÃµes por perÃ­odos (manhÃ£, tarde, noite, madrugada)
function analyzePeriodPatterns(spins) {
    const periodPatterns = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const period = hour < 6 ? 'madrugada' : 
                      hour < 12 ? 'manhÃ£' : 
                      hour < 18 ? 'tarde' : 'noite';
        const key = `${period}-${spin.color}`;
        
        if (!periodPatterns[key]) {
            periodPatterns[key] = {
                period: period,
                color: spin.color,
                count: 0,
                totalInPeriod: 0
            };
        }
        
        periodPatterns[key].count++;
    });
    
    // Calcular total por perÃ­odo
    const periodTotals = {};
    Object.values(periodPatterns).forEach(p => {
        if (!periodTotals[p.period]) periodTotals[p.period] = 0;
        periodTotals[p.period] += p.count;
    });
    
    // Encontrar padrÃ£o do perÃ­odo atual
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    const currentPeriod = currentHour < 6 ? 'madrugada' : 
                         currentHour < 12 ? 'manhÃ£' : 
                         currentHour < 18 ? 'tarde' : 'noite';
    
    const currentPeriodPatterns = Object.values(periodPatterns).filter(p => p.period === currentPeriod);
    if (currentPeriodPatterns.length === 0) return null;
    
    const bestPattern = currentPeriodPatterns.sort((a, b) => b.count - a.count)[0];
    const totalInCurrentPeriod = periodTotals[currentPeriod] || 1;
    const confidence = (bestPattern.count / totalInCurrentPeriod) * 100;
    
    if (confidence < 60) return null;
    
    return {
        type: 'period',
        pattern: `${currentPeriod}: ${bestPattern.color} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestPattern.color,
        confidence: Math.min(confidence, 80),
        occurrences: bestPattern.count,
        statisticalSignificance: bestPattern.count / 2
    };
}

// Analisar ciclos temporais (padrÃµes que se repetem em horÃ¡rios especÃ­ficos)
function analyzeTemporalCycles(spins) {
    const cyclePatterns = {};
    
    // Procurar ciclos de 1-4 horas
    for (let cycleHours = 1; cycleHours <= 4; cycleHours++) {
        spins.forEach(spin => {
            const spinTime = new Date(spin.timestamp);
            const hour = spinTime.getHours();
            const cyclePosition = hour % cycleHours;
            const key = `ciclo-${cycleHours}h-${cyclePosition}-${spin.color}`;
            
            if (!cyclePatterns[key]) {
                cyclePatterns[key] = {
                    cycleHours: cycleHours,
                    position: cyclePosition,
                    color: spin.color,
                    count: 0,
                    totalInPosition: 0
                };
            }
            
            cyclePatterns[key].count++;
        });
    }
    
    // Calcular total por posiÃ§Ã£o do ciclo
    const positionTotals = {};
    Object.values(cyclePatterns).forEach(p => {
        const key = `${p.cycleHours}h-${p.position}`;
        if (!positionTotals[key]) positionTotals[key] = 0;
        positionTotals[key] += p.count;
    });
    
    // Encontrar ciclo mais forte
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    
    let bestCycle = null;
    let bestConfidence = 0;
    
    for (let cycleHours = 1; cycleHours <= 4; cycleHours++) {
        const cyclePosition = currentHour % cycleHours;
        const key = `ciclo-${cycleHours}h-${cyclePosition}`;
        const totalInPosition = positionTotals[key] || 1;
        
        const cyclePatternsInPosition = Object.values(cyclePatterns).filter(p => 
            p.cycleHours === cycleHours && p.position === cyclePosition
        );
        
        if (cyclePatternsInPosition.length > 0) {
            const bestPattern = cyclePatternsInPosition.sort((a, b) => b.count - a.count)[0];
            const confidence = (bestPattern.count / totalInPosition) * 100;
            
            if (confidence > bestConfidence && confidence >= 60) {
                bestConfidence = confidence;
                bestCycle = bestPattern;
            }
        }
    }
    
    if (!bestCycle) return null;
    
    return {
        type: 'cycle',
        pattern: `Ciclo ${bestCycle.cycleHours}h posiÃ§Ã£o ${bestCycle.position}: ${bestCycle.color} (${bestConfidence.toFixed(1)}%)`,
        suggestedColor: bestCycle.color,
        confidence: Math.min(bestConfidence, 85),
        occurrences: bestCycle.count,
        statisticalSignificance: bestCycle.count / 2
    };
}

// ANÃLISE DE CORRELAÃ‡Ã•ES MULTIDIMENSIONAIS
function analyzeCorrelations(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o de correlaÃ§Ãµes
    const recentSpins = history; // Todo o histÃ³rico
    
    // 1. CORRELAÃ‡ÃƒO COR + NÃšMERO
    const colorNumberCorrelation = analyzeColorNumberCorrelation(recentSpins);
    
    // 2. CORRELAÃ‡ÃƒO COR + TEMPO
    const colorTimeCorrelation = analyzeColorTimeCorrelation(recentSpins);
    
    // 3. CORRELAÃ‡ÃƒO NÃšMERO + TEMPO
    const numberTimeCorrelation = analyzeNumberTimeCorrelation(recentSpins);
    
    // 4. CORRELAÃ‡ÃƒO COMPOSTA (COR + NÃšMERO + TEMPO)
    const compositeCorrelation = analyzeCompositeCorrelation(recentSpins);
    
    // Combinar todas as correlaÃ§Ãµes
    const correlations = [colorNumberCorrelation, colorTimeCorrelation, numberTimeCorrelation, compositeCorrelation].filter(c => c !== null);
    
    if (correlations.length === 0) return null;
    
    // Encontrar a correlaÃ§Ã£o com maior confianÃ§a
    const bestCorrelation = correlations.sort((a, b) => b.confidence - a.confidence)[0];
    
    // CRÃTICO: Verificar se a correlaÃ§Ã£o atual realmente corresponde ao padrÃ£o encontrado
    const colors = history.map(s => s.color);
    const numbers = history.map(s => s.number);
    
    // Para correlaÃ§Ãµes de cor-nÃºmero, verificar se o padrÃ£o atual corresponde
    if (bestCorrelation.type === 'color-number') {
        const patternParts = bestCorrelation.pattern.split('-');
        if (patternParts.length >= 2) {
            const expectedColor = patternParts[0];
            const expectedNumber = parseInt(patternParts[1]);
            
            // Verificar se o Ãºltimo giro corresponde Ã  correlaÃ§Ã£o
            if (colors[0] !== expectedColor || numbers[0] !== expectedNumber) {
                console.log('âŒ CorrelaÃ§Ã£o cor-nÃºmero nÃ£o corresponde ao padrÃ£o atual:', {
                    foundPattern: bestCorrelation.pattern,
                    currentColor: colors[0],
                    currentNumber: numbers[0],
                    expectedColor: expectedColor,
                    expectedNumber: expectedNumber
                });
                return null;
            }
        }
    }
    
    console.log('âœ… CorrelaÃ§Ã£o atual confirma o padrÃ£o encontrado:', {
        foundPattern: bestCorrelation.pattern,
        currentColor: colors[0],
        currentNumber: numbers[0]
    });
    
    return {
        type: 'correlation',
        pattern: bestCorrelation.pattern,
        suggestedColor: bestCorrelation.suggestedColor,
        confidence: bestCorrelation.confidence,
        occurrences: bestCorrelation.occurrences,
        statisticalSignificance: bestCorrelation.statisticalSignificance,
        subCorrelations: correlations.map(c => ({ type: c.type, confidence: c.confidence }))
    };
}

// CorrelaÃ§Ã£o Cor + NÃºmero
function analyzeColorNumberCorrelation(spins) {
    const correlations = {};
    
    spins.forEach(spin => {
        const key = `${spin.color}-${spin.number}`;
        if (!correlations[key]) {
            correlations[key] = {
                color: spin.color,
                number: spin.number,
                count: 0,
                nextColors: []
            };
        }
        correlations[key].count++;
    });
    
    // Encontrar correlaÃ§Ãµes mais frequentes
    const frequentCorrelations = Object.values(correlations).filter(c => c.count >= 2);
    if (frequentCorrelations.length === 0) return null;
    
    const bestCorrelation = frequentCorrelations.sort((a, b) => b.count - a.count)[0];
    
    // Calcular prÃ³xima cor baseada na correlaÃ§Ã£o
    const colorCounts = {};
    frequentCorrelations.forEach(c => {
        colorCounts[c.color] = (colorCounts[c.color] || 0) + c.count;
    });
    
    const mostFrequentColor = Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b, 'red'
    );
    
    const confidence = (colorCounts[mostFrequentColor] / frequentCorrelations.length) * 100;
    
    return {
        type: 'color-number',
        pattern: `Cor-NÃºmero: ${bestCorrelation.color}-${bestCorrelation.number} (${confidence.toFixed(1)}%)`,
        suggestedColor: mostFrequentColor,
        confidence: Math.min(confidence, 80),
        occurrences: bestCorrelation.count,
        statisticalSignificance: bestCorrelation.count / 2
    };
}

// CorrelaÃ§Ã£o Cor + Tempo
function analyzeColorTimeCorrelation(spins) {
    const correlations = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const minute = Math.floor(spinTime.getMinutes() / 15) * 15; // Quartos de hora
        const key = `${spin.color}-${hour}h${minute}m`;
        
        if (!correlations[key]) {
            correlations[key] = {
                color: spin.color,
                time: `${hour}h${minute}m`,
                count: 0
            };
        }
        correlations[key].count++;
    });
    
    // Encontrar correlaÃ§Ãµes mais frequentes
    const frequentCorrelations = Object.values(correlations).filter(c => c.count >= 2);
    if (frequentCorrelations.length === 0) return null;
    
    const bestCorrelation = frequentCorrelations.sort((a, b) => b.count - a.count)[0];
    
    const confidence = (bestCorrelation.count / frequentCorrelations.length) * 100;
    
    return {
        type: 'color-time',
        pattern: `Cor-Tempo: ${bestCorrelation.color}-${bestCorrelation.time} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestCorrelation.color,
        confidence: Math.min(confidence, 75),
        occurrences: bestCorrelation.count,
        statisticalSignificance: bestCorrelation.count / 2
    };
}

// CorrelaÃ§Ã£o NÃºmero + Tempo
function analyzeNumberTimeCorrelation(spins) {
    const correlations = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const numberRange = spin.number === 0 ? 'branco' : 
                           (spin.number >= 1 && spin.number <= 7) ? 'vermelho' : 'preto';
        const key = `${numberRange}-${hour}h`;
        
        if (!correlations[key]) {
            correlations[key] = {
                numberRange: numberRange,
                hour: hour,
                count: 0
            };
        }
        correlations[key].count++;
    });
    
    // Encontrar correlaÃ§Ãµes mais frequentes
    const frequentCorrelations = Object.values(correlations).filter(c => c.count >= 2);
    if (frequentCorrelations.length === 0) return null;
    
    const bestCorrelation = frequentCorrelations.sort((a, b) => b.count - a.count)[0];
    
    const confidence = (bestCorrelation.count / frequentCorrelations.length) * 100;
    
    return {
        type: 'number-time',
        pattern: `NÃºmero-Tempo: ${bestCorrelation.numberRange}-${bestCorrelation.hour}h (${confidence.toFixed(1)}%)`,
        suggestedColor: bestCorrelation.numberRange === 'vermelho' ? 'red' : 
                       bestCorrelation.numberRange === 'preto' ? 'black' : 'white',
        confidence: Math.min(confidence, 70),
        occurrences: bestCorrelation.count,
        statisticalSignificance: bestCorrelation.count / 2
    };
}

// CorrelaÃ§Ã£o Composta (Cor + NÃºmero + Tempo)
function analyzeCompositeCorrelation(spins) {
    const correlations = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const minute = Math.floor(spinTime.getMinutes() / 15) * 15;
        const key = `${spin.color}-${spin.number}-${hour}h${minute}m`;
        
        if (!correlations[key]) {
            correlations[key] = {
                color: spin.color,
                number: spin.number,
                time: `${hour}h${minute}m`,
                count: 0
            };
        }
        correlations[key].count++;
    });
    
    // Encontrar correlaÃ§Ãµes mais frequentes
    const frequentCorrelations = Object.values(correlations).filter(c => c.count >= 2);
    if (frequentCorrelations.length === 0) return null;
    
    const bestCorrelation = frequentCorrelations.sort((a, b) => b.count - a.count)[0];
    
    const confidence = (bestCorrelation.count / frequentCorrelations.length) * 100;
    
    return {
        type: 'composite',
        pattern: `Composto: ${bestCorrelation.color}-${bestCorrelation.number}-${bestCorrelation.time} (${confidence.toFixed(1)}%)`,
        suggestedColor: bestCorrelation.color,
        confidence: Math.min(confidence, 85),
        occurrences: bestCorrelation.count,
        statisticalSignificance: bestCorrelation.count / 2
    };
}

// ANÃLISE DE FREQUÃŠNCIA MULTIDIMENSIONAL
function analyzeMultidimensionalFrequency(history) {
    if (history.length < 50) return null; // MÃ­nimo de 50 giros
    
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o de frequÃªncia
    const recentSpins = history; // Todo o histÃ³rico
    
    // 1. FREQUÃŠNCIA POR FAIXA NUMÃ‰RICA
    const rangeFrequency = analyzeRangeFrequency(recentSpins);
    
    // 2. FREQUÃŠNCIA POR PERÃODO DO DIA
    const periodFrequency = analyzePeriodFrequency(recentSpins);
    
    // 3. FREQUÃŠNCIA POR DIA DA SEMANA
    const dayFrequency = analyzeDayFrequency(recentSpins);
    
    // 4. FREQUÃŠNCIA POR MINUTO
    const minuteFrequency = analyzeMinuteFrequency(recentSpins);
    
    // Combinar todas as frequÃªncias
    const frequencies = [rangeFrequency, periodFrequency, dayFrequency, minuteFrequency].filter(f => f !== null);
    
    if (frequencies.length === 0) return null;
    
    // Encontrar a frequÃªncia com maior confianÃ§a
    const bestFrequency = frequencies.sort((a, b) => b.confidence - a.confidence)[0];
    
    return {
        type: 'frequency',
        pattern: bestFrequency.pattern,
        suggestedColor: bestFrequency.suggestedColor,
        confidence: bestFrequency.confidence,
        occurrences: bestFrequency.occurrences,
        statisticalSignificance: bestFrequency.statisticalSignificance,
        subFrequencies: frequencies.map(f => ({ type: f.type, confidence: f.confidence }))
    };
}

// FrequÃªncia por faixa numÃ©rica
function analyzeRangeFrequency(spins) {
    const rangeCounts = { red: 0, black: 0, white: 0 };
    
    spins.forEach(spin => {
        if (spin.number === 0) rangeCounts.white++;
        else if (spin.number >= 1 && spin.number <= 7) rangeCounts.red++;
        else if (spin.number >= 8 && spin.number <= 14) rangeCounts.black++;
    });
    
    const total = spins.length;
    const redPercent = (rangeCounts.red / total) * 100;
    const blackPercent = (rangeCounts.black / total) * 100;
    const whitePercent = (rangeCounts.white / total) * 100;
    
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o, retornar null se nÃ£o houver padrÃ£o claro
    let suggestedColor = null;
    let confidence = 0;
    
    if (redPercent > 60) {
        suggestedColor = 'black';
        confidence = Math.min(redPercent - 50, 80);
    } else if (blackPercent > 60) {
        suggestedColor = 'red';
        confidence = Math.min(blackPercent - 50, 80);
    } else if (whitePercent > 25) {
        // âœ… CORREÃ‡ÃƒO: Usar a cor MENOS frequente em vez de sempre 'red'
        suggestedColor = redPercent < blackPercent ? 'red' : 'black';
        confidence = Math.min(whitePercent * 2, 70);
    } else {
        return null;
    }
    
    if (!suggestedColor) return null;
    
    return {
        type: 'range-frequency',
        pattern: `Faixa: R${redPercent.toFixed(1)}% B${blackPercent.toFixed(1)}% W${whitePercent.toFixed(1)}%`,
        suggestedColor: suggestedColor,
        confidence: confidence,
        occurrences: Math.max(rangeCounts.red, rangeCounts.black, rangeCounts.white),
        statisticalSignificance: confidence / 50
    };
}

// FrequÃªncia por perÃ­odo do dia
function analyzePeriodFrequency(spins) {
    const periodCounts = { madrugada: 0, manhÃ£: 0, tarde: 0, noite: 0 };
    const periodColors = { madrugada: {}, manhÃ£: {}, tarde: {}, noite: {} };
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        const period = hour < 6 ? 'madrugada' : 
                      hour < 12 ? 'manhÃ£' : 
                      hour < 18 ? 'tarde' : 'noite';
        
        periodCounts[period]++;
        if (!periodColors[period][spin.color]) periodColors[period][spin.color] = 0;
        periodColors[period][spin.color]++;
    });
    
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    const currentPeriod = currentHour < 6 ? 'madrugada' : 
                         currentHour < 12 ? 'manhÃ£' : 
                         currentHour < 18 ? 'tarde' : 'noite';
    
    const currentPeriodCount = periodCounts[currentPeriod];
    if (currentPeriodCount < 3) return null;
    
    const currentPeriodColors = periodColors[currentPeriod];
    const totalColors = Object.values(currentPeriodColors).reduce((a, b) => a + b, 0);
    
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
    let suggestedColor = null;
    let confidence = 0;
    
    Object.entries(currentPeriodColors).forEach(([color, count]) => {
        const percent = (count / totalColors) * 100;
        if (percent > 60) {
            // âœ… CORREÃ‡ÃƒO: Sugerir cor oposta sem viÃ©s
            if (color === 'red') suggestedColor = 'black';
            else if (color === 'black') suggestedColor = 'red';
            else suggestedColor = 'black'; // Se white estÃ¡ dominante, apostar em black
            confidence = Math.min(percent - 50, 75);
        }
    });
    
    if (confidence < 60 || !suggestedColor) return null;
    
    return {
        type: 'period-frequency',
        pattern: `${currentPeriod}: ${suggestedColor} (${confidence.toFixed(1)}%)`,
        suggestedColor: suggestedColor,
        confidence: confidence,
        occurrences: currentPeriodCount,
        statisticalSignificance: confidence / 50
    };
}

// FrequÃªncia por dia da semana
function analyzeDayFrequency(spins) {
    const dayNames = ['domingo', 'segunda', 'terÃ§a', 'quarta', 'quinta', 'sexta', 'sÃ¡bado'];
    const dayCounts = {};
    const dayColors = {};
    
    dayNames.forEach(day => {
        dayCounts[day] = 0;
        dayColors[day] = {};
    });
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const dayOfWeek = spinTime.getDay();
        const dayName = dayNames[dayOfWeek];
        
        dayCounts[dayName]++;
        if (!dayColors[dayName][spin.color]) dayColors[dayName][spin.color] = 0;
        dayColors[dayName][spin.color]++;
    });
    
    const currentTime = new Date();
    const currentDay = dayNames[currentTime.getDay()];
    
    const currentDayCount = dayCounts[currentDay];
    if (currentDayCount < 3) return null;
    
    const currentDayColors = dayColors[currentDay];
    const totalColors = Object.values(currentDayColors).reduce((a, b) => a + b, 0);
    
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
    let suggestedColor = null;
    let confidence = 0;
    
    Object.entries(currentDayColors).forEach(([color, count]) => {
        const percent = (count / totalColors) * 100;
        if (percent > 60) {
            // âœ… CORREÃ‡ÃƒO: Sugerir cor oposta sem viÃ©s
            if (color === 'red') suggestedColor = 'black';
            else if (color === 'black') suggestedColor = 'red';
            else suggestedColor = 'black'; // Se white estÃ¡ dominante, apostar em black
            confidence = Math.min(percent - 50, 70);
        }
    });
    
    if (confidence < 60 || !suggestedColor) return null;
    
    return {
        type: 'day-frequency',
        pattern: `${currentDay}: ${suggestedColor} (${confidence.toFixed(1)}%)`,
        suggestedColor: suggestedColor,
        confidence: confidence,
        occurrences: currentDayCount,
        statisticalSignificance: confidence / 50
    };
}

// FrequÃªncia por minuto
function analyzeMinuteFrequency(spins) {
    const minuteCounts = {};
    const minuteColors = {};
    
    spins.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const minute = Math.floor(spinTime.getMinutes() / 15) * 15; // Quartos de hora
        const key = `${minute}`;
        
        if (!minuteCounts[key]) {
            minuteCounts[key] = 0;
            minuteColors[key] = {};
        }
        
        minuteCounts[key]++;
        if (!minuteColors[key][spin.color]) minuteColors[key][spin.color] = 0;
        minuteColors[key][spin.color]++;
    });
    
    const currentTime = new Date();
    const currentMinute = Math.floor(currentTime.getMinutes() / 15) * 15;
    const currentMinuteKey = `${currentMinute}`;
    
    const currentMinuteCount = minuteCounts[currentMinuteKey];
    if (currentMinuteCount < 2) return null;
    
    const currentMinuteColors = minuteColors[currentMinuteKey];
    const totalColors = Object.values(currentMinuteColors).reduce((a, b) => a + b, 0);
    
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
    let suggestedColor = null;
    let confidence = 0;
    
    Object.entries(currentMinuteColors).forEach(([color, count]) => {
        const percent = (count / totalColors) * 100;
        if (percent > 60) {
            // âœ… CORREÃ‡ÃƒO: Sugerir cor oposta sem viÃ©s
            if (color === 'red') suggestedColor = 'black';
            else if (color === 'black') suggestedColor = 'red';
            else suggestedColor = 'black'; // Se white estÃ¡ dominante, apostar em black
            confidence = Math.min(percent - 50, 80);
        }
    });
    
    if (confidence < 60 || !suggestedColor) return null;
    
    return {
        type: 'minute-frequency',
        pattern: `Minuto ${currentMinute}: ${suggestedColor} (${confidence.toFixed(1)}%)`,
        suggestedColor: suggestedColor,
        confidence: confidence,
        occurrences: currentMinuteCount,
        statisticalSignificance: confidence / 50
    };
}

// FUNÃ‡ÃƒO PARA COMPARAR SE DOIS PADRÃ•ES SÃƒO IGUAIS
function comparePatterns(lastPattern, currentPattern) {
    try {
        // Comparar tipo de anÃ¡lise principal
        const lastMainType = lastPattern.colorAnalysis ? 'color' : 
                           lastPattern.numberAnalysis ? 'number' : 
                           lastPattern.timeAnalysis ? 'time' : 
                           lastPattern.correlationAnalysis ? 'correlation' : 'frequency';
        
        const currentMainType = currentPattern.colorAnalysis ? 'color' : 
                              currentPattern.numberAnalysis ? 'number' : 
                              currentPattern.timeAnalysis ? 'time' : 
                              currentPattern.correlationAnalysis ? 'correlation' : 'frequency';
        
        // Se tipos diferentes, nÃ£o sÃ£o o mesmo padrÃ£o
        if (lastMainType !== currentMainType) {
            return false;
        }
        
        // Comparar sequÃªncias especÃ­ficas baseadas no tipo
        if (lastMainType === 'color') {
            const lastSequence = lastPattern.colorAnalysis?.pattern || [];
            const currentSequence = currentPattern.colorAnalysis?.pattern || [];
            
            // Comparar sequÃªncias de cores
            if (lastSequence.length !== currentSequence.length) {
                return false;
            }
            
            return lastSequence.every((color, index) => color === currentSequence[index]);
        }
        
        if (lastMainType === 'number') {
            const lastSequence = lastPattern.numberAnalysis?.pattern || '';
            const currentSequence = currentPattern.numberAnalysis?.pattern || '';
            
            return lastSequence === currentSequence;
        }
        
        if (lastMainType === 'time') {
            const lastPatternType = lastPattern.timeAnalysis?.pattern || '';
            const currentPatternType = currentPattern.timeAnalysis?.pattern || '';
            
            return lastPatternType === currentPatternType;
        }
        
        if (lastMainType === 'correlation') {
            const lastCorrelation = lastPattern.correlationAnalysis?.pattern || '';
            const currentCorrelation = currentPattern.correlationAnalysis?.pattern || '';
            
            return lastCorrelation === currentCorrelation;
        }
        
        // Para frequency, comparar por tipo de zona
        if (lastMainType === 'frequency') {
            const lastZone = lastPattern.frequencyAnalysis?.zone || '';
            const currentZone = currentPattern.frequencyAnalysis?.zone || '';
            
            return lastZone === currentZone;
        }
        
        return false;
    } catch (e) {
        console.log('âš ï¸ Erro ao comparar padrÃµes:', e);
        return false; // Em caso de erro, considerar como padrÃ£o diferente
    }
}

// COMBINAR TODAS AS ANÃLISES MULTIDIMENSIONAIS COM REGRAS DE RIGOR
async function combineMultidimensionalAnalyses(colorAnalysis, numberAnalysis, timeAnalysis, correlationAnalysis, frequencyAnalysis) {
    const analyses = [colorAnalysis, numberAnalysis, timeAnalysis, correlationAnalysis, frequencyAnalysis].filter(a => a !== null);
    
    if (analyses.length === 0) return null;
    
    // NOVA LÃ“GICA: Verificar se mÃºltiplos padrÃµes recomendam a mesma cor
    const colorRecommendations = {};
    analyses.forEach(analysis => {
        const color = analysis.suggestedColor;
        if (!colorRecommendations[color]) {
            colorRecommendations[color] = {
                color: color,
                analyses: [],
                totalConfidence: 0,
                count: 0
            };
        }
        colorRecommendations[color].analyses.push(analysis);
        colorRecommendations[color].totalConfidence += analysis.confidence;
        colorRecommendations[color].count++;
    });
    
    // Calcular confianÃ§a ajustada baseada no consenso
    Object.keys(colorRecommendations).forEach(color => {
        const rec = colorRecommendations[color];
        const avgConfidence = rec.totalConfidence / rec.count;
        
        // Se mÃºltiplos padrÃµes recomendam a mesma cor, AUMENTAR confianÃ§a
        if (rec.count > 1) {
            const consensusBonus = (rec.count - 1) * 5; // +5% por padrÃ£o adicional
            rec.adjustedConfidence = Math.min(avgConfidence + consensusBonus, 95);
            console.log(`ğŸ¯ Consenso detectado: ${rec.count} padrÃµes recomendam ${color} - ConfianÃ§a ajustada: ${rec.adjustedConfidence.toFixed(1)}%`);
        } else {
            // Se apenas um padrÃ£o, manter confianÃ§a original
            rec.adjustedConfidence = avgConfidence;
        }
    });
    
    // Escolher a cor com maior confianÃ§a ajustada
    const bestRecommendation = Object.values(colorRecommendations).sort((a, b) => 
        b.adjustedConfidence - a.adjustedConfidence
    )[0];
    
	// NOVAS REGRAS DE RIGOR: Sistema de escalonamento 50% â†’ 60%
    // âœ… Premium (Modo PadrÃ£o): o rigor deve ser o rigor do usuÃ¡rio (configurÃ¡vel),
    // nÃ£o thresholds ocultos (rigorLevel / P(3 LOSS) / sig fixo).
    const { minOcc: minOccurrences, maxOcc: maxOccurrences } = getUserRigorThresholdsForPremium();
    const minStatisticalSignificance = 0; // nÃ£o aplicar gate oculto no Premium
    const minConfidence = 0; // nÃ£o aplicar gate oculto no Premium
    const hasRecentLoss = false;
    
    console.log(`ğŸ¯ Rigor do usuÃ¡rio (Premium): minOcc=${minOccurrences} | maxOcc=${maxOccurrences > 0 ? maxOccurrences : 'sem limite'} | win%Outras=${(analyzerConfig && typeof analyzerConfig.winPercentOthers === 'number') ? analyzerConfig.winPercentOthers : (DEFAULT_ANALYZER_CONFIG.winPercentOthers)}% | trigger=${(analyzerConfig && analyzerConfig.requireTrigger) ? 'on' : 'off'}`);
    console.log(`ğŸ¯ Melhor recomendaÃ§Ã£o: ${bestRecommendation.color} com ${bestRecommendation.adjustedConfidence.toFixed(1)}% (${bestRecommendation.count} padrÃ£o${bestRecommendation.count > 1 ? 's' : ''})`);
    
    // Verificar se atende aos critÃ©rios
    const bestAnalysis = bestRecommendation.analyses.sort((a, b) => b.confidence - a.confidence)[0];

    // âœ… Premium: sem filtro oculto de risco de sequÃªncia (P(3 LOSS))
    const streakRiskOk = true;

    const bestOcc = Number(bestAnalysis?.occurrences ?? 0);
    const bestSig = Number(bestAnalysis?.statisticalSignificance ?? 0);
    const meetsCriteria =
        (Number.isFinite(bestOcc) ? bestOcc : 0) >= minOccurrences &&
        (maxOccurrences === 0 || ((Number.isFinite(bestOcc) ? bestOcc : 0) <= maxOccurrences)) &&
        ((Number.isFinite(bestSig) ? bestSig : 0) >= minStatisticalSignificance) &&
        streakRiskOk;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // VALIDAÃ‡ÃƒO DE RIGOR POR TIPO DE ANÃLISE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let rigorOk = true;
    let rigorMessage = '';
    
    // Identificar qual tipo de anÃ¡lise foi escolhida como melhor
    const bestType = bestAnalysis.type;
    
    console.log(`\nğŸ¯ Tipo de anÃ¡lise selecionada: ${bestType}`);
    
    // âœ… APLICAR VALIDAÃ‡ÃƒO ESPECÃFICA BASEADA NO TIPO
    if (bestType === 'color-pattern' && colorAnalysis) {
        // âœ… PADRÃ•ES DE COR: Aplicar regras configurÃ¡veis do usuÃ¡rio
        console.log('ğŸ“Š Aplicando regras de RIGOR para PADRÃ•ES DE COR (configurÃ¡veis)...');
        
        const needsRigor = (analyzerConfig && (analyzerConfig.minOccurrences > 1 || (analyzerConfig.winPercentOthers || 0) > 0 || (analyzerConfig.maxOccurrences || 0) > 0 || (analyzerConfig.minPatternSize || 0) > 2));
        
    if (needsRigor) {
            const sampleMin = analyzerConfig.minOccurrences || 1;
            const sampleOk = colorAnalysis.sampleMinWins100 === true || sampleMin === 1;
            const rigorPct = typeof colorAnalysis.rigorWinPct === 'number' ? colorAnalysis.rigorWinPct : 
                             (typeof colorAnalysis.winPct === 'number' ? colorAnalysis.winPct : 0);
            const threshold = analyzerConfig.winPercentOthers || 0;
            
            // âœ… NOVA VALIDAÃ‡ÃƒO: OcorrÃªncias MÃXIMAS (0 = sem limite)
            const totalOccurrences = colorAnalysis.occurrences || 0;
            const maxOccurrences = analyzerConfig.maxOccurrences || 0;
            const maxOccurrencesOk = maxOccurrences === 0 || totalOccurrences <= maxOccurrences;
            
            // âœ… VALIDAÃ‡ÃƒO DE TAMANHO DO PADRÃƒO (minPatternSize e maxPatternSize)
            const patternSize = colorAnalysis.pattern ? colorAnalysis.pattern.length : 0;
            const minPatternSize = analyzerConfig.minPatternSize || 2;
            const maxPatternSize = analyzerConfig.maxPatternSize || 0; // 0 = sem limite
            const patternSizeOk = (patternSize >= minPatternSize) && (maxPatternSize === 0 || patternSize <= maxPatternSize);
            
            rigorOk = sampleOk && (rigorPct >= threshold) && maxOccurrencesOk && patternSizeOk;
            
            // âœ… LOG DETALHADO DO FILTRO DE RIGOR
            console.log('â•‘  ğŸ” VALIDAÃ‡ÃƒO DE RIGOR (Filtros de qualidade)            â•‘');
            console.log(`â•‘  ğŸ“ Tamanho do PadrÃ£o: ${patternSize} giros`);
            console.log(`â•‘  ğŸ¯ Limite MÃ­nimo: ${minPatternSize} giros`);
            console.log(`â•‘  ğŸ¯ Limite MÃ¡ximo: ${maxPatternSize === 0 ? 'SEM LIMITE' : maxPatternSize + ' giros'}`);
            console.log(`â•‘  ${patternSizeOk ? 'âœ…' : 'âŒ'} ValidaÃ§Ã£o Tamanho: ${patternSizeOk ? 'APROVADO' : 'REJEITADO'} ${maxPatternSize > 0 ? `(${minPatternSize} <= ${patternSize} <= ${maxPatternSize})` : `(${patternSize} >= ${minPatternSize})`}`);
            console.log(`â•‘  ğŸ“Š Total de OcorrÃªncias: ${totalOccurrences}`);
            console.log(`â•‘  ğŸ¯ Limite MÃ¡ximo OcorrÃªncias: ${maxOccurrences === 0 ? 'SEM LIMITE' : maxOccurrences}`);
            console.log(`â•‘  ${maxOccurrencesOk ? 'âœ…' : 'âŒ'} ValidaÃ§Ã£o MÃ¡ximo OcorrÃªncias: ${maxOccurrencesOk ? 'APROVADO' : 'REJEITADO'} ${maxOccurrences > 0 ? `(${totalOccurrences} <= ${maxOccurrences})` : ''}`);
            console.log(`â•‘  ğŸ“Š Demais OcorrÃªncias: ${colorAnalysis.othersCount || 0} (excluindo amostra mÃ­nima)`);
            console.log(`â•‘  âœ… Demais WINs: ${colorAnalysis.othersWins || 0}`);
            console.log(`â•‘  âŒ Demais LOSSes: ${colorAnalysis.othersLosses || 0}`);
            console.log(`â•‘  ğŸ“ˆ Rigor WIN%: ${rigorPct.toFixed(1)}%`);
            console.log(`â•‘  ğŸ¯ Threshold WIN% (configurado): ${threshold}%`);
            console.log(`â•‘  ${(rigorPct >= threshold) ? 'âœ…' : 'âŒ'} ValidaÃ§Ã£o WIN%: ${(rigorPct >= threshold) ? 'APROVADO' : 'REJEITADO'} (rigorPct >= threshold)`);
            console.log(`â•‘  ${rigorOk ? 'âœ… RESULTADO FINAL: APROVADO' : 'âŒ RESULTADO FINAL: REJEITADO'}                              â•‘`);
        }
        
    } else if (bestType === 'number-correlation' && numberAnalysis) {
        // âœ… ANÃLISE NÃšMERO + COR: 3 ocorrÃªncias, 100% WIN (0 LOSS)
        console.log('ğŸ”¢ Aplicando regras de RIGOR para NÃšMERO + COR (3 occ, 100% WIN)...');
        const validation = validateNumberAnalysis(numberAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else if (bestType === 'time-pattern' && timeAnalysis) {
        // âœ… ANÃLISE TEMPORAL: 6 ocorrÃªncias, 100% WIN (0 LOSS)
        console.log('â° Aplicando regras de RIGOR para ANÃLISE TEMPORAL (6 occ, 100% WIN)...');
        const validation = validateTemporalAnalysis(timeAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else if (bestType === 'correlation' && correlationAnalysis) {
        // âœ… ANÃLISE DE CICLO: 6 ocorrÃªncias, 100% WIN (0 LOSS)
        console.log('ğŸ”„ Aplicando regras de RIGOR para ANÃLISE DE CICLO (6 occ, 100% WIN)...');
        const validation = validateCorrelationAnalysis(correlationAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else if (bestType === 'frequency' && frequencyAnalysis) {
        // âœ… ANÃLISE DE TENDÃŠNCIA: 5 ocorrÃªncias, 100% WIN (0 LOSS)
        console.log('ğŸ“Š Aplicando regras de RIGOR para TENDÃŠNCIA/FREQUÃŠNCIA (5 occ, 100% WIN)...');
        const validation = validateFrequencyAnalysis(frequencyAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else if (bestType === 'mixed-pattern' && timeAnalysis) {
        // âœ… PADRÃƒO TEMPORAL/MISTO: Usar mesma validaÃ§Ã£o temporal (6 occ, 100% WIN)
        console.log('ğŸ”€ Aplicando regras de RIGOR para PADRÃƒO MISTO (6 occ, 100% WIN)...');
        const validation = validateTemporalAnalysis(timeAnalysis);
        rigorOk = validation.valid;
        if (!rigorOk) rigorMessage = validation.reason;
        
    } else {
        // âœ… TIPO DESCONHECIDO OU SEM ANÃLISE: Rejeitar
        console.log(`âš ï¸ Tipo de anÃ¡lise desconhecido ou sem dados: ${bestType}`);
        rigorOk = false;
        rigorMessage = `Tipo de anÃ¡lise nÃ£o suportado: ${bestType}`;
    }

    if (!meetsCriteria || !rigorOk) {
        if (!rigorOk && rigorMessage) {
            console.log(`âŒ AnÃ¡lise rejeitada por validaÃ§Ã£o especÃ­fica: ${rigorMessage}`);
        }
        if (!rigorOk) {
            console.log('âŒ AnÃ¡lise rejeitada por rigor do usuÃ¡rio:', {
                hasColorAnalysis: !!colorAnalysis,
                patternSize: colorAnalysis && colorAnalysis.pattern ? colorAnalysis.pattern.length : undefined,
                minPatternSize: analyzerConfig.minPatternSize,
                maxPatternSize: analyzerConfig.maxPatternSize || 'sem limite',
                totalOccurrences: colorAnalysis ? colorAnalysis.occurrences : undefined,
                maxOccurrences: analyzerConfig.maxOccurrences || 'sem limite',
                sampleMin: analyzerConfig.minOccurrences,
                sampleMinWins100: colorAnalysis ? colorAnalysis.sampleMinWins100 : undefined,
                rigorWinPct: colorAnalysis ? (colorAnalysis.rigorWinPct ?? colorAnalysis.winPct) : undefined,
                threshold: analyzerConfig.winPercentOthers
            });
        }
        // âœ… LOG SEGURO (Premium): sem gates ocultos (sem P(3 LOSS) / rigorLevel)
        const confStr = bestRecommendation?.adjustedConfidence != null ? bestRecommendation.adjustedConfidence.toFixed(1) : 'N/A';
        const occStr = bestAnalysis?.occurrences != null ? bestAnalysis.occurrences : 'N/A';
        const sigStr = bestAnalysis?.statisticalSignificance != null ? bestAnalysis.statisticalSignificance.toFixed(2) : 'N/A';
        const maxOccStr = (typeof maxOccurrences === 'number' && maxOccurrences > 0) ? `/mÃ¡x ${maxOccurrences}` : '';
        console.log(`âŒ AnÃ¡lise rejeitada (Premium): conf=${confStr}%, occ=${occStr}/${minOccurrences}${maxOccStr}, sig=${sigStr}${rigorMessage ? ` | ${rigorMessage}` : ''}`);
        return null;
    }
    
    // âœ… LOG SEGURO para aprovaÃ§Ã£o tambÃ©m
    const confStrOk = bestRecommendation?.adjustedConfidence != null ? bestRecommendation.adjustedConfidence.toFixed(1) : 'N/A';
    const occStrOk = bestAnalysis?.occurrences != null ? bestAnalysis.occurrences : 'N/A';
    const sigStrOk = bestAnalysis?.statisticalSignificance != null ? bestAnalysis.statisticalSignificance.toFixed(2) : 'N/A';
    console.log(`âœ… ANÃLISE MULTIDIMENSIONAL APROVADA: conf=${confStrOk}%, occ=${occStrOk}, sig=${sigStrOk}`);
    
    // Aplicar calibraÃ§Ã£o do observador inteligente na confianÃ§a final
    const rawConfidence = bestRecommendation.adjustedConfidence;
    const calibratedConfidence = applyCalibratedConfidence(rawConfidence);
    
    // Calcular contribuiÃ§Ãµes baseadas no consenso
    const contributions = {};
    bestRecommendation.analyses.forEach(analysis => {
        const weight = analysis.type === 'color-pattern' ? 0.30 : 
                      analysis.type === 'number-correlation' ? 0.25 :
                      analysis.type === 'time-pattern' ? 0.20 :
                      analysis.type === 'mixed-pattern' ? 0.20 :
                      analysis.type === 'correlation' ? 0.15 : 0.10;
        contributions[analysis.type] = analysis.confidence * weight;
    });
    
    // âœ… CRIAR TIMESTAMPS CORRETOS (nÃºmeros, nÃ£o strings!)
    const now = Date.now();
    const nextSpinTimestamp = now + 30000; // 30 segundos para prÃ³ximo giro
    
    return {
        suggestion: 'Entrada na prÃ³xima rodada (anÃ¡lise multidimensional confirmada)',
        color: bestRecommendation.color,
        confidence: calibratedConfidence,
        patternDescription: JSON.stringify({
            	expected_next: bestRecommendation.color,
            colorAnalysis: colorAnalysis ? { 
                pattern: colorAnalysis.pattern, 
                confidence: colorAnalysis.confidence,
                occurrences: colorAnalysis.occurrences,
                allOccurrenceTimestamps: colorAnalysis.allOccurrenceTimestamps || [],
                allOccurrenceNumbers: colorAnalysis.allOccurrenceNumbers || [],
                occurrenceTimes: colorAnalysis.occurrenceTimes || [],
                triggerColor: colorAnalysis.triggerColor || null,
                allTriggerColors: colorAnalysis.allTriggerColors || [],
                allTriggerNumbers: colorAnalysis.allTriggerNumbers || [],
                allTriggerTimestamps: colorAnalysis.allTriggerTimestamps || [],
                occurrenceDetails: colorAnalysis.occurrenceDetails || [],
                assertiveness: colorAnalysis.assertivenessExplain ? colorAnalysis.assertivenessExplain : {
                    occurrences: colorAnalysis.occurrences,
                    wins: colorAnalysis.wins,
                    losses: colorAnalysis.losses,
                    winPct: colorAnalysis.winPct,
                    lossPct: colorAnalysis.lossPct,
                    othersCount: colorAnalysis.othersCount,
                    othersWins: colorAnalysis.othersWins,
                    othersLosses: colorAnalysis.othersLosses,
                    rigorWinPct: colorAnalysis.rigorWinPct,
                    sampleMin: colorAnalysis.sampleMin,
                    sampleMinWins100: colorAnalysis.sampleMinWins100
                }
            } : null,
            numberAnalysis: numberAnalysis ? { pattern: numberAnalysis.pattern, confidence: numberAnalysis.confidence } : null,
            timeAnalysis: timeAnalysis ? { pattern: timeAnalysis.pattern, confidence: timeAnalysis.confidence } : null,
            correlationAnalysis: correlationAnalysis ? { pattern: correlationAnalysis.pattern, confidence: correlationAnalysis.confidence } : null,
            frequencyAnalysis: frequencyAnalysis ? { pattern: frequencyAnalysis.pattern, confidence: frequencyAnalysis.confidence } : null,
            contributions: contributions,
            finalConfidence: calibratedConfidence,
            rawConfidence: rawConfidence,
            rigorLevel: minConfidence,
            hasRecentLoss: hasRecentLoss,
            consensusCount: bestRecommendation.count,
            consensusBonus: bestRecommendation.count > 1 ? (bestRecommendation.count - 1) * 5 : 0
        }),
        // âœ… TIMESTAMPS NUMÃ‰RICOS para validaÃ§Ã£o WIN/LOSS funcionar!
        createdOnTimestamp: now,
        predictedFor: nextSpinTimestamp,
        phase: 'G0',
        contributions: contributions,
        rigorLevel: minConfidence,
        hasRecentLoss: hasRecentLoss,
        consensusCount: bestRecommendation.count,
        consensusBonus: bestRecommendation.count > 1 ? (bestRecommendation.count - 1) * 5 : 0
    };
}



// Calcular similaridade entre sequÃªncias
function calculateSequenceSimilarity(seq1, seq2) {
    if (seq1.length !== seq2.length) return 0;
    
    let matches = 0;
    for (let i = 0; i < seq1.length; i++) {
        if (seq1[i] === seq2[i]) matches++;
    }
    
    return matches / seq1.length;
}

// Analisar padrÃµes temporais
function analyzeTemporalPatterns(history) {
    const now = new Date();
    const currentHour = now.getHours();
    
    // Analisar giros do mesmo horÃ¡rio nos Ãºltimos dias
    const recentHistory = history.filter(spin => {
        const spinTime = new Date(spin.timestamp);
        const timeDiff = now - spinTime;
        return timeDiff < 7 * 24 * 60 * 60 * 1000; // Ãšltimos 7 dias
    });
    
    const hourlyPatterns = {};
    recentHistory.forEach(spin => {
        const spinTime = new Date(spin.timestamp);
        const hour = spinTime.getHours();
        
        if (!hourlyPatterns[hour]) {
            hourlyPatterns[hour] = { red: 0, black: 0, white: 0, total: 0 };
        }
        
        hourlyPatterns[hour][spin.color]++;
        hourlyPatterns[hour].total++;
    });
    
    // Encontrar padrÃ£o no horÃ¡rio atual
    const currentHourPattern = hourlyPatterns[currentHour];
    if (currentHourPattern && currentHourPattern.total >= 5) {
        const redPercent = (currentHourPattern.red / currentHourPattern.total) * 100;
        const blackPercent = (currentHourPattern.black / currentHourPattern.total) * 100;
        const whitePercent = (currentHourPattern.white / currentHourPattern.total) * 100;
        
        // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
        let suggestedColor = null;
        let confidence = 0;
        
        if (redPercent > 60) {
            suggestedColor = 'red';
            confidence = Math.min(redPercent, 80);
        } else if (blackPercent > 60) {
            suggestedColor = 'black';
            confidence = Math.min(blackPercent, 80);
        } else if (whitePercent > 30) {
            suggestedColor = 'white';
            confidence = Math.min(whitePercent * 2, 70);
        }
        
        if (!suggestedColor || confidence === 0) return null;
        
        return {
            type: 'temporal',
            suggestedColor: suggestedColor,
            confidence: confidence,
            pattern: `PadrÃ£o horÃ¡rio ${currentHour}h: ${redPercent.toFixed(1)}%V ${blackPercent.toFixed(1)}%P ${whitePercent.toFixed(1)}%B`
        };
    }
    
    return null;
}

// Analisar frequÃªncia de cores
function analyzeColorFrequency(history) {
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const recentSpins = history; // Todo o histÃ³rico
    const colorCounts = { red: 0, black: 0, white: 0 };
    
    recentSpins.forEach(spin => {
        colorCounts[spin.color]++;
    });
    
    const total = recentSpins.length;
    const redPercent = (colorCounts.red / total) * 100;
    const blackPercent = (colorCounts.black / total) * 100;
    const whitePercent = (colorCounts.white / total) * 100;
    
    // Se uma cor estÃ¡ muito frequente, sugerir a oposta
    // âœ… CORREÃ‡ÃƒO: NÃ£o usar padrÃ£o 'red'
    let suggestedColor = null;
    let confidence = 0;
    let pattern = '';
    
    if (redPercent > 70) {
        suggestedColor = 'black';
        confidence = Math.min(redPercent - 50, 60);
        pattern = `Vermelho dominante (${redPercent.toFixed(1)}%) - Sugerindo preto`;
    } else if (blackPercent > 70) {
        suggestedColor = 'red';
        confidence = Math.min(blackPercent - 50, 60);
        pattern = `Preto dominante (${blackPercent.toFixed(1)}%) - Sugerindo vermelho`;
    } else if (whitePercent > 25) {
        // âœ… CORREÃ‡ÃƒO: Sugerir a cor MENOS frequente entre red e black
        suggestedColor = redPercent < blackPercent ? 'red' : 'black';
        confidence = Math.min(whitePercent * 2, 60);
        const colorText = suggestedColor === 'red' ? 'vermelho' : 'preto';
        pattern = `Branco frequente (${whitePercent.toFixed(1)}%) - Sugerindo ${colorText}`;
    } else {
        // PadrÃ£o equilibrado, usar anÃ¡lise de sequÃªncias
        return null;
    }
    
    if (!suggestedColor) return null;
    
    return {
        type: 'frequency',
        suggestedColor: suggestedColor,
        confidence: confidence,
        pattern: pattern
    };
}

// Combinar todas as anÃ¡lises
function combineAnalyses(sequenceAnalysis, zoneAnalysis, trendAnalysis) {
    const analysis = sequenceAnalysis || null;
    if (!analysis) {
        return null;
    }

    // Base confidence from sequence (sem limitaÃ§Ã£o artificial)
    let confidence = analysis.confidence || 0;
    const occurrences = analysis.occurrences || 0;
    const statisticalSignificance = analysis.statisticalSignificance || 1;

    // Ajustes por zona e tendÃªncia (mais conservador)
    if (zoneAnalysis) {
        if (zoneAnalysis.zoneColor === analysis.suggestedColor) {
            confidence = Math.min(confidence + (zoneAnalysis.confidence * 0.3), 95); // Apenas 30% do boost
        } else {
            confidence = Math.max(confidence - (zoneAnalysis.confidence * 0.2), 0); // Penalidade menor
        }
    }
    if (trendAnalysis) {
        if (trendAnalysis.trendColor === analysis.suggestedColor) {
            confidence = Math.min(confidence + (trendAnalysis.confidence * 0.3), 95); // Apenas 30% do boost
        } else {
            confidence = Math.max(confidence - (trendAnalysis.confidence * 0.2), 0); // Penalidade menor
        }
    }

    // CRITÃ‰RIOS ULTRA RIGOROSOS PARA 80%+ ACERTIVIDADE
    const allowEntry = confidence >= 80 && occurrences >= 5 && statisticalSignificance >= 2.0;
    if (!allowEntry) {
        console.log(`PadrÃ£o rejeitado: conf=${confidence.toFixed(1)}%, occ=${occurrences}, sig=${statisticalSignificance.toFixed(2)}`);
        return null;
    }

    const description = JSON.stringify({ 
        pattern: analysis.pattern, 
        occurrences: analysis.occurrences, 
        times: analysis.occurrenceTimes || [], 
        lastSequenceTimes: analysis.lastOccurrenceTimestamps || [],
        lastSequenceNumbers: analysis.lastOccurrenceNumbers || [],
        zone: zoneAnalysis ? { color: zoneAnalysis.zoneColor, dominance: zoneAnalysis.dominance } : null,
        trend: trendAnalysis ? { color: trendAnalysis.trendColor, aligned: trendAnalysis.alignment } : null,
        statisticalSignificance: statisticalSignificance
    });

    console.log(`âœ… PADRÃƒO APROVADO: conf=${confidence.toFixed(1)}%, occ=${occurrences}, sig=${statisticalSignificance.toFixed(2)}`);

    return {
        suggestion: 'Entrada na prÃ³xima rodada (padrÃ£o confirmado)',
        color: analysis.suggestedColor,
        confidence: confidence,
        patternDescription: description,
        createdOnTimestamp: analysis.createdOnTimestamp || null,
        predictedFor: 'next',
        phase: 'G0'
    };
}

// Analyze color streaks
function analyzeColorStreaks(spins) {
    const colors = spins.map(s => s.color);
    const lastColor = colors[0];
    const streakLength = getStreakLength(colors, lastColor);
    
    // If streak is 3 or more, suggest opposite color
    if (streakLength >= 3) {
        const oppositeColor = lastColor === 'red' ? 'black' : lastColor === 'black' ? 'red' : 'red';
        const confidence = Math.min(streakLength * 15, 70); // Max 70% confidence
        
        return {
            confidence,
            suggestion: `SequÃªncia de ${streakLength} ${lastColor}s detectada`,
            color: oppositeColor,
            probability: confidence,
            description: `PadrÃ£o de sequÃªncia: ${streakLength} ${lastColor}s consecutivos`,
            weight: 1.2
        };
    }
    
    return null;
}

// Analyze number distribution
function analyzeNumberDistribution(spins) {
    const numbers = spins.map(s => s.number);
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const recentNumbers = numbers; // Todo o histÃ³rico
    
    // Count frequency of each number
    const frequency = {};
    recentNumbers.forEach(num => {
        frequency[num] = (frequency[num] || 0) + 1;
    });
    
    // Find least frequent numbers
    const minFreq = Math.min(...Object.values(frequency));
    const leastFrequent = Object.keys(frequency).filter(num => frequency[num] === minFreq);
    
    if (leastFrequent.length > 0 && minFreq === 0) {
        const suggestedNumber = parseInt(leastFrequent[0]);
        const color = getColorFromNumber(suggestedNumber);
        
        return {
            confidence: 45,
            suggestion: `NÃºmero ${suggestedNumber} nÃ£o apareceu recentemente`,
            color,
            probability: 45,
            description: `DistribuiÃ§Ã£o: nÃºmero ${suggestedNumber} ausente nas Ãºltimas 20 rodadas`,
            weight: 0.8
        };
    }
    
    return null;
}

// Analyze alternating patterns
function analyzeAlternatingPatterns(spins) {
    const colors = spins.map(s => s.color);
    
    // Check for alternating pattern in last 6 spins
    if (colors.length >= 6) {
        const last6 = colors.slice(0, 6);
        let alternating = true;
        
        for (let i = 1; i < last6.length; i++) {
            if (last6[i] === last6[i-1]) {
                alternating = false;
                break;
            }
        }
        
        if (alternating) {
            const nextColor = last6[0] === 'red' ? 'black' : last6[0] === 'black' ? 'red' : 'red';
            
            return {
                confidence: 55,
                suggestion: 'PadrÃ£o alternado detectado',
                color: nextColor,
                probability: 55,
                description: 'PadrÃ£o alternado nas Ãºltimas 6 rodadas',
                weight: 1.0
            };
        }
    }
    
    return null;
}

// Analyze hot/cold numbers
function analyzeHotColdNumbers(spins) {
    const numbers = spins.map(s => s.number);
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const recentNumbers = numbers; // Todo o histÃ³rico
    
    // Count frequency
    const frequency = {};
    recentNumbers.forEach(num => {
        frequency[num] = (frequency[num] || 0) + 1;
    });
    
    // Find hot numbers (appeared most frequently)
    const maxFreq = Math.max(...Object.values(frequency));
    const hotNumbers = Object.keys(frequency).filter(num => frequency[num] === maxFreq);
    
    if (hotNumbers.length > 0 && maxFreq >= 3) {
        const suggestedNumber = parseInt(hotNumbers[0]);
        const color = getColorFromNumber(suggestedNumber);
        
        return {
            confidence: 40,
            suggestion: `NÃºmero quente: ${suggestedNumber}`,
            color,
            probability: 40,
            description: `NÃºmero ${suggestedNumber} apareceu ${maxFreq} vezes nas Ãºltimas 30 rodadas`,
            weight: 0.6
        };
    }
    
    return null;
}

// Reconhecimento de Zonas: detecta cor dominante em janelas recentes
function analyzeZones(history) {
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const windowSize = history.length; // Todo o histÃ³rico
    if (windowSize < 50) return null; // MÃ­nimo de 50 giros
    const recent = history; // Todo o histÃ³rico
    const colorCounts = { red: 0, black: 0, white: 0 };
    recent.forEach(s => { colorCounts[s.color] = (colorCounts[s.color] || 0) + 1; });
    const total = recent.length;
    const ratios = {
        red: colorCounts.red / total,
        black: colorCounts.black / total,
        white: colorCounts.white / total
    };
    let zoneColor = 'red';
    if (ratios.black >= ratios.red && ratios.black >= ratios.white) zoneColor = 'black';
    else if (ratios.white >= ratios.red && ratios.white >= ratios.black) zoneColor = 'white';
    const dominance = Math.max(ratios.red, ratios.black, ratios.white) * 100; // 0-100
    if (dominance < 55) return null; // Sem zona dominante
    return {
        type: 'zone',
        zoneColor,
        dominance,
        confidence: Math.min(dominance - 50, 15) // atÃ© +15
    };
}

// Reconhecimento de TendÃªncia: compara janelas curta e mÃ©dia
function analyzeTrend(history) {
    // Usar TODO o histÃ³rico disponÃ­vel para mÃ¡xima precisÃ£o
    const shortN = Math.min(50, history.length); // Janela curta: 50 giros
    const midN = history.length; // Janela mÃ©dia: todo o histÃ³rico
    if (shortN < 50) return null; // MÃ­nimo de 50 giros
    const short = history.slice(0, shortN);
    const mid = history; // Todo o histÃ³rico
    function dominantColor(spins) {
        const c = { red: 0, black: 0, white: 0 };
        spins.forEach(s => { c[s.color] = (c[s.color] || 0) + 1; });
        const total = spins.length;
        const r = c.red / total, b = c.black / total, w = c.white / total;
        let color = 'red', dom = r;
        if (b >= dom) { color = 'black'; dom = b; }
        if (w >= dom) { color = 'white'; dom = w; }
        return { color, share: dom*100 };
    }
    const s = dominantColor(short);
    const m = dominantColor(mid);
    if (s.share < 55 && m.share < 55) return null; // tendÃªncia fraca
    const aligned = s.color === m.color;
    return {
        type: 'trend',
        trendColor: aligned ? s.color : s.color,
        alignment: aligned,
        confidence: aligned ? Math.min((s.share - 50) + (m.share - 50), 20) : Math.min(s.share - 50, 10) // atÃ© +20
    };
}

// Helper functions
function getStreakLength(colors, color) {
    let streak = 0;
    for (let i = 0; i < colors.length; i++) {
        if (colors[i] === color) {
            streak++;
        } else {
            break;
        }
    }
    return streak;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GET COLOR FROM NUMBER (GLOBAL) - REFATORADO 100%
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getColorFromNumber(number) {
    // âœ… VALIDAÃ‡ÃƒO DE ENTRADA (silenciosa - undefined Ã© comum em anÃ¡lises)
    if (typeof number !== 'number' || isNaN(number) || number === undefined || number === null) {
        return 'unknown';
    }
    
    // âœ… NORMALIZAR NÃšMERO (caso seja float)
    const normalizedNumber = Math.floor(number);
    
    // âœ… VALIDAR RANGE (0-14)
    if (normalizedNumber < 0 || normalizedNumber > 14) {
        return 'unknown';
    }
    
    // âœ… DETERMINAR COR
    if (normalizedNumber === 0) {
        return 'white';
    } else if (normalizedNumber >= 1 && normalizedNumber <= 7) {
        return 'red';
    } else if (normalizedNumber >= 8 && normalizedNumber <= 14) {
    return 'black';
    }
    
    // âœ… FALLBACK (nunca deve chegar aqui)
    return 'unknown';
}

// ========= NOVO: CÃ¡lculo inteligente de assertividade =========
// (Constantes movidas para o inÃ­cio do arquivo para evitar TDZ errors)

// Calcula assertividade para padrÃµes de cor (pattern: [colors], expectedNext: 'red'|'black'|'white')
function computeAssertivenessForColorPattern(patternColors, expectedNext, history) {
	try {
		if (!Array.isArray(patternColors) || patternColors.length < 3 || !history || history.length < 50) {
			return null;
		}

		// 1) Desempenho histÃ³rico do padrÃ£o (wins/losses)
		let totalWins = 0, totalLosses = 0, totalOcc = 0;
		const colors = history.map(s => s.color);
		const need = patternColors.length;
		for (let i = need; i < colors.length; i++) {
			const seq = colors.slice(i, i + need);
			if (seq.length < need) break;
			const match = seq.every((c, idx) => c === patternColors[idx]);
			if (!match) continue;
			totalOcc++;
			const outcome = colors[i - 1];
			if (outcome === expectedNext) totalWins++; else totalLosses++;
		}
		if (totalOcc === 0) return null;
		let base = (totalWins / totalOcc) * 100;
		if (totalLosses === 0 && totalWins >= 3) base = Math.min(100, 95 + Math.min(totalWins, 5));

		// 2) TendÃªncia recente (Ãºltimos 25 giros)
		const recent = history.slice(0, Math.min(RECENT_WINDOW, history.length));
		const rc = { red: 0, black: 0, white: 0 };
		recent.forEach(s => { rc[s.color] = (rc[s.color] || 0) + 1; });
		const totalRecent = recent.length || 1;
		const recentPct = {
			red: (rc.red / totalRecent) * 100,
			black: (rc.black / totalRecent) * 100,
			white: (rc.white / totalRecent) * 100
		};
		let trendAdj = 0;
		// DominÃ¢ncia oposta >70% â†’ -15%
		const opposite = expectedNext === 'red' ? 'black' : expectedNext === 'black' ? 'red' : (recentPct.red >= recentPct.black ? 'red' : 'black');
		if (recentPct[opposite] > 70) trendAdj -= PENALTY_OPPOSITE_DOMINANCE;
		// RepetiÃ§Ã£o longa atual >5 â†’ -10%
		const streakLen = getStreakLength(colors, colors[0]);
		if (streakLen > 5) trendAdj -= PENALTY_LONG_STREAK;
		// TendÃªncia a favor >60% â†’ +10%
		if (recentPct[expectedNext] > 60) trendAdj += BONUS_FAVORABLE_TREND;

		// 3) Estabilidade do padrÃ£o (variÃ¢ncia do desempenho por janelas)
		// AproximaÃ§Ã£o: medir taxa de acerto por blocos de 10 ocorrÃªncias
		let stabilityAdj = 0;
		if (totalOcc >= 6) {
			const blockSize = 10;
			const accRates = [];
			let acc = 0, cnt = 0;
			// Revarrer somando wins/losses sequencialmente
			for (let i = need; i < colors.length; i++) {
				const seq = colors.slice(i, i + need);
				if (seq.length < need) break;
				if (!seq.every((c, idx) => c === patternColors[idx])) continue;
				cnt++;
				const outcome = colors[i - 1];
				if (outcome === expectedNext) acc++;
				if (cnt === blockSize) {
					accRates.push(acc / cnt);
					acc = 0; cnt = 0;
				}
			}
			if (cnt > 0) accRates.push(acc / cnt);
			if (accRates.length >= 2) {
				const mean = accRates.reduce((a,b)=>a+b,0) / accRates.length;
				const variance = accRates.reduce((s,v)=> s + Math.pow(v - mean, 2), 0) / accRates.length;
				const std = Math.sqrt(variance);
				// Baixa variÃ¢ncia â†’ estÃ¡vel
				if (std <= 0.1) stabilityAdj += BONUS_STABILITY;
				else if (std >= 0.25) stabilityAdj -= PENALTY_INSTABILITY;
			}
		}

		// 4) Final
	let rawConfidence = Math.max(0, Math.min(100, base + trendAdj + stabilityAdj));
	
	// 5) Aplicar calibraÃ§Ã£o do observador inteligente
	let finalConfidence = applyCalibratedConfidence(rawConfidence);
	
	// LOG DETALHADO para debug (padrÃµes com 100% win)
	if (totalLosses === 0 && totalWins >= 3) {
		console.log('ğŸ” PADRÃƒO 100% WIN - CÃLCULO DETALHADO:', {
			pattern: patternColors.join('-'),
			expected_next: expectedNext,
			total_wins: totalWins,
			total_losses: totalLosses,
			'BASE (antes ajustes)': base.toFixed(2) + '%',
			'--- ÃšLTIMOS 25 GIROS ---': '',
			red_pct: recentPct.red.toFixed(1) + '%',
			black_pct: recentPct.black.toFixed(1) + '%',
			white_pct: recentPct.white.toFixed(1) + '%',
			'--- AJUSTES ---': '',
			cor_oposta: opposite,
			dominancia_oposta: recentPct[opposite].toFixed(1) + '%',
			penalidade_dominancia: recentPct[opposite] > 70 ? '-15%' : '0%',
			repeticao_atual: streakLen,
			penalidade_repeticao: streakLen > 5 ? '-10%' : '0%',
			bonus_tendencia: recentPct[expectedNext] > 60 ? '+10%' : '0%',
			'AJUSTE TENDÃŠNCIA TOTAL': trendAdj + '%',
			'AJUSTE ESTABILIDADE': stabilityAdj + '%',
			'--- RESULTADO FINAL ---': '',
			calculo: `${base} + ${trendAdj} + ${stabilityAdj} = ${base + trendAdj + stabilityAdj}`,
			'CONFIANÃ‡A RAW': rawConfidence.toFixed(2) + '%',
			'FATOR CALIBRAÃ‡ÃƒO': (observerData.calibrationFactor * 100).toFixed(1) + '%',
			'CONFIANÃ‡A CALIBRADA': finalConfidence + '%'
		});
	}
	
		return {
			finalConfidence,
			explain: {
				pattern: patternColors,
				expected_next: expectedNext,
				total_wins: totalWins,
				total_losses: totalLosses,
				recent_window: RECENT_WINDOW,
				tendencia_ultimos_25: recentPct,
				repeticao_atual: streakLen,
				base: parseFloat(base.toFixed(2)),
				ajuste_tendencia: trendAdj,
				ajuste_estabilidade: stabilityAdj,
				assertividade_final: parseFloat(finalConfidence.toFixed(2))
			}
		};
	} catch (e) {
		console.warn('Falha no computeAssertivenessForColorPattern:', e);
		return null;
	}
}

// FunÃ§Ã£o auxiliar para enviar mensagens com tratamento de erro
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENVIAR MENSAGEM PARA CONTENT SCRIPT - REFATORADO 100% (Async com verificaÃ§Ã£o)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function sendMessageToContent(type, data = null) {
    return new Promise((resolve) => {
        chrome.tabs.query({}, function(tabs) {
            const blazeTabs = tabs.filter(tab => {
                if (!tab.url) return false;
                return tab.url.includes('blaze.bet.br') || 
                       tab.url.includes('blaze.com') || 
                       tab.url.includes('blaze1.space') ||
                       tab.url.includes('blaze-1.com');
            });
            
            if (!blazeTabs || blazeTabs.length === 0) {
                resolve(false);
                return;
            }
            
            const message = { type };
            if (data) {
                message.data = data;
            }

            let successCount = 0;
            let processedCount = 0;

            const finalize = () => {
                if (processedCount === blazeTabs.length) {
                    resolve(successCount > 0);
                }
            };

            blazeTabs.forEach(tab => {
                chrome.tabs.sendMessage(tab.id, message)
                .then(() => {
                        successCount += 1;
                        processedCount += 1;
                        finalize();
                })
                .catch(error => {
                        processedCount += 1;
                        if (error?.message && (
                            error.message.includes('Could not establish connection') ||
                            error.message.includes('Receiving end does not exist')
                        )) {
                            finalize();
                } else {
                            if (error) {
                                console.error(`âŒ Erro ao enviar ${type} para a aba ${tab.id}:`, error);
                            }
                            finalize();
                        }
                    });
            });
        });
    });
}

function attachLatestSpinsSnapshot(analysis) {
    if (!analysis || !Array.isArray(cachedHistory)) {
        return analysis;
    }
    try {
        const payload = { ...analysis };
        const last14 = cachedHistory.slice(0, 14).map(spin => ({
            color: spin.color,
            number: spin.number,
            timestamp: spin.timestamp
        }));
        const last10 = last14.slice(0, 10);

        payload.last10Spins = last10;
        payload.last14Spins = last14;
        payload.last5Spins = last14;

        if (!payload.phase && martingaleState && martingaleState.active) {
            payload.phase = martingaleState.stage || 'G0';
        }

        if (typeof payload.patternDescription === 'string') {
            try {
                const parsed = JSON.parse(payload.patternDescription);
                if (parsed && typeof parsed === 'object') {
                    parsed.last14Spins = last14;
                    parsed.last10Spins = last10;
                    parsed.last5Spins = last14;
                    payload.patternDescription = JSON.stringify(parsed);
                }
            } catch (_) {
                // ignorar: patternDescription nÃ£o Ã© JSON
            }
        } else if (payload.patternDescription && typeof payload.patternDescription === 'object') {
            payload.patternDescription = {
                ...payload.patternDescription,
                last14Spins: last14,
                last10Spins: last10,
                last5Spins: last14
            };
        }

        return payload;
    } catch (error) {
        console.warn('âš ï¸ NÃ£o foi possÃ­vel anexar Ãºltimos giros ao payload da anÃ¡lise:', error);
        return analysis;
    }
}

// âœ… Para o modal "PadrÃ£o da Entrada":
// garantir que o snapshot de giros inclua o GIRO QUE RESOLVEU a entrada (WIN/LOSS) no Ã­ndice 0,
// mesmo se o cachedHistory ainda nÃ£o tiver atualizado.
function buildEntrySpinsSnapshot(resolvedSpin, limit = 14) {
    const safeLimit = Math.max(1, Math.min(30, Math.floor(Number(limit) || 14)));
    const out = [];
    const norm = (s) => {
        const color = s && s.color != null ? s.color : null;
        const number = s && s.number != null ? s.number : null;
        const timestamp = (s && (s.timestamp != null ? s.timestamp : (s.created_at != null ? s.created_at : null))) || null;
        return { color, number, timestamp };
    };
    try {
        if (resolvedSpin && typeof resolvedSpin === 'object') {
            out.push(norm(resolvedSpin));
        }
    } catch (_) {}

    try {
        const resTs = out[0] && out[0].timestamp != null ? out[0].timestamp : null;
        const arr = Array.isArray(cachedHistory) ? cachedHistory : [];
        for (const s of arr) {
            if (out.length >= safeLimit) break;
            const ns = norm(s);
            if (resTs != null && ns.timestamp != null && ns.timestamp === resTs) continue;
            out.push(ns);
        }
    } catch (_) {}
    return out.slice(0, safeLimit);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§© FASE 2 - SINAL DE ENTRADA (APURAÃ‡ÃƒO POR HISTÃ“RICO DE ENTRADAS)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ’ DIAMANTE: identificar qual nÃ­vel "mandou" o sinal (nÃ­vel de origem)
// Regra: maior contribuiÃ§Ã£o para a cor vencedora; se nenhum votou na cor, pega o maior geral.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pickDiamondSourceLevel(levelsRaw, winningColorRaw) {
    const winningColor = String(winningColorRaw || '').toLowerCase().trim();
    const levels = Array.isArray(levelsRaw) ? levelsRaw : [];
    if (!levels.length) return null;

    const normalize = (lvl) => {
        const id = lvl && lvl.id ? String(lvl.id) : null;
        const name = lvl && lvl.name ? String(lvl.name) : null;
        const color = lvl && lvl.color ? String(lvl.color).toLowerCase().trim() : null;
        const contribution = Number.isFinite(Number(lvl.contribution))
            ? Number(lvl.contribution)
            : (Number.isFinite(Number(lvl.score)) && Number.isFinite(Number(lvl.weight))
                ? Number(lvl.score) * Number(lvl.weight)
                : 0);
        const strength = Number.isFinite(Number(lvl.strength)) ? Number(lvl.strength) : null;
        const weight = Number.isFinite(Number(lvl.weight)) ? Number(lvl.weight) : null;
        return { id, name, color, contribution, strength, weight };
    };

    const normalized = levels.map(normalize).filter(x => x && x.id);
    if (!normalized.length) return null;

    const candidates = (winningColor === 'red' || winningColor === 'black' || winningColor === 'white')
        ? normalized.filter(l => l.color === winningColor)
        : normalized;

    const pool = candidates.length ? candidates : normalized;
    pool.sort((a, b) => (b.contribution || 0) - (a.contribution || 0));
    const top = pool[0];
    if (!top) return null;
    return {
        id: top.id,
        name: top.name || top.id,
        color: top.color || null,
        contribution: Number.isFinite(Number(top.contribution)) ? Number(top.contribution.toFixed(3)) : 0,
        strength: top.strength != null ? Number(top.strength.toFixed(3)) : null,
        weight: top.weight != null ? Number(top.weight.toFixed(3)) : null
    };
}

function computeDiamondEntryHitRatesFromEntries(entriesHistoryRaw) {
    const entries = Array.isArray(entriesHistoryRaw) ? entriesHistoryRaw : [];
    const byLevel = new Map();
    let overallWins = 0;
    let overallLosses = 0;

    const ensure = (id) => {
        if (!byLevel.has(id)) byLevel.set(id, { wins: 0, losses: 0, total: 0, hitRate: 0 });
        return byLevel.get(id);
    };

    for (const entry of entries) {
        if (!entry || typeof entry !== 'object') continue;
        if (entry.analysisMode !== 'diamond') continue;
        const stage = String(entry.martingaleStage || entry.wonAt || entry.phase || '').toUpperCase().trim();
        if (stage !== 'ENTRADA' && stage !== 'G0') continue;
        const res = String(entry.result || '').toUpperCase().trim();
        if (res !== 'WIN' && res !== 'LOSS') continue;

        const src = entry.diamondSourceLevel
            || (entry.patternData && entry.patternData.diamondSourceLevel)
            || null;
        const srcId = src && src.id ? String(src.id) : null;
        if (!srcId) continue;

        const bucket = ensure(srcId);
        if (res === 'WIN') { bucket.wins++; overallWins++; }
        else { bucket.losses++; overallLosses++; }
        bucket.total = bucket.wins + bucket.losses;
        bucket.hitRate = bucket.total ? bucket.wins / bucket.total : 0;
    }

    const overallTotal = overallWins + overallLosses;
    return {
        byLevel,
        overall: {
            wins: overallWins,
            losses: overallLosses,
            total: overallTotal,
            hitRate: overallTotal ? overallWins / overallTotal : 0
        }
    };
}

function computeDiamondEntryHitRatesFromSignalsHistory() {
    const list = signalsHistory && Array.isArray(signalsHistory.signals) ? signalsHistory.signals : [];
    const byLevel = new Map();
    let overallWins = 0;
    let overallLosses = 0;

    const ensure = (id) => {
        if (!byLevel.has(id)) byLevel.set(id, { wins: 0, losses: 0, total: 0, hitRate: 0 });
        return byLevel.get(id);
    };

    for (const sig of list) {
        if (!sig || typeof sig !== 'object') continue;
        if (sig.patternType !== 'nivel-diamante') continue;
        if (typeof sig.hit !== 'boolean') continue;
        if (sig.verified !== true) continue;

        const colorRecommended = String(sig.colorRecommended || '').toLowerCase().trim();
        if (colorRecommended !== 'red' && colorRecommended !== 'black' && colorRecommended !== 'white') continue;

        const src = sig.sourceLevel || pickDiamondSourceLevel(sig.levelBreakdown, colorRecommended);
        const srcId = src && src.id ? String(src.id) : null;
        if (!srcId) continue;

        const bucket = ensure(srcId);
        if (sig.hit) { bucket.wins++; overallWins++; }
        else { bucket.losses++; overallLosses++; }
        bucket.total = bucket.wins + bucket.losses;
        bucket.hitRate = bucket.total ? bucket.wins / bucket.total : 0;
    }

    const overallTotal = overallWins + overallLosses;
    return {
        byLevel,
        overall: {
            wins: overallWins,
            losses: overallLosses,
            total: overallTotal,
            hitRate: overallTotal ? overallWins / overallTotal : 0
        }
    };
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ FASE 2 V2.0 - CÃ“DIGO APRIMORADO (INÃCIO)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Integrado automaticamente em: 20251221_102327
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ FASE 2 APRIMORADA - Sistema HÃ­brido de NÃ­veis com AnÃ¡lise Inteligente
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VersÃ£o: 2.0
// Data: 21/12/2025
// DescriÃ§Ã£o: Sistema inteligente que analisa padrÃµes histÃ³ricos e libera sinais
//            apenas em momentos de alta probabilidade de vitÃ³ria
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const MASTER_SIGNAL_CONFIG_V2 = Object.freeze({
    enabled: true,
    version: '2.0',
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¯ SISTEMA HÃBRIDO DE NÃVEIS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Modo de operaÃ§Ã£o:
    // - 'auto'   = HÃBRIDO (todas as camadas/nÃ­veis operam simultaneamente; aceita qualquer nÃ­vel elegÃ­vel)
    // - 'manual' = SOMENTE 1 NÃVEL (opera apenas na camada escolhida)
    levelMode: 'auto', // 'auto' | 'manual'
    
    // NÃ­vel fixo quando levelMode = 'manual' (1, 2 ou 3)
    manualLevel: 2,
    
    // Meta de sinais quando levelMode = 'auto' (sistema tenta atingir esse nÃºmero)
    autoTargetSignals: 50,
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“Š NÃVEIS DE CONFIANÃ‡A
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    levels: Object.freeze({
        // ğŸ”¥ NÃVEL 1 - CERTEZA ABSOLUTA
        level1: Object.freeze({
            name: 'Certeza Absoluta',
            description: 'Apenas situaÃ§Ãµes comprovadamente seguras (100% histÃ³rico)',
            minScore: 95,
            enabled: true,
            requirePerfectPattern: true,
            minPerfectSamples: 5,
            blockIfAnyRiskDetected: true,
            requireMultipleIndicators: 3,
        }),
        
        // âš¡ NÃVEL 2 - ALTA CONFIANÃ‡A
        level2: Object.freeze({
            name: 'Alta ConfianÃ§a',
            description: 'SituaÃ§Ãµes muito provÃ¡veis (95-98% sucesso)',
            minScore: 78,
            enabled: true,
            minPatternSuccessRate: 0.95,
            minSamples: 10,
            maxAllowedRisk: 0.05,
            requireMultipleIndicators: 2,
        }),
        
        // âœ¨ NÃVEL 3 - CONFIANÃ‡A BALANCEADA
        level3: Object.freeze({
            name: 'ConfianÃ§a Balanceada',
            description: 'SituaÃ§Ãµes favorÃ¡veis (90-95% sucesso)',
            minScore: 65,
            enabled: true,
            minPatternSuccessRate: 0.90,
            minSamples: 5,
            maxAllowedRisk: 0.10,
            requireMultipleIndicators: 1,
        })
    }),
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ§® ANÃLISE DE PADRÃ•ES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    minCycles: 15,
    maxCyclesForStats: 250,
    minEventsForDistance: 3,
    decisionWindowCycles: 100,
    
    // AnÃ¡lise de gaps/distÃ¢ncias
    entryGapTopN: 5,
    entryGapMinSupport: 0.08,
    entryGapMinCount: 2,
    entryTargetWindow: 1,
    minEntryHazard: 0.15,
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”¥ DETECÃ‡ÃƒO DE ZONAS QUENTES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    hotZones: Object.freeze({
        enabled: true,
        
        afterLossStreak: Object.freeze({
            enabled: true,
            minStreakLength: 2,
            maxHistoricalStreak: 2,
            minSamples: 8,
            scoreBonus: 30,
        }),
        
        recoveryCycles: Object.freeze({
            enabled: true,
            detectCyclePatterns: true,
            minCycleRepetitions: 3,
            scoreBonus: 25,
        }),
        
        opportunityWindows: Object.freeze({
            enabled: true,
            minSuccessRate: 0.92,
            minOccurrences: 5,
            scoreBonus: 20,
        })
    }),
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“ˆ ANÃLISE DE PROBABILIDADE CONDICIONAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    conditionalProb: Object.freeze({
        enabled: true,
        
        afterLoss: Object.freeze({
            enabled: true,
            checkStreaks: [1, 2, 3],
            minProbForSignal: 0.90,
            minSamples: 8,
        }),
        
        afterG1Wins: Object.freeze({
            enabled: true,
            checkStreaks: [2, 3, 4],
            minProbForSignal: 0.85,
            minSamples: 8,
        }),
        
        afterG2Wins: Object.freeze({
            enabled: true,
            checkStreaks: [2, 3],
            minProbForSignal: 0.85,
            minSamples: 6,
        }),
        
        afterAlternatingPattern: Object.freeze({
            enabled: true,
            detectAlternation: true,
            minAlternations: 2,
            minProbForSignal: 0.80,
            minSamples: 6,
        })
    }),
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ² SISTEMA DE SCORE MULTIFATORIAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    scoreWeights: Object.freeze({
        lossStreakSafety: 35,
        distanceFromLastWin: 20,
        patternMatch: 20,
        conditionalProb: 15,
        recoveryWindowActive: 10,
        nearLossZone: -25,
        highLossRisk: -20,
        weakHistoricalSupport: -15,
    }),
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ›¡ï¸ PROTEÃ‡Ã•ES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // âœ… Regra do usuÃ¡rio: apÃ³s 1 LOSS, NUNCA entrar no sinal seguinte.
    // (evita pegar o 2Âº LOSS numa sequÃªncia de 2)
    // A exceÃ§Ã£o Ã© o "ponto alto": apÃ³s 2 LOSS seguidos quando o histÃ³rico confirma que nÃ£o existe 3Âº.
    minSignalsAfterRet: 2,

    // âœ… NOVO (Fase 2 simplificada): usar distÃ¢ncia entre LOSS para BLOQUEAR RED
    // SÃ³ ativar o modelo quando houver base mÃ­nima de LOSS no histÃ³rico.
    // (evita decisÃµes "noisy" com pouco LOSS)
    minLossesForLossDistanceModel: 10,
    // Block se o hazard condicional do LOSS na distÃ¢ncia atual for alto:
    // hazard(d) = P(gap=d | gap>=d). Ex.: se hazard=0.25, 25% de chance de vir LOSS agora.
    lossDistanceHazardBlockAbove: 0.12,
    // Incluir a distÃ¢ncia mÃ©dia (arredondada) como alvo APENAS se ela persistir bastante no histÃ³rico
    lossDistanceAvgGapMinSupport: 0.18,
    lossDistanceAvgGapMinCount: 2,

    // âœ… NOVA REGRA (usuÃ¡rio): entre REDs, liberar poucas entradas
    // Ex.: apÃ³s acontecer um RED na IA, permitir no mÃ¡ximo 2 entradas.
    // A 3Âª entrada sÃ³ Ã© permitida quando for "muito certo" (NÃ­vel 1).
    // Depois disso, aguardar um novo RED para "reiniciar" a janela.
    maxMasterEntriesPerRedWindow: 2,
    maxMasterEntriesPerRedWindowHard: 3,
    retGapTopN: 5,
    retGapMinSupport: 0.12,
    retGapMinCount: 2,
    // âœ… Evitar "cair em cima do LOSS" (ponto tÃ­pico) â€” janela 0 = evita APENAS a coincidÃªncia exata
    // (mais sinais, sem ficar rigoroso demais)
    retAvoidWindow: 0,
    maxRetRiskInCountdown: 0.35,
    avoidLossExactCoincidence: true,
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”„ STREAKS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    streakGates: Object.freeze({
        enabled: true,
        maxK: 8,
        minSamples: 8,
        
        red: Object.freeze({
            minLen: 2,
            maxContinueProb: 0.08,
            bypassPostLossCooldown: true,
        }),
        
        g1: Object.freeze({
            minLen: 2,
            minNextWinProb: 0.75,
        }),
        
        g2: Object.freeze({
            minLen: 2,
            minNextWinProb: 0.75,
        })
    }),
    
    relaxEntryGate: Object.freeze({
        enabled: true,
        minCycles: 30,
        winRateAbove: 0.82,
    }),
    
    diamondLevelTrust: Object.freeze({
        enabled: true,
        minSamples: 8,
        blockBelowHitRate: 0.55,
        hardBlockBelowHitRate: 0.40,
        strongAboveHitRate: 0.88,
    }),
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ” DETECÃ‡ÃƒO DE ANOMALIAS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    anomalyDetection: Object.freeze({
        enabled: true,
        checkPatternShift: true,
        maxPatternShiftTolerance: 0.25,
        checkWinrateDrop: true,
        maxWinrateDropInWindow: 0.15,
        recentWindowSize: 20,
        pauseOnAnomaly: true,
        resumeAfterCycles: 10,
    })
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ CONFIG RUNTIME (V2): permitir override via analyzerConfig (UI)
// - MantÃ©m defaults do MASTER_SIGNAL_CONFIG_V2
// - Sanitiza valores para evitar crash/valores invÃ¡lidos
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function getMasterSignalConfigV2Runtime(baseCfg = MASTER_SIGNAL_CONFIG_V2) {
    const base = baseCfg && typeof baseCfg === 'object' ? baseCfg : MASTER_SIGNAL_CONFIG_V2;
    const ui = (typeof analyzerConfig !== 'undefined' && analyzerConfig && typeof analyzerConfig === 'object')
        ? (analyzerConfig.masterSignalV2 || null)
        : null;

    const clampInt = (val, min, max, fallback) => {
        const n = Math.floor(Number(val));
        if (!Number.isFinite(n)) return fallback;
        return Math.max(min, Math.min(max, n));
    };
    const clampFloat = (val, min, max, fallback) => {
        const n = Number(val);
        if (!Number.isFinite(n)) return fallback;
        return Math.max(min, Math.min(max, n));
    };

    const levelMode = (ui && typeof ui.levelMode === 'string')
        ? String(ui.levelMode).toLowerCase().trim()
        : base.levelMode;
    const normalizedLevelMode = (levelMode === 'manual') ? 'manual' : 'auto';

    const manualLevel = clampInt(ui && ui.manualLevel, 1, 3, clampInt(base.manualLevel, 1, 3, 2));
    const autoTargetSignals = clampInt(ui && ui.autoTargetSignals, 10, 200, clampInt(base.autoTargetSignals, 10, 200, 50));

    // Opcional: permitir ligar/desligar V2 via UI (se existir)
    const enabled = (ui && Object.prototype.hasOwnProperty.call(ui, 'enabled'))
        ? !!ui.enabled
        : !!base.enabled;

    // âœ… NOVO: overrides opcionais do modelo anti-LOSS (se a UI expor isso no futuro)
    const minLossesForLossDistanceModel = clampInt(
        ui && ui.minLossesForLossDistanceModel,
        3, 50,
        clampInt(base.minLossesForLossDistanceModel, 3, 50, 10)
    );
    const lossDistanceHazardBlockAbove = clampFloat(
        ui && ui.lossDistanceHazardBlockAbove,
        0, 1,
        clampFloat(base.lossDistanceHazardBlockAbove, 0, 1, 0.12)
    );
    const lossDistanceAvgGapMinSupport = clampFloat(
        ui && ui.lossDistanceAvgGapMinSupport,
        0, 1,
        clampFloat(base.lossDistanceAvgGapMinSupport, 0, 1, 0.18)
    );
    const lossDistanceAvgGapMinCount = clampInt(
        ui && ui.lossDistanceAvgGapMinCount,
        1, 20,
        clampInt(base.lossDistanceAvgGapMinCount, 1, 20, 2)
    );

    return {
        ...base,
        enabled,
        levelMode: normalizedLevelMode,
        manualLevel,
        autoTargetSignals,
        minLossesForLossDistanceModel,
        lossDistanceHazardBlockAbove,
        lossDistanceAvgGapMinSupport,
        lossDistanceAvgGapMinCount
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§® FUNÃ‡Ã•ES DE ANÃLISE APRIMORADA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Analisa padrÃµes de sequÃªncias consecutivas
 * Identifica: WIN WIN WIN â†’ prÃ³ximo? | LOSS LOSS â†’ prÃ³ximo?
 */
function analyzeConsecutivePatterns(cycles, isWin, isRet, resolveWinStage) {
    // âœ… Reescrito: agora conta sequÃªncias reais (2+ consecutivos) e registra o que vem DEPOIS.
    // TambÃ©m expÃµe: mÃ¡ximos histÃ³ricos de streak e distribuiÃ§Ã£o do prÃ³ximo resultado por estÃ¡gio.
    if (!Array.isArray(cycles) || cycles.length < 3) {
        return { patterns: {}, confidence: 0, totalSamples: 0, maxStreaks: {}, currentStreaks: {} };
    }

    const initBucket = () => ({
        total: 0,
        wins: 0,     // prÃ³ximo NÃƒO Ã© LOSS
        losses: 0,   // prÃ³ximo Ã© LOSS
        next: { entry: 0, g1: 0, g2: 0, loss: 0 },
        winProb: 0,
        lossProb: 0
    });

    const patterns = {
        afterEntryWins: initBucket(),
        afterG1Wins: initBucket(),
        afterG2Wins: initBucket(),
        afterLosses: initBucket()
    };

    const classify = (c) => {
        if (isRet(c)) return 'loss';
        if (!isWin(c)) return 'loss';
        const st = resolveWinStage(c);
        if (st === 'ENTRADA') return 'entry';
        if (st === 'G1') return 'g1';
        return 'g2'; // G2+
    };

    const types = cycles.map(classify);
    const maxStreaks = { entry: 0, g1: 0, g2: 0, loss: 0 };

    // calcular mÃ¡ximos de streak por tipo (histÃ³rico inteiro)
    {
        let curType = types[0];
        let curLen = 1;
        for (let i = 1; i < types.length; i++) {
            if (types[i] === curType) curLen++;
            else {
                if (curLen > (maxStreaks[curType] || 0)) maxStreaks[curType] = curLen;
                curType = types[i];
                curLen = 1;
            }
        }
        if (curLen > (maxStreaks[curType] || 0)) maxStreaks[curType] = curLen;
    }

    // streak atual (tail)
    const currentStreaks = (() => {
        const out = { entry: 0, g1: 0, g2: 0, loss: 0 };
        const tailType = types[types.length - 1];
        let len = 0;
        for (let i = types.length - 1; i >= 0; i--) {
            if (types[i] === tailType) len++;
            else break;
        }
        out[tailType] = len;
        return out;
    })();

    // Registrar "o que saiu depois" apÃ³s uma SEQUÃŠNCIA (run) de 2+ do tipo
    const recordAfterRun = (runType, nextType) => {
        const key = runType === 'entry'
            ? 'afterEntryWins'
            : (runType === 'g1'
                ? 'afterG1Wins'
                : (runType === 'g2' ? 'afterG2Wins' : 'afterLosses'));
        const bucket = patterns[key];
        bucket.total++;
        if (nextType === 'loss') bucket.losses++;
        else bucket.wins++;
        if (bucket.next && Object.prototype.hasOwnProperty.call(bucket.next, nextType)) {
            bucket.next[nextType]++;
        }
    };

    // varrer runs
    let i = 0;
    while (i < types.length) {
        const runType = types[i];
        let j = i + 1;
        while (j < types.length && types[j] === runType) j++;
        const runLen = j - i;
        const nextIdx = j;
        if (runLen >= 2 && nextIdx < types.length) {
            recordAfterRun(runType, types[nextIdx]);
        }
        i = j;
    }

    // Calcular probabilidades
    for (const key of Object.keys(patterns)) {
        const p = patterns[key];
        p.winProb = p.total > 0 ? (p.wins / p.total) : 0;
        p.lossProb = p.total > 0 ? (p.losses / p.total) : 0;
    }

    const totalSamples = Object.values(patterns).reduce((sum, p) => sum + (p.total || 0), 0);
    const confidence = Math.min(100, (totalSamples / 25) * 100); // confianÃ§a simples por amostra

    return { patterns, confidence, totalSamples, maxStreaks, currentStreaks, types };
}

/**
 * Calcula distÃ¢ncias entre eventos e identifica gaps frequentes
 */
function analyzeDistancePatterns(cycles, isWin, isRet, resolveWinStage) {
    if (!Array.isArray(cycles) || cycles.length < 5) {
        return { distances: {}, gaps: {} };
    }
    
    const indices = {
        entry: [],
        g1: [],
        g2: [],
        losses: []
    };
    
    // Coletar Ã­ndices
    for (let i = 0; i < cycles.length; i++) {
        const c = cycles[i];
        if (!c) continue;
        
        if (isRet(c)) {
            indices.losses.push(i);
        } else if (isWin(c)) {
            const stage = resolveWinStage(c);
            if (stage === 'ENTRADA') indices.entry.push(i);
            else if (stage === 'G1') indices.g1.push(i);
            else indices.g2.push(i);
        }
    }
    
    // Calcular gaps (distÃ¢ncias entre ocorrÃªncias)
    const calculateGaps = (indexArray) => {
        const gaps = [];
        for (let i = 1; i < indexArray.length; i++) {
            gaps.push(indexArray[i] - indexArray[i - 1]);
        }
        
        // FrequÃªncia de cada gap
        const freq = {};
        for (const gap of gaps) {
            freq[gap] = (freq[gap] || 0) + 1;
        }
        
        // Ordenar por frequÃªncia
        const sorted = Object.entries(freq)
            .map(([gap, count]) => ({ gap: Number(gap), count, prob: count / gaps.length }))
            .sort((a, b) => b.count - a.count);
        
        return { gaps, freq, sorted, avgGap: gaps.length > 0 ? gaps.reduce((a, b) => a + b, 0) / gaps.length : 0 };
    };
    
    return {
        distances: {
            entry: calculateGaps(indices.entry),
            g1: calculateGaps(indices.g1),
            g2: calculateGaps(indices.g2),
            losses: calculateGaps(indices.losses)
        },
        indices
    };
}

/**
 * Detecta zonas quentes (hot zones) - momentos de alta probabilidade
 */
function detectHotZones(cycles, patterns, distances, cfg) {
    const hotZones = [];
    
    if (!cfg.hotZones || !cfg.hotZones.enabled) {
        return hotZones;
    }
    
    // 1. ZONA QUENTE: ApÃ³s 2 LOSS consecutivos (regra forte do histÃ³rico)
    if (cfg.hotZones.afterLossStreak && cfg.hotZones.afterLossStreak.enabled) {
        const afterLossData = patterns && patterns.patterns ? patterns.patterns.afterLosses : null;
        const maxLossStreak = patterns && patterns.maxStreaks ? Number(patterns.maxStreaks.loss || 0) : 0;
        const currentLossStreak = patterns && patterns.currentStreaks ? Number(patterns.currentStreaks.loss || 0) : 0;

        const minLen = Math.max(2, Number(cfg.hotZones.afterLossStreak.minStreakLength || 2));
        const maxHist = Math.max(2, Number(cfg.hotZones.afterLossStreak.maxHistoricalStreak || 2));

        // SÃ³ faz sentido se estamos realmente em 2+ LOSS agora e o histÃ³rico nÃ£o passou de 2.
        if (currentLossStreak >= minLen && maxLossStreak > 0 && maxLossStreak <= maxHist) {
            // Se temos base suficiente, usar prob real do 3Âº LOSS (continuaÃ§Ã£o)
            if (afterLossData && afterLossData.total >= cfg.hotZones.afterLossStreak.minSamples) {
                const nextLossProb = Number.isFinite(Number(afterLossData.lossProb)) ? Number(afterLossData.lossProb) : 1;
                if (nextLossProb <= 0.001) {
                    hotZones.push({
                        type: 'afterLossStreak',
                        description: `Ponto alto: apÃ³s ${currentLossStreak} LOSS (mÃ¡x histÃ³rico=${maxLossStreak})`,
                        scoreBonus: cfg.hotZones.afterLossStreak.scoreBonus,
                        confidence: 99,
                        data: { maxLossStreak, nextLossProb, samples: afterLossData.total, next: afterLossData.next }
                    });
                } else if (nextLossProb <= 0.05) {
                    hotZones.push({
                        type: 'afterLossStreak',
                        description: `ApÃ³s ${currentLossStreak} LOSS (mÃ¡x histÃ³rico=${maxLossStreak}) â€¢ P(LOSS)â‰ˆ${(nextLossProb * 100).toFixed(0)}%`,
                        scoreBonus: Math.max(0, Math.round(cfg.hotZones.afterLossStreak.scoreBonus * 0.8)),
                        confidence: Math.max(90, Math.round((1 - nextLossProb) * 100)),
                        data: { maxLossStreak, nextLossProb, samples: afterLossData.total, next: afterLossData.next }
                    });
                }
            } else {
                // âœ… Base baixa (sem amostras suficientes): ainda assim marcar como ponto alto
                // porque a regra Ã© "no histÃ³rico disponÃ­vel nunca passou de 2".
                hotZones.push({
                    type: 'afterLossStreak',
                    description: `Ponto alto: apÃ³s ${currentLossStreak} LOSS (mÃ¡x histÃ³rico=${maxLossStreak})`,
                    scoreBonus: Math.max(10, Math.round(cfg.hotZones.afterLossStreak.scoreBonus * 0.6)),
                    confidence: 90,
                    data: { maxLossStreak, nextLossProb: null, samples: afterLossData ? afterLossData.total : 0, next: afterLossData ? afterLossData.next : null }
                });
            }
        }
    }

    // 1.1 ZONAS QUENTES: apÃ³s 2+ vitÃ³rias consecutivas por estÃ¡gio (Entrada / G1 / G2+)
    // Regra do usuÃ¡rio: se historicamente "apÃ³s 2 seguidas" o prÃ³ximo ciclo continua WIN (quase nunca LOSS),
    // isso vira ponto alto para entrar.
    try {
        const minSamples = Math.max(5, Math.floor(Number(cfg.hotZones?.afterLossStreak?.minSamples || 8)));
        const current = patterns && patterns.currentStreaks ? patterns.currentStreaks : {};
        const pmap = patterns && patterns.patterns ? patterns.patterns : {};

        const pushIfStrong = (key, typeLabel, curLen, bucket, bonusBase) => {
            if (!bucket || !Number.isFinite(Number(bucket.total))) return;
            if (curLen < 2) return;
            if (bucket.total < minSamples) return;
            const lossProb = Number.isFinite(Number(bucket.lossProb)) ? Number(bucket.lossProb) : 1;
            const winProb = Number.isFinite(Number(bucket.winProb)) ? Number(bucket.winProb) : (1 - lossProb);
            if (lossProb <= 0.05) {
                hotZones.push({
                    type: key,
                    description: `ApÃ³s ${curLen} ${typeLabel} seguidos â€¢ P(LOSS)â‰ˆ${(lossProb * 100).toFixed(0)}% (${bucket.losses}/${bucket.total})`,
                    scoreBonus: Math.max(10, Math.round(bonusBase * (1 - lossProb))),
                    confidence: Math.max(85, Math.round(winProb * 100)),
                    data: { curLen, winProb, lossProb, samples: bucket.total, next: bucket.next }
                });
            }
        };

        pushIfStrong('afterEntryStreak', 'WIN na ENTRADA', Number(current.entry || 0), pmap.afterEntryWins, 18);
        pushIfStrong('afterG1Streak', 'WIN no G1', Number(current.g1 || 0), pmap.afterG1Wins, 15);
        pushIfStrong('afterG2Streak', 'WIN no G2+', Number(current.g2 || 0), pmap.afterG2Wins, 15);
    } catch (_) {}
    
    // 2. ZONA QUENTE: Janelas de oportunidade (distÃ¢ncias especÃ­ficas)
    if (cfg.hotZones.opportunityWindows && cfg.hotZones.opportunityWindows.enabled) {
        const entryDist = distances.distances.entry;
        if (entryDist && entryDist.sorted) {
            for (const item of entryDist.sorted.slice(0, 3)) {
                if (item.count >= cfg.hotZones.opportunityWindows.minOccurrences &&
                    item.prob >= (cfg.hotZones.opportunityWindows.minSuccessRate / item.count)) {
                    hotZones.push({
                        type: 'opportunityWindow',
                        description: `DistÃ¢ncia ${item.gap} (${item.count}x, ${(item.prob * 100).toFixed(0)}%)`,
                        scoreBonus: cfg.hotZones.opportunityWindows.scoreBonus,
                        confidence: Math.min(95, item.prob * 100),
                        data: { gap: item.gap, count: item.count, prob: item.prob }
                    });
                }
            }
        }
    }
    
    return hotZones;
}

/**
 * Calcula probabilidade condicional: P(WIN | condiÃ§Ã£o X)
 */
function calculateConditionalProbabilities(cycles, patterns, currentState, cfg) {
    const probabilities = {
        afterCurrentLossStreak: null,
        afterCurrentEntryStreak: null,
        afterCurrentG1Streak: null,
        afterCurrentG2Streak: null,
        overall: 0
    };
    
    if (!cfg.conditionalProb || !cfg.conditionalProb.enabled) {
        return probabilities;
    }
    
    // P(WIN | apÃ³s 2+ LOSS) â€” usando a distribuiÃ§Ã£o "apÃ³s 2 LOSS seguidos"
    if (cfg.conditionalProb.afterLoss && cfg.conditionalProb.afterLoss.enabled) {
        const lossStreakNow = currentState.lossStreak || 0;
        const afterLossData = patterns.patterns.afterLosses;
        
        if (afterLossData && afterLossData.total >= cfg.conditionalProb.afterLoss.minSamples) {
            // SÃ³ faz sentido quando jÃ¡ estamos em streak 2+ (regra do histÃ³rico)
            if (lossStreakNow >= 2) {
                probabilities.afterCurrentLossStreak = {
                    streak: lossStreakNow,
                    winProb: afterLossData.winProb,
                    samples: afterLossData.total,
                    meetsThreshold: afterLossData.winProb >= cfg.conditionalProb.afterLoss.minProbForSignal
                };
            }
        }
    }
    
    // P(WIN | apÃ³s 2+ WIN na ENTRADA)
    try {
        const entryStreakNow = currentState.entryStreak || 0;
        const afterEntryData = patterns.patterns.afterEntryWins;
        if (afterEntryData && afterEntryData.total >= (cfg.conditionalProb.afterG1Wins?.minSamples || 8)) {
            if (entryStreakNow >= 2) {
                probabilities.afterCurrentEntryStreak = {
                    streak: entryStreakNow,
                    winProb: afterEntryData.winProb,
                    samples: afterEntryData.total,
                    meetsThreshold: afterEntryData.winProb >= 0.85
                };
            }
        }
    } catch (_) {}

    // P(WIN | apÃ³s X WIN no G1)
    if (cfg.conditionalProb.afterG1Wins && cfg.conditionalProb.afterG1Wins.enabled) {
        const g1StreakNow = currentState.g1Streak || 0;
        const afterG1Data = patterns.patterns.afterG1Wins;
        
        if (afterG1Data && afterG1Data.total >= cfg.conditionalProb.afterG1Wins.minSamples) {
            if (g1StreakNow >= 2) {
                probabilities.afterCurrentG1Streak = {
                    streak: g1StreakNow,
                    winProb: afterG1Data.winProb,
                    samples: afterG1Data.total,
                    meetsThreshold: afterG1Data.winProb >= cfg.conditionalProb.afterG1Wins.minProbForSignal
                };
            }
        }
    }
    
    // P(WIN | apÃ³s X WIN no G2+)
    if (cfg.conditionalProb.afterG2Wins && cfg.conditionalProb.afterG2Wins.enabled) {
        const g2StreakNow = currentState.g2Streak || 0;
        const afterG2Data = patterns.patterns.afterG2Wins;
        
        if (afterG2Data && afterG2Data.total >= cfg.conditionalProb.afterG2Wins.minSamples) {
            if (cfg.conditionalProb.afterG2Wins.checkStreaks.includes(g2StreakNow)) {
                probabilities.afterCurrentG2Streak = {
                    streak: g2StreakNow,
                    winProb: afterG2Data.winProb,
                    samples: afterG2Data.total,
                    meetsThreshold: afterG2Data.winProb >= cfg.conditionalProb.afterG2Wins.minProbForSignal
                };
            }
        }
    }
    
    // Calcular probabilidade geral
    const probs = [
        probabilities.afterCurrentLossStreak?.winProb,
        probabilities.afterCurrentEntryStreak?.winProb,
        probabilities.afterCurrentG1Streak?.winProb,
        probabilities.afterCurrentG2Streak?.winProb
    ].filter(p => p != null);
    
    probabilities.overall = probs.length > 0 
        ? probs.reduce((sum, p) => sum + p, 0) / probs.length 
        : 0;
    
    return probabilities;
}

/**
 * Calcula score multifatorial (0-100)
 */
function calculateMultifactorScore(analysis, cfg) {
    // âœ… Base um pouco mais alta para evitar travar com pouco histÃ³rico (sem perder proteÃ§Ãµes anti-LOSS)
    let score = 55; // Score base
    const reasons = [];
    const weights = cfg.scoreWeights || {};
    
    // 1. SEGURANÃ‡A PÃ“S-LOSS (peso alto)
    if (analysis.hotZones) {
        const lossStreakZone = analysis.hotZones.find(z => z.type === 'afterLossStreak');
        if (lossStreakZone) {
            score += weights.lossStreakSafety || 35;
            const maxHist = lossStreakZone && lossStreakZone.data && lossStreakZone.data.maxLossStreak != null
                ? lossStreakZone.data.maxLossStreak
                : (lossStreakZone.data && lossStreakZone.data.maxStreak != null ? lossStreakZone.data.maxStreak : 'â€”');
            reasons.push(`+${weights.lossStreakSafety || 35}: Zona quente pÃ³s-LOSS (mÃ¡x histÃ³rico=${maxHist})`);
        }
    }

    // 1.1 Zonas quentes por vitÃ³rias consecutivas (Entrada/G1/G2+)
    if (analysis.hotZones) {
        const streakZones = analysis.hotZones.filter(z =>
            z && (z.type === 'afterEntryStreak' || z.type === 'afterG1Streak' || z.type === 'afterG2Streak')
        );
        if (streakZones.length) {
            // Somar bÃ´nus moderado (sem exagerar)
            let bonusSum = 0;
            streakZones.slice(0, 2).forEach((z) => { bonusSum += Math.max(8, Math.min(18, Number(z.scoreBonus) || 0)); });
            if (bonusSum > 0) {
                score += bonusSum;
                reasons.push(`+${bonusSum.toFixed(0)}: Zona quente por sequÃªncia de WIN (${streakZones.map(z => z.type.replace('after', '')).join(', ')})`);
            }
        }
    }
    
    // 2. DISTÃ‚NCIAS (gaps reais) â€” ENTRADA / G1 / G2
    // âœ… NÃ£o usar mÃ©dia: usar gaps mais frequentes + janela discreta
    const targetWindow = Math.max(0, Math.floor(Number(cfg.entryTargetWindow || 1)));
    const addGapMatchBonus = (label, dist, sortedGaps, cap) => {
        if (dist == null) return;
        const list = Array.isArray(sortedGaps) ? sortedGaps : [];
        const match = list.find(g => g && Number.isFinite(Number(g.gap)) && Math.abs(Number(g.gap) - Number(dist)) <= targetWindow);
        if (!match) return;
        const prob = Number.isFinite(Number(match.prob)) ? Number(match.prob) : 0;
        const bonus = Math.min(cap, prob * (cap + 5));
        if (bonus <= 0) return;
        score += bonus;
        reasons.push(`+${bonus.toFixed(0)}: ${label} distÃ¢ncia ${dist} ~ gap ${Number(match.gap)} (${(prob * 100).toFixed(0)}%)`);
    };

    const distObj = analysis.distances || {};
    addGapMatchBonus('ENTR', distObj.sinceEntry, analysis.distancePatterns?.distances?.entry?.sorted, weights.distanceFromLastWin || 20);
    addGapMatchBonus('G1', distObj.sinceG1, analysis.distancePatterns?.distances?.g1?.sorted, Math.max(8, Math.round((weights.distanceFromLastWin || 20) * 0.6)));
    addGapMatchBonus('G2', distObj.sinceG2, analysis.distancePatterns?.distances?.g2?.sorted, Math.max(8, Math.round((weights.distanceFromLastWin || 20) * 0.6)));
    
    // 3. PADRÃƒO IDENTIFICADO
    if (analysis.consecutivePatterns && analysis.consecutivePatterns.confidence > 60) {
        const bonus = (weights.patternMatch || 20) * (analysis.consecutivePatterns.confidence / 100);
        score += bonus;
        reasons.push(`+${bonus.toFixed(0)}: PadrÃ£o identificado (${analysis.consecutivePatterns.confidence.toFixed(0)}% confianÃ§a)`);
    }
    
    // 4. PROBABILIDADE CONDICIONAL
    if (analysis.conditionalProb && analysis.conditionalProb.overall > 0.80) {
        const bonus = (weights.conditionalProb || 15) * (analysis.conditionalProb.overall);
        score += bonus;
        reasons.push(`+${bonus.toFixed(0)}: Prob. condicional ${(analysis.conditionalProb.overall * 100).toFixed(0)}%`);
    }

    // 4.1 BÃ”NUS: risco de LOSS muito baixo agora
    try {
        const lr = (analysis.risks && typeof analysis.risks.lossRisk === 'number') ? analysis.risks.lossRisk : null;
        if (lr != null && lr <= 0.08) {
            const bonus = Math.min(12, (0.08 - lr) * 120 + 4); // 4..~14, cap em 12
            score += bonus;
            reasons.push(`+${bonus.toFixed(0)}: Risco LOSS baixo (${(lr * 100).toFixed(0)}%)`);
        }
    } catch (_) {}
    
    // 5. JANELA DE RECUPERAÃ‡ÃƒO
    if (analysis.hotZones) {
        const recoveryZone = analysis.hotZones.find(z => z.type === 'opportunityWindow');
        if (recoveryZone) {
            score += weights.recoveryWindowActive || 10;
            reasons.push(`+${weights.recoveryWindowActive || 10}: Janela de recuperaÃ§Ã£o ativa`);
        }
    }
    
    // PENALIDADES
    
    // 6. PERTO DE ZONA DE LOSS
    if (analysis.risks && analysis.risks.nearLossZone) {
        score += weights.nearLossZone || -25;
        reasons.push(`${weights.nearLossZone || -25}: Perto de zona de LOSS`);
    }
    
    // 7. RISCO ALTO DE LOSS
    if (analysis.risks && typeof analysis.risks.lossRisk === 'number' && analysis.risks.lossRisk > (cfg.maxRetRiskInCountdown || 0.35)) {
        score += weights.highLossRisk || -20;
        reasons.push(`${weights.highLossRisk || -20}: Risco alto de LOSS (${(analysis.risks.lossRisk * 100).toFixed(0)}%)`);
    }
    
    // 8. SUPORTE HISTÃ“RICO FRACO
    if (analysis.consecutivePatterns && analysis.consecutivePatterns.totalSamples < 10) {
        score += weights.weakHistoricalSupport || -15;
        reasons.push(`${weights.weakHistoricalSupport || -15}: Pouco suporte histÃ³rico (${analysis.consecutivePatterns.totalSamples} amostras)`);
    }
    
    // Limitar score entre 0-100
    score = Math.max(0, Math.min(100, score));
    
    return { score, reasons };
}

/**
 * Determina o nÃ­vel apropriado baseado no score e configuraÃ§Ã£o
 */
function determineSignalLevel(score, cfg) {
    // âœ… Novo: nÃ­veis operam SIMULTANEAMENTE (camadas em paralelo).
    // "Auto" (hÃ­brido) = aceitar qualquer nÃ­vel que passe.
    // "Manual" = usuÃ¡rio pode travar em um Ãºnico nÃ­vel (tratado na funÃ§Ã£o principal).
    const levels = cfg && cfg.levels ? cfg.levels : {};

    const s = Number(score);
    const scoreNum = Number.isFinite(s) ? Math.max(0, Math.min(100, s)) : 0;

    // Fallback legacy (caso nÃ£o tenhamos anÃ¡lise detalhada)
    if (!cfg || !levels || typeof levels !== 'object') return null;

    // analysis opcional (quando chamada antiga). Se nÃ£o vier, manter heurÃ­stica simples por score.
    const analysis = arguments.length >= 3 ? arguments[2] : null;
    if (!analysis || typeof analysis !== 'object') {
        if (levels.level1 && levels.level1.enabled && scoreNum >= levels.level1.minScore) {
            return { level: 1, name: levels.level1.name, description: levels.level1.description };
        }
        if (levels.level2 && levels.level2.enabled && scoreNum >= levels.level2.minScore) {
            return { level: 2, name: levels.level2.name, description: levels.level2.description };
        }
        if (levels.level3 && levels.level3.enabled && scoreNum >= levels.level3.minScore) {
            return { level: 3, name: levels.level3.name, description: levels.level3.description };
        }
        return null;
    }

    const clamp01 = (x) => {
        const n = Number(x);
        if (!Number.isFinite(n)) return 0;
        return Math.max(0, Math.min(1, n));
    };

    const nearLossZone = !!analysis?.risks?.nearLossZone;
    const lossRisk = clamp01(analysis?.risks?.lossRisk);

    // Indicadores (camadas) â€” contam para "requireMultipleIndicators"
    const indicators = [];

    // A) Zona quente apÃ³s 2+ LOSS (ponto alto)
    const hasHotAfterLoss = Array.isArray(analysis.hotZones)
        && analysis.hotZones.some(z => z && z.type === 'afterLossStreak' && Number(z.confidence || 0) >= 90);
    if (hasHotAfterLoss) indicators.push('hotAfterLoss');

    // B) Zona quente apÃ³s 2+ WIN consecutivos (Entrada/G1/G2+)
    const hasHotAfterWinStreak = Array.isArray(analysis.hotZones)
        && analysis.hotZones.some(z => z && (z.type === 'afterEntryStreak' || z.type === 'afterG1Streak' || z.type === 'afterG2Streak') && Number(z.confidence || 0) >= 85);
    if (hasHotAfterWinStreak) indicators.push('hotAfterWinStreak');

    // C) Match de distÃ¢ncia (gaps reais) em qualquer estÃ¡gio
    const window = Math.max(0, Math.floor(Number(cfg.entryTargetWindow || 1)));
    const matchGap = (dist, sorted) => {
        if (dist == null) return null;
        const d = Math.floor(Number(dist));
        if (!Number.isFinite(d) || d <= 0) return null;
        const list = Array.isArray(sorted) ? sorted : [];
        const m = list.find(it => it && Number.isFinite(Number(it.gap)) && Math.abs(Number(it.gap) - d) <= window);
        if (!m) return null;
        return {
            gap: Math.floor(Number(m.gap)),
            prob: Number.isFinite(Number(m.prob)) ? Number(m.prob) : 0
        };
    };
    const dmEntry = matchGap(analysis?.distances?.sinceEntry, analysis?.distancePatterns?.distances?.entry?.sorted);
    const dmG1 = matchGap(analysis?.distances?.sinceG1, analysis?.distancePatterns?.distances?.g1?.sorted);
    const dmG2 = matchGap(analysis?.distances?.sinceG2, analysis?.distancePatterns?.distances?.g2?.sorted);
    const hasDistanceMatch = !!(dmEntry || dmG1 || dmG2);
    if (hasDistanceMatch) indicators.push('distanceMatch');

    // D) Probabilidade condicional acima do limiar (qualquer uma)
    const cond = analysis?.conditionalProb || null;
    const hasConditionalOk = !!(
        cond?.afterCurrentLossStreak?.meetsThreshold ||
        cond?.afterCurrentEntryStreak?.meetsThreshold ||
        cond?.afterCurrentG1Streak?.meetsThreshold ||
        cond?.afterCurrentG2Streak?.meetsThreshold
    );
    if (hasConditionalOk) indicators.push('conditionalOk');

    // E) PadrÃµes (consecutivos) com base razoÃ¡vel
    const pat = analysis?.consecutivePatterns || null;
    const hasPatternOk = !!(pat && Number(pat.confidence || 0) >= 60 && Number(pat.totalSamples || 0) >= 8);
    if (hasPatternOk) indicators.push('patternOk');

    const indicatorCount = indicators.length;

    // Para evitar travar, o mÃ­nimo de score pode ser levemente relaxado se houver match de distÃ¢ncia + risco baixo.
    const relaxScoreForDistance = (baseMin) => {
        const min = Number(baseMin);
        const base = Number.isFinite(min) ? min : 0;
        if (!hasDistanceMatch) return base;
        if (lossRisk > 0.10) return base;
        // relaxa atÃ© 8 pontos quando a distÃ¢ncia bate e risco estÃ¡ baixo
        return Math.max(0, base - 8);
    };

    // "Gatilho perfeito" (100% no histÃ³rico) â€” usado no nÃ­vel 1 quando requirePerfectPattern=true
    const isPerfectBucket = (bucket, minSamples) => {
        const b = bucket && typeof bucket === 'object' ? bucket : null;
        if (!b) return false;
        const total = Number(b.total || 0);
        const lossProb = clamp01(b.lossProb);
        return total >= Math.max(1, Math.floor(Number(minSamples) || 1)) && lossProb <= 0.0001;
    };
    const perfectRequired = !!levels?.level1?.requirePerfectPattern;
    const perfectMin = Math.max(2, Math.floor(Number(levels?.level1?.minPerfectSamples || 5)));
    const curr = analysis?.currentState || {};
    const cp = analysis?.consecutivePatterns?.patterns || {};
    const perfectTrigger = (
        (Number(curr.lossStreak || 0) >= 2 && isPerfectBucket(cp.afterLosses, perfectMin)) ||
        (Number(curr.entryStreak || 0) >= 2 && isPerfectBucket(cp.afterEntryWins, perfectMin)) ||
        (Number(curr.g1Streak || 0) >= 2 && isPerfectBucket(cp.afterG1Wins, perfectMin)) ||
        (Number(curr.g2Streak || 0) >= 2 && isPerfectBucket(cp.afterG2Wins, perfectMin))
    );

    const canLevel = (lvlCfg, lvlNumber) => {
        if (!lvlCfg || !lvlCfg.enabled) return false;
        const minScore = relaxScoreForDistance(lvlCfg.minScore);
        if (scoreNum < minScore) return false;

        const reqIndicators = Math.max(0, Math.floor(Number(lvlCfg.requireMultipleIndicators || 0)));
        if (indicatorCount < reqIndicators) return false;

        // Regras de risco por nÃ­vel
        const maxRisk = (lvlNumber === 1)
            ? 0.03
            : clamp01(lvlCfg.maxAllowedRisk != null ? lvlCfg.maxAllowedRisk : (lvlNumber === 2 ? 0.08 : 0.12));
        if (lossRisk > maxRisk) return false;

        // Evitar cair em cima do LOSS (zona tÃ­pica) para todos os nÃ­veis
        if (nearLossZone) return false;

        // NÃ­vel 1: se exigir padrÃ£o perfeito, precisa de um gatilho perfeito real (100% no histÃ³rico)
        if (lvlNumber === 1 && perfectRequired && !perfectTrigger) return false;

        return true;
    };

    // Escolher o MELHOR nÃ­vel elegÃ­vel (1 > 2 > 3), pois as camadas rodam em paralelo.
    if (canLevel(levels.level1, 1)) {
        return { level: 1, name: levels.level1.name, description: levels.level1.description, indicators, lossRisk };
    }
    if (canLevel(levels.level2, 2)) {
        return { level: 2, name: levels.level2.name, description: levels.level2.description, indicators, lossRisk };
    }
    if (canLevel(levels.level3, 3)) {
        return { level: 3, name: levels.level3.name, description: levels.level3.description, indicators, lossRisk };
    }
    return null;
}

/**
 * Detecta anomalias no padrÃ£o histÃ³rico
 */
function detectAnomalies(cycles, recentWindow, cfg) {
    if (!cfg.anomalyDetection || !cfg.anomalyDetection.enabled) {
        return { hasAnomaly: false, type: null, description: null };
    }
    
    if (!Array.isArray(cycles) || cycles.length < recentWindow * 2) {
        return { hasAnomaly: false, type: null, description: null };
    }
    
    const recent = cycles.slice(-recentWindow);
    const older = cycles.slice(-(recentWindow * 2), -recentWindow);
    
    // Calcular winrate
    const calcWinrate = (arr) => {
        const wins = arr.filter(c => c && (c.finalResult === 'WIN' || c.result === 'WIN')).length;
        return arr.length > 0 ? wins / arr.length : 0;
    };
    
    const recentWinrate = calcWinrate(recent);
    const olderWinrate = calcWinrate(older);
    const winrateDrop = olderWinrate - recentWinrate;
    
    // Verificar queda brusca de winrate
    if (cfg.anomalyDetection.checkWinrateDrop && 
        winrateDrop > cfg.anomalyDetection.maxWinrateDropInWindow) {
        return {
            hasAnomaly: true,
            type: 'winrateDrop',
            description: `Queda de ${(winrateDrop * 100).toFixed(0)}% no winrate (${(olderWinrate * 100).toFixed(0)}% â†’ ${(recentWinrate * 100).toFixed(0)}%)`,
            data: { recentWinrate, olderWinrate, drop: winrateDrop }
        };
    }
    
    return { hasAnomaly: false, type: null, description: null };
}



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ FUNÃ‡ÃƒO PRINCIPAL DE DECISÃƒO DA FASE 2 - VERSÃƒO APRIMORADA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * FunÃ§Ã£o principal que decide se deve liberar sinal de entrada (FASE 2)
 * VersÃ£o 2.0 - Aprimorada com anÃ¡lise inteligente de padrÃµes
 * 
 * @param {Array} entriesHistoryRaw - HistÃ³rico de entradas realizadas
 * @param {string} analysisModeRaw - Modo de anÃ¡lise ('standard' ou 'diamond')
 * @param {Object} analysis - AnÃ¡lise atual da Fase 1
 * @returns {Object} DecisÃ£o de liberaÃ§Ã£o do sinal
 */
function computeMasterSignalDecisionV2(entriesHistoryRaw, analysisModeRaw, analysis) {
    // Usar configuraÃ§Ã£o V2 (com overrides vindos da UI), senÃ£o fallback para a antiga
    const cfg = (typeof MASTER_SIGNAL_CONFIG_V2 !== 'undefined' && MASTER_SIGNAL_CONFIG_V2)
        ? (typeof getMasterSignalConfigV2Runtime === 'function'
            ? getMasterSignalConfigV2Runtime(MASTER_SIGNAL_CONFIG_V2)
            : MASTER_SIGNAL_CONFIG_V2)
        : MASTER_SIGNAL_CONFIG;
    
    const analysisMode = normalizeMasterMode(analysisModeRaw);
    
    const nowTs = (() => {
        try {
            const raw = analysis && (analysis.createdOnTimestamp || analysis.timestamp) 
                ? (analysis.createdOnTimestamp || analysis.timestamp) 
                : null;
            if (raw == null) return Date.now();
            const ms = (typeof raw === 'number') ? raw : Date.parse(String(raw));
            return Number.isFinite(ms) ? ms : Date.now();
        } catch (_) {
            return Date.now();
        }
    })();
    
    const entriesHistory = Array.isArray(entriesHistoryRaw) ? entriesHistoryRaw : [];
    const hasExplicitMode = entriesHistory.some(e => 
        e && (e.analysisMode === 'diamond' || e.analysisMode === 'standard')
    );
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1. FILTRAR E PREPARAR DADOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const byMode = entriesHistory.filter(e => 
        resolveEntryModeMaster(e, hasExplicitMode) === analysisMode
    );
    const finalsRecentFirst = byMode.filter(isFinalCycleMaster);
    const cycles = [...finalsRecentFirst.slice(0, Math.max(0, cfg.maxCyclesForStats))].reverse();
    
    const totalCycles = cycles.length;
    
    // VerificaÃ§Ãµes bÃ¡sicas
    if (!cfg.enabled) {
        return { 
            active: false, 
            mode: analysisMode, 
            computedAt: nowTs, 
            reason: 'Fase 2 desativada por configuraÃ§Ã£o',
            version: cfg.version || '1.0'
        };
    }
    
    if (totalCycles < cfg.minCycles) {
        return { 
            active: false, 
            mode: analysisMode, 
            computedAt: nowTs, 
            reason: `Base insuficiente: ${totalCycles}/${cfg.minCycles} ciclos`,
            meta: { totalCycles, needed: cfg.minCycles - totalCycles },
            version: cfg.version || '1.0'
        };
    }
    
    // FunÃ§Ãµes helper
    const isRet = (e) => {
        if (!e || typeof e !== 'object') return false;
        if (e.finalResult === 'RED' || e.finalResult === 'RET') return true;
        if (e.result === 'LOSS' && ((e.finalResult === 'RED' || e.finalResult === 'RET') || !hasContinuationFlagMaster(e))) return true;
        return false;
    };
    
    const isWin = (e) => {
        if (!e || typeof e !== 'object') return false;
        if (e.finalResult === 'WIN') return true;
        if (e.result === 'WIN') return true;
        return false;
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 2. ANÃLISE DE PADRÃ•ES CONSECUTIVOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const consecutivePatterns = typeof analyzeConsecutivePatterns === 'function'
        ? analyzeConsecutivePatterns(cycles, isWin, isRet, resolveWinStageMaster)
        : null;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 3. ANÃLISE DE DISTÃ‚NCIAS E GAPS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const distancePatterns = typeof analyzeDistancePatterns === 'function'
        ? analyzeDistancePatterns(cycles, isWin, isRet, resolveWinStageMaster)
        : null;
    
    // DistÃ¢ncias desde o Ãºltimo evento
    const indices = distancePatterns?.indices || { entry: [], g1: [], g2: [], losses: [] };
    const nextIndex = cycles.length;
    const last = (arr) => (Array.isArray(arr) && arr.length ? arr[arr.length - 1] : null);
    
    const lastEntrada = last(indices.entry);
    const lastG1 = last(indices.g1);
    const lastG2 = last(indices.g2);
    const lastLoss = last(indices.losses);
    const sinceEntry = lastEntrada != null ? (nextIndex - lastEntrada) : null;
    const sinceG1 = lastG1 != null ? (nextIndex - lastG1) : null;
    const sinceG2 = lastG2 != null ? (nextIndex - lastG2) : null;
    const sinceLoss = lastLoss != null ? (nextIndex - lastLoss) : null;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 4. ESTADO ATUAL (para probabilidade condicional)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Calcular streaks atuais
    const calculateCurrentStreak = (predicate) => {
        let streak = 0;
        for (let i = cycles.length - 1; i >= 0; i--) {
            if (predicate(cycles[i])) streak++;
            else break;
        }
        return streak;
    };
    
    const currentState = {
        lossStreak: calculateCurrentStreak(isRet),
        entryStreak: calculateCurrentStreak(c => isWin(c) && resolveWinStageMaster(c) === 'ENTRADA'),
        g1Streak: calculateCurrentStreak(c => isWin(c) && resolveWinStageMaster(c) === 'G1'),
        g2Streak: calculateCurrentStreak(c => isWin(c) && resolveWinStageMaster(c) !== 'ENTRADA' && resolveWinStageMaster(c) !== 'G1')
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 4.1 REGRA ABSOLUTA (usuÃ¡rio): PONTO ALTO PÃ“S-LOSS (cap histÃ³rico)
    // - Nunca entrar apÃ³s 1 LOSS (isso Ã© tratado no cooldown)
    // - Entrar quando o streak atual de LOSS atingir o MÃXIMO histÃ³rico observado (>=2)
    //   Ex.: se nunca existiu 3 LOSS seguidos, ao ocorrer 2 LOSS seguidos => FORÃ‡AR sinal.
    //   Se algum dia ocorrer 3 (novo mÃ¡ximo), ao ocorrer 3 => FORÃ‡AR sinal, etc.
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const capWindow = Math.max(250, Math.min(5000, Math.floor(Number(cfg.maxCyclesForStats || 0) || 0) || 250, 5000));
    const capSlice = Math.max(250, Math.min(5000, 2000)); // analisar bem mais que 250 para nÃ£o perder streak raro
    const capCycles = [...finalsRecentFirst.slice(0, Math.max(capWindow, capSlice))].reverse(); // cronolÃ³gico
    const computeMaxLossStreak = (arr) => {
        if (!Array.isArray(arr) || !arr.length) return 0;
        let max = 0;
        let cur = 0;
        for (const c of arr) {
            if (isRet(c)) {
                cur++;
                if (cur > max) max = cur;
            } else {
                cur = 0;
            }
        }
        return max;
    };
    const maxLossStreakHistAll = computeMaxLossStreak(capCycles);
    const lossStreakNow = Number(currentState.lossStreak || 0);
    // âœ… Regra dinÃ¢mica:
    // - Se o histÃ³rico NUNCA teve 2 LOSS seguidos (mÃ¡x=1), entÃ£o apÃ³s 1 LOSS jÃ¡ Ã© "ponto alto" (pode entrar).
    // - Se o histÃ³rico NUNCA teve 3 LOSS seguidos (mÃ¡x=2), entÃ£o apÃ³s 2 LOSS Ã© "ponto alto", etc.
    const forcedByLossCap = (lossStreakNow >= 1 && maxLossStreakHistAll >= 1 && lossStreakNow >= maxLossStreakHistAll);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 5. DETECTAR ZONAS QUENTES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const hotZones = typeof detectHotZones === 'function'
        ? detectHotZones(cycles, consecutivePatterns, distancePatterns, cfg)
        : [];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 6. CALCULAR PROBABILIDADES CONDICIONAIS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const conditionalProb = typeof calculateConditionalProbabilities === 'function'
        ? calculateConditionalProbabilities(cycles, consecutivePatterns, currentState, cfg)
        : null;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 7. AVALIAR RISCOS (evitar cair em cima do LOSS)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const clamp01 = (x) => {
        const n = Number(x);
        if (!Number.isFinite(n)) return 0;
        return Math.max(0, Math.min(1, n));
    };

    const hazardAt = (gapsArr, d) => {
        const dist = Math.floor(Number(d));
        if (!Number.isFinite(dist) || dist <= 0) return null;
        const gaps = Array.isArray(gapsArr)
            ? gapsArr.map(Number).filter(n => Number.isFinite(n) && n > 0).map(n => Math.floor(n))
            : [];
        if (!gaps.length) return null;
        let at = 0;
        let ge = 0;
        for (const g of gaps) {
            if (g >= dist) ge++;
            if (g === dist) at++;
        }
        if (ge <= 0) return null;
        return at / ge;
    };

    // DistÃ¢ncias tÃ­picas de LOSS (gaps reais entre LOSS finais)
    const lossDist = distancePatterns?.distances?.losses || null;
    const lossGapsSorted = lossDist && Array.isArray(lossDist.sorted) ? lossDist.sorted : [];
    const lossGapsArr = lossDist && Array.isArray(lossDist.gaps) ? lossDist.gaps : [];

    // âœ… Modelo simplificado (novo): sÃ³ confiar em distÃ¢ncia de LOSS com base mÃ­nima de LOSS
    const lossCountForLossDistanceModel = Array.isArray(indices && indices.losses) ? indices.losses.length : 0;
    const minLossesForLossDistanceModel = Math.max(0, Math.floor(Number(cfg.minLossesForLossDistanceModel || 10)));
    const lossDistanceModelEnabled = (lossCountForLossDistanceModel >= minLossesForLossDistanceModel);
    let lossAvgGapRounded = null;
    let lossAvgGapCount = null;
    let lossAvgGapSupport = null;

    // Alvos discretos para LOSS (os gaps mais provÃ¡veis)
    const retTopN = Math.max(1, Math.floor(Number(cfg.retGapTopN || 4)));
    const retMinCount = Math.max(1, Math.floor(Number(cfg.retGapMinCount || 2)));
    const retMinSupport = Math.max(0, Number(cfg.retGapMinSupport || 0.12));
    const retAvoidWindow = Math.max(0, Math.floor(Number(cfg.retAvoidWindow ?? 1)));
    const retTargetsStrict = lossGapsSorted
        .filter(it => it && Number.isFinite(Number(it.gap)))
        .filter(it => (Number(it.count) || 0) >= retMinCount && (Number(it.prob) || 0) >= retMinSupport)
        .slice(0, retTopN)
        .map(it => Math.floor(Number(it.gap)));
    const retTargetsFallback = lossGapsSorted
        .filter(it => it && Number.isFinite(Number(it.gap)))
        .slice(0, retTopN)
        .map(it => Math.floor(Number(it.gap)));
    let retTargets = retTargetsStrict.length ? retTargetsStrict : retTargetsFallback;

    // âœ… Incluir a distÃ¢ncia MÃ‰DIA (arredondada) como alvo apenas se ela "persistir" no histÃ³rico (vÃ¡rias ocorrÃªncias)
    try {
        if (lossDistanceModelEnabled && lossDist && Number.isFinite(Number(lossDist.avgGap))) {
            const avg = Number(lossDist.avgGap);
            const rounded = Math.max(1, Math.floor(Math.round(avg)));
            const freq = (lossDist && lossDist.freq && typeof lossDist.freq === 'object') ? lossDist.freq : null;
            const total = Array.isArray(lossGapsArr) ? lossGapsArr.length : 0;
            const cnt = (freq && freq[rounded] != null) ? Number(freq[rounded] || 0) : 0;
            const sup = total > 0 ? (cnt / total) : 0;
            const minCnt = Math.max(1, Math.floor(Number(cfg.lossDistanceAvgGapMinCount ?? 2)));
            const minSup = Math.max(0, Number(cfg.lossDistanceAvgGapMinSupport ?? 0.18));
            lossAvgGapRounded = rounded;
            lossAvgGapCount = cnt;
            lossAvgGapSupport = sup;
            if (cnt >= minCnt && sup >= minSup) {
                const set = new Set(Array.isArray(retTargets) ? retTargets : []);
                set.add(rounded);
                retTargets = Array.from(set).sort((a, b) => a - b);
            }
        }
    } catch (_) {}

    // Risco "por distÃ¢ncia" (hazard) â€” NÃƒO Ã© mÃ©dia
    const lossHazardNow = sinceLoss != null ? hazardAt(lossGapsArr, sinceLoss) : null;
    const lossHazardBlockAbove = clamp01(
        cfg.lossDistanceHazardBlockAbove != null ? cfg.lossDistanceHazardBlockAbove : (cfg.maxRetRiskInCountdown || 0.35)
    );
    // âœ… Threshold efetivo: mais conservador que a taxa base de LOSS (para evitar cair em RED)
    const baselineLossRate = totalCycles > 0 ? (lossCountForLossDistanceModel / totalCycles) : 0;
    const lossHazardBlockAboveEffective = lossDistanceModelEnabled
        ? Math.max(0.02, Math.min(lossHazardBlockAbove, baselineLossRate * 0.55))
        : lossHazardBlockAbove;

    // Risco "por sequÃªncia": apÃ³s 2 LOSS seguidos, qual chance de vir outro LOSS?
    const afterLossData = consecutivePatterns?.patterns?.afterLosses || null;
    const lossContinueProbAfter2 = (lossStreakNow >= 2 && afterLossData && afterLossData.total >= (cfg.minEventsForDistance || 3))
        ? clamp01(afterLossData.lossProb)
        : null;

    // Detectar zona de risco: cair em cima de um alvo tÃ­pico de LOSS
    // - Se sinceLoss==1 (logo apÃ³s LOSS), isso significa "consecutivo". A decisÃ£o melhor vem da estatÃ­stica do streak.
    const nearLossZone = (sinceLoss != null && sinceLoss >= (lossDistanceModelEnabled ? 1 : 2))
        ? retTargets.some(t => Math.abs(sinceLoss - t) <= retAvoidWindow)
        : false;

    // Risco final de LOSS no prÃ³ximo ciclo (mistura distÃ¢ncia + sequÃªncia)
    // âœ… Se estamos em "ponto alto" (cap histÃ³rico), nÃ£o faz sentido usar hazard(d=1) como risco,
    // pois ele mede P(gap=1) e nÃ£o P(3Âº LOSS apÃ³s 2). Aqui o risco relevante Ã© o do "prÃ³ximo LOSS apÃ³s 2",
    // que (quando nÃ£o hÃ¡ 3 no histÃ³rico) deve ser ~0.
    const lossRisk = forcedByLossCap
        ? clamp01(lossContinueProbAfter2 != null ? lossContinueProbAfter2 : 0)
        : clamp01(Math.max(
            (lossHazardNow != null ? lossHazardNow : 0),
            (lossContinueProbAfter2 != null ? lossContinueProbAfter2 : 0)
        ));
    
    const risks = {
        nearLossZone,
        lossRisk,
        lossHazardNow,
        lossContinueProbAfter2,
        retTargets,
        lossDistanceModel: {
            enabled: lossDistanceModelEnabled,
            minLosses: minLossesForLossDistanceModel,
            lossCount: lossCountForLossDistanceModel,
            avgGapRounded: lossAvgGapRounded,
            avgGapCount: lossAvgGapCount,
            avgGapSupport: lossAvgGapSupport,
            hazardBlockAbove: lossHazardBlockAboveEffective,
            hazardBlockAboveRaw: lossHazardBlockAbove,
            baselineLossRate
        },
        highRisk: lossRisk > (cfg.maxRetRiskInCountdown || 0.35)
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 8. MONTAR OBJETO DE ANÃLISE COMPLETA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const fullAnalysis = {
        consecutivePatterns,
        distancePatterns,
        hotZones,
        conditionalProb,
        risks,
        distances: {
            sinceEntry,
            sinceG1,
            sinceG2,
            sinceLoss
        },
        currentState,
        totalCycles,
        lossCap: {
            current: lossStreakNow,
            maxHistorical: maxLossStreakHistAll,
            forced: forcedByLossCap
        }
    };
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 9. CALCULAR SCORE MULTIFATORIAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const scoreResult = typeof calculateMultifactorScore === 'function'
        ? calculateMultifactorScore(fullAnalysis, cfg)
        : { score: 50, reasons: ['CÃ¡lculo de score nÃ£o disponÃ­vel'] };
    
    const { score, reasons: scoreReasons } = scoreResult;
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 10. DETECTAR ANOMALIAS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const anomaly = typeof detectAnomalies === 'function'
        ? detectAnomalies(cycles, cfg.anomalyDetection?.recentWindowSize || 20, cfg)
        : { hasAnomaly: false };
    
    if (anomaly.hasAnomaly && cfg.anomalyDetection?.pauseOnAnomaly) {
        return {
            active: false,
            mode: analysisMode,
            computedAt: nowTs,
            reason: `âš ï¸ ANOMALIA DETECTADA: ${anomaly.description}`,
            anomaly,
            score,
            scoreReasons,
            meta: { totalCycles },
            version: cfg.version || '2.0'
        };
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 11. DETERMINAR NÃVEL E DECISÃƒO FINAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let signalLevel = typeof determineSignalLevel === 'function'
        ? determineSignalLevel(score, cfg, fullAnalysis)
        : null;

    // âœ… Ponto alto pÃ³s-LOSS: se atingiu cap histÃ³rico, FORÃ‡AR como NÃ­vel 1 (camada mais rÃ­gida)
    if (forcedByLossCap) {
        const lvl1 = cfg?.levels?.level1 || null;
        signalLevel = {
            level: 1,
            name: lvl1?.name || 'Certeza Absoluta',
            description: lvl1?.description || 'Ponto alto pÃ³s-LOSS (cap histÃ³rico)',
            forcedByLossCap: true
        };
    }

    // âœ… NOVO (simplificado): quando houver base mÃ­nima de LOSS, a Fase 2 decide quase sÃ³ por:
    // - streak de LOSS (cap histÃ³rico)  -> forcedByLossCap (jÃ¡ tratado acima)
    // - distÃ¢ncia para o prÃ³ximo LOSS   -> retTargets + hazardAt(sinceLoss)
    // Isso aumenta MUITO o volume de sinais e evita cair em cima do RED.
    if (lossDistanceModelEnabled && !forcedByLossCap) {
        const hazardHigh = (lossHazardNow != null && lossHazardNow >= lossHazardBlockAboveEffective);
        const blockedByLossDistance = !!(nearLossZone || hazardHigh);
        if (blockedByLossDistance) {
            signalLevel = null;
        } else {
            const hz = lossHazardNow;
            const lvl2MaxHazard = 0.05;
            const isLvl2 = (hz != null && hz <= lvl2MaxHazard);
            const lvlNum = isLvl2 ? 2 : 3;
            const lvlCfg = (lvlNum === 2) ? (cfg?.levels?.level2 || null) : (cfg?.levels?.level3 || null);
            signalLevel = {
                level: lvlNum,
                name: lvlCfg?.name || (lvlNum === 2 ? 'Alta ConfianÃ§a' : 'ConfianÃ§a Balanceada'),
                description: `Anti-LOSS: distÃ¢ncia segura${hz != null ? ` (hazardâ‰ˆ${(hz * 100).toFixed(0)}%)` : ''}`,
                indicators: ['lossDistance'],
                lossRisk
            };
        }
    }
    
    // Modo manual: respeitar nÃ­vel escolhido pelo usuÃ¡rio
    let shouldActivate = false;
    let activationReason = '';
    
    if (cfg.levelMode === 'manual') {
        const manualLevel = cfg.manualLevel || 2;
        // âœ… Modo "somente nÃ­vel": operar APENAS na camada escolhida (nÃ£o Ã© escalonado)
        shouldActivate = signalLevel != null && signalLevel.level === manualLevel;
        if (shouldActivate) {
            const ind = (signalLevel && Array.isArray(signalLevel.indicators) && signalLevel.indicators.length)
                ? ` â€¢ ${signalLevel.indicators.join('+')}`
                : '';
            activationReason = `NÃ­vel ${signalLevel.level} (somente NÃ­vel ${manualLevel})${ind} â€¢ score ${score.toFixed(0)}`;
        } else if (signalLevel && typeof signalLevel.level === 'number') {
            const ind = (signalLevel && Array.isArray(signalLevel.indicators) && signalLevel.indicators.length)
                ? ` â€¢ ${signalLevel.indicators.join('+')}`
                : '';
            activationReason = `Bloqueado: somente NÃ­vel ${manualLevel} (atingiu NÃ­vel ${signalLevel.level}${ind} â€¢ score ${score.toFixed(0)})`;
        } else {
            activationReason = `Aguardando condiÃ§Ãµes do NÃ­vel ${manualLevel} (score ${score.toFixed(0)})`;
        }
    } else {
        // âœ… Modo hÃ­brido: camadas operam em paralelo; aceitar qualquer nÃ­vel vÃ¡lido
        shouldActivate = signalLevel != null;
        activationReason = shouldActivate
            ? (() => {
                const ind = (signalLevel && Array.isArray(signalLevel.indicators) && signalLevel.indicators.length)
                    ? ` â€¢ ${signalLevel.indicators.join('+')}`
                    : '';
                return `HÃ­brido: NÃ­vel ${signalLevel.level}${ind} â€¢ score ${score.toFixed(0)}`;
            })()
            : `HÃ­brido: score ${score.toFixed(0)} insuficiente (mÃ­nimo: ${cfg.levels?.level3?.minScore || 75})`;
    }

    // âœ… Se forÃ§ou por cap histÃ³rico, sobrescrever o motivo (em auto/hÃ­brido) para ficar explÃ­cito
    if (forcedByLossCap && cfg.levelMode !== 'manual') {
        activationReason = `PONTO ALTO: pÃ³s-${lossStreakNow} LOSS â€¢ cap histÃ³rico=${maxLossStreakHistAll} â€¢ ENTRAR`;
    }

    // âœ… Motivo simplificado (anti-LOSS) quando o modelo por distÃ¢ncia estiver ativo (em auto/hÃ­brido)
    if (!forcedByLossCap && lossDistanceModelEnabled && cfg.levelMode !== 'manual') {
        const hzTxt = (lossHazardNow != null) ? `${(lossHazardNow * 100).toFixed(0)}%` : 'â€”';
        const avgTxt = (lossDist && Number.isFinite(Number(lossDist.avgGap))) ? Number(lossDist.avgGap).toFixed(1) : 'â€”';
        const targetsTxt = (Array.isArray(retTargets) && retTargets.length) ? retTargets.join(',') : 'â€”';
        if (shouldActivate) {
            activationReason = `OK anti-LOSS â€¢ distLOSS=${sinceLoss} â€¢ hazardâ‰ˆ${hzTxt} â€¢ mÃ©diaâ‰ˆ${avgTxt} â€¢ evitar [${targetsTxt}]`;
        } else if (nearLossZone && sinceLoss != null) {
            activationReason = `Bloqueado anti-LOSS â€¢ distLOSS=${sinceLoss} em [${targetsTxt}] â€¢ mÃ©diaâ‰ˆ${avgTxt}`;
        } else if (lossHazardNow != null && lossHazardNow >= lossHazardBlockAboveEffective) {
            activationReason = `Bloqueado anti-LOSS â€¢ hazardâ‰ˆ${hzTxt} â‰¥ ${(lossHazardBlockAboveEffective * 100).toFixed(0)}% â€¢ distLOSS=${sinceLoss} â€¢ mÃ©diaâ‰ˆ${avgTxt}`;
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 12. PROTEÃ‡Ã•ES FINAIS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // ProteÃ§Ã£o pÃ³s-LOSS (cooldown)
    // âœ… Regra dinÃ¢mica (usuÃ¡rio):
    // - Se jÃ¡ existiu 2+ LOSS seguidos no histÃ³rico (mÃ¡x>=2), apÃ³s 1 LOSS NÃƒO entrar no sinal seguinte (evita 2Âº LOSS).
    // - Se NUNCA existiu 2 LOSS seguidos (mÃ¡x=1), pode entrar apÃ³s 1 LOSS.
    // âœ… ExceÃ§Ã£o: "ponto alto" â€” quando o streak atual atingiu o cap histÃ³rico (forcedByLossCap)
    let minAfterLoss = Number.isFinite(Number(cfg.minSignalsAfterRet)) ? Number(cfg.minSignalsAfterRet) : 2;
    minAfterLoss = Math.max(1, Math.floor(minAfterLoss));
    if (maxLossStreakHistAll <= 1) {
        minAfterLoss = 1;
    }
    const postLossOk = (sinceLoss == null)
        ? true
        : (sinceLoss >= minAfterLoss || forcedByLossCap);
    
    const bypassedPostLoss = !!(sinceLoss != null && sinceLoss < minAfterLoss && forcedByLossCap);

    // Se bypassou (ponto alto), deixar explÃ­cito no motivo
    if (shouldActivate && bypassedPostLoss && cfg.levelMode !== 'manual') {
        // jÃ¡ fica explÃ­cito no activationReason acima (PONTO ALTO)
    }

    if (shouldActivate && !postLossOk) {
        shouldActivate = false;
        const wait = Math.max(0, minAfterLoss - Number(sinceLoss || 0));
        activationReason = `Bloqueado pÃ³s-LOSS: aguarde ${wait} sinal(is) (evitar 2Âº LOSS)`;
    }
    
    // ProteÃ§Ã£o: nÃ£o entrar em zona tÃ­pica de LOSS (hard-block) â€” exceto "ponto alto" validado
    const hasHotAfterLoss = !!forcedByLossCap || (Array.isArray(hotZones) && hotZones.some(z => z && z.type === 'afterLossStreak' && (z.confidence || 0) >= 90));
    if (shouldActivate && cfg.avoidLossExactCoincidence && nearLossZone && !hasHotAfterLoss) {
        shouldActivate = false;
        activationReason = `Bloqueado: zona tÃ­pica de LOSS (RED em ${sinceLoss} â€¢ evitar [${(retTargets || []).join(',') || 'â€”'}]Â±${retAvoidWindow})`;
    }

    // ProteÃ§Ã£o: nÃ£o entrar se risco de LOSS agora estÃ¡ alto
    if (shouldActivate && risks.highRisk && !hasHotAfterLoss) {
        shouldActivate = false;
        activationReason = `Bloqueado: risco de LOSS ${(lossRisk * 100).toFixed(0)}% > ${((cfg.maxRetRiskInCountdown || 0.35) * 100).toFixed(0)}%`;
    }

    // âœ… Regra extra: limitar quantidade de ENTRADAS liberadas ENTRE REDs (janela pÃ³s-RED)
    // - Por padrÃ£o: max 2 entradas apÃ³s o Ãºltimo RED
    // - A 3Âª sÃ³ pode se for "muito certo" (NÃ­vel 1 / ponto alto)
    // - Se bater o limite: aguardar um novo RED para liberar novamente
    try {
        const softMax = Math.max(1, Math.min(10, Math.floor(Number(cfg.maxMasterEntriesPerRedWindow ?? 2) || 2)));
        const hardMax = Math.max(softMax, Math.min(10, Math.floor(Number(cfg.maxMasterEntriesPerRedWindowHard ?? 3) || 3)));
        const allowThird = !!(forcedByLossCap || (signalLevel && Number(signalLevel.level) === 1));
        const capNow = allowThird ? hardMax : softMax;

        // capCycles jÃ¡ Ã© cronolÃ³gico e inclui bem mais histÃ³rico (finals) â€” Ã³timo para detectar "Ãºltimo RED"
        let lastRedIdxAll = -1;
        for (let i = capCycles.length - 1; i >= 0; i--) {
            if (isRet(capCycles[i])) { lastRedIdxAll = i; break; }
        }
        const afterLastRed = (lastRedIdxAll >= 0) ? capCycles.slice(lastRedIdxAll + 1) : capCycles;
        const usedMasterInWindow = afterLastRed.filter(c => c && c.isMaster).length;

        if (shouldActivate && usedMasterInWindow >= capNow) {
            shouldActivate = false;
            if (!allowThird && hardMax > softMax && usedMasterInWindow < hardMax) {
                activationReason = `Bloqueado: limite entre REDs (${usedMasterInWindow}/${softMax}) â€¢ 3Âª sÃ³ no NÃ­vel 1 â€¢ aguarde novo RED`;
            } else {
                activationReason = `Bloqueado: limite entre REDs (${usedMasterInWindow}/${capNow}) â€¢ aguarde novo RED`;
            }
        }
    } catch (_) {}
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 13. MONTAR RESPOSTA FINAL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const wins = cycles.filter(isWin).length;
    const losses = cycles.filter(isRet).length;
    const winrate = totalCycles > 0 ? (wins / totalCycles) * 100 : 0;
    
    return {
        active: shouldActivate,
        mode: analysisMode,
        computedAt: nowTs,
        version: cfg.version || '2.0',
        
        // InformaÃ§Ãµes do sinal
        signalLevel: signalLevel || { level: 0, name: 'Nenhum', description: 'Score insuficiente' },
        score: Math.round(score),
        scoreBreakdown: scoreReasons,
        
        // RazÃ£o da decisÃ£o
        reason: activationReason,
        
        // EstatÃ­sticas
        stats: {
            totalCycles,
            wins,
            losses,
            winrate: winrate.toFixed(1) + '%',
            sinceEntry,
            sinceLoss
        },
        
        // AnÃ¡lises detalhadas
        patterns: {
            consecutive: consecutivePatterns?.patterns || {},
            distances: distancePatterns?.distances || {},
            currentState
        },
        
        // Zonas quentes identificadas
        hotZones: hotZones.map(z => ({
            type: z.type,
            description: z.description,
            scoreBonus: z.scoreBonus
        })),
        
        // Probabilidades condicionais
        conditionalProbabilities: conditionalProb,
        
        // Riscos identificados
        risks: {
            nearLossZone,
            lossRisk: (lossRisk * 100).toFixed(0) + '%',
            highRisk: risks.highRisk
        },
        
        // Anomalias
        anomaly: anomaly.hasAnomaly ? {
            type: anomaly.type,
            description: anomaly.description
        } : null,
        
        // Metadados
        meta: {
            configVersion: cfg.version || '2.0',
            levelMode: cfg.levelMode || 'auto',
            analysisTimestamp: nowTs
        }
    };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNÃ‡ÃƒO DE INTEGRAÃ‡ÃƒO - Usa V2 se disponÃ­vel, senÃ£o fallback para V1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function computeMasterSignalDecision(entriesHistoryRaw, analysisModeRaw, analysis) {
    // Se funÃ§Ãµes V2 estÃ£o disponÃ­veis, usar versÃ£o aprimorada
    const hasV2Functions = typeof analyzeConsecutivePatterns === 'function' &&
                           typeof calculateMultifactorScore === 'function' &&
                           typeof determineSignalLevel === 'function';
    
    if (hasV2Functions && typeof MASTER_SIGNAL_CONFIG_V2 !== 'undefined') {
        console.log('[FASE 2] Usando versÃ£o aprimorada V2');
        return computeMasterSignalDecisionV2(entriesHistoryRaw, analysisModeRaw, analysis);
    }
    
    // Fallback para versÃ£o original (cÃ³digo jÃ¡ existente)
    console.log('[FASE 2] Usando versÃ£o original V1 (fallback)');
    return computeMasterSignalDecisionV1Original(entriesHistoryRaw, analysisModeRaw, analysis);
}



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¯ FASE 2 V2.0 - CÃ“DIGO APRIMORADO (FIM)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIGURAÃ‡ÃƒO ORIGINAL (V1) - MANTIDA COMO FALLBACK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MASTER_SIGNAL_CONFIG = Object.freeze({
    enabled: true,
    // âœ… Regra do usuÃ¡rio: sÃ³ comeÃ§ar apÃ³s ter base suficiente (ciclos com resultado)
    minCycles: 10,
    // âœ… Performance: nÃ£o analisar histÃ³rico infinito
    maxCyclesForStats: 200,
    // âœ… SeguranÃ§a: quantidade mÃ­nima de eventos para calcular distÃ¢ncias (ex.: 2 WINS na Entrada)
    minEventsForDistance: 2,
    // âœ… Adaptativo: calcular distÃ¢ncias com janela RECENTE (evita "mÃ©dia global" que cai em cima de LOSS)
    decisionWindowCycles: 90,
    // âœ… Alvos discretos (valores reais) para a ENTRADA: usar os gaps mais frequentes no histÃ³rico recente
    entryGapTopN: 4,
    entryGapMinSupport: 0.10, // 10%+
    entryGapMinCount: 2,
    // âœ… Janela de oportunidade: nÃ£o exigir bater "no nÃºmero exato" (senÃ£o trava demais)
    // Ex.: alvo(s) [2,3] com window=1 => aceita 1..4
    entryTargetWindow: 1,
    // âœ… QUALIDADE (FASE 2): nÃ£o usa a "confidence" da FASE 1.
    // Em vez disso, exige que o ponto atual seja estatisticamente forte no histÃ³rico real (hazard da ENTRADA).
    // hazardEntrada(d) = P(gap=d | gap >= d), calculado sobre gaps de vitÃ³rias na ENTRADA.
    minEntryHazard: 0.20,
    // âœ… Se o histÃ³rico estÃ¡ MUITO bom (winrate alto), relaxar o gate da ENTRADA
    // (evita mandar poucos sinais quando hÃ¡ ampla margem entre REDs)
    relaxEntryGate: Object.freeze({
        // âš ï¸ Importante: relax NÃƒO pode virar "libera tudo".
        // Ele sÃ³ deve, no mÃ¡ximo, relaxar levemente a janela do alvo.
        enabled: false,
        minCycles: 40,
        winRateAbove: 0.84
    }),
    // âœ… SequÃªncias (streaks): regras de qualidade por CONTEXTO, como vocÃª descreveu:
    // - apÃ³s 2 RED seguidos: qual a chance de vir o 3Âº?
    // - apÃ³s 3 vitÃ³rias seguidas em G1/G2: qual a chance de vir WIN no prÃ³ximo ciclo?
    streakGates: Object.freeze({
        enabled: true,
        maxK: 6,          // calcular k=1..6
        minSamples: 12,   // mÃ­nimo de exemplos histÃ³ricos para confiar na estatÃ­stica
        red: Object.freeze({
            minLen: 2,
            // Se P(prÃ³ximo=RED | â‰¥minLen RED seguidos) for BAIXA, isso vira um gatilho forte (ponto alto).
            maxContinueProb: 0.12,
            // Se o histÃ³rico diz que 3Âº RED Ã© raro, permitir entrada mesmo "logo apÃ³s" o RED (bypass do cooldown).
            bypassPostLossCooldown: true
        }),
        g1: Object.freeze({
            minLen: 3,
            // Se P(prÃ³ximo ciclo ser WIN | â‰¥minLen vitÃ³rias em G1 seguidas) for ALTA, isso vira gatilho.
            minNextWinProb: 0.78
        }),
        g2: Object.freeze({
            minLen: 3,
            minNextWinProb: 0.78
        })
    }),
    // âœ… ProteÃ§Ã£o pÃ³s-LOSS: nunca liberar mestre â€œlogo depoisâ€ de um RED
    // sinceRed = 1 significa "prÃ³ximo sinal apÃ³s o RED" â†’ bloqueado
    minSignalsAfterRet: 2,
    // âœ… Alvos discretos (valores reais) para RED: zonas mais frequentes entre um RED e outro
    retGapTopN: 4,
    retGapMinSupport: 0.15, // 15%+
    retGapMinCount: 2,
    // âœ… Evitar zona de LOSS: evitar cair exatamente no alvo tÃ­pico de RED
    // (0 = somente o ponto exato; evita travar demais)
    retAvoidWindow: 0,
    // âœ… VerificaÃ§Ã£o do countdown: risco estimado de RED acontecer antes do mestre (0..1)
    // Se risco alto, NÃƒO prometer "mestre em N sinais" (porque pode vir LOSS no meio).
    maxRetRiskInCountdown: 0.45,
    // âœ… Regras do mestre (base = WIN na ENTRADA)
    // - Master sÃ³ nasce quando a ENTRADA estÃ¡ â€œno pontoâ€ (distÃ¢ncia >= alvo)
    // - E nÃ£o pode coincidir com o ponto tÃ­pico de RED (se houver base para isso)
    avoidLossExactCoincidence: true,
    // âœ… Diamante: usar assertividade do nÃ­vel que "mandou" o sinal para aumentar/desconfiar
    diamondLevelTrust: Object.freeze({
        enabled: true,
        // mÃ­nimo de amostras para confiar no winrate do nÃ­vel
        minSamples: 10,
        // se o nÃ­vel estiver abaixo disso, marcar como nÃ­vel fraco (reduz confianÃ§a)
        blockBelowHitRate: 0.60,
        // bloqueio REAL sÃ³ se estiver muito ruim
        hardBlockBelowHitRate: 0.45,
        // se estiver acima disso, marcar como nÃ­vel forte (sÃ³ informativo)
        strongAboveHitRate: 0.85
    })
});

function normalizeMasterMode(mode) {
    const m = String(mode || '').toLowerCase().trim();
    return m === 'diamond' ? 'diamond' : 'standard';
}

function hasContinuationFlagMaster(entry) {
    try {
        const obj = entry && typeof entry === 'object' ? entry : null;
        if (!obj) return false;
        return Object.keys(obj).some((k) => k && k.startsWith('continuingToG') && !!obj[k]);
    } catch (_) {
        return false;
    }
}

function isFinalCycleMaster(entry) {
    if (!entry || typeof entry !== 'object') return false;
    if (entry.finalResult === 'WIN' || entry.finalResult === 'RED' || entry.finalResult === 'RET') return true;
    if (entry.result === 'WIN') return true; // legado
    if (entry.result === 'LOSS') {
        if (entry.finalResult === 'RED' || entry.finalResult === 'RET') return true;
        // LOSS intermediÃ¡rio (vai para G1/G2) NÃƒO Ã© ciclo final
        if (hasContinuationFlagMaster(entry)) return false;
        // LOSS sem flags (config sem gales) -> tratar como ciclo final
        return true;
    }
    return false;
}

function resolveEntryModeMaster(entry, hasExplicitMode) {
    const m = entry && typeof entry.analysisMode === 'string' ? entry.analysisMode : null;
    if (m === 'diamond' || m === 'standard') return m;
    // Se jÃ¡ existem entradas modernas com analysisMode explÃ­cito, ignorar legado para nÃ£o misturar.
    return hasExplicitMode ? 'legacy' : 'standard';
}

function resolveWinStageMaster(entry) {
    const raw = entry && (entry.martingaleStage || entry.wonAt || entry.phase)
        ? String(entry.martingaleStage || entry.wonAt || entry.phase)
        : '';
    const s = raw.toUpperCase().trim();
    if (s === 'ENTRADA' || s === 'G0') return 'ENTRADA';
    const m = s.match(/^G(\d+)$/);
    if (m) return `G${m[1]}`;
    return 'ENTRADA';
}

// âœ… Helper compartilhado: "Evitar" RED com sensibilidade (mistura recente + histÃ³rico completo)
function pickTopGapsWeightedMaster(recentGapsArr, allGapsArr, topN, minCount, minSupport) {
    const clean = (arr) => (Array.isArray(arr)
        ? arr.map(Number).filter(n => Number.isFinite(n) && n > 0).map(n => Math.round(n))
        : []);

    const recent = clean(recentGapsArr);
    const all = clean(allGapsArr);
    if (!recent.length && !all.length) return [];

    const countMap = (arr) => {
        const m = new Map();
        for (const v of arr) {
            m.set(v, (m.get(v) || 0) + 1);
        }
        return m;
    };

    const mr = countMap(recent);
    const ma = countMap(all);
    const nR = recent.length;
    const nA = all.length;

    // Peso do recente cresce conforme aumenta amostra recente (com limites).
    const wRecent = Math.max(0.35, Math.min(0.85, nR / (nR + 20)));

    const keys = new Set([...mr.keys(), ...ma.keys()]);
    const items = Array.from(keys).map((gap) => {
        const cr = mr.get(gap) || 0;
        const ca = ma.get(gap) || 0;
        const sr = nR ? (cr / nR) : 0;
        const sa = nA ? (ca / nA) : 0;
        const score = (wRecent * sr) + ((1 - wRecent) * sa);
        return { gap, score, count: cr + ca };
    }).sort((a, b) => (b.score - a.score) || (b.count - a.count) || (a.gap - b.gap));

    const filtered = items.filter(it =>
        it.count >= Math.max(1, minCount) &&
        it.score >= Math.max(0, minSupport)
    );
    const chosen = filtered.length ? filtered : items;
    return chosen.slice(0, Math.max(1, topN)).map(it => it.gap);
}

function computeTailStreakMaster(cycles, predicate) {
    if (!Array.isArray(cycles) || !cycles.length || typeof predicate !== 'function') return 0;
    let len = 0;
    for (let i = cycles.length - 1; i >= 0; i--) {
        if (predicate(cycles[i])) len++;
        else break;
    }
    return len;
}

// EstatÃ­stica: P(prÃ³ximo satisfazer nextPredicate | jÃ¡ estou em uma streak de k satisfazendo statePredicate)
function computeStreakContinuationMaster(cycles, statePredicate, nextPredicate, maxK = 6) {
    const K = Math.max(1, Math.min(20, Math.floor(Number(maxK) || 0)));
    const samples = Array(K + 1).fill(0);
    const hits = Array(K + 1).fill(0);
    if (!Array.isArray(cycles) || cycles.length < 2) {
        return { K, samples, hits };
    }
    let streak = 0;
    for (let i = 0; i < cycles.length - 1; i++) {
        if (statePredicate(cycles[i])) streak++;
        else streak = 0;
        if (streak <= 0) continue;
        const nextHit = !!nextPredicate(cycles[i + 1]);
        const cap = Math.min(streak, K);
        for (let k = 1; k <= cap; k++) {
            samples[k]++;
            if (nextHit) hits[k]++;
        }
    }
    return { K, samples, hits };
}

function computeMasterSignalDecisionV1Original(entriesHistoryRaw, analysisModeRaw, analysis) {
    const cfg = MASTER_SIGNAL_CONFIG;
    const analysisMode = normalizeMasterMode(analysisModeRaw);
    // computedAt deve ser estÃ¡vel por anÃ¡lise (evita flutuaÃ§Ã£o e writes constantes)
    const nowTs = (() => {
        try {
            const raw = analysis && (analysis.createdOnTimestamp || analysis.timestamp) ? (analysis.createdOnTimestamp || analysis.timestamp) : null;
            if (raw == null) return Date.now();
            const ms = (typeof raw === 'number') ? raw : Date.parse(String(raw));
            return Number.isFinite(ms) ? ms : Date.now();
        } catch (_) {
            return Date.now();
        }
    })();

    const entriesHistory = Array.isArray(entriesHistoryRaw) ? entriesHistoryRaw : [];
    const hasExplicitMode = entriesHistory.some(e => e && (e.analysisMode === 'diamond' || e.analysisMode === 'standard'));

    // 1) Filtrar por modo (Premium vs Diamante) e por ciclos finais (WIN/RET)
    const byMode = entriesHistory.filter(e => resolveEntryModeMaster(e, hasExplicitMode) === analysisMode);
    const finalsRecentFirst = byMode.filter(isFinalCycleMaster);
    const cycles = [...finalsRecentFirst.slice(0, Math.max(0, cfg.maxCyclesForStats))].reverse(); // cronolÃ³gico

    const totalCycles = cycles.length;
    if (!cfg.enabled) {
        return { active: false, mode: analysisMode, computedAt: nowTs, reason: 'Desativado por configuraÃ§Ã£o' };
    }
    if (totalCycles < cfg.minCycles) {
        return { active: false, mode: analysisMode, computedAt: nowTs, reason: `Base insuficiente: ${totalCycles}/${cfg.minCycles} ciclos` };
    }

    const isRet = (e) => {
        if (!e || typeof e !== 'object') return false;
        if (e.finalResult === 'RED' || e.finalResult === 'RET') return true;
        if (e.result === 'LOSS' && ((e.finalResult === 'RED' || e.finalResult === 'RET') || !hasContinuationFlagMaster(e))) return true;
        return false;
    };
    const isWin = (e) => {
        if (!e || typeof e !== 'object') return false;
        if (e.finalResult === 'WIN') return true;
        if (e.result === 'WIN') return true;
        return false;
    };

    // 2) Classificar ciclos e coletar Ã­ndices (para distÃ¢ncias)
    const idxEntrada = [];
    const idxG1 = [];
    const idxG2 = [];
    const idxRet = [];

    for (let i = 0; i < cycles.length; i++) {
        const c = cycles[i];
        if (isRet(c)) {
            idxRet.push(i);
            continue;
        }
        if (!isWin(c)) continue;
        const stage = resolveWinStageMaster(c); // ENTRADA | G1 | G2 | G3...
        if (stage === 'ENTRADA') idxEntrada.push(i);
        else if (stage === 'G1') idxG1.push(i);
        else idxG2.push(i); // G2 ou acima
    }

    const gaps = (indices) => {
        const out = [];
        for (let i = 1; i < indices.length; i++) {
            out.push(Number(indices[i]) - Number(indices[i - 1]));
        }
        return out.filter(n => Number.isFinite(n) && n > 0);
    };

    const pickTopGaps = (gapsArr, topN, minCount, minSupport) => {
        const g = Array.isArray(gapsArr) ? gapsArr.map(Number).filter(n => Number.isFinite(n) && n > 0) : [];
        if (!g.length) return [];
        const h = new Map();
        for (const v of g) {
            const k = Math.round(v);
            h.set(k, (h.get(k) || 0) + 1);
        }
        const total = g.length;
        const items = Array.from(h.entries())
            .map(([gap, count]) => ({ gap, count, support: total ? count / total : 0 }))
            .sort((a, b) => (b.count - a.count) || (a.gap - b.gap));
        const filtered = items.filter(it => it.count >= Math.max(1, minCount) && it.support >= Math.max(0, minSupport));
        return filtered.slice(0, Math.max(1, topN)).map(it => it.gap);
    };

    // 3) DistÃ¢ncias â€œdesde o Ãºltimoâ€ (para o PRÃ“XIMO sinal)
    const nextIndex = cycles.length;
    const last = (arr) => (Array.isArray(arr) && arr.length ? arr[arr.length - 1] : null);
    const lastEntrada = last(idxEntrada);
    const lastRet = last(idxRet);
    const sinceEntrada = lastEntrada === null ? null : (nextIndex - lastEntrada);
    const sinceRet = lastRet === null ? null : (nextIndex - lastRet);

    // 4) Alvos DISCRETOS (valores reais) com janela recente (adaptativo)
    const decisionWindowCycles = Math.max(cfg.minCycles, Math.floor(Number(cfg.decisionWindowCycles) || 0) || totalCycles);
    const decisionCycles = cycles.slice(Math.max(0, cycles.length - decisionWindowCycles));
    const idxEntradaDec = [];
    const idxG1Dec = [];
    const idxG2Dec = [];
    const idxRetDec = [];
    for (let i = 0; i < decisionCycles.length; i++) {
        const c = decisionCycles[i];
        if (isRet(c)) {
            idxRetDec.push(i);
            continue;
        }
        if (!isWin(c)) continue;
        const stage = resolveWinStageMaster(c);
        if (stage === 'ENTRADA') idxEntradaDec.push(i);
        else if (stage === 'G1') idxG1Dec.push(i);
        else idxG2Dec.push(i);
    }

    const entryGapsAll = gaps(idxEntrada);
    const g1GapsAll = gaps(idxG1);
    const g2GapsAll = gaps(idxG2);
    const retGapsAll = gaps(idxRet);

    const entryGapsDecision = gaps(idxEntradaDec);
    const g1GapsDecision = gaps(idxG1Dec);
    const g2GapsDecision = gaps(idxG2Dec);
    const retGapsDecision = gaps(idxRetDec);

    const entryGapsUse = entryGapsDecision.length ? entryGapsDecision : entryGapsAll;
    const g1GapsUse = g1GapsDecision.length ? g1GapsDecision : g1GapsAll;
    const g2GapsUse = g2GapsDecision.length ? g2GapsDecision : g2GapsAll;
    const retGapsUse = retGapsDecision.length ? retGapsDecision : retGapsAll;

    const entryTargetsStrict = pickTopGaps(
        entryGapsUse,
        cfg.entryGapTopN,
        cfg.entryGapMinCount,
        cfg.entryGapMinSupport
    );
    const entryTargetsFallback = pickTopGaps(entryGapsUse, 1, 1, 0);
    const entryTargets = entryTargetsStrict.length ? entryTargetsStrict : entryTargetsFallback;

    // âœ… "Evitar" RED com sensibilidade: mistura histÃ³rico inteiro + recente (janela) com peso maior no recente
    const retTargets = pickTopGapsWeightedMaster(
        retGapsDecision,
        retGapsAll,
        cfg.retGapTopN,
        cfg.retGapMinCount,
        cfg.retGapMinSupport
    );

    const topG1Gaps = pickTopGaps(g1GapsUse, cfg.entryGapTopN, cfg.entryGapMinCount, cfg.entryGapMinSupport);
    const topG2Gaps = pickTopGaps(g2GapsUse, cfg.entryGapTopN, cfg.entryGapMinCount, cfg.entryGapMinSupport);

    // 5) DecisÃ£o do prÃ³ximo sinal: mestre ou nÃ£o?
    // - Base: entrar quando "bater" em um dos alvos reais (gaps) de WIN na ENTRADA
    // - ProteÃ§Ã£o: cooldown pÃ³s-LOSS + evitar zona tÃ­pica de RET
    if (idxEntrada.length < cfg.minEventsForDistance || sinceEntrada === null || !entryTargets.length) {
        return {
            active: false,
            mode: analysisMode,
            computedAt: nowTs,
            reason: 'Base insuficiente para calcular distÃ¢ncias reais da ENTRADA',
            meta: { totalCycles, entryWins: idxEntrada.length, decisionWindowCycles: decisionCycles.length }
        };
    }

    const minSignalsAfterRet = Math.max(1, Math.floor(Number(cfg.minSignalsAfterRet) || 2));
    const retAvoidWindow = Math.max(0, Math.floor(Number(cfg.retAvoidWindow) || 0));
    const maxRetRiskNow = Math.max(0, Math.min(1, Number(cfg.maxRetRiskInCountdown) || 0));

    // Probabilidade estimada de RED acontecer "agora" (hazard discreto):
    // hazard(d) = P(gap = d | gap >= d)
    // âœ… Importante: se NÃƒO hÃ¡ gaps >= d, isso NÃƒO significa 100%.
    // AÃ­ a gente cai para a taxa real de RED (ou null) para evitar alarme falso.
    const computeGapHazardNow = (d, recentGaps, allGaps, baseRate) => {
        const distance = Number.isFinite(Number(d)) ? Math.max(1, Math.round(Number(d))) : null;
        if (distance == null) return null;
        const clean = (arr) => (Array.isArray(arr) ? arr.map(Number).filter(n => Number.isFinite(n) && n > 0).map(n => Math.round(n)) : []);
        const r = clean(recentGaps);
        const a = clean(allGaps);

        const hazardAt = (arr) => {
            if (!arr.length) return null;
            const denom = arr.filter(x => x >= distance).length;
            if (denom <= 0) return null;
            const num = arr.filter(x => x === distance).length;
            return num / denom;
        };

        const hRecent = hazardAt(r);
        const hAll = hazardAt(a);

        // Peso adaptativo: quanto mais amostras recentes, mais peso nelas (capado).
        const nRecent = r.length;
        const wRecent = Math.max(0.2, Math.min(0.85, nRecent / (nRecent + 20)));

        if (hRecent == null && hAll == null) {
            const br = Number.isFinite(Number(baseRate)) ? Math.max(0, Math.min(1, Number(baseRate))) : null;
            return br;
        }
        if (hRecent == null) return hAll;
        if (hAll == null) return hRecent;
        return (wRecent * hRecent) + ((1 - wRecent) * hAll);
    };

    // 6) Decidir APENAS quando um sinal real existe (t=0).
    // âœ… NÃ£o exigir "ponto exato": usar janela em torno dos gaps reais mais frequentes da ENTRADA.
    const entryWindow = Math.max(0, Math.floor(Number(cfg.entryTargetWindow) || 0));
    const entryDueStrict = entryTargets.some(t => Math.abs(Number(sinceEntrada) - Number(t)) <= entryWindow);
    const cycleWinsLocal = cycles.filter(isWin).length;
    const cycleWinRateLocal = totalCycles ? (cycleWinsLocal / totalCycles) : 0;
    const relaxCfg = cfg && cfg.relaxEntryGate ? cfg.relaxEntryGate : null;
    const relaxEntryGateEnabled = !!(relaxCfg && relaxCfg.enabled);
    const relaxMinCycles = Math.max(cfg.minCycles, Math.floor(Number(relaxCfg && relaxCfg.minCycles) || 0));
    const relaxWinRateAbove = Math.max(0, Math.min(1, Number(relaxCfg && relaxCfg.winRateAbove) || 1));
    const relaxEntryGate = !!(relaxEntryGateEnabled && totalCycles >= relaxMinCycles && cycleWinRateLocal >= relaxWinRateAbove);

    // âœ… Se relaxEntryGate estiver ativo, ele apenas RELAXA a janela (Â±1), nunca vira "libera tudo".
    const relaxedWindow = relaxEntryGate ? (entryWindow + 1) : entryWindow;
    const entryDueRelaxed = relaxEntryGate
        ? entryTargets.some(t => Math.abs(Number(sinceEntrada) - Number(t)) <= relaxedWindow)
        : entryDueStrict;

    const sRetNow = (sinceRet != null && Number.isFinite(Number(sinceRet))) ? Number(sinceRet) : null;
    let postLossOk = sRetNow == null ? true : (sRetNow >= minSignalsAfterRet);
    // âš ï¸ "Zona de RED" pode ficar muito agressiva quando o histÃ³rico muda (ex.: fase boa vs fase ruim).
    // Em vez de bloquear por proximidade do alvo, usamos somente o risco real (hazard) calculado abaixo.
    // SÃ³ faz sentido evitar "pontos crÃ­ticos" depois do cooldown
    const retTargetsAfterCooldown = Array.isArray(retTargets)
        ? retTargets.map(Number).filter(n => Number.isFinite(n) && n > minSignalsAfterRet)
        : [];
    const nearRedTarget = (sRetNow != null && (cfg.avoidLossExactCoincidence || retAvoidWindow > 0) && retTargetsAfterCooldown.length)
        ? retTargetsAfterCooldown.some(t => Math.abs(sRetNow - Number(t)) <= Math.max(0, retAvoidWindow))
        : false;

    // Risco de RED "agora" (hazard discreto), usando TODO histÃ³rico + priorizando recente
    const redBaseRate = totalCycles ? (idxRet.length / totalCycles) : null;
    const retRiskNow = (sRetNow != null)
        ? computeGapHazardNow(sRetNow, retGapsDecision, retGapsAll, redBaseRate)
        : null;
    // âœ… Regra: usar risco como proteÃ§Ã£o leve (pode ser ajustado via config).
    const retRiskOk = (retRiskNow == null || maxRetRiskNow <= 0) ? true : (retRiskNow <= maxRetRiskNow);

    // âœ… QUALIDADE (FASE 2): forÃ§a estatÃ­stica do ponto atual para vitÃ³rias na ENTRADA (hazard)
    const entryBaseRate = totalCycles ? (idxEntrada.length / totalCycles) : null;
    const entryHazardNow = (sinceEntrada != null)
        ? computeGapHazardNow(sinceEntrada, entryGapsDecision, entryGapsAll, entryBaseRate)
        : null;
    const minEntryHazard = Math.max(0, Math.min(1, Number(cfg.minEntryHazard) || 0));
    const entryHazardOk = (entryHazardNow != null && minEntryHazard > 0) ? (entryHazardNow >= minEntryHazard) : true;

    // âœ… SequÃªncias (streaks) â€” estatÃ­sticas condicionais do tipo:
    // - P(RED no prÃ³ximo | â‰¥2 RED seguidos)
    // - P(WIN no prÃ³ximo | â‰¥3 vitÃ³rias em G1 seguidas)
    const streakCfg = cfg && cfg.streakGates ? cfg.streakGates : null;
    let streakInfo = null;
    let streakGateOk = false;
    let postLossBypassed = false;
    try {
        if (streakCfg && streakCfg.enabled && totalCycles >= cfg.minCycles) {
            const K = Math.max(1, Math.min(20, Math.floor(Number(streakCfg.maxK) || 6)));
            const minSamples = Math.max(1, Math.floor(Number(streakCfg.minSamples) || 0));
            const isWinG1 = (c) => isWin(c) && resolveWinStageMaster(c) === 'G1';
            const isWinG2 = (c) => isWin(c) && (() => {
                const s = resolveWinStageMaster(c);
                return s !== 'ENTRADA' && s !== 'G1';
            })();

            const redStreakNow = computeTailStreakMaster(cycles, isRet);
            const g1StreakNow = computeTailStreakMaster(cycles, isWinG1);
            const g2StreakNow = computeTailStreakMaster(cycles, isWinG2);

            const redCont = computeStreakContinuationMaster(cycles, isRet, isRet, K);
            const g1Cont = computeStreakContinuationMaster(cycles, isWinG1, isWin, K);
            const g2Cont = computeStreakContinuationMaster(cycles, isWinG2, isWin, K);

            const pick = (stats, k) => {
                const kk = Math.max(1, Math.min(stats && stats.K ? stats.K : K, Math.floor(Number(k) || 1)));
                const n = stats && Array.isArray(stats.samples) ? Number(stats.samples[kk] || 0) : 0;
                const h = stats && Array.isArray(stats.hits) ? Number(stats.hits[kk] || 0) : 0;
                const prob = n > 0 ? (h / n) : null;
                return { k: kk, samples: n, hits: h, prob };
            };

            const redRule = streakCfg.red || {};
            const g1Rule = streakCfg.g1 || {};
            const g2Rule = streakCfg.g2 || {};

            const redPick = pick(redCont, redStreakNow || 1);
            const g1Pick = pick(g1Cont, g1StreakNow || 1);
            const g2Pick = pick(g2Cont, g2StreakNow || 1);

            const safeAfterRedStreak = (redStreakNow >= Math.max(2, Math.floor(Number(redRule.minLen) || 2))) &&
                (redPick.samples >= minSamples) &&
                (redPick.prob != null) &&
                (redPick.prob <= Math.max(0, Math.min(1, Number(redRule.maxContinueProb) || 0)));

            const goodAfterG1Streak = (g1StreakNow >= Math.max(2, Math.floor(Number(g1Rule.minLen) || 3))) &&
                (g1Pick.samples >= minSamples) &&
                (g1Pick.prob != null) &&
                (g1Pick.prob >= Math.max(0, Math.min(1, Number(g1Rule.minNextWinProb) || 1)));

            const goodAfterG2Streak = (g2StreakNow >= Math.max(2, Math.floor(Number(g2Rule.minLen) || 3))) &&
                (g2Pick.samples >= minSamples) &&
                (g2Pick.prob != null) &&
                (g2Pick.prob >= Math.max(0, Math.min(1, Number(g2Rule.minNextWinProb) || 1)));

            streakGateOk = !!(safeAfterRedStreak || goodAfterG1Streak || goodAfterG2Streak);

            // Se 2+ RED seguidos historicamente NÃƒO costuma virar 3Âº, permitir entrada mesmo logo apÃ³s RED (bypass cooldown)
            if (!postLossOk && safeAfterRedStreak && !!redRule.bypassPostLossCooldown) {
                postLossOk = true;
                postLossBypassed = true;
            }

            streakInfo = {
                red: {
                    current: redStreakNow,
                    k: redPick.k,
                    samples: redPick.samples,
                    hits: redPick.hits,
                    continueProb: redPick.prob
                },
                g1: {
                    current: g1StreakNow,
                    k: g1Pick.k,
                    samples: g1Pick.samples,
                    hits: g1Pick.hits,
                    nextWinProb: g1Pick.prob
                },
                g2: {
                    current: g2StreakNow,
                    k: g2Pick.k,
                    samples: g2Pick.samples,
                    hits: g2Pick.hits,
                    nextWinProb: g2Pick.prob
                },
                used: {
                    safeAfterRedStreak: !!safeAfterRedStreak,
                    goodAfterG1Streak: !!goodAfterG1Streak,
                    goodAfterG2Streak: !!goodAfterG2Streak,
                    postLossBypassed: !!postLossBypassed
                }
            };
        }
    } catch (_) {}

    const entryDueOk = !!(entryDueStrict && entryHazardOk);
    const entryDueRelaxedOk = !!(relaxEntryGate && entryDueRelaxed && entryHazardOk);
    const entryGateOk = !!(entryDueOk || entryDueRelaxedOk || streakGateOk);

    // âœ… Sinal de entrada (FASE 2) = gate ENTRADA (alvo/relax/streak) + proteÃ§Ã£o pÃ³s-RED + NÃƒO cair no ponto crÃ­tico de RED + risco de RED agora aceitÃ¡vel
    let active = !!(entryGateOk && postLossOk && !nearRedTarget && retRiskOk);

    // Texto "humano" para UI/Status
    let chosenReason = '';
    if (!entryHazardOk && entryHazardNow != null) {
        chosenReason = `Bloqueado: ponto fraco (hazardEntradaâ‰ˆ${(entryHazardNow * 100).toFixed(0)}% < ${(minEntryHazard * 100).toFixed(0)}%)`;
    } else if (!postLossOk && sRetNow != null) {
        chosenReason = `PÃ³s-LOSS: aguarde ${Math.max(0, minSignalsAfterRet - sRetNow)} sinal(is)`;
    } else if (nearRedTarget && sRetNow != null) {
        const rt = retTargetsAfterCooldown.length ? retTargetsAfterCooldown.join(',') : (Array.isArray(retTargets) ? retTargets.join(',') : 'â€”');
        chosenReason = `Bloqueado: ponto crÃ­tico de RED (${sRetNow} em [${rt}])`;
    } else if (!retRiskOk && retRiskNow != null) {
        chosenReason = `Risco de LOSS alto: ${(retRiskNow * 100).toFixed(0)}% (limite ${(maxRetRiskNow * 100).toFixed(0)}%)`;
    } else if (!entryGateOk) {
        const et = Array.isArray(entryTargets) ? entryTargets.join(',') : 'â€”';
        chosenReason = `Entrada: alvo(s)=${et}Â±${entryWindow} atual=${sinceEntrada}`;
        if (streakInfo && streakInfo.red && streakInfo.red.current >= 2 && streakInfo.red.samples > 0 && streakInfo.red.continueProb != null) {
            chosenReason += ` â€¢ streakRED=${streakInfo.red.current} P(RED)â‰ˆ${(streakInfo.red.continueProb * 100).toFixed(0)}%`;
        }
        if (relaxEntryGate && entryDueRelaxed && !entryDueStrict) {
            chosenReason += ` â€¢ relax(winrate ${(cycleWinRateLocal * 100).toFixed(1)}%)`;
        }
    } else {
        const et = Array.isArray(entryTargets) ? entryTargets.join(',') : 'â€”';
        const rt = Array.isArray(retTargets) ? retTargets.join(',') : 'â€”';
        const gateLabel = entryDueOk
            ? `alvo`
            : (streakInfo && streakInfo.used && (streakInfo.used.safeAfterRedStreak || streakInfo.used.goodAfterG1Streak || streakInfo.used.goodAfterG2Streak))
                ? `streak`
                : (relaxEntryGate && entryDueRelaxed ? 'relax' : 'gate');
        chosenReason = `SINAL DE ENTRADA: OK â€¢ gate=${gateLabel}` +
            (entryDueOk ? ` â€¢ Entrada ${sinceEntrada} em [${et}]Â±${entryWindow}` : '') +
            (streakInfo && streakInfo.used && streakInfo.used.safeAfterRedStreak && streakInfo.red && streakInfo.red.continueProb != null
                ? ` â€¢ pÃ³s-${streakInfo.red.current}RED P(RED)â‰ˆ${(streakInfo.red.continueProb * 100).toFixed(0)}%`
                : '') +
            (streakInfo && streakInfo.used && streakInfo.used.goodAfterG1Streak && streakInfo.g1 && streakInfo.g1.nextWinProb != null
                ? ` â€¢ pÃ³s-${streakInfo.g1.current}xG1 P(WIN)â‰ˆ${(streakInfo.g1.nextWinProb * 100).toFixed(0)}%`
                : '') +
            (streakInfo && streakInfo.used && streakInfo.used.goodAfterG2Streak && streakInfo.g2 && streakInfo.g2.nextWinProb != null
                ? ` â€¢ pÃ³s-${streakInfo.g2.current}xG2+ P(WIN)â‰ˆ${(streakInfo.g2.nextWinProb * 100).toFixed(0)}%`
                : '') +
            (postLossBypassed ? ` â€¢ bypass pÃ³s-LOSS` : '') +
            (relaxEntryGate && entryDueRelaxed && !entryDueStrict ? ` â€¢ relax(winrate ${(cycleWinRateLocal * 100).toFixed(1)}%)` : '') +
            (sRetNow != null ? ` â€¢ RED ${sRetNow} evitar [${rt}]` : '') +
            (retRiskNow != null ? ` â€¢ riscoREDâ‰ˆ${(retRiskNow * 100).toFixed(0)}%` : '');
    }

    const signalsUntilMaster = null;
    const pickedRisk = retRiskNow;
    const pickedWhy = null;

    // 7) Diamante: levar em conta QUAL NÃVEL "MANDOU" o sinal + assertividade histÃ³rica desse nÃ­vel
    let diamondSourceLevel = null;
    let diamondSourceLevelStats = null;
    try {
        const trustCfg = cfg && cfg.diamondLevelTrust ? cfg.diamondLevelTrust : null;
        const src = (analysisMode === 'diamond' && analysis && typeof analysis === 'object')
            ? (analysis.diamondSourceLevel || null)
            : null;
        const srcId = src && src.id ? String(src.id) : null;
        if (analysisMode === 'diamond' && trustCfg && trustCfg.enabled && srcId) {
            diamondSourceLevel = {
                id: srcId,
                name: src && src.name ? String(src.name) : srcId
            };

            // Preferir entriesHistory (entrada real); fallback para signalsHistory (hit no prÃ³ximo giro)
            const fromEntries = computeDiamondEntryHitRatesFromEntries(entriesHistoryRaw);
            let stats = fromEntries && fromEntries.byLevel ? fromEntries.byLevel.get(srcId) : null;
            let source = 'entries';
            if (!stats || stats.total < Number(trustCfg.minSamples || 0)) {
                const fromSignals = computeDiamondEntryHitRatesFromSignalsHistory();
                const stats2 = fromSignals && fromSignals.byLevel ? fromSignals.byLevel.get(srcId) : null;
                if (stats2 && (!stats || (stats2.total > stats.total))) {
                    stats = stats2;
                    source = 'signals';
                }
            }

            if (stats && Number.isFinite(Number(stats.total)) && stats.total > 0) {
                const hitRate = Number.isFinite(Number(stats.hitRate)) ? Number(stats.hitRate) : (stats.wins / stats.total);
                diamondSourceLevelStats = {
                    wins: stats.wins || 0,
                    losses: stats.losses || 0,
                    total: stats.total || 0,
                    hitRate,
                    source
                };

                // Aplicar â€œdesconfianÃ§aâ€ apenas quando o sinal jÃ¡ estaria como sinal de entrada.
                if (active && stats.total >= Number(trustCfg.minSamples || 0)) {
                    const warnBelow = Number(trustCfg.blockBelowHitRate || 0);
                    const hardBlockBelow = Number(trustCfg.hardBlockBelowHitRate || 0);
                    const strongAbove = Number(trustCfg.strongAboveHitRate || 1);
                    const pct = (hitRate * 100);

                    if (hardBlockBelow > 0 && hitRate < hardBlockBelow) {
                        active = false;
                        chosenReason = `Bloqueado (nÃ­vel muito fraco): ${srcId} ${pct.toFixed(1)}% (${stats.wins}/${stats.total})`;
                    } else if (hitRate >= strongAbove) {
                        chosenReason = `${chosenReason} â€¢ NÃ­vel forte: ${srcId} ${pct.toFixed(1)}% (${stats.wins}/${stats.total})`;
                    } else if (warnBelow > 0 && hitRate < warnBelow) {
                        // âœ… NÃ£o bloquear aqui (para nÃ£o "travar" o volume). Apenas avisar/reduzir confianÃ§a (informativo).
                        chosenReason = `${chosenReason} â€¢ NÃ­vel fraco: ${srcId} ${pct.toFixed(1)}% (${stats.wins}/${stats.total})`;
                    } else {
                        chosenReason = `${chosenReason} â€¢ NÃ­vel: ${srcId} ${pct.toFixed(1)}% (${stats.wins}/${stats.total})`;
                    }
                }
            }
        }
    } catch (_) {}

    const master = {
        active,
        mode: analysisMode,
        computedAt: nowTs,
        cyclesUsed: totalCycles,
        pickedPlan: pickedWhy || null,
        retRiskInCountdown: pickedRisk,
        diamondSourceLevel,
        diamondSourceLevelStats,
        // Contadores (para debug/telemetria)
        counts: {
            entradaWins: idxEntrada.length,
            g1Wins: idxG1.length,
            g2Wins: idxG2.length,
            rets: idxRet.length
        },
        // DistÃ¢ncias e alvos (o que vocÃª pediu como â€œsomaâ€)
        distances: {
            decisionWindowCycles: decisionCycles.length,
            entryTargets,
            entryTargetWindow: entryWindow,
            entryGateRelaxed: relaxEntryGate && entryDueRelaxed && !entryDueStrict,
            entryHazardNow,
            minEntryHazard,
            entryHazardOk,
            cycleWinRate: cycleWinRateLocal,
            sinceEntrada,
            g1Targets: topG1Gaps,
            g2Targets: topG2Gaps,
            retTargets,
            sinceRet,
            redRiskNow: retRiskNow,
            nearRedTarget,
            streaks: streakInfo
        },
        signalsUntilMaster,
        reason: chosenReason
    };

    if (analysis && typeof analysis === 'object') {
        master.cycleId = analysis.createdOnTimestamp || analysis.timestamp || null;
    }

    return master;
}

// Retorna estatÃ­sticas para o card "Sinais de entrada" (UI)
function computeMasterSignalStats(entriesHistoryRaw, analysisModeRaw, currentAnalysisRaw = null) {
    const cfg = MASTER_SIGNAL_CONFIG;
    const analysisMode = normalizeMasterMode(analysisModeRaw);
    const entriesHistory = Array.isArray(entriesHistoryRaw) ? entriesHistoryRaw : [];
    const hasExplicitMode = entriesHistory.some(e => e && (e.analysisMode === 'diamond' || e.analysisMode === 'standard'));

    const byMode = entriesHistory.filter(e => resolveEntryModeMaster(e, hasExplicitMode) === analysisMode);
    const finalsRecentFirst = byMode.filter(isFinalCycleMaster);
    const cycles = [...finalsRecentFirst.slice(0, Math.max(0, cfg.maxCyclesForStats))].reverse(); // cronolÃ³gico

    const totalCycles = cycles.length;
    const isWin = (e) => {
        if (!e || typeof e !== 'object') return false;
        if (e.finalResult === 'WIN') return true;
        if (e.result === 'WIN') return true;
        return false;
    };
    const isRet = (e) => {
        if (!e || typeof e !== 'object') return false;
        if (e.finalResult === 'RED' || e.finalResult === 'RET') return true;
        if (e.result === 'LOSS' && ((e.finalResult === 'RED' || e.finalResult === 'RET') || !hasContinuationFlagMaster(e))) return true;
        return false;
    };

    const wins = cycles.filter(isWin).length;
    const rets = cycles.filter(isRet).length;
    const cycleWinRate = totalCycles ? (wins / totalCycles) * 100 : 0;

    // WIN por estÃ¡gio (probabilidade por ciclo)
    let entryWinCount = 0;
    let g1WinCount = 0;
    let g2WinCount = 0; // inclui G2+ (G2, G3, ...)
    for (const c of cycles) {
        if (!isWin(c)) continue;
        const stage = resolveWinStageMaster(c);
        if (stage === 'ENTRADA') entryWinCount++;
        else if (stage === 'G1') g1WinCount++;
        else g2WinCount++;
    }

    const entryWinPct = totalCycles ? (entryWinCount / totalCycles) * 100 : 0;
    const g1WinPct = totalCycles ? (g1WinCount / totalCycles) * 100 : 0;
    const g2WinPct = totalCycles ? (g2WinCount / totalCycles) * 100 : 0;

    const collecting = totalCycles < cfg.minCycles;
    const neededToStart = collecting ? Math.max(0, cfg.minCycles - totalCycles) : 0;

    // DistÃ¢ncias entre ocorrÃªncias (o que vocÃª pediu: "distÃ¢ncia de um para o outro")
    const idxEntrada = [];
    const idxG1 = [];
    const idxG2 = [];
    const idxRet = [];
    for (let i = 0; i < cycles.length; i++) {
        const c = cycles[i];
        if (isRet(c)) {
            idxRet.push(i);
            continue;
        }
        if (!isWin(c)) continue;
        const stage = resolveWinStageMaster(c);
        if (stage === 'ENTRADA') idxEntrada.push(i);
        else if (stage === 'G1') idxG1.push(i);
        else idxG2.push(i);
    }
    const gaps = (indices) => {
        const out = [];
        for (let i = 1; i < indices.length; i++) {
            const d = Number(indices[i]) - Number(indices[i - 1]);
            if (Number.isFinite(d) && d > 0) out.push(d);
        }
        return out;
    };
    const pickTopGaps = (gapsArr, topN, minCount, minSupport) => {
        const g = Array.isArray(gapsArr) ? gapsArr.map(Number).filter(n => Number.isFinite(n) && n > 0) : [];
        if (!g.length) return [];
        const h = new Map();
        for (const v of g) {
            const k = Math.round(v);
            h.set(k, (h.get(k) || 0) + 1);
        }
        const total = g.length;
        const items = Array.from(h.entries())
            .map(([gap, count]) => ({ gap, count, support: total ? count / total : 0 }))
            .sort((a, b) => (b.count - a.count) || (a.gap - b.gap));
        const filtered = items.filter(it => it.count >= Math.max(1, minCount) && it.support >= Math.max(0, minSupport));
        return filtered.slice(0, Math.max(1, topN)).map(it => it.gap);
    };

    const entryGapsAll = gaps(idxEntrada);
    const g1GapsAll = gaps(idxG1);
    const g2GapsAll = gaps(idxG2);
    const retGapsAll = gaps(idxRet);

    const decisionWindowCycles = Math.max(cfg.minCycles, Math.floor(Number(cfg.decisionWindowCycles) || 0) || totalCycles);
    const decisionCycles = cycles.slice(Math.max(0, cycles.length - decisionWindowCycles));
    const idxEntradaDec = [];
    const idxG1Dec = [];
    const idxG2Dec = [];
    const idxRetDec = [];
    for (let i = 0; i < decisionCycles.length; i++) {
        const c = decisionCycles[i];
        if (isRet(c)) {
            idxRetDec.push(i);
            continue;
        }
        if (!isWin(c)) continue;
        const stage = resolveWinStageMaster(c);
        if (stage === 'ENTRADA') idxEntradaDec.push(i);
        else if (stage === 'G1') idxG1Dec.push(i);
        else idxG2Dec.push(i);
    }

    const entryGapsDecision = gaps(idxEntradaDec);
    const g1GapsDecision = gaps(idxG1Dec);
    const g2GapsDecision = gaps(idxG2Dec);
    const retGapsDecision = gaps(idxRetDec);

    const entryGapsUse = entryGapsDecision.length ? entryGapsDecision : entryGapsAll;
    const g1GapsUse = g1GapsDecision.length ? g1GapsDecision : g1GapsAll;
    const g2GapsUse = g2GapsDecision.length ? g2GapsDecision : g2GapsAll;
    const retGapsUse = retGapsDecision.length ? retGapsDecision : retGapsAll;

    const entryTargetsStrict = pickTopGaps(entryGapsUse, cfg.entryGapTopN, cfg.entryGapMinCount, cfg.entryGapMinSupport);
    const entryTargetsFallback = pickTopGaps(entryGapsUse, 1, 1, 0);
    const entryTargets = entryTargetsStrict.length ? entryTargetsStrict : entryTargetsFallback;

    // âœ… "Evitar" RED com sensibilidade: mistura histÃ³rico inteiro + recente (janela) com peso maior no recente
    const retTargets = pickTopGapsWeightedMaster(retGapsDecision, retGapsAll, cfg.retGapTopN, cfg.retGapMinCount, cfg.retGapMinSupport);

    const g1Targets = pickTopGaps(g1GapsUse, cfg.entryGapTopN, cfg.entryGapMinCount, cfg.entryGapMinSupport);
    const g2Targets = pickTopGaps(g2GapsUse, cfg.entryGapTopN, cfg.entryGapMinCount, cfg.entryGapMinSupport);

    const nextIndex = cycles.length;
    const last = (arr) => (Array.isArray(arr) && arr.length ? arr[arr.length - 1] : null);
    const lastEntrada = last(idxEntrada);
    const lastRet = last(idxRet);
    const sinceEntrada = lastEntrada == null ? null : (nextIndex - lastEntrada);
    const sinceRet = lastRet == null ? null : (nextIndex - lastRet);

    // âœ… "PrÃ³ximo sinal" (Entrada/Normal) deve ser calculado somente quando existir um sinal real pendente
    let hasCurrentSignal = false;
    let nextIsMaster = false;
    let reason = collecting ? `Coletando dados (${totalCycles}/${cfg.minCycles})` : 'Aguardando sinal...';
    try {
        const currentAnalysis = currentAnalysisRaw && typeof currentAnalysisRaw === 'object' ? currentAnalysisRaw : null;
        const msExisting = currentAnalysis && currentAnalysis.masterSignal && typeof currentAnalysis.masterSignal.active === 'boolean'
            ? currentAnalysis.masterSignal
            : null;
        const msMode = msExisting && msExisting.mode ? String(msExisting.mode) : null;
        if (currentAnalysis && msMode === analysisMode) {
            hasCurrentSignal = true;
            nextIsMaster = !!msExisting.active;
            reason = msExisting && msExisting.reason ? String(msExisting.reason) : (nextIsMaster ? 'ENTRADA' : 'Normal');
        }
    } catch (_) {}

    const distanceSinceLastRet = sinceRet != null && Number.isFinite(Number(sinceRet)) ? Number(sinceRet) : null;

    // âœ… SequÃªncias (streaks) para transparÃªncia na UI
    let streaks = null;
    try {
        const streakCfg = cfg && cfg.streakGates ? cfg.streakGates : null;
        if (streakCfg && streakCfg.enabled && totalCycles >= cfg.minCycles) {
            const K = Math.max(1, Math.min(20, Math.floor(Number(streakCfg.maxK) || 6)));
            const minSamples = Math.max(1, Math.floor(Number(streakCfg.minSamples) || 0));
            const isWinG1 = (c) => isWin(c) && resolveWinStageMaster(c) === 'G1';
            const isWinG2 = (c) => isWin(c) && (() => {
                const s = resolveWinStageMaster(c);
                return s !== 'ENTRADA' && s !== 'G1';
            })();

            const redStreakNow = computeTailStreakMaster(cycles, isRet);
            const g1StreakNow = computeTailStreakMaster(cycles, isWinG1);
            const g2StreakNow = computeTailStreakMaster(cycles, isWinG2);

            const redCont = computeStreakContinuationMaster(cycles, isRet, isRet, K);
            const g1Cont = computeStreakContinuationMaster(cycles, isWinG1, isWin, K);
            const g2Cont = computeStreakContinuationMaster(cycles, isWinG2, isWin, K);

            const pick = (stats, k) => {
                const kk = Math.max(1, Math.min(stats && stats.K ? stats.K : K, Math.floor(Number(k) || 1)));
                const n = stats && Array.isArray(stats.samples) ? Number(stats.samples[kk] || 0) : 0;
                const h = stats && Array.isArray(stats.hits) ? Number(stats.hits[kk] || 0) : 0;
                const prob = n > 0 ? (h / n) : null;
                return { k: kk, samples: n, hits: h, prob };
            };

            const redPick = pick(redCont, redStreakNow || 1);
            const g1Pick = pick(g1Cont, g1StreakNow || 1);
            const g2Pick = pick(g2Cont, g2StreakNow || 1);

            // SÃ³ expor se houver base mÃ­nima â€” evita nÃºmeros â€œnoisyâ€
            streaks = {
                minSamples,
                red: {
                    current: redStreakNow,
                    k: redPick.k,
                    samples: redPick.samples,
                    hits: redPick.hits,
                    continueProb: redPick.prob
                },
                g1: {
                    current: g1StreakNow,
                    k: g1Pick.k,
                    samples: g1Pick.samples,
                    hits: g1Pick.hits,
                    nextWinProb: g1Pick.prob
                },
                g2: {
                    current: g2StreakNow,
                    k: g2Pick.k,
                    samples: g2Pick.samples,
                    hits: g2Pick.hits,
                    nextWinProb: g2Pick.prob
                }
            };
        }
    } catch (_) {}

    // âœ… Diamante: exibir qual nÃ­vel "originou" o sinal atual + distribuiÃ§Ã£o de sinais por nÃ­vel
    let diamondCurrentSourceLevel = null;
    let diamondCurrentSourceStats = null;
    let diamondSignalsByLevel = null;
    try {
        if (analysisMode === 'diamond') {
            const currentAnalysis = currentAnalysisRaw && typeof currentAnalysisRaw === 'object' ? currentAnalysisRaw : null;
            const ms = currentAnalysis && currentAnalysis.masterSignal && typeof currentAnalysis.masterSignal === 'object'
                ? currentAnalysis.masterSignal
                : null;
            const src = (ms && ms.diamondSourceLevel) ? ms.diamondSourceLevel : (currentAnalysis ? currentAnalysis.diamondSourceLevel : null);
            const srcId = src && src.id ? String(src.id) : (typeof src === 'string' ? String(src) : null);
            if (srcId) {
                diamondCurrentSourceLevel = { id: srcId, name: (src && src.name) ? String(src.name) : srcId };
            }
            diamondCurrentSourceStats = (ms && ms.diamondSourceLevelStats && typeof ms.diamondSourceLevelStats === 'object')
                ? ms.diamondSourceLevelStats
                : null;

            // DistribuiÃ§Ã£o: contar SINAIS DE ENTRADA (ciclos com isMaster) por nÃ­vel no histÃ³rico (janela do stats)
            const masterCycles = cycles.filter(c => c && c.isMaster);
            const totalMasterCycles = masterCycles.length;
            const map = new Map();
            const ensure = (id) => {
                if (!map.has(id)) map.set(id, { id, count: 0, wins: 0, losses: 0 });
                return map.get(id);
            };
            for (const c of masterCycles) {
                const src2 = c.diamondSourceLevel || (c.patternData && c.patternData.diamondSourceLevel) || null;
                const id = src2 && src2.id ? String(src2.id) : (typeof src2 === 'string' ? String(src2) : null);
                const bucket = ensure(id || 'â€”');
                bucket.count++;
                if (isWin(c)) bucket.wins++;
                else if (isRet(c)) bucket.losses++;
            }
            const list = Array.from(map.values()).map(row => {
                const pct = totalMasterCycles > 0 ? (row.count / totalMasterCycles) : 0;
                const hitRate = row.count > 0 ? (row.wins / row.count) : 0;
                return {
                    id: row.id,
                    count: row.count,
                    pct,
                    wins: row.wins,
                    losses: row.losses,
                    hitRate
                };
            }).sort((a, b) => (b.count - a.count) || (String(a.id).localeCompare(String(b.id))));

            diamondSignalsByLevel = {
                totalMasterCycles,
                levels: list
            };
        }
    } catch (_) {}

    return {
        mode: analysisMode,
        minCycles: cfg.minCycles,
        decisionWindowCycles: decisionCycles.length,
        totalCycles,
        wins,
        rets,
        cycleWinRate,
        entryWinCount,
        entryWinPct,
        g1WinCount,
        g1WinPct,
        g2WinCount,
        g2WinPct,
        entryTargets,
        g1Targets,
        g2Targets,
        retTargets,
        sinceEntrada,
        sinceRet,
        hasCurrentSignal,
        nextIsMaster,
        signalsUntilMaster: null,
        neededToStart,
        distanceSinceLastRet,
        reason,
        streaks,
        // Diamante: origem do sinal + ranking por nÃ­vel (sinais de entrada)
        diamondCurrentSourceLevel,
        diamondCurrentSourceStats,
        diamondSignalsByLevel
    };
}

async function attachMasterSignalToAnalysis(analysis, mode) {
    try {
        if (!analysis || typeof analysis !== 'object') return analysis;

        const phase = String(analysis.phase || 'G0').toUpperCase().trim();
        const isEntryPhase = !phase || phase === 'G0' || phase === 'ENTRADA';
        if (!isEntryPhase) {
            // Se nÃ£o Ã© entrada e nÃ£o tem masterSignal, herdar do ciclo (Martingale) se disponÃ­vel
            try {
                if (martingaleState && martingaleState.analysisData && martingaleState.analysisData.masterSignal) {
                    return { ...analysis, masterSignal: martingaleState.analysisData.masterSignal };
                }
            } catch (_) {}
            return analysis;
        }

        const stored = await chrome.storage.local.get(['entriesHistory', ENTRIES_CLEAR_CUTOFF_KEY]);
        const entriesHistoryAll = stored && Array.isArray(stored.entriesHistory) ? stored.entriesHistory : [];
        const cutoffMs = getMasterCutoffMsForMode(stored ? stored[ENTRIES_CLEAR_CUTOFF_KEY] : null, mode);

        // âœ… Hot-path: para o Diamante tambÃ©m, NÃƒO podemos varrer histÃ³rico inteiro.
        // Montar uma janela curta (por ciclos) e parar cedo (newest-first).
        const buildEntriesWindowForMaster = (all, cutoff, modeRaw) => {
            try {
                const list = Array.isArray(all) ? all : [];
                const modeKey = normalizeMasterMode(modeRaw);
                const c = Number(cutoff);
                const hasCutoff = Number.isFinite(c) && c > 0;

                // Quantos ciclos a Fase 2 usa no mÃ¡ximo (V2 > V1)
                let maxCycles = 200;
                try {
                    if (typeof MASTER_SIGNAL_CONFIG_V2 !== 'undefined' && MASTER_SIGNAL_CONFIG_V2 && MASTER_SIGNAL_CONFIG_V2.maxCyclesForStats) {
                        maxCycles = Math.floor(Number(MASTER_SIGNAL_CONFIG_V2.maxCyclesForStats) || maxCycles);
                    } else if (typeof MASTER_SIGNAL_CONFIG !== 'undefined' && MASTER_SIGNAL_CONFIG && MASTER_SIGNAL_CONFIG.maxCyclesForStats) {
                        maxCycles = Math.floor(Number(MASTER_SIGNAL_CONFIG.maxCyclesForStats) || maxCycles);
                    }
                } catch (_) {}
                maxCycles = Math.max(50, Math.min(1000, maxCycles || 200));
                const targetFinals = maxCycles;
                const hardCapEntries = Math.max(500, targetFinals * 8); // seguranÃ§a: inclui intermediÃ¡rios se existirem

                const hasExplicitMode = list.some(e => e && (e.analysisMode === 'diamond' || e.analysisMode === 'standard'));
                let finals = 0;
                const out = [];
                let prevTs = Infinity;
                let monotonic = true;

                for (let i = 0; i < list.length; i++) {
                    const e = list[i];
                    if (!e || typeof e !== 'object') continue;

                    const ts = getEntryTimestampMsForHistory(e);
                    if (Number.isFinite(ts) && ts > 0) {
                        if (ts > prevTs + 2000) monotonic = false;
                        prevTs = ts;
                        if (hasCutoff && ts < c) {
                            if (monotonic) break;
                            continue;
                        }
                    } else {
                        // cutoff ativo: ts invÃ¡lido seria filtrado fora â†’ ignorar
                        if (hasCutoff) continue;
                    }

                    const entryMode = resolveEntryModeMaster(e, hasExplicitMode);
                    if (entryMode !== modeKey) continue;
                    out.push(e);

                    if (isFinalCycleMaster(e)) {
                        finals++;
                        if (finals >= targetFinals) break;
                    }
                    if (out.length >= hardCapEntries) break;
                }

                return out;
            } catch (_) {
                return Array.isArray(all) ? all : [];
            }
        };

        const entriesHistory = buildEntriesWindowForMaster(entriesHistoryAll, cutoffMs, mode);
        const masterSignal = computeMasterSignalDecision(entriesHistory, mode, analysis);

        const updated = { ...analysis, masterSignal };

        // âœ… Persistir tambÃ©m no storage para reload/aba nova renderizar corretamente
        try {
            await chrome.storage.local.set({ analysis: updated });
        } catch (_) {}

        return updated;
    } catch (error) {
        console.warn('âš ï¸ Falha ao anexar masterSignal na anÃ¡lise:', error);
        return analysis;
    }
}

async function emitAnalysisToContent(analysis, mode) {
    try {
        if (analysis && typeof analysis === 'object' && recoveryModeEnabled) {
            // ğŸ›Ÿ RecuperaÃ§Ã£o ativa:
            // - Continuar gerando sinais (fase 1) para alimentar histÃ³rico interno.
            // - NÃƒO mostrar sinais normais ao usuÃ¡rio.
            // - SÃ³ "liberar" (mostrar) quando o gate indicar momento seguro.
            // - Se o ciclo jÃ¡ Ã© de recuperaÃ§Ã£o (analysis.recoveryMode), manter visÃ­vel inclusive em G1/G2.
            const modeKey = mode || (analyzerConfig && analyzerConfig.aiMode ? 'diamond' : 'standard');
            const phase = String(analysis.phase || 'G0');
            const isGalePhase = (phase !== 'G0' && phase !== 'ENTRADA');

            if (!analysis.recoveryMode) {
                // Por padrÃ£o, tudo roda como "silencioso" (nÃ£o aparece na IA/topo).
                analysis.hiddenInternal = true;

                // Se estiver em gale de um ciclo "silencioso", nunca liberar no meio do ciclo.
                if (isGalePhase) {
                    analysis.recoveryGate = null;
                } else {
                    try {
                        // âœ… RecuperaÃ§Ã£o usa histÃ³rico interno (seeded) SEM cutoff da IA
                        const stored = await chrome.storage.local.get([RECOVERY_SECURE_HISTORY_KEY, 'entriesHistory']);
                        const allRecovery = stored && Array.isArray(stored[RECOVERY_SECURE_HISTORY_KEY]) ? stored[RECOVERY_SECURE_HISTORY_KEY] : [];
                        const baseEntries = stored && Array.isArray(stored.entriesHistory) ? stored.entriesHistory : [];

                        // Se por algum motivo o recoverySecureHistory estiver vazio, usar entriesHistory como fallback
                        const source = allRecovery.length ? allRecovery : baseEntries;
                        const gate = computeRecoveryGateFromEntries(source, modeKey);
                        if (gate && gate.ok === true) {
                            analysis.recoveryMode = true;
                            analysis.hiddenInternal = false; // âœ… sinal seguro: visÃ­vel (IA + RecuperaÃ§Ã£o)
                            analysis.recoveryGate = gate && gate.stats ? gate.stats : null;
                            // limpar texto de â€œaguardandoâ€ ao liberar sinal
                            try { emitRecoveryGateStatus(modeKey, ''); } catch (_) {}
                        } else {
                            analysis.recoveryMode = false;
                            analysis.hiddenInternal = true;
                            analysis.recoveryGate = gate && gate.stats ? gate.stats : null;
                            try { emitRecoveryGateStatus(modeKey, gate && gate.reason ? gate.reason : 'Aguardando ponto seguro...'); } catch (_) {}
                        }
                    } catch (_) {
                        analysis.recoveryMode = false;
                        analysis.hiddenInternal = true;
                        analysis.recoveryGate = null;
                        try { emitRecoveryGateStatus(modeKey, 'Aguardando ponto seguro...'); } catch (_) {}
                    }
                }
            } else {
                // âœ… Ciclo jÃ¡ Ã© "sinal seguro": manter VISÃVEL inclusive em G1/G2.
                analysis.hiddenInternal = false;
            }
        }
    } catch (_) {}

    const annotated = await attachMasterSignalToAnalysis(analysis, mode);

    // Persistir flags de RecuperaÃ§Ã£o no storage (evita vazamento em refresh e garante avaliaÃ§Ã£o correta no background)
    try {
        if (annotated && typeof annotated === 'object' && recoveryModeEnabled) {
            await chrome.storage.local.set({ analysis: annotated });
        }
    } catch (_) {}

    // Se for sinal interno (silencioso), persistimos no storage mas NÃƒO emitimos para UI.
    // ExceÃ§Ã£o: quando `recoveryMode=true`, ele deve aparecer apenas na aba "RecuperaÃ§Ã£o segura".
    if (annotated && annotated.hiddenInternal && !annotated.recoveryMode) {
        return false;
    }

    const payload = annotated ? { ...attachLatestSpinsSnapshot(annotated) } : {};
    if (mode) payload.analysisMode = mode;
    return sendMessageToContent('NEW_ANALYSIS', payload);
}

// FunÃ§Ã£o para enviar status de anÃ¡lise para o content script
function sendAnalysisStatus(status) {
    sendMessageToContent('ANALYSIS_STATUS', { status: status });
}

// Helper local para obter um snapshot simples da memÃ³ria ativa
function getMemoriaAtivaStatus() {
    try {
        const totalGiros = Array.isArray(memoriaAtiva.giros) ? memoriaAtiva.giros.length : 0;
        return {
            inicializada: !!memoriaAtiva.inicializada,
            totalAtualizacoes: memoriaAtiva.totalAtualizacoes || 0,
            tempoUltimaAtualizacao: memoriaAtiva.tempoUltimaAtualizacao || 0,
            totalGiros
        };
    } catch (e) {
        return {
            inicializada: false,
            totalAtualizacoes: 0,
            tempoUltimaAtualizacao: 0,
            totalGiros: 0
        };
    }
}

// FunÃ§Ã£o para restaurar o status "IA ativada" apÃ³s anÃ¡lise
async function restoreIAStatus() {
    lastDiamondLevelTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    lastDiamondLevelTimeouts = [];
    try {
        const status = getMemoriaAtivaStatus();
        const updates = status.totalAtualizacoes || 0;
        const baseText = updates > 0
            ? `MemÃ³ria ativada â€¢ ${updates} anÃ¡lises`
            : 'IA ativada';
        sendAnalysisStatus(baseText);
        console.log('%câœ… Status restaurado:', 'color: #00FF88; font-weight: bold;', baseText);
    } catch (error) {
        console.error('âŒ Erro ao restaurar status:', error);
    }
}

// ============================================
// TELEGRAM INTEGRATION
// ============================================

// FunÃ§Ã£o para enviar mensagem ao Telegram
async function sendTelegramMessage(text) {
    if (!analyzerConfig.telegramChatId || analyzerConfig.telegramChatId.trim() === '') {
        console.log('âš ï¸ Telegram Chat ID nÃ£o configurado. Mensagem nÃ£o enviada.');
        console.log('ğŸ’¡ Configure seu Chat ID na caixa de configuraÃ§Ãµes da extensÃ£o.');
        return false;
    }

    console.log('ğŸ“¤ Tentando enviar mensagem ao Telegram...');
    console.log('ğŸ“± Chat ID:', analyzerConfig.telegramChatId);
    console.log('ğŸ“ Mensagem:', text);

    try {
        const response = await fetch(TELEGRAM_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                chat_id: analyzerConfig.telegramChatId,
                text: text,
                parse_mode: 'HTML'
            })
        });

        const result = await response.json();
        
        if (result.ok) {
            console.log('âœ… Mensagem enviada ao Telegram com sucesso!');
            console.log('ğŸ“¬ Resposta:', result);
            return true;
        } else {
            console.error('âŒ Erro ao enviar mensagem ao Telegram:', result);
            if (result.description) {
                console.error('ğŸ“‹ DescriÃ§Ã£o do erro:', result.description);
                if (result.description.includes('chat not found')) {
                    console.error('ğŸ’¡ SOLUÃ‡ÃƒO: VocÃª precisa iniciar uma conversa com o bot primeiro!');
                    console.error('ğŸ’¡ Acesse: https://t.me/Blaze_doubleIA_Bot e clique em "Start"');
                }
            }
            return false;
        }
    } catch (error) {
        console.error('âŒ Erro de conexÃ£o com Telegram:', error);
        console.error('ğŸ“‹ Detalhes:', error.message);
        return false;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENVIAR SINAL DE ENTRADA AO TELEGRAM - REFATORADO 100% (Com verificaÃ§Ã£o de retorno)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function sendTelegramEntrySignal(color, lastSpin, confidence, analysisData = null) {
    console.log('ğŸ¯ Enviando SINAL DE ENTRADA ao Telegram...');
    
    // âœ… VERIFICAR SE HÃ ABA DA BLAZE ABERTA (SEGURANÃ‡A EXTRA)
    const hasBlaze = await hasBlazeTabOpen();
    if (!hasBlaze) {
        console.log('â•‘  â›” ENVIO BLOQUEADO: NENHUMA ABA DA BLAZE ABERTA         â•‘');
        console.log('â•‘  ğŸ’¡ Sinais sÃ³ sÃ£o enviados quando a Blaze estÃ¡ aberta    â•‘');
        return false;
    }
    
    // âœ… VALIDAÃ‡ÃƒO DE PARÃ‚METROS
    if (!color || !lastSpin) {
        console.error('âŒ ParÃ¢metros invÃ¡lidos para envio ao Telegram:', { color, lastSpin });
        return false;
    }
    
    const colorEmoji = color === 'red' ? 'ğŸ”´' : color === 'black' ? 'âš«' : 'âšª';
    const colorText = color === 'red' ? 'VERMELHO' : color === 'black' ? 'PRETO' : 'BRANCO';
    
    // Extrair informaÃ§Ãµes de assertividade do patternDescription se disponÃ­vel
    let assertivenessInfo = '';
    let isAIAnalysis = false;
    if (analysisData && analysisData.patternDescription) {
        try {
            // Tentar fazer parse como JSON primeiro
            const patternDesc = JSON.parse(analysisData.patternDescription);
            
            // Verificar se Ã© anÃ¡lise IA (novo formato estruturado)
            if (patternDesc.type === 'AI_ANALYSIS') {
                isAIAnalysis = true;
                console.log('%cğŸ¤– AnÃ¡lise IA detectada (formato estruturado)', 'color: #00FF88;');
                assertivenessInfo = ''; // Nenhuma info extra
            } else if (patternDesc.type === 'AI_ANALYSIS_OLD' || (typeof patternDesc === 'string' && patternDesc.includes('ğŸ¤–'))) {
                // Formato antigo de IA (texto)
                isAIAnalysis = true;
                console.log('%cğŸ¤– AnÃ¡lise IA detectada (formato antigo)', 'color: #00FF88;');
                assertivenessInfo = '';
            } else {
                // Para anÃ¡lise padrÃ£o, patternDescription Ã© JSON
            let assert = null;
            
            // Buscar informaÃ§Ãµes de assertividade em diferentes locais
            if (patternDesc) {
                // Prioridade 1: colorAnalysis.summary (padrÃµes salvos)
                if (patternDesc.colorAnalysis && patternDesc.colorAnalysis.summary) {
                    assert = patternDesc.colorAnalysis.summary;
                }
                // Prioridade 2: colorAnalysis.assertiveness (anÃ¡lise nova)
                else if (patternDesc.colorAnalysis && patternDesc.colorAnalysis.assertiveness) {
                    assert = patternDesc.colorAnalysis.assertiveness;
                }
                // Prioridade 3: assertiveness direto (padrÃµes salvos legacy)
                else if (patternDesc.assertiveness) {
                    assert = patternDesc.assertiveness;
                }
            }
            
            if (assert) {
                // InformaÃ§Ãµes sobre as demais ocorrÃªncias (excluindo a amostra mÃ­nima)
                if (assert.othersCount !== undefined && assert.othersCount > 0) {
                    // âœ… CORREÃ‡ÃƒO: Usar othersCount diretamente, nÃ£o somar othersWins + othersLosses
                    const othersTotal = assert.othersCount;
                    const othersPct = othersTotal > 0 ? ((assert.othersWins / othersTotal) * 100).toFixed(1) : '0.0';
                    assertivenessInfo += `\nğŸ“Š <b>Demais OcorrÃªncias:</b> ${assert.othersWins}W / ${assert.othersLosses}L (${othersPct}%)`;
                }
                
                // InformaÃ§Ãµes totais
                if (assert.occurrences !== undefined) {
                    assertivenessInfo += `\nğŸ“ˆ <b>Total de OcorrÃªncias:</b> ${assert.occurrences}`;
                }
                
                if (assert.wins !== undefined && assert.losses !== undefined) {
                    const totalPct = assert.winPct ? assert.winPct.toFixed(1) : '0.0';
                    assertivenessInfo += `\nğŸ’¯ <b>WIN Total:</b> ${assert.wins}W / ${assert.losses}L (${totalPct}%)`;
                }
            }
            }
        } catch (e) {
            console.error('Erro ao extrair informaÃ§Ãµes de assertividade:', e);
            // Continuar sem as informaÃ§Ãµes de assertividade
        }
    }
    
    // âœ… Calcular placar baseado em CICLOS COMPLETOS
    const { entriesHistory = [] } = await chrome.storage.local.get('entriesHistory');
    const { totalWins, totalLosses } = calculateCycleScore(entriesHistory);
    
    // isAIAnalysis jÃ¡ foi definido anteriormente ao fazer parse do patternDescription
    const systemTag = isAIAnalysis ? 'ğŸ¤– AnÃ¡lise AvanÃ§ada (IA)' : 'ğŸ“Š Sistema PadrÃ£o';
    
    const message = `
ğŸ¯ <b>ATENÃ‡ÃƒO ENTRAR AGORA</b>
${colorEmoji} <b>${colorText}</b>
ğŸ“Š ConfianÃ§a: ${confidence}%
${isAIAnalysis ? 'ğŸ¤– <b>AnÃ¡lise: InteligÃªncia Artificial</b>' : ''}
ğŸ² Ãšltimo: ${lastSpin.color === 'red' ? 'ğŸ”´' : lastSpin.color === 'black' ? 'âš«' : 'âšª'} ${lastSpin.color === 'red' ? 'Vermelho' : lastSpin.color === 'black' ? 'Preto' : 'Branco'} (${lastSpin.number})
ğŸ“ˆ Placar: WIN: ${totalWins} | LOSS: ${totalLosses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();

    // âœ… ENVIAR E VERIFICAR RETORNO
    const result = await sendTelegramMessage(message);
    
    if (result) {
        console.log('âœ… Sinal de entrada enviado ao Telegram com sucesso!');
        return true;
    } else {
        console.error('âŒ FALHA ao enviar sinal de entrada ao Telegram!');
        console.error('ğŸ’¡ Verifique: 1) Chat ID configurado | 2) Bot iniciado | 3) ConexÃ£o com internet');
        return false;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• FUNÃ‡ÃƒO: Calcular placar filtrado por modo de anÃ¡lise
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function calculateFilteredScore(entriesHistory, analysisMode) {
    // Filtrar entradas pelo modo de anÃ¡lise
    const filteredEntries = entriesHistory.filter(e => {
        // âœ… Entradas antigas sem analysisMode â†’ tratar como MODO PADRÃƒO
        const entryMode = e.analysisMode || 'standard';
        
        // Incluir apenas se for do modo especificado
        return entryMode === analysisMode;
    });
    
    // Filtrar apenas ciclos completos (WIN ou RED)
    const completeCycles = filteredEntries.filter(e => {
        if (e.result === 'WIN') return true;
        if (e.result === 'LOSS' && (e.finalResult === 'RED' || e.finalResult === 'RET')) return true;
        return false;
    });
    
    const wins = completeCycles.filter(e => e.result === 'WIN').length;
    const losses = completeCycles.filter(e => e.result === 'LOSS').length;
    
    console.log(`ğŸ“Š Placar filtrado (modo ${analysisMode}):`, { wins, losses, total: wins + losses });
    
    return { wins, losses };
}

// FunÃ§Ã£o para enviar confirmaÃ§Ã£o de WIN ao Telegram
async function sendTelegramWinConfirmation(wins, losses) {
    console.log('ğŸ’° Enviando confirmaÃ§Ã£o de WIN ao Telegram...');
    console.log('ğŸ“Š Placar: WIN', wins, '/ LOSS', losses);
    
    const total = wins + losses;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
    
    const message = `
ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°
ğŸ”´ <b>Vermelho</b>
ğŸ“Š ConfianÃ§a: 75.2%
ğŸ“ˆ Placar: WIN: ${wins} | LOSS: ${losses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();

    console.log('ğŸ“¤ Enviando mensagem de WIN...');
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio WIN:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// FunÃ§Ã£o para enviar confirmaÃ§Ã£o de LOSS ao Telegram
async function sendTelegramLossConfirmation(wins, losses) {
    console.log('âŒ Enviando confirmaÃ§Ã£o de LOSS ao Telegram...');
    console.log('ğŸ“Š Placar: WIN', wins, '/ LOSS', losses);
    
    const total = wins + losses;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
    
    const message = `
âŒâŒâŒâŒâŒâŒâŒ <b>LOSS</b> âŒâŒâŒâŒâŒâŒâŒ
âš« <b>Preto</b>
ğŸ“Š ConfianÃ§a: 91.2%
ğŸ“ˆ Placar: WIN: ${wins} | LOSS: ${losses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();

    console.log('ğŸ“¤ Enviando mensagem de LOSS...');
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio LOSS:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNÃ‡Ã•ES DE ENVIO DE SINAIS - SISTEMA DE MARTINGALE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Enviar sinal de LOSS (ENTRADA, G1 ou G2)
async function sendTelegramMartingaleLoss(stage, resultSpin, confidencePct = null) {
    console.log(`âŒ Enviando confirmaÃ§Ã£o de LOSS ${stage} ao Telegram...`);
    
    // âœ… Determinar prÃ³ximo Gale baseado no estÃ¡gio atual
    let nextGale = '';
    if (stage === 'ENTRADA') {
        nextGale = 'ğŸ”„ PrÃ³ximo: <b>G1</b>';
    } else if (stage === 'G1') {
        nextGale = 'ğŸ”„ PrÃ³ximo: <b>G2</b>';
    } else if (stage === 'G2') {
        nextGale = 'ğŸ”„ PrÃ³ximo: <b>G3</b>';
    } else if (stage.startsWith('G')) {
        const currentNum = parseInt(stage.substring(1)) || 0;
        nextGale = `ğŸ”„ PrÃ³ximo: <b>G${currentNum + 1}</b>`;
    }
    
    // âœ… Simplificar nome do estÃ¡gio (remover "ENTRADA" se for entrada)
    const stageName = stage === 'ENTRADA' ? '' : ` ${stage}`;
    
    const pctNumber = Number(confidencePct);
    const confidenceText = Number.isFinite(pctNumber) ? `${pctNumber.toFixed(1)}%` : 'N/A';
    
    const message = `
âŒ <b>LOSS${stageName}</b>
ğŸ“Š ConfianÃ§a: ${confidenceText}
ğŸ² Ãšltimo: ${resultSpin.color === 'red' ? 'ğŸ”´' : resultSpin.color === 'black' ? 'âš«' : 'âšª'} ${resultSpin.color === 'red' ? 'Vermelho' : resultSpin.color === 'black' ? 'Preto' : 'Branco'} (${resultSpin.number})
${nextGale}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio LOSS:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ†• FUNÃ‡ÃƒO GENÃ‰RICA: Enviar sinal de qualquer Gale (G1, G2, G3... G200)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function sendTelegramMartingaleGale(galeNumber, color, percentage = null, lastSpin = null) {
    console.log(`ğŸ”„ Enviando sinal de G${galeNumber} ao Telegram...`);
    
    const colorEmoji = color === 'red' ? 'ğŸ”´' : color === 'black' ? 'âš«' : 'âšª';
    const colorText = color === 'red' ? 'VERMELHO' : color === 'black' ? 'PRETO' : 'BRANCO';

    const pctNumber = Number(percentage);
    const confidenceText = Number.isFinite(pctNumber) ? `${pctNumber.toFixed(1)}%` : 'N/A';
    const lastSpinEmoji = lastSpin && lastSpin.color
        ? (lastSpin.color === 'red' ? 'ğŸ”´' : lastSpin.color === 'black' ? 'âš«' : 'âšª')
        : 'ğŸ²';
    const lastSpinColorText = lastSpin && lastSpin.color
        ? (lastSpin.color === 'red' ? 'Vermelho' : lastSpin.color === 'black' ? 'Preto' : 'Branco')
        : 'N/A';
    const lastSpinNumberText = lastSpin && typeof lastSpin.number !== 'undefined' ? ` (${lastSpin.number})` : '';
    
    // Determinar texto de alerta baseado no nÃºmero do Gale
    let warningText = '';
    const { maxGales } = getMartingaleSettingsForEntryColor(color);
    const configuredMaxGales = maxGales || 2;
    if (galeNumber === configuredMaxGales) {
        warningText = '\nâš ï¸ <b>ÃšLTIMA TENTATIVA!</b> âš ï¸';
    } else if (galeNumber >= 3) {
        warningText = `\nâš ï¸ Gale ${galeNumber} de ${configuredMaxGales}`;
    }
    
    const message = `
ğŸ”„ <b>GALE ${galeNumber}</b>
${colorEmoji} <b>${colorText}</b>
ğŸ“Š ConfianÃ§a: ${confidenceText}
ğŸ² Ãšltimo: ${lastSpinEmoji} ${lastSpinColorText}${lastSpinNumberText}${warningText}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log(`ğŸ“¬ Resultado do envio G${galeNumber}:`, result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// Enviar sinal de G1 (Martingale 1)
async function sendTelegramMartingaleG1(color, confidencePct = null, lastSpin = null) {
    return sendTelegramMartingaleGale(1, color, confidencePct, lastSpin);
}

// Enviar sinal de G2 (Martingale 2)
async function sendTelegramMartingaleG2(color, confidencePct = null, lastSpin = null) {
    return sendTelegramMartingaleGale(2, color, confidencePct, lastSpin);
}

// Enviar sinal de WIN no Martingale
async function sendTelegramMartingaleWin(stage, resultSpin, wins, losses, analysisMode = 'standard', confidencePct = null) {
    console.log(`âœ… Enviando confirmaÃ§Ã£o de WIN ${stage} ao Telegram...`);
    console.log(`   Modo de anÃ¡lise: ${analysisMode}`);
    
    const total = wins + losses;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
    const spinEmoji = resultSpin.color === 'red' ? 'ğŸ”´' : resultSpin.color === 'black' ? 'âš«' : 'âšª';
    const spinColor = resultSpin.color === 'red' ? 'VERMELHO' : resultSpin.color === 'black' ? 'PRETO' : 'BRANCO';
    
    // âœ… Identificador do modo
    const modeIcon = analysisMode === 'diamond' ? 'ğŸ’' : 'âš™ï¸';
    const modeName = analysisMode === 'diamond' ? 'Modo Diamante' : 'Modo PadrÃ£o';
    
    let stageMessage = '';
    if (stage === 'ENTRADA') {
        stageMessage = 'ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°';
    } else if (stage === 'G1') {
        stageMessage = 'ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN G1</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°';
    } else if (stage === 'G2') {
        stageMessage = 'ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN G2</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°';
    } else if (stage.startsWith('G')) {
        const galeNum = stage.substring(1);
        stageMessage = `ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’° <b>WIN G${galeNum}</b> ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°ğŸ’°`;
    }
    
    const pctNumber = Number(confidencePct);
    const confidenceText = Number.isFinite(pctNumber) ? `${pctNumber.toFixed(1)}%` : 'N/A';
    
    const message = `
${stageMessage}
${spinEmoji} <b>${spinColor}</b>
${modeIcon} <b>${modeName}</b>
ğŸ“Š ConfianÃ§a: ${confidenceText}
ğŸ“ˆ Placar (${modeName}): WIN: ${wins} | LOSS: ${losses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio WIN:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// Enviar sinal de RED (Loss Final)
async function sendTelegramMartingaleRET(wins, losses, analysisMode = 'standard', confidencePct = null) {
    console.log('â›” Enviando sinal de RED ao Telegram...');
    console.log(`   Modo de anÃ¡lise: ${analysisMode}`);
    
    const total = wins + losses;
    const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
    
    // âœ… Identificador do modo
    const modeIcon = analysisMode === 'diamond' ? 'ğŸ’' : 'âš™ï¸';
    const modeName = analysisMode === 'diamond' ? 'Modo Diamante' : 'Modo PadrÃ£o';
    
    const pctNumber = Number(confidencePct);
    const confidenceText = Number.isFinite(pctNumber) ? `${pctNumber.toFixed(1)}%` : 'N/A';
    
    const message = `
âŒâŒâŒâŒâŒâŒâŒ <b>LOSS NÃƒO PAGOU</b> âŒâŒâŒâŒâŒâŒâŒ
ğŸ”´ <b>Vermelho</b>
${modeIcon} <b>${modeName}</b>
ğŸ“Š ConfianÃ§a: ${confidenceText}
ğŸ“ˆ Placar (${modeName}): WIN: ${wins} | LOSS: ${losses}
â° ${new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
    `.trim();
    
    const result = await sendTelegramMessage(message);
    console.log('ğŸ“¬ Resultado do envio RED:', result ? 'âœ… Sucesso' : 'âŒ Falha');
    return result;
}

// Monitorar abas e controlar extensÃ£o automaticamente
chrome.tabs.onRemoved.addListener(async (tabId, removeInfo) => {
    // Verificar se ainda hÃ¡ abas da Blaze abertas
    const hasBlaze = await hasBlazeTabOpen();
    if (!hasBlaze && isRunning) {
        console.log('â•‘  âš ï¸ NENHUMA ABA DA BLAZE ABERTA - PARANDO EXTENSÃƒO       â•‘');
        stopDataCollection();
    }
});

chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
    if (changeInfo.status === 'complete') {
        // âœ… Verificar mÃºltiplos domÃ­nios da Blaze
        const blazeDomains = [
            'blaze.com',
            'blaze1.space',
            'blaze-1.com',
            'blaze-bet.com',
            'blaze.bet.br'
        ];
        
        const isBlaze = tab.url && blazeDomains.some(domain => tab.url.includes(domain));
        
        if (isBlaze) {
            if (!isRunning) {
                console.log('â•‘  âœ… ABA DA BLAZE DETECTADA - INICIANDO EXTENSÃƒO          â•‘');
                console.log(`â•‘  URL: ${tab.url.substring(0, 50)}...`);
                startDataCollection();
            }
        }
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’ SIMULAÃ‡ÃƒO NO PASSADO (BACKTEST) - MODO DIAMANTE (SEM SPOILER)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const DIAMOND_SIMULATION_BATCH = 25;
// âœ… Backtest determinÃ­stico por sessÃ£o: snapshot do histÃ³rico (evita mudar resultado ao clicar "Testar novamente")
const pastSimHistorySnapshots = new Map(); // key => { chronological, meta, fromTimestamp, toTimestamp }

function makePastSimSnapshotKey(kind, sessionId, usedHistoryLimit) {
    const sid = String(sessionId || '').trim();
    if (!sid) return null;
    const k = String(kind || '').toLowerCase().trim() === 'standard' ? 'standard' : 'diamond';
    const lim = Math.max(0, Math.floor(Number(usedHistoryLimit) || 0));
    return `${k}|${sid}|${lim}`;
}

function prunePastSimSnapshots(max = 12) {
    try {
        const cap = Math.max(4, Math.min(50, Math.floor(Number(max) || 12)));
        if (pastSimHistorySnapshots.size <= cap) return;
        // Map mantÃ©m ordem de inserÃ§Ã£o: remover mais antigos
        const keys = Array.from(pastSimHistorySnapshots.keys());
        const drop = Math.max(0, keys.length - cap);
        for (let i = 0; i < drop; i++) {
            pastSimHistorySnapshots.delete(keys[i]);
        }
    } catch (_) {}
}
const DIAMOND_OPTIMIZATION_TRIALS_DEFAULT = 100;
const DIAMOND_OPTIMIZATION_PROGRESS_EVERY = 1; // enviar progresso a cada tentativa (100 no total)
const DIAMOND_OPTIMIZATION_MIN_PCT_DEFAULT = 95; // âœ… sÃ³ "recomendar" config >= 95%
const diamondOptimizationJobs = new Map(); // jobId -> { cancelled: boolean }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âš™ï¸ SIMULAÃ‡ÃƒO NO PASSADO (BACKTEST) - MODO PADRÃƒO / ANÃLISE PREMIUM (SEM SPOILER)
//  - Reusa o banco de padrÃµes (verifyWithSavedPatterns)
//  - NÃ£o olha futuro: cria sinal no giro i para avaliar no giro i+1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const STANDARD_SIMULATION_BATCH = 25;
const STANDARD_OPTIMIZATION_TRIALS_DEFAULT = 100;
const STANDARD_OPTIMIZATION_PROGRESS_EVERY = 1;
const STANDARD_OPTIMIZATION_MIN_PCT_DEFAULT = 95;

const standardSimulationJobs = new Map(); // jobId -> { cancelled: boolean }
const standardOptimizationJobs = new Map(); // jobId -> { cancelled: boolean }

function makeStandardSimulationJobId() {
    return `std-sim-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function makeStandardOptimizationJobId() {
    return `std-opt-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

async function withTempAnalyzerConfig(tempConfig, fn) {
    const prev = deepClonePlain(analyzerConfig);
    try {
        const merged = { ...prev, ...(tempConfig && typeof tempConfig === 'object' ? deepClonePlain(tempConfig) : {}) };
        merged.aiMode = false; // forÃ§ar modo padrÃ£o durante simulaÃ§Ã£o/otimizaÃ§Ã£o premium
        analyzerConfig = merged;
        return await fn();
    } finally {
        analyzerConfig = prev;
    }
}

function normalizeStandardConfigForSimulation(cfg) {
    const c = cfg && typeof cfg === 'object' ? deepClonePlain(cfg) : {};
    c.aiMode = false;
    ensureMartingaleProfiles(c);
    return c;
}

async function maybeGenerateStandardAnalysisSimulation(history, simState, patternDB) {
    const config = simState.config || {};
    const { consecutiveGales } = getMartingaleSettingsForEntryColor(simState?.martingaleState?.entryColor, 'standard', config);

    // se anÃ¡lise pendente, nÃ£o gerar outra
    if (simState.analysis && simState.analysis.createdOnTimestamp && simState.analysis.predictedFor === 'next') {
        const latestTs = history[0]?.timestamp;
        if (latestTs && simState.analysis.createdOnTimestamp !== latestTs) {
            return;
        }
    }

    // se estamos em gale consecutivo, nÃ£o buscar novo padrÃ£o (mantÃ©m ciclo)
    if (simState.martingaleState.active && isMartingaleStageConsecutive(simState.martingaleState.stage, consecutiveGales)) return;

    const verifyResult = await verifyWithSavedPatterns(history, patternDB);
    if (!verifyResult) return;

    let analysis = { ...verifyResult };
    analysis.predictedFor = 'next';
    analysis.createdOnTimestamp = history[0]?.timestamp;
    if (!analysis.phase) analysis.phase = 'G0';

    if (simState.martingaleState && simState.martingaleState.active) {
        analysis.phase = simState.martingaleState.stage;
        const forcedColor = simState.martingaleState.currentColor || simState.martingaleState.entryColor;
        if (forcedColor && isMartingaleStageConsecutive(simState.martingaleState.stage, consecutiveGales)) {
            analysis.color = forcedColor;
        }
        analysis.confidence = calculateGaleConfidenceValue(analysis.confidence, analysis, simState.martingaleState);
    }

    simState.analysis = analysis;
    simState.lastSignalSpinNumber = history[0]?.number ?? null;
    simState.lastSignalSpinId = history[0]?.id ?? null;
    simState.lastSignalSpinTimestamp = history[0]?.timestamp ?? null;

    const signal = {
        timestamp: history[0]?.timestamp ? new Date(history[0].timestamp).getTime() : Date.now(),
        patternType: analysis.patternType || 'premium',
        patternName: analysis.patternDescription || 'SimulaÃ§Ã£o Premium',
        colorRecommended: analysis.color,
        verified: false,
        colorThatCame: null,
        hit: null
    };
    if (simState.signalsHistory && Array.isArray(simState.signalsHistory.signals)) {
        simState.signalsHistory.signals.push(signal);
        if (simState.signalsHistory.signals.length > 200) {
            simState.signalsHistory.signals = simState.signalsHistory.signals.slice(-200);
        }
    }
    simState.totalSignals++;
}

async function runStandardPastSimulation({ config, senderTabId, jobId, historyLimit, sessionId, reuseSnapshot }) {
    const job = standardSimulationJobs.get(jobId);
    const requestedLimit = Number(historyLimit);
    const safeDefault = 1440;
    const sourceHistory = await getHistorySourceForPastRuns(requestedLimit);
    const availableHistory = Array.isArray(sourceHistory) ? sourceHistory.length : 0;
    const limit = (Number.isFinite(requestedLimit) && requestedLimit > 0)
        ? Math.min(requestedLimit, 10000, availableHistory || requestedLimit)
        : Math.min(safeDefault, availableHistory || safeDefault);

    let stableWindow = null;
    let chronological = [];
    const useSnap = reuseSnapshot !== false && sessionId;
    const snapKey = useSnap ? makePastSimSnapshotKey('standard', sessionId, limit) : null;
    const snap = snapKey ? pastSimHistorySnapshots.get(snapKey) : null;
    if (snap && Array.isArray(snap.chronological)) {
        chronological = snap.chronological;
        stableWindow = {
            chronological,
            meta: snap.meta || {
                availableHistory: chronological.length,
                uniqueCount: chronological.length,
                droppedDuplicates: 0,
                droppedInvalidTs: 0,
                usedHistoryLimit: chronological.length
            }
        };
    } else {
        stableWindow = getStableChronologicalHistoryWindow({ limit, sourceHistory: Array.isArray(sourceHistory) ? sourceHistory : [] });
        chronological = stableWindow.chronological;
        if (snapKey) {
            pastSimHistorySnapshots.set(snapKey, {
                chronological,
                meta: stableWindow.meta,
                fromTimestamp: chronological[0]?.timestamp || null,
                toTimestamp: chronological[chronological.length - 1]?.timestamp || null
            });
            prunePastSimSnapshots();
        }
    }
    const totalSpins = chronological.length;
    const fromTimestamp = chronological[0]?.timestamp || null;
    const toTimestamp = chronological[totalSpins - 1]?.timestamp || null;

    const simConfig = normalizeStandardConfigForSimulation(config);
    const simState = createDiamondSimulationState(simConfig);
    const simHistory = [];

    const patternDB = await loadPatternDB();

    return await withTempAnalyzerConfig(simConfig, async () => {
        for (let i = 0; i < totalSpins; i++) {
            if (job && job.cancelled) {
                if (senderTabId != null) {
                    try { chrome.tabs.sendMessage(senderTabId, { type: 'STANDARD_SIMULATION_CANCELLED', data: { jobId } }); } catch (_) {}
                }
                return {
                    cancelled: true,
                    fromTimestamp,
                    toTimestamp,
                    totalSpins,
                    requestedLimit,
                    usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
                    availableHistory: stableWindow.meta.availableHistory,
                    uniqueHistory: stableWindow.meta.uniqueCount,
                    droppedDuplicates: stableWindow.meta.droppedDuplicates,
                    droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
                    simState
                };
            }

            const spin = chronological[i];
            simHistory.unshift(spin);
            if (simHistory.length > limit) simHistory.pop();

            // 1) avaliar anÃ¡lise pendente no giro atual
            evaluatePendingAnalysisSimulation(spin, simState, simHistory, 'standard');

            // 2) gerar sinal para o prÃ³ximo giro (sem ver o futuro)
            if (i < totalSpins - 1) {
                await maybeGenerateStandardAnalysisSimulation(simHistory, simState, patternDB);
            }

            if (i % STANDARD_SIMULATION_BATCH === 0 || i === totalSpins - 1) {
                try {
                    try {
                        chrome.runtime.sendMessage({
                            type: 'STANDARD_SIMULATION_PROGRESS',
                            data: { jobId, processed: i + 1, total: totalSpins }
                        });
                    } catch (_) {}
                } catch (_) {}
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        return {
            cancelled: false,
            fromTimestamp,
            toTimestamp,
            totalSpins,
            requestedLimit,
            usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
            availableHistory: stableWindow.meta.availableHistory,
            uniqueHistory: stableWindow.meta.uniqueCount,
            droppedDuplicates: stableWindow.meta.droppedDuplicates,
            droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
            simState
        };
    });
}

function buildStandardOptimizationCandidateConfig(baseConfig, rng) {
    const cfg = normalizeStandardConfigForSimulation(baseConfig);
    // variar em torno do valor atual (faixas seguras)
    const baseDepth = clampInt(cfg.historyDepth ?? 500, 100, REALTIME_HISTORY_CAP);
    const baseMinOcc = clampInt(cfg.minOccurrences ?? 2, 1, 20);
    const baseMaxOcc = clampInt(cfg.maxOccurrences ?? 0, 0, 60);
    const baseInterval = clampInt(cfg.minIntervalSpins ?? 0, 0, 30);
    const baseMinSize = clampInt(cfg.minPatternSize ?? 3, 2, 20);
    const baseMaxSize = clampInt(cfg.maxPatternSize ?? 0, 0, 30);
    const baseWinPct = clampInt(cfg.winPercentOthers ?? 100, 0, 100);
    const baseReqTrig = cfg.requireTrigger !== undefined ? !!cfg.requireTrigger : true;

    const depth = clampInt(
        randomInt(
            rng,
            Math.max(100, Math.floor(baseDepth * 0.6)),
            Math.min(REALTIME_HISTORY_CAP, Math.ceil(baseDepth * 1.4))
        ),
        100,
        REALTIME_HISTORY_CAP
    );
    const minOcc = clampInt(randomInt(rng, Math.max(1, baseMinOcc - 2), Math.min(20, baseMinOcc + 4)), 1, 20);
    const maxOccChoices = [0, clampInt(randomInt(rng, minOcc, Math.min(60, Math.max(minOcc, baseMaxOcc || 20))), minOcc, 60)];
    const maxOcc = maxOccChoices[Math.floor(rng() * maxOccChoices.length)];
    const interval = clampInt(randomInt(rng, Math.max(0, baseInterval - 3), Math.min(30, baseInterval + 6)), 0, 30);
    const minSize = clampInt(randomInt(rng, Math.max(2, baseMinSize - 1), Math.min(20, baseMinSize + 4)), 2, 20);
    const maxSizeChoices = [0, clampInt(randomInt(rng, minSize, Math.min(30, Math.max(minSize, baseMaxSize || 12))), minSize, 30)];
    const maxSize = maxSizeChoices[Math.floor(rng() * maxSizeChoices.length)];
    const winPct = clampInt(randomInt(rng, Math.max(0, baseWinPct - 25), Math.min(100, baseWinPct + 10)), 0, 100);
    const reqTrig = rng() < 0.25 ? !baseReqTrig : baseReqTrig;

    cfg.historyDepth = depth;
    cfg.minOccurrences = minOcc;
    cfg.maxOccurrences = maxOcc;
    cfg.minIntervalSpins = interval;
    cfg.minPatternSize = minSize;
    cfg.maxPatternSize = maxSize;
    cfg.winPercentOthers = winPct;
    cfg.requireTrigger = reqTrig;

    return cfg;
}

async function runStandardPastOptimization({ config, senderTabId, jobId, historyLimit, trials }) {
    const job = standardOptimizationJobs.get(jobId);
    const requestedLimit = Number(historyLimit);
    const safeDefault = 1440;
    const sourceHistory = await getHistorySourceForPastRuns(requestedLimit);
    const availableHistory = Array.isArray(sourceHistory) ? sourceHistory.length : 0;
    const limit = (Number.isFinite(requestedLimit) && requestedLimit > 0)
        ? Math.min(requestedLimit, 10000, availableHistory || requestedLimit)
        : Math.min(safeDefault, availableHistory || safeDefault);

    const stableWindow = getStableChronologicalHistoryWindow({ limit, sourceHistory: Array.isArray(sourceHistory) ? sourceHistory : [] });
    const chronological = stableWindow.chronological;
    const totalSpins = chronological.length;
    const fromTimestamp = chronological[0]?.timestamp || null;
    const toTimestamp = chronological[totalSpins - 1]?.timestamp || null;

    const totalTrials = clampInt(trials || STANDARD_OPTIMIZATION_TRIALS_DEFAULT, 1, 1000);
    const minPct = STANDARD_OPTIMIZATION_MIN_PCT_DEFAULT;
    const baseConfig = normalizeStandardConfigForSimulation(config);

    // Seed determinÃ­stico: mesma config + mesma janela => mesmos 100 testes
    const seedPayload = JSON.stringify({
        usedHistoryLimit: limit,
        fromTimestamp,
        toTimestamp,
        standard: {
            historyDepth: baseConfig.historyDepth,
            minOccurrences: baseConfig.minOccurrences,
            maxOccurrences: baseConfig.maxOccurrences,
            minIntervalSpins: baseConfig.minIntervalSpins,
            minPatternSize: baseConfig.minPatternSize,
            maxPatternSize: baseConfig.maxPatternSize,
            winPercentOthers: baseConfig.winPercentOthers,
            requireTrigger: baseConfig.requireTrigger
        }
    });
    const seed = hashStringToSeed(seedPayload);
    const rng = makeMulberry32(seed);

    const patternDB = await loadPatternDB();

    let bestOverall = null;
    let bestEligible = null;
    const seen = new Set();

    const simulateCandidate = async (candidateCfg) => {
        const simState = createDiamondSimulationState(candidateCfg);
        const simHistory = [];
        for (let i = 0; i < totalSpins; i++) {
            const spin = chronological[i];
            simHistory.unshift(spin);
            if (simHistory.length > limit) simHistory.pop();
            evaluatePendingAnalysisSimulation(spin, simState, simHistory, 'standard');
            if (i < totalSpins - 1) {
                await maybeGenerateStandardAnalysisSimulation(simHistory, simState, patternDB);
            }
        }
        const entries = simState.entriesHistory || [];
        const filtered = filterFinalEntries(entries);
        const wins = filtered.filter(e => e.result === 'WIN').length;
        const totalCycles = filtered.length;
        const losses = totalCycles - wins;
        const pct = totalCycles ? (wins / totalCycles) * 100 : 0;
        const score = scoreOptimizationCandidate(pct, totalCycles);
        return { pct: Number(pct.toFixed(1)), wins, losses, totalCycles, totalSignals: simState.totalSignals || 0, score, entries, config: candidateCfg };
    };

    for (let t = 0; t < totalTrials; t++) {
        if (job && job.cancelled) {
            if (senderTabId != null) {
                try { chrome.tabs.sendMessage(senderTabId, { type: 'STANDARD_OPTIMIZATION_CANCELLED', data: { jobId } }); } catch (_) {}
            }
            return {
                cancelled: true,
                jobId,
                totalTrials,
                fromTimestamp,
                toTimestamp,
                totalSpins,
                requestedLimit,
                usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
                availableHistory: stableWindow.meta.availableHistory,
                uniqueHistory: stableWindow.meta.uniqueCount,
                droppedDuplicates: stableWindow.meta.droppedDuplicates,
                droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
                bestEligible: null,
                bestOverall: null
            };
        }

        let candidateCfg = null;
        let sig = '';
        for (let tries = 0; tries < 30; tries++) {
            candidateCfg = buildStandardOptimizationCandidateConfig(baseConfig, rng);
            sig = `D${candidateCfg.historyDepth}|minOcc${candidateCfg.minOccurrences}|maxOcc${candidateCfg.maxOccurrences}|int${candidateCfg.minIntervalSpins}|minS${candidateCfg.minPatternSize}|maxS${candidateCfg.maxPatternSize}|win${candidateCfg.winPercentOthers}|trig${candidateCfg.requireTrigger ? 1 : 0}`;
            if (!seen.has(sig)) break;
        }
        if (!candidateCfg) continue;
        seen.add(sig);

        const result = await withTempAnalyzerConfig(candidateCfg, async () => simulateCandidate(candidateCfg));

        if (!bestOverall || result.score > bestOverall.score) {
            bestOverall = result;
        }
        if (result.pct >= minPct && (!bestEligible || result.score > bestEligible.score)) {
            bestEligible = result;
        }

        if ((t % STANDARD_OPTIMIZATION_PROGRESS_EVERY) === 0 || t === totalTrials - 1) {
            try {
                chrome.runtime.sendMessage({
                    type: 'STANDARD_OPTIMIZATION_PROGRESS',
                    data: {
                        jobId,
                        trial: t + 1,
                        totalTrials,
                        minPct,
                        recommendedFound: !!bestEligible,
                        best: (bestEligible || bestOverall) ? {
                            pct: (bestEligible || bestOverall).pct,
                            totalCycles: (bestEligible || bestOverall).totalCycles
                        } : null
                    }
                });
            } catch (_) {}
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    return {
        cancelled: false,
        jobId,
        totalTrials,
        minPct,
        fromTimestamp,
        toTimestamp,
        totalSpins,
        requestedLimit,
        usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
        availableHistory: stableWindow.meta.availableHistory,
        uniqueHistory: stableWindow.meta.uniqueCount,
        droppedDuplicates: stableWindow.meta.droppedDuplicates,
        droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
        bestEligible,
        bestOverall
    };
}

function makeDiamondOptimizationJobId() {
    return `diamond-opt-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function deepClonePlain(obj) {
    try {
        return obj ? JSON.parse(JSON.stringify(obj)) : {};
    } catch (_) {
        return obj ? { ...obj } : {};
    }
}

function makeMulberry32(seed) {
    let a = (Number(seed) || 0) >>> 0;
    return function rng() {
        a |= 0;
        a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
}

function hashStringToSeed(str) {
    const s = String(str || '');
    let h = 2166136261 >>> 0;
    for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
    }
    return h >>> 0;
}

function parseSpinTimestamp(spin) {
    if (!spin) return NaN;
    const raw = spin.timestamp ?? spin.created_at ?? spin.createdAt ?? spin.time ?? null;
    if (raw == null) return NaN;
    if (typeof raw === 'number') {
        // Normalizar: timestamps em segundos (10 dÃ­gitos) -> ms
        return raw > 0 && raw < 1e12 ? raw * 1000 : raw;
    }
    const n = Number(raw);
    if (Number.isFinite(n)) {
        return n > 0 && n < 1e12 ? n * 1000 : n;
    }
    const t = Date.parse(String(raw));
    return Number.isFinite(t) ? t : NaN;
}

function getSpinDedupKey(spin) {
    if (!spin) return null;
    if (spin.id != null) return `id:${String(spin.id)}`;
    const ts = parseSpinTimestamp(spin);
    const num = spin.number != null ? String(spin.number) : '';
    const col = spin.color != null ? String(spin.color) : '';
    if (Number.isFinite(ts)) return `ts:${ts}|n:${num}|c:${col}`;
    return null;
}

function getStableChronologicalHistoryWindow({ limit, sourceHistory }) {
    const raw = Array.isArray(sourceHistory) ? sourceHistory : [];
    const availableHistory = raw.length;
    const take = Math.max(0, Math.min(Number(limit) || 0, availableHistory));

    // Snapshot em memÃ³ria + dedup + filtro timestamp
    const seen = new Set();
    const unique = [];
    let droppedDuplicates = 0;
    let droppedInvalidTs = 0;

    // raw costuma vir most-recent-first; mas pode ter duplicados / fora de ordem
    for (let i = 0; i < raw.length; i++) {
        const spin = raw[i];
        if (!spin || !spin.color) continue;
        const ts = parseSpinTimestamp(spin);
        if (!Number.isFinite(ts)) {
            droppedInvalidTs++;
            continue;
        }
        const key = getSpinDedupKey(spin);
        if (key && seen.has(key)) {
            droppedDuplicates++;
            continue;
        }
        if (key) seen.add(key);
        unique.push({
            ...spin,
            timestamp: spin.timestamp ?? ts // garantir campo timestamp utilizÃ¡vel
        });
    }

    unique.sort((a, b) => parseSpinTimestamp(a) - parseSpinTimestamp(b)); // antigo -> recente
    const windowChron = take > 0 ? unique.slice(Math.max(0, unique.length - take)) : [];

    return {
        chronological: windowChron,
        meta: {
            availableHistory,
            uniqueCount: unique.length,
            droppedDuplicates,
            droppedInvalidTs,
            usedHistoryLimit: take
        }
    };
}

function clampInt(n, min, max) {
    const v = Math.floor(Number(n));
    if (!Number.isFinite(v)) return min;
    return Math.max(min, Math.min(max, v));
}

function randomInt(rng, min, max) {
    const a = Math.ceil(min);
    const b = Math.floor(max);
    if (b <= a) return a;
    return a + Math.floor(rng() * (b - a + 1));
}

function scoreOptimizationCandidate(pct, totalCycles) {
    const p = Number(pct) || 0;
    const n = Math.max(0, Number(totalCycles) || 0);
    // Combina assertividade com "cobertura" (evita 100% com 1 ciclo vencer 90% com 100 ciclos)
    return p * Math.log10(n + 1);
}

function buildDiamondOptimizationCandidateConfig(baseConfig, levelId, rng) {
    const cfg = deepClonePlain(baseConfig || {});
    cfg.aiMode = true;
    ensureMartingaleProfiles(cfg);
    cfg.diamondLevelEnabled = buildDiamondSingleLevelEnabledMap(levelId, cfg.diamondLevelEnabled || {});

    const windows = cfg.diamondLevelWindows && typeof cfg.diamondLevelWindows === 'object'
        ? { ...cfg.diamondLevelWindows }
        : {};

    // âœ… IMPORTANTE: nunca variar campos de OUTROS nÃ­veis.
    // O otimizador por nÃ­vel deve mexer SOMENTE nos parÃ¢metros daquele nÃ­vel.
    const upper = String(levelId || '').toUpperCase();
    if (upper === 'N1') {
        const baseW = Number(windows.n1WindowSize ?? SAFE_ZONE_DEFAULTS.windowSize) || SAFE_ZONE_DEFAULTS.windowSize;
        const baseA = Number(windows.n1PrimaryRequirement ?? SAFE_ZONE_DEFAULTS.primaryRequirement) || SAFE_ZONE_DEFAULTS.primaryRequirement;
        const baseB = Number(windows.n1SecondaryRequirement ?? SAFE_ZONE_DEFAULTS.secondaryRequirement) || SAFE_ZONE_DEFAULTS.secondaryRequirement;
        const baseMaxE = Number(windows.n1MaxEntries ?? SAFE_ZONE_DEFAULTS.maxEntries) || SAFE_ZONE_DEFAULTS.maxEntries;

        // variar em torno do valor atual (Â±50%), respeitando limites
        const w = randomInt(rng, Math.max(5, Math.floor(baseW * 0.5)), Math.min(200, Math.ceil(baseW * 1.5)));
        const aMax = Math.max(1, w - 1);
        const a = randomInt(rng, Math.max(1, Math.floor(baseA * 0.5)), Math.min(aMax, Math.ceil(baseA * 1.5)));
        const bMax = Math.max(1, a - 1);
        const b = randomInt(rng, 1, Math.min(bMax, Math.max(1, Math.ceil(baseB * 1.5))));
        const maxE = randomInt(rng, Math.max(1, Math.floor(baseMaxE * 0.5)), Math.min(20, Math.ceil(baseMaxE * 1.5)));

        windows.n1WindowSize = clampInt(w, 5, 200);
        windows.n1PrimaryRequirement = clampInt(a, 1, windows.n1WindowSize - 1);
        windows.n1SecondaryRequirement = clampInt(b, 1, windows.n1PrimaryRequirement - 1);
        windows.n1MaxEntries = clampInt(maxE, 1, 20);
    } else if (upper === 'N2') {
        // N2 - Ritmo AutÃ´nomo (W Ãºnico)
        const baseW = clampInt(windows.n2Recent ?? 10, 6, 200);
        const w = clampInt(
            randomInt(rng, Math.max(6, Math.floor(baseW * 0.5)), Math.min(200, Math.ceil(baseW * 1.6))),
            6,
            200
        );
        windows.n2Recent = w;
        windows.n2Previous = w; // legado: espelha W por compatibilidade
    } else if (upper === 'N3') {
        // N3 - AlternÃ¢ncia
        const baseHist = clampInt(windows.n3Alternance ?? 2000, 4, 10000);
        const baseGlobalThreshPct = clampInt(windows.n3BaseThresholdPct ?? 60, 50, 95);
        const baseMinOcc = clampInt(windows.n3MinOccurrences ?? 3, 1, 500);
        const baseAllowBackoff = windows.n3AllowBackoff !== undefined ? !!windows.n3AllowBackoff : false;
        const baseIgnoreWhite = windows.n3IgnoreWhite !== undefined ? !!windows.n3IgnoreWhite : false;

        const hist = clampInt(
            randomInt(rng, Math.max(4, Math.floor(baseHist * 0.5)), Math.min(10000, Math.ceil(baseHist * 1.5))),
            4,
            10000
        );
        const globalThreshPct = clampInt(
            randomInt(rng, Math.max(50, baseGlobalThreshPct - 18), Math.min(95, baseGlobalThreshPct + 12)),
            50,
            95
        );
        const minOcc = clampInt(
            randomInt(rng, 1, Math.min(500, Math.max(1, baseMinOcc + 12))),
            1,
            500
        );
        const allowBackoff = rng() < 0.35 ? !baseAllowBackoff : baseAllowBackoff;
        // Branco quebra alternÃ¢ncia; esse toggle Ã© compatibilidade/UX â€” manter, mas variar pouco
        const ignoreWhite = rng() < 0.15 ? !baseIgnoreWhite : baseIgnoreWhite;

        windows.n3Alternance = hist;
        windows.n3BaseThresholdPct = globalThreshPct;
        windows.n3MinOccurrences = minOcc;
        windows.n3AllowBackoff = allowBackoff;
        windows.n3IgnoreWhite = ignoreWhite;
    } else if (upper === 'N4') {
        // N4 - Autointeligente (histÃ³rico analisado)
        const baseW = clampInt(windows.n4Persistence ?? DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence, 10, REALTIME_HISTORY_CAP);
        const w = clampInt(
            randomInt(rng, Math.max(10, Math.floor(baseW * 0.5)), Math.min(REALTIME_HISTORY_CAP, Math.ceil(baseW * 1.6))),
            10,
            REALTIME_HISTORY_CAP
        );
        windows.n4Persistence = w;
    } else {
        // Outros nÃ­veis: nÃ£o alterar nada por enquanto (evita bagunÃ§ar configuraÃ§Ãµes do usuÃ¡rio).
    }

    cfg.diamondLevelWindows = windows;
    return cfg;
}

async function runDiamondPastOptimization({ config, levelId, senderTabId, jobId, historyLimit, trials }) {
    const job = diamondOptimizationJobs.get(jobId);
    const requestedLimit = Number(historyLimit);
    const safeDefault = 1440;
    const sourceHistory = await getHistorySourceForPastRuns(requestedLimit);
    const availableHistory = Array.isArray(sourceHistory) ? sourceHistory.length : 0;
    const limit = (Number.isFinite(requestedLimit) && requestedLimit > 0)
        ? Math.min(requestedLimit, 10000, availableHistory || requestedLimit)
        : Math.min(safeDefault, availableHistory || safeDefault);

    const stableWindow = getStableChronologicalHistoryWindow({ limit, sourceHistory: Array.isArray(sourceHistory) ? sourceHistory : [] });
    const chronological = stableWindow.chronological;
    const totalSpins = chronological.length;
    const fromTimestamp = chronological[0]?.timestamp || null;
    const toTimestamp = chronological[totalSpins - 1]?.timestamp || null;

    const totalTrials = clampInt(trials || DIAMOND_OPTIMIZATION_TRIALS_DEFAULT, 1, 1000);
    const minPct = DIAMOND_OPTIMIZATION_MIN_PCT_DEFAULT;
    const baseConfig = (config && typeof config === 'object') ? deepClonePlain(config) : {};
    baseConfig.aiMode = true;
    ensureMartingaleProfiles(baseConfig);

    // âœ… Seed determinÃ­stico: mesma config + mesma janela => mesmos 100 testes (sem "aleatoriedade do nada")
    const seedPayload = JSON.stringify({
        levelId: String(levelId || '').toUpperCase(),
        usedHistoryLimit: limit,
        fromTimestamp,
        toTimestamp,
        windows: baseConfig.diamondLevelWindows || {},
        enabled: baseConfig.diamondLevelEnabled || {}
    });
    const seed = hashStringToSeed(seedPayload);
    const rng = makeMulberry32(seed);

    let bestOverall = null; // melhor "geral" (para referÃªncia)
    let bestEligible = null; // melhor >= minPct (para recomendaÃ§Ã£o)
    const seen = new Set();

    for (let t = 0; t < totalTrials; t++) {
        if (job && job.cancelled) {
            if (senderTabId != null) {
                try { chrome.tabs.sendMessage(senderTabId, { type: 'DIAMOND_OPTIMIZATION_CANCELLED', data: { jobId } }); } catch (_) {}
            }
            return {
                cancelled: true,
                jobId,
                totalTrials,
                fromTimestamp,
                toTimestamp,
                totalSpins,
                requestedLimit,
                usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
                availableHistory: stableWindow.meta.availableHistory,
                uniqueHistory: stableWindow.meta.uniqueCount,
                droppedDuplicates: stableWindow.meta.droppedDuplicates,
                droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
                bestEligible: null,
                bestOverall: null
            };
        }

        // gerar config candidata (garantir "diferentes" pelo menos por assinatura)
        let candidateCfg = null;
        let sig = '';
        for (let tries = 0; tries < 30; tries++) {
            candidateCfg = buildDiamondOptimizationCandidateConfig(baseConfig, levelId, rng);
            const dw = candidateCfg.diamondLevelWindows || {};
            if (String(levelId || '').toUpperCase() === 'N1') {
                sig = `W${dw.n1WindowSize}|A${dw.n1PrimaryRequirement}|B${dw.n1SecondaryRequirement}|E${dw.n1MaxEntries}`;
            } else {
                sig = JSON.stringify(dw);
            }
            if (!seen.has(sig)) break;
            candidateCfg = null;
        }
        if (!candidateCfg) {
            // fallback: aceitar mesmo se repetiu
            candidateCfg = buildDiamondOptimizationCandidateConfig(baseConfig, levelId, rng);
        } else {
            seen.add(sig);
        }

        // rodar simulaÃ§Ã£o walk-forward (sem vazamento)
        const simState = createDiamondSimulationState(candidateCfg);
        const simHistory = [];
        for (let i = 0; i < totalSpins; i++) {
            const spin = chronological[i];
            simHistory.unshift(spin);
            if (simHistory.length > limit) simHistory.pop();

            evaluatePendingAnalysisSimulation(spin, simState, simHistory, 'diamond');
            if (i < totalSpins - 1) {
                maybeGenerateDiamondAnalysisSimulation(simHistory, simState);
            }
        }

        const entries = simState.entriesHistory || [];
        const filtered = filterFinalEntries(entries);
        const wins = filtered.filter(e => e && e.result === 'WIN').length;
        const totalCycles = filtered.length;
        const losses = totalCycles - wins;
        const pct = totalCycles ? ((wins / totalCycles) * 100) : 0;
        const score = scoreOptimizationCandidate(pct, totalCycles);
        const totalSignals = simState.totalSignals || 0;

        const candidate = {
            score,
            pct: Number(pct.toFixed(2)),
            wins,
            losses,
            totalCycles,
            totalSignals,
            config: candidateCfg,
            entries,
            meta: { totalSpins, fromTimestamp, toTimestamp }
        };

        const isBetterOverall = !bestOverall
            || candidate.score > bestOverall.score
            || (candidate.score === bestOverall.score && candidate.pct > bestOverall.pct)
            || (candidate.score === bestOverall.score && candidate.pct === bestOverall.pct && candidate.totalCycles > bestOverall.totalCycles);

        if (isBetterOverall) bestOverall = candidate;

        const isEligible = candidate.totalCycles > 0 && candidate.pct >= minPct;
        if (isEligible) {
            const isBetterEligible = !bestEligible
                || candidate.score > bestEligible.score
                || (candidate.score === bestEligible.score && candidate.pct > bestEligible.pct)
                || (candidate.score === bestEligible.score && candidate.pct === bestEligible.pct && candidate.totalCycles > bestEligible.totalCycles);
            if (isBetterEligible) bestEligible = candidate;
        }

        if (t % DIAMOND_OPTIMIZATION_PROGRESS_EVERY === 0 || t === totalTrials - 1) {
            try {
                const pick = bestEligible || bestOverall;
                const dw = (pick && pick.config && pick.config.diamondLevelWindows) ? pick.config.diamondLevelWindows : {};
                const upper = String(levelId || '').toUpperCase();
                const summary = upper === 'N1'
                    ? `W ${dw.n1WindowSize} | minA ${dw.n1PrimaryRequirement} | minB ${dw.n1SecondaryRequirement} | maxE ${dw.n1MaxEntries}`
                    : upper === 'N2'
                    ? `W ${dw.n2Recent}`
                    : upper === 'N3'
                    ? `Prof ${dw.n3Alternance} | R ${dw.n3BaseThresholdPct ?? 60}% | minOcc ${dw.n3MinOccurrences ?? 3}`
                    : upper === 'N4'
                    ? `Hist ${dw.n4Persistence}`
                    : 'â€”';

                // âœ… Enviar via runtime (nÃ£o depende de tabId). Quem nÃ£o for o job atual ignora pelo jobId.
                try {
                    chrome.runtime.sendMessage({
                        type: 'DIAMOND_OPTIMIZATION_PROGRESS',
                        data: {
                            jobId,
                            levelId: upper,
                            trial: t + 1,
                            totalTrials,
                            minPct,
                            recommendedFound: !!bestEligible,
                            best: pick ? {
                                pct: pick.pct,
                                totalCycles: pick.totalCycles,
                                totalSignals: pick.totalSignals,
                                score: Number(pick.score.toFixed(2)),
                                summary
                            } : null
                        }
                    });
                } catch (_) {}
            } catch (_) {}
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    return {
        cancelled: false,
        jobId,
        totalTrials,
        fromTimestamp,
        toTimestamp,
        totalSpins,
        requestedLimit,
        usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
        availableHistory: stableWindow.meta.availableHistory,
        uniqueHistory: stableWindow.meta.uniqueCount,
        droppedDuplicates: stableWindow.meta.droppedDuplicates,
        droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
        minPct,
        bestEligible,
        bestOverall
    };
}
const diamondSimulationJobs = new Map();

function makeDiamondSimulationJobId() {
    return `diamond-sim-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function getDiamondWindowFromConfig(config, key, fallback) {
    const windows = config && config.diamondLevelWindows ? config.diamondLevelWindows : {};
    const rawValue = windows ? Number(windows[key]) : NaN;
    if (Number.isFinite(rawValue) && rawValue > 0) {
        return rawValue;
    }
    const legacyKeyMap = {
        n6RetracementWindow: 'n8RetracementWindow',
        n7DecisionWindow: 'n10DecisionWindow',
        n7HistoryWindow: 'n10HistoryWindow',
        n8Barrier: 'n6Barrier',
        n0History: 'n0TotalHistory',
        n0Window: 'n0WindowSize'
    };
    const legacyKey = legacyKeyMap[key];
    if (legacyKey && Number.isFinite(Number(windows[legacyKey])) && Number(windows[legacyKey]) > 0) {
        return Number(windows[legacyKey]);
    }
    if (key === 'n5MinuteBias' && Number.isFinite(Number(config && config.minuteSpinWindow))) {
        const legacy = Number(config.minuteSpinWindow);
        if (legacy > 0) return legacy;
    }
    return fallback;
}

function getDiamondBooleanFromConfig(config, key, fallback = false) {
    const windows = config && config.diamondLevelWindows ? config.diamondLevelWindows : {};
    if (!windows || !Object.prototype.hasOwnProperty.call(windows, key)) {
        return fallback;
    }
    const raw = windows[key];
    if (typeof raw === 'boolean') return raw;
    if (typeof raw === 'string') {
        const lowered = raw.trim().toLowerCase();
        if (lowered === 'true') return true;
        if (lowered === 'false') return false;
        const numeric = Number(raw);
        if (!Number.isNaN(numeric)) return numeric > 0;
        return fallback;
    }
    if (typeof raw === 'number') {
        if (!Number.isNaN(raw)) return raw > 0;
    }
    return fallback;
}

function getSafeZoneSettingsFromConfig(config) {
    const windows = config?.diamondLevelWindows || {};
    let windowSize = Number(windows.n1WindowSize) || SAFE_ZONE_DEFAULTS.windowSize;
    let minPrimary = Number(windows.n1PrimaryRequirement) || SAFE_ZONE_DEFAULTS.primaryRequirement;
    let minSecondary = Number(windows.n1SecondaryRequirement) || SAFE_ZONE_DEFAULTS.secondaryRequirement;
    let maxEntries = Number(windows.n1MaxEntries) || SAFE_ZONE_DEFAULTS.maxEntries;

    windowSize = Math.max(5, Math.min(200, windowSize));
    minPrimary = Math.max(1, Math.min(windowSize - 1, minPrimary));
    minSecondary = Math.max(1, Math.min(minPrimary - 1, minSecondary));
    maxEntries = Math.max(1, Math.min(20, Math.floor(maxEntries)));

    return { windowSize, minPrimary, minSecondary, maxEntries };
}

function getN0SettingsFromConfig(config) {
    const windows = config && config.diamondLevelWindows ? config.diamondLevelWindows : {};
    const historySizeRaw = Number(windows.n0History);
    const windowSizeRaw = Number(windows.n0Window);
    const historySize = Number.isFinite(historySizeRaw) && historySizeRaw > 0 ? Math.floor(historySizeRaw) : N0_DEFAULTS.historySize;
    const windowSize = Number.isFinite(windowSizeRaw) && windowSizeRaw > 0 ? Math.floor(windowSizeRaw) : N0_DEFAULTS.windowSize;
    return {
        historySize: Math.max(200, Math.min(REALTIME_HISTORY_CAP, historySize)),
        windowSize: Math.max(25, Math.min(250, windowSize)),
        allowBlockAll: config && config.n0AllowBlockAll !== false
    };
}

function analyzeMomentumFromConfig(history, config) {
    // âœ… NOVO N2: janela base Ãºnica W (usuÃ¡rio) + ajuste automÃ¡tico
    const baseW = Math.max(6, Math.min(200, getDiamondWindowFromConfig(config, 'n2Recent', 10)));
    return analyzeMomentumWithSizes(history, baseW, 0);
}

function buildDiamondSingleLevelEnabledMap(levelId, baseEnabledMap = null) {
    const allKeys = Object.keys(DEFAULT_ANALYZER_CONFIG.diamondLevelEnabled || {});
    const enabled = {};
    allKeys.forEach(k => { enabled[k] = false; });
    const key = getDiamondLevelKeyFromId(levelId);
    if (key) enabled[key] = true;

    // âœ… Garantir que a Barreira N9 continue respeitada quando o usuÃ¡rio estiver
    // simulando "apenas um nÃ­vel" (N9 Ã© validador/veto, nÃ£o Ã© voto).
    // Se o usuÃ¡rio manteve N9 ativo na configuraÃ§Ã£o base, preservamos n9 aqui.
    if (baseEnabledMap && typeof baseEnabledMap === 'object') {
        if (baseEnabledMap.n9 === true) {
            enabled.n9 = true;
        }
    }
    return enabled;
}

function computeIntervalBlockForSimulation(history, config, simState) {
    // âŒ Removido a pedido do usuÃ¡rio: nÃ£o aplicar cooldown/intervalo entre sinais na simulaÃ§Ã£o.
    return { blocked: false, message: '' };
}

function createDiamondSimulationState(config) {
    return {
        config,
        analysis: null,
        entriesHistory: [],
        lastSignalSpinId: null,
        lastSignalSpinNumber: null,
        lastSignalSpinTimestamp: null,
        lastCycleResolvedSpinId: null,
        lastCycleResolvedSpinTimestamp: null,
        signalsHistory: { signals: [] },
        safeZoneEntryState: { signature: null, entriesUsed: 0 },
        alternanceEntryControl: {
            active: false,
            patternSignature: null,
            entryColor: null,
            entryCount: 0,
            lastResult: null,
            lastEntryTimestamp: null,
            blockedUntil: null,
            totalWins: 0,
            totalLosses: 0
        },
        martingaleState: {
            active: false,
            stage: 'ENTRADA',
            patternKey: null,
            entryColor: null,
            currentColor: null,
            entryColorResult: null,
            entryTimestamp: null,
            analysisData: null,
            lossCount: 0,
            lossColors: [],
            patternsWithoutHistory: 0
        },
        totalSignals: 0
    };
}

function updateAlternanceControlAfterSignal(simState, hit) {
    const ctrl = simState.alternanceEntryControl;
    if (!ctrl || !ctrl.active) return;
    ctrl.lastResult = hit ? 'win' : 'loss';
    if (hit) {
        ctrl.totalWins++;
        if (ctrl.entryCount >= 2) {
            ctrl.active = false;
            ctrl.patternSignature = null;
            ctrl.entryColor = null;
            ctrl.entryCount = 0;
            ctrl.lastResult = null;
            ctrl.lastEntryTimestamp = null;
        }
    } else {
        ctrl.totalLosses++;
        if (ctrl.entryCount <= 1 || ctrl.entryCount >= 2) {
            ctrl.active = false;
            ctrl.patternSignature = null;
            ctrl.entryColor = null;
            ctrl.entryCount = 0;
            ctrl.lastResult = null;
            ctrl.lastEntryTimestamp = null;
        }
    }
}

function markLastSignalResolved(simState, newSpin, hit) {
    const signals = simState?.signalsHistory?.signals;
    if (!Array.isArray(signals) || signals.length === 0) return;
    const lastSignal = signals[signals.length - 1];
    if (!lastSignal || lastSignal.verified) return;
    lastSignal.colorThatCame = newSpin?.color || null;
    lastSignal.hit = !!hit;
    lastSignal.verified = true;
    updateAlternanceControlAfterSignal(simState, !!hit);
}

function evaluatePendingAnalysisSimulation(latestSpin, simState, history, modeKey = 'diamond') {
    const config = simState.config || {};
    const currentAnalysis = simState.analysis;
    if (!currentAnalysis || !currentAnalysis.createdOnTimestamp || currentAnalysis.predictedFor !== 'next') {
        return;
    }
    if (currentAnalysis.createdOnTimestamp === latestSpin.timestamp) {
        return;
    }

    const normalizeSimpleColor = (value) => {
        const s = String(value || '').toLowerCase().trim();
        if (!s) return '';
        if (s.startsWith('r')) return 'red';
        if (s.startsWith('b') && s !== 'branco') return 'black';
        if (s.startsWith('w') || s === 'branco') return 'white';
        return s;
    };
    const expectedColor = normalizeSimpleColor(currentAnalysis.color);
    const actualColor = normalizeSimpleColor(latestSpin.color);

    // âœ… ProteÃ§Ã£o no branco: se ativada, WHITE conta como WIN (ciclo nÃ£o Ã© perdido).
    const whiteProtectedHit = !!config.whiteProtectionAsWin
        && actualColor === 'white'
        && (expectedColor === 'red' || expectedColor === 'black');
    const hit = (expectedColor === actualColor) || whiteProtectedHit;

    // Atualizar signalsHistory (N7) + alternance control
    markLastSignalResolved(simState, latestSpin, hit);

    const martingale = simState.martingaleState;
    const entryColorForSettings = (martingale && martingale.active) ? martingale.entryColor : (currentAnalysis && currentAnalysis.color);
    const { maxGales, consecutiveGales } = getMartingaleSettingsForEntryColor(entryColorForSettings, modeKey, config);

    const historyRef = Array.isArray(history) ? history : [];
    // âœ… Snapshot correto (corrige modal do sinal): usar os giros REAIS do momento em que o ciclo foi resolvido.
    // Isso evita "WIN/LOSS em cima do nÃºmero errado" quando a entrada fecha em G1/G2.
    const snapshotSpins = (limit = 14) => {
        try {
            const safeLimit = Math.max(1, Math.min(40, Math.floor(Number(limit) || 14)));
            return historyRef.slice(0, safeLimit).map((spin) => ({
                color: spin?.color,
                number: spin?.number,
                timestamp: spin?.timestamp
            }));
        } catch (_) {
            return [];
        }
    };
    const last14SpinsSnapshot = snapshotSpins(14);
    const last10SpinsSnapshot = last14SpinsSnapshot.slice(0, 10);
    const last5SpinsSnapshot = last14SpinsSnapshot.slice(0, 5);
    const shouldUseN4DynamicGales = (() => {
        try {
            // âœ… SÃ³ aplicar quando estiver "sÃ³ N4" (evita mudar comportamento do consenso multi-nÃ­veis).
            const enabledIds = DIAMOND_LEVEL_IDS.filter(id => isDiamondLevelEnabled(id, config));
            const voteIds = enabledIds.filter(id => id !== 'N9');
            return voteIds.length === 1 && voteIds[0] === 'N4';
        } catch (_) {
            return false;
        }
    })();

    const pickN4GaleColor = (stageNumber) => {
        if (!shouldUseN4DynamicGales) return null;
        // âšª Branco: NÃƒO mudar cor em gales â€” respeitar configuraÃ§Ã£o exclusiva do Branco.
        const cycleEntryColor = (martingale && martingale.active) ? martingale.entryColor : (currentAnalysis && currentAnalysis.color);
        if (normalizeSimpleBetColor(cycleEntryColor) === 'white') return null;
        try {
            const n4Window = getDiamondWindowFromConfig(config, 'n4Persistence', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence);
            const overallMax = Math.max(0, Math.floor(Number(maxGales) || 0));
            // remaining: quantos gales ainda existem depois do stage atual (0=>sÃ³ Entrada, 1=>Entrada+G1, 2=>Entrada+G1+G2)
            const remaining = Math.max(0, Math.min(2, overallMax - Math.max(0, Math.floor(stageNumber))));
            const n4 = analyzeAutointeligente(historyRef, {
                historySize: n4Window,
                maxGales: remaining,
                signalIntensity: config.signalIntensity || 'aggressive',
                whiteProtectionAsWin: !!config.whiteProtectionAsWin,
                dynamicGales: true,
                forcePick: true
            });
            return n4 && n4.color ? n4.color : null;
        } catch (_) {
            return null;
        }
    };

    if (hit) {
        let martingaleStage = 'ENTRADA';
        if (currentAnalysis.phase === 'G1') martingaleStage = 'G1';
        else if (currentAnalysis.phase === 'G2') martingaleStage = 'G2';
        else if (martingale.active) martingaleStage = martingale.stage;

        const winEntry = {
            timestamp: latestSpin.timestamp,
            number: latestSpin.number,
            color: latestSpin.color,
            phase: currentAnalysis.phase || 'G0',
            result: 'WIN',
            confidence: currentAnalysis.confidence,
            patternData: {
                patternDescription: currentAnalysis.patternDescription,
                confidence: currentAnalysis.confidence,
                color: currentAnalysis.color,
                createdOnTimestamp: currentAnalysis.createdOnTimestamp,
                // âœ… snapshot atualizado no momento do WIN (inclui o giro que resolveu)
                last14Spins: last14SpinsSnapshot,
                last10Spins: last10SpinsSnapshot,
                last5Spins: last5SpinsSnapshot
            },
            martingaleStage,
            wonAt: martingaleStage,
            finalResult: 'WIN',
            analysisMode: modeKey,
            isMaster: !!(currentAnalysis && currentAnalysis.masterSignal && currentAnalysis.masterSignal.active),
            simulation: true
        };
        simState.entriesHistory.unshift(winEntry);
        // âœ… Marcar fim do ciclo (para intervalo apÃ³s entrada)
        simState.lastCycleResolvedSpinId = latestSpin?.id ?? null;
        simState.lastCycleResolvedSpinTimestamp = latestSpin?.timestamp ?? null;

        // Reset ciclo
        if (martingale.active) {
            simState.martingaleState = {
                ...simState.martingaleState,
                active: false,
                stage: 'ENTRADA',
                patternKey: null,
                entryColor: null,
                entryColorResult: null,
                entryTimestamp: null,
                analysisData: null,
                lossCount: 0,
                lossColors: []
            };
        }
        simState.analysis = null;
        return;
    }

    // LOSS
    const currentStage = martingale.active ? martingale.stage : 'ENTRADA';
    let currentGaleNumber = 0;
    if (currentStage === 'ENTRADA') currentGaleNumber = 0;
    else if (currentStage.startsWith('G')) currentGaleNumber = parseInt(currentStage.substring(1)) || 0;
    const nextGaleNumber = currentGaleNumber + 1;
    const canTryNextGale = nextGaleNumber <= maxGales;

    if (currentStage === 'ENTRADA') {
        if (!canTryNextGale) {
            const lossEntry = {
                timestamp: latestSpin.timestamp,
                number: latestSpin.number,
                color: latestSpin.color,
                phase: 'G0',
                result: 'LOSS',
                confidence: currentAnalysis.confidence,
                patternData: {
                    patternDescription: currentAnalysis.patternDescription,
                    confidence: currentAnalysis.confidence,
                    color: currentAnalysis.color,
                    createdOnTimestamp: currentAnalysis.createdOnTimestamp,
                    // âœ… snapshot atualizado no momento do LOSS final (RED)
                    last14Spins: last14SpinsSnapshot,
                    last10Spins: last10SpinsSnapshot,
                    last5Spins: last5SpinsSnapshot
                },
                martingaleStage: 'ENTRADA',
                finalResult: 'RED',
                analysisMode: modeKey,
                isMaster: !!(currentAnalysis && currentAnalysis.masterSignal && currentAnalysis.masterSignal.active),
                simulation: true
            };
            simState.entriesHistory.unshift(lossEntry);
            // âœ… Marcar fim do ciclo (RED)
            simState.lastCycleResolvedSpinId = latestSpin?.id ?? null;
            simState.lastCycleResolvedSpinTimestamp = latestSpin?.timestamp ?? null;
            simState.martingaleState = {
                ...simState.martingaleState,
                active: false,
                stage: 'ENTRADA',
                patternKey: null,
                entryColor: null,
                currentColor: null,
                entryColorResult: null,
                entryTimestamp: null,
                analysisData: null,
                lossCount: 0,
                lossColors: []
            };
            simState.analysis = null;
            return;
        }

        // Registrar LOSS da entrada e ativar ciclo
        const entradaLossEntry = {
            timestamp: latestSpin.timestamp,
            number: latestSpin.number,
            color: latestSpin.color,
            phase: 'G0',
            result: 'LOSS',
            confidence: currentAnalysis.confidence,
            patternData: {
                patternDescription: currentAnalysis.patternDescription,
                confidence: currentAnalysis.confidence,
                color: currentAnalysis.color,
                createdOnTimestamp: currentAnalysis.createdOnTimestamp,
                // âœ… snapshot atualizado (ENTRADA falhou e vai para G1)
                last14Spins: last14SpinsSnapshot,
                last10Spins: last10SpinsSnapshot,
                last5Spins: last5SpinsSnapshot
            },
            martingaleStage: 'ENTRADA',
            finalResult: null,
            continuingToG1: true,
            analysisMode: modeKey,
            isMaster: !!(currentAnalysis && currentAnalysis.masterSignal && currentAnalysis.masterSignal.active),
            simulation: true
        };
        simState.entriesHistory.unshift(entradaLossEntry);

        const patternKey = martingale.active ? martingale.patternKey : createPatternKey(currentAnalysis);
        const g1Color = shouldUseN4DynamicGales ? (pickN4GaleColor(1) || currentAnalysis.color) : currentAnalysis.color;
        simState.martingaleState = {
            ...simState.martingaleState,
            active: true,
            stage: 'G1',
            patternKey,
            entryColor: currentAnalysis.color,
            currentColor: g1Color,
            entryColorResult: latestSpin.color,
            entryTimestamp: currentAnalysis.createdOnTimestamp,
            analysisData: currentAnalysis,
            lossCount: 1,
            lossColors: [latestSpin.color]
        };

        // âœ… SÃ³ auto-gera o prÃ³ximo gale se ele estiver dentro do "consecutivo atÃ©"
        if (nextGaleNumber <= consecutiveGales) {
            const g1Analysis = {
                ...currentAnalysis,
                color: g1Color,
                phase: 'G1',
                predictedFor: 'next',
                createdOnTimestamp: latestSpin.timestamp
            };
            g1Analysis.confidence = calculateGaleConfidenceValue(g1Analysis.confidence, g1Analysis, simState.martingaleState);
            simState.analysis = g1Analysis;
        } else {
            simState.analysis = null;
        }
        return;
    }

    // LOSS em um GALE
    if (currentStage.startsWith('G')) {
        if (!canTryNextGale) {
            const retEntry = {
                timestamp: latestSpin.timestamp,
                number: latestSpin.number,
                color: latestSpin.color,
                phase: currentStage,
                result: 'LOSS',
                confidence: currentAnalysis.confidence,
                patternData: {
                    patternDescription: currentAnalysis.patternDescription,
                    confidence: currentAnalysis.confidence,
                    color: currentAnalysis.color,
                    createdOnTimestamp: currentAnalysis.createdOnTimestamp,
                    // âœ… snapshot atualizado no momento do LOSS final (RET/RED)
                    last14Spins: last14SpinsSnapshot,
                    last10Spins: last10SpinsSnapshot,
                    last5Spins: last5SpinsSnapshot
                },
                martingaleStage: currentStage,
                finalResult: 'RED',
                    analysisMode: modeKey,
                isMaster: !!(currentAnalysis && currentAnalysis.masterSignal && currentAnalysis.masterSignal.active),
                simulation: true
            };
            simState.entriesHistory.unshift(retEntry);
            // âœ… Marcar fim do ciclo (RED)
            simState.lastCycleResolvedSpinId = latestSpin?.id ?? null;
            simState.lastCycleResolvedSpinTimestamp = latestSpin?.timestamp ?? null;
            simState.martingaleState = {
                ...simState.martingaleState,
                active: false,
                stage: 'ENTRADA',
                patternKey: null,
                entryColor: null,
                entryColorResult: null,
                entryTimestamp: null,
                analysisData: null,
                lossCount: 0,
                lossColors: []
            };
            simState.analysis = null;
            return;
        }

        const nextStage = `G${nextGaleNumber}`;
        const lossEntry = {
            timestamp: latestSpin.timestamp,
            number: latestSpin.number,
            color: latestSpin.color,
            phase: currentStage,
            result: 'LOSS',
            confidence: currentAnalysis.confidence,
            patternData: {
                patternDescription: currentAnalysis.patternDescription,
                confidence: currentAnalysis.confidence,
                color: currentAnalysis.color,
                createdOnTimestamp: currentAnalysis.createdOnTimestamp,
                // âœ… snapshot atualizado (GALE falhou e vai para prÃ³ximo GALE)
                last14Spins: last14SpinsSnapshot,
                last10Spins: last10SpinsSnapshot,
                last5Spins: last5SpinsSnapshot
            },
            martingaleStage: currentStage,
            finalResult: null,
            [`continuingTo${nextStage}`]: true,
            analysisMode: modeKey,
            isMaster: !!(currentAnalysis && currentAnalysis.masterSignal && currentAnalysis.masterSignal.active),
            simulation: true
        };
        simState.entriesHistory.unshift(lossEntry);

        const nextColor = shouldUseN4DynamicGales
            ? (pickN4GaleColor(nextGaleNumber) || simState.martingaleState.currentColor || simState.martingaleState.entryColor || currentAnalysis.color)
            : (simState.martingaleState.entryColor || currentAnalysis.color);

        simState.martingaleState = {
            ...simState.martingaleState,
            active: true,
            stage: nextStage,
            currentColor: nextColor,
            lossCount: nextGaleNumber,
            lossColors: [...(simState.martingaleState.lossColors || []), latestSpin.color]
        };

        if (nextGaleNumber <= consecutiveGales) {
            const nextAnalysis = {
                ...currentAnalysis,
                color: nextColor,
                phase: nextStage,
                predictedFor: 'next',
                createdOnTimestamp: latestSpin.timestamp
            };
            nextAnalysis.confidence = calculateGaleConfidenceValue(nextAnalysis.confidence, nextAnalysis, simState.martingaleState);
            simState.analysis = nextAnalysis;
        } else {
            simState.analysis = null;
        }
    }
}

function analyzeDiamondLevelsSimulation(history, config, simState) {
    const totalDiamondLevels = DIAMOND_LEVEL_IDS.length;
    const diamondLevelEnabledMap = {};
    DIAMOND_LEVEL_IDS.forEach(id => {
        diamondLevelEnabledMap[id] = isDiamondLevelEnabled(id, config);
    });
    const isLevelEnabledLocal = (id) => !!diamondLevelEnabledMap[id];
    const activeDiamondLevels = DIAMOND_LEVEL_IDS.filter(id => diamondLevelEnabledMap[id]);

    if (activeDiamondLevels.length === 0) {
        return null;
    }

    const { blocked: intervalBlocked } = computeIntervalBlockForSimulation(history, config, simState);

    const configuredSize = Math.min(Math.max(config.aiHistorySize || 60, 60), 2000);
    const historySize = Math.min(configuredSize, history.length);

    const lastSpinTimestamp = history[0]?.timestamp || Date.now();
    const lastSpinPosition = history[0]?.timestamp ? identifySpinPosition(lastSpinTimestamp) : 1;
    const nextSpinPosition = lastSpinPosition === 1 ? 2 : 1;
    const lastSpinDate = new Date(lastSpinTimestamp);
    const nextSpinDate = new Date(lastSpinDate);
    if (lastSpinPosition === 2) {
        nextSpinDate.setMinutes(nextSpinDate.getMinutes() + 1);
    }
    const targetMinute = nextSpinDate.getMinutes();

    const clamp01Local = (value) => Math.max(0, Math.min(1, typeof value === 'number' ? value : 0));
    const directionValue = (color) => color === 'red' ? 1 : color === 'black' ? -1 : 0;

    // Pesos e meta (igual ao modo real)
    const levelWeights = {
        whiteDetector: 0,
        patterns: 0.19,
        momentum: 0.15,
        alternance: 0.13,
        persistence: 0.11,
        minuteSpin: 0.095,
        retracement: 0.085,
        globalContinuity: 0.11,
        barrier: 0.05,
        bayesianCalibration: 0.08,
        walkForward: 0.12
    };

    const levelReports = [];

    // N0
    const n0Enabled = isLevelEnabledLocal('N0');
    const n0Settings = getN0SettingsFromConfig(config);
    // âœ… SimulaÃ§Ã£o deve seguir GALES DO BRANCO (config exclusiva), igual ao modo real.
    const { maxGales: n0MaxGalesConfigured } = getMartingaleSettingsForEntryColor('white', 'diamond', config);
    const n0LookaheadSpins = Math.max(1, Math.min(6, (Math.floor(Number(n0MaxGalesConfigured) || 0) + 1)));
    const n0Options = {
        historySize: n0Settings.historySize,
        windowSize: n0Settings.windowSize,
        lookaheadSpins: n0LookaheadSpins,
        // âœ… Backtest deve ser rÃ¡pido: histÃ³rico jÃ¡ Ã© estÃ¡vel (ordenado/Ãºnico) e nÃ£o precisa de logs.
        assumeStableHistory: true,
        silent: true,
        cache: true,
        cacheMaxAgeSpins: Math.max(20, Math.min(60, n0Settings.windowSize)),
        analysesToRun: N0_DEFAULTS.analysesToRun,
        minWindowsRequired: N0_DEFAULTS.minWindowsRequired,
        precisionMin: N0_DEFAULTS.precisionMin,
        confidenceGrid: N0_DEFAULTS.confidenceGrid,
        holdoutEnabled: N0_DEFAULTS.holdoutEnabled,
        holdoutTolerance: N0_DEFAULTS.holdoutTolerance,
        seed: N0_DEFAULTS.seed
    };

    let n0Result = null;
    let n0EffectiveAction = 'no_block';
    let n0ForceWhite = false;
    let n0SoftBlockActive = false;
    let n0WhiteStrength = 0;
    let n0ActionSuppressed = false;
    // âœ… Gate/observadores no simulador (alinha com o modo real, sem mexer no budget global)
    let n0UiVoteWhite = false;
    let n0EffectiveConfidence = null; // 0..1
    let n0ObsShort = null;
    let n0GateReason = null;

    if (n0Enabled) {
        try {
            n0Result = runN0Detector(history, n0Options);
            if (n0Result && n0Result.enabled) {
                const actionRequested = n0Result.blocking_action || 'no_block';
                const blockAllAllowed = n0Settings.allowBlockAll;
                n0WhiteStrength = clamp01Local(n0Result.white_confidence || 0);
                n0EffectiveAction = actionRequested;
                if (actionRequested === 'block_all' && !blockAllAllowed) {
                    n0EffectiveAction = 'no_block';
                    n0ActionSuppressed = true;
                }
                n0ForceWhite = n0EffectiveAction === 'block_all' && n0Result.pred_live === 'W';
                n0SoftBlockActive = n0EffectiveAction === 'soft_block' && n0Result.pred_live === 'W';
            }
        } catch (_) {
            n0Result = { enabled: false, reason: 'Erro interno' };
        }
    }

    // âœ… Gate por observadores (simulaÃ§Ã£o): saturaÃ§Ã£o/confirm. mÃ­nimas/limiar soft
    try {
        if (n0Enabled && n0Result && n0Result.enabled !== false && n0Result.pred_live === 'W') {
            const nowMs = Number.isFinite(parseSpinTimestamp(history && history[0])) ? parseSpinTimestamp(history[0]) : Date.now();
            const pack = computeN0ObserverPackage({ history, nowMs, n0Result, lookaheadSpins: n0LookaheadSpins });
            n0ObsShort = pack && typeof pack.short === 'string' ? pack.short : null;
            const hour = pack && pack.hourStats ? pack.hourStats : null;
            const saturated = !!(hour && hour.saturated);
            const needFill = !!(hour && hour.needFill);
            const strong = pack && Number.isFinite(Number(pack.strongCount)) ? Number(pack.strongCount) : 0;

            const softThreshold = (() => {
                const t = (n0Result && typeof n0Result.blocking_threshold === 'number')
                    ? clamp01Local(n0Result.blocking_threshold)
                    : null;
                const base = (t == null) ? 0.5 : t;
                return clamp01Local(base * 0.8);
            })();

            const boost = (() => {
                let b = 0;
                if (hour && hour.needFill) b += 0.06;
                if (hour && hour.burst) b += 0.04;
                const extra = Math.max(0, strong - 2);
                b += Math.min(0.08, extra * 0.03);
                return b;
            })();
            n0EffectiveConfidence = clamp01Local(n0WhiteStrength + boost);

            const reqAlert = needFill ? 1 : N0_OBS_CONFIRM_MIN_DEFAULT;
            const reqBlock = needFill ? Math.max(1, N0_OBS_CONFIRM_MIN_STRONG - 1) : N0_OBS_CONFIRM_MIN_STRONG;
            const baseOk = !saturated && strong >= reqAlert;
            const softOk = (n0EffectiveConfidence >= softThreshold) || needFill;
            const alertOk = baseOk && softOk;
            const blockOk = (!saturated && strong >= reqBlock) && softOk;

            n0UiVoteWhite = alertOk;
            if (n0ForceWhite) {
                n0ForceWhite = !!blockOk;
            }
            if (!n0UiVoteWhite) {
                n0SoftBlockActive = false;
            }
            n0GateReason = saturated ? 'hour_saturated' : (!baseOk ? 'insufficient_confirmations' : (!softOk ? 'below_soft_threshold' : 'ok'));
        }
    } catch (_) {
        // silencioso no simulador
    }

    levelReports.push({
        id: 'N0',
        name: 'Detector de Branco',
        color: n0UiVoteWhite ? 'white' : null,
        weight: n0Enabled ? levelWeights.whiteDetector : 0,
        strength: (typeof n0EffectiveConfidence === 'number' && Number.isFinite(n0EffectiveConfidence)) ? n0EffectiveConfidence : n0WhiteStrength,
        score: 0,
        details: !n0Enabled
            ? 'DESATIVADO'
            : (n0ForceWhite
                ? 'BLOCK ALL'
                : (n0UiVoteWhite
                    ? (n0SoftBlockActive ? 'SOFT BLOCK' : (n0ActionSuppressed ? 'ALERTA (info)' : 'ALERTA'))
                    : ((n0Result && n0Result.pred_live === 'W') ? `EVITAR (${n0GateReason || 'gate'})` : 'NULO')
                )
            ) + (n0ObsShort ? ` â€¢ ${n0ObsShort}` : ''),
        disabled: !n0Enabled
    });

    const n0WeightModifier = (n0Enabled && n0SoftBlockActive) ? N0_DEFAULTS.softBlockFactor : 1;
    const weightFor = (baseWeight) => baseWeight * n0WeightModifier;

    // N1 - Zona Segura
    let safeZoneVote = null;
    let safeZoneMeta = null;
    let patternDescription = 'AnÃ¡lise NÃ­vel Diamante - SimulaÃ§Ã£o';

    const n1Enabled = isLevelEnabledLocal('N1');
    if (n1Enabled) {
        const safeZoneSettings = getSafeZoneSettingsFromConfig(config);
        safeZoneMeta = analyzeSafeZone(history, safeZoneSettings);
        safeZoneMeta.maxEntries = safeZoneSettings.maxEntries;
        safeZoneMeta.entriesUsed = simState.safeZoneEntryState.entriesUsed || 0;

        if (!safeZoneMeta.zoneActive) {
            simState.safeZoneEntryState = { signature: null, entriesUsed: 0 };
        } else {
            if (safeZoneMeta.signal) {
                const signature = buildSafeZoneSignature(safeZoneMeta);
                if (simState.safeZoneEntryState.signature !== signature) {
                    simState.safeZoneEntryState = { signature, entriesUsed: 0 };
                }
                safeZoneMeta.entriesUsed = simState.safeZoneEntryState.entriesUsed;
                if (simState.safeZoneEntryState.entriesUsed >= safeZoneSettings.maxEntries) {
                    safeZoneMeta.signal = false;
                    safeZoneMeta.reason = 'entry_limit_reached';
                }
            }
        }

        if (safeZoneMeta.zoneActive && safeZoneMeta.signal && safeZoneMeta.dominant) {
            safeZoneVote = {
                color: safeZoneMeta.dominant,
                source: 'safe-zone',
                confidence: safeZoneMeta.strength,
                detail: safeZoneMeta
            };
            const signature = buildSafeZoneSignature(safeZoneMeta);
            simState.safeZoneEntryState = {
                signature,
                entriesUsed: Math.min(safeZoneSettings.maxEntries, (simState.safeZoneEntryState.signature === signature ? simState.safeZoneEntryState.entriesUsed : 0) + 1)
            };
            safeZoneMeta.entriesUsed = simState.safeZoneEntryState.entriesUsed;
            safeZoneMeta.reason = 'zone_active_last_is_dominant';
            patternDescription = JSON.stringify({
                type: 'safe_zone',
                dominant: safeZoneMeta.dominant,
                secondary: safeZoneMeta.secondary,
                counts: safeZoneMeta.counts,
                windowSize: safeZoneMeta.windowSize,
                minPrimary: safeZoneMeta.minPrimary,
                minSecondary: safeZoneMeta.minSecondary,
                lastColor: safeZoneMeta.lastColor,
                status: safeZoneMeta.reason,
                entriesUsed: safeZoneMeta.entriesUsed,
                maxEntries: safeZoneSettings.maxEntries
            });
        }
    }

    let patternStrength = 0;
    let patternColor = null;
    let patternDetailsText = n1Enabled ? 'NULO' : 'DESATIVADO';
    if (n1Enabled && safeZoneMeta) {
        if (safeZoneMeta.zoneActive && safeZoneMeta.signal && safeZoneVote && safeZoneVote.color) {
            patternColor = safeZoneVote.color;
            patternStrength = clamp01Local(safeZoneVote.confidence ?? safeZoneMeta.strength ?? 0.5);
            const entriesInfo = safeZoneMeta.maxEntries
                ? `${safeZoneMeta.entriesUsed}/${safeZoneMeta.maxEntries}`
                : `${safeZoneMeta.entriesUsed || 0}`;
            const dominantLabel = safeZoneMeta.dominant
                ? `${safeZoneMeta.dominant.toUpperCase()} ${safeZoneMeta.counts[safeZoneMeta.dominant]}/${safeZoneMeta.windowSize}`
                : 'Zona ativa';
            patternDetailsText = `DominÃ¢ncia ${dominantLabel} â€¢ entradas ${entriesInfo}`;
        }
    }

    levelReports.push({
        id: 'N1',
        name: 'Zona Segura',
        color: patternColor,
        weight: n1Enabled ? weightFor(levelWeights.patterns) : 0,
        strength: patternStrength,
        score: patternColor ? directionValue(patternColor) * patternStrength : 0,
        details: patternDetailsText,
        disabled: !n1Enabled,
        meta: safeZoneMeta
    });

    // N2 - Ritmo AutÃ´nomo
    const n2Enabled = isLevelEnabledLocal('N2');
    const nivel5 = n2Enabled ? analyzeMomentumFromConfig(history, config) : null;
    const momentumColor = n2Enabled && nivel5 ? nivel5.color : null;
    const redMomentum = Number(nivel5?.momentum?.red ?? 0);
    const blackMomentum = Number(nivel5?.momentum?.black ?? 0);
    const diffMomentum = (isFinite(redMomentum) && isFinite(blackMomentum)) ? Math.abs(redMomentum - blackMomentum) : 0;
    // âœ… ForÃ§a deve refletir significÃ¢ncia (confidence do N2)
    let momentumStrength = (n2Enabled && momentumColor && typeof nivel5?.confidence === 'number')
        ? clamp01Local(nivel5.confidence)
        : 0;
    levelReports.push({
        id: 'N2',
        name: 'Ritmo AutÃ´nomo',
        color: momentumColor,
        weight: n2Enabled ? weightFor(levelWeights.momentum) : 0,
        strength: n2Enabled ? momentumStrength : 0,
        score: n2Enabled && momentumColor ? directionValue(momentumColor) * momentumStrength : 0,
        details: !n2Enabled
            ? 'DESATIVADO'
            : (nivel5 && nivel5.details ? nivel5.details : `Î” ${diffMomentum.toFixed(1)} pp (P2+)`),
        disabled: !n2Enabled
    });

    // N3 - AlternÃ¢ncia
    const n3Enabled = isLevelEnabledLocal('N3');
    const n3HistoryWindow = Math.max(4, getDiamondWindowFromConfig(config, 'n3Alternance', historySize));
    const n3BaseThresholdPctConfigured = Math.max(50, Math.min(95, getDiamondWindowFromConfig(config, 'n3BaseThresholdPct', 60)));
    const n3MinOccurrencesConfigured = Math.max(1, Math.min(500, getDiamondWindowFromConfig(config, 'n3MinOccurrences', 3)));
    const n3AllowBackoffConfigured = getDiamondBooleanFromConfig(config, 'n3AllowBackoff', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n3AllowBackoff);
    const n3IgnoreWhiteConfigured = getDiamondBooleanFromConfig(config, 'n3IgnoreWhite', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n3IgnoreWhite);

    const nivel7 = n3Enabled ? analyzeAlternancePattern(history, {
        historySize: n3HistoryWindow,
        baseThreshold: n3BaseThresholdPctConfigured / 100,
        minOccurrences: n3MinOccurrencesConfigured,
        allowBackoff: n3AllowBackoffConfigured,
        ignoreWhite: n3IgnoreWhiteConfigured
    }) : null;

    const alternanceColor = n3Enabled && nivel7 && nivel7.color ? nivel7.color : null;
    const alternanceOverrideActive = n3Enabled && Boolean(nivel7 && nivel7.override && alternanceColor);
    let alternanceStrength = 0;
    if (n3Enabled && alternanceColor) {
        const baseConfidence = typeof nivel7.confidence === 'number' ? nivel7.confidence : (nivel7.probability || 0);
        alternanceStrength = alternanceOverrideActive ? 1 : clamp01Local(baseConfidence);
    }

    levelReports.push({
        id: 'N3',
        name: 'AlternÃ¢ncia',
        color: alternanceColor,
        weight: n3Enabled ? weightFor(levelWeights.alternance) : 0,
        strength: n3Enabled ? alternanceStrength : 0,
        score: n3Enabled && alternanceColor ? directionValue(alternanceColor) * alternanceStrength : 0,
        details: n3Enabled ? (nivel7 && nivel7.details ? nivel7.details : 'NULO') : 'DESATIVADO',
        override: alternanceOverrideActive,
        disabled: !n3Enabled
    });

    // N4 - Autointeligente
    const n4Enabled = isLevelEnabledLocal('N4');
    const { maxGales: n4MaxGalesConfigured } = getMartingaleSettings('diamond', config);
    const n4HistoryWindow = getDiamondWindowFromConfig(config, 'n4Persistence', DEFAULT_ANALYZER_CONFIG.diamondLevelWindows.n4Persistence);
    const nivel9 = n4Enabled ? analyzeAutointeligente(history, {
        historySize: n4HistoryWindow,
        maxGales: n4MaxGalesConfigured,
        signalIntensity: config.signalIntensity || 'aggressive',
        whiteProtectionAsWin: !!config.whiteProtectionAsWin,
        dynamicGales: shouldUseN4DynamicGalesForConfig(config),
        // âœ… Mesma leitura do modo real (filtro/boost por performance recente do tipo)
        n4SelfLearning: (signalsHistory && signalsHistory.n4SelfLearning) ? signalsHistory.n4SelfLearning : null
    }) : null;
    const autoColor = n4Enabled && nivel9 && nivel9.color ? nivel9.color : null;
    const autoStrength = n4Enabled && nivel9 && nivel9.color ? clamp01Local(nivel9.confidence ?? 0) : 0;
    const autoDetails = n4Enabled
        ? (nivel9 && nivel9.details ? nivel9.details : 'NULO')
        : 'DESATIVADO';
    levelReports.push({
        id: 'N4',
        name: 'Autointeligente',
        color: autoColor,
        weight: n4Enabled ? weightFor(levelWeights.persistence) : 0,
        strength: n4Enabled ? autoStrength : 0,
        score: n4Enabled && autoColor ? directionValue(autoColor) * autoStrength : 0,
        details: autoDetails,
        disabled: !n4Enabled
    });

    // N5 - Ritmo por giro
    const n5Enabled = isLevelEnabledLocal('N5');
    const minuteSpinWindow = Math.max(10, Math.min(200, getDiamondWindowFromConfig(config, 'n5MinuteBias', 60)));
    const minuteBiasResult = n5Enabled ? analyzeMinuteSpinBias(history, targetMinute, nextSpinPosition, minuteSpinWindow) : null;
    const minuteBiasColor = n5Enabled && minuteBiasResult && minuteBiasResult.color ? minuteBiasResult.color : null;
    const minuteBiasStrength = clamp01Local(minuteBiasResult ? minuteBiasResult.confidence : 0);
    levelReports.push({
        id: 'N5',
        name: 'Ritmo por Giro',
        color: minuteBiasColor,
        weight: n5Enabled ? weightFor(levelWeights.minuteSpin) : 0,
        strength: n5Enabled ? minuteBiasStrength : 0,
        score: n5Enabled && minuteBiasColor ? directionValue(minuteBiasColor) * minuteBiasStrength : 0,
        details: n5Enabled ? (minuteBiasResult ? minuteBiasResult.details : 'NULO') : 'DESATIVADO',
        disabled: !n5Enabled
    });

    // N6 - RetraÃ§Ã£o HistÃ³rica
    const n6Enabled = isLevelEnabledLocal('N6');
    const retracementWindow = Math.max(30, Math.min(120, getDiamondWindowFromConfig(config, 'n6RetracementWindow', 80)));
    const retracementResult = n6Enabled ? analyzeHistoricalRetracement(history, retracementWindow, config.signalIntensity || 'aggressive') : null;
    levelReports.push({
        id: 'N6',
        name: 'RetraÃ§Ã£o HistÃ³rica',
        color: n6Enabled ? retracementResult.color : null,
        weight: n6Enabled ? weightFor(levelWeights.retracement) : 0,
        strength: n6Enabled ? (retracementResult.strength || 0) : 0,
        score: n6Enabled && retracementResult.color ? directionValue(retracementResult.color) * (retracementResult.strength || 0) : 0,
        details: n6Enabled ? retracementResult.details : 'DESATIVADO',
        disabled: !n6Enabled
    });

    // N7 - Continuidade global
    const n7Enabled = isLevelEnabledLocal('N7');
    const decisionWindowConfigured = Math.max(10, Math.min(50, getDiamondWindowFromConfig(config, 'n7DecisionWindow', 20)));
    const historyWindowConfigured = Math.max(decisionWindowConfigured, Math.min(200, getDiamondWindowFromConfig(config, 'n7HistoryWindow', 100)));
    const continuityResult = n7Enabled ? analyzeGlobalContinuity(simState.signalsHistory, decisionWindowConfigured, historyWindowConfigured, config.signalIntensity || 'aggressive') : null;
    levelReports.push({
        id: 'N7',
        name: 'Continuidade Global',
        color: n7Enabled ? continuityResult.color : null,
        weight: n7Enabled ? weightFor(levelWeights.globalContinuity) : 0,
        strength: n7Enabled ? (continuityResult.strength || 0) : 0,
        score: n7Enabled && continuityResult.color ? directionValue(continuityResult.color) * (continuityResult.strength || 0) : 0,
        details: n7Enabled ? continuityResult.details : 'DESATIVADO',
        disabled: !n7Enabled
    });

    // N8 - Walk-forward (id N8)
    const n8Enabled = isLevelEnabledLocal('N8');
    if (n8Enabled) {
        try {
            const windowsCfg = config.diamondLevelWindows || {};
            const n8WindowCfg = getDiamondWindowFromConfig(config, 'n10Window', N8_DEFAULTS.windowSize);
            const n8HistoryCfg = Number(windowsCfg.n10History) > 0 ? Number(windowsCfg.n10History) : N8_DEFAULTS.historySize;
            const n8AnalysesCfg = Number(windowsCfg.n10Analyses) > 0 ? Number(windowsCfg.n10Analyses) : N8_DEFAULTS.analysesToRun;
            const n8MinWindowsCfg = Number(windowsCfg.n10MinWindows) > 0 ? Number(windowsCfg.n10MinWindows) : N8_DEFAULTS.minWindowsRequired;
            const n8ConfMinPctCfg = Number(windowsCfg.n10ConfMin) > 0 ? Number(windowsCfg.n10ConfMin) : N8_DEFAULTS.confMinLive * 100;
            const n8ConfMinCfg = Math.max(0, Math.min(1, n8ConfMinPctCfg / 100));

            const n8Result = runN8Detector(history, {
                windowSize: n8WindowCfg,
                historySize: n8HistoryCfg,
                analysesToRun: n8AnalysesCfg,
                minWindows: n8MinWindowsCfg,
                confMinLive: n8ConfMinCfg,
                // âœ… Backtest deve ser rÃ¡pido e fiel: histÃ³rico da simulaÃ§Ã£o jÃ¡ Ã© estÃ¡vel
                assumeStableHistory: true,
                silent: true,
                cache: true,
                cacheMaxAgeSpins: Math.max(20, Math.min(60, n8WindowCfg))
            });

            if (n8Result && n8Result.enabled && n8Result.color) {
                const n8Color = n8Result.color;
                const n8Strength = clamp01Local(n8Result.confidence || 0);
                levelReports.push({
                    id: 'N8',
                    name: 'Walk-forward',
                    color: n8Color,
                    weight: weightFor(levelWeights.walkForward),
                    strength: n8Strength,
                    score: directionValue(n8Color) * n8Strength,
                    details: n8Result.summaryText || 'Walk-forward diversificado',
                    disabled: false
                });
            } else {
                levelReports.push({
                    id: 'N8',
                    name: 'Walk-forward',
                    color: null,
                    weight: weightFor(levelWeights.walkForward),
                    strength: 0,
                    score: 0,
                    details: n8Result && n8Result.summaryText ? n8Result.summaryText : 'NULO',
                    disabled: false
                });
            }
        } catch (_) {
            levelReports.push({
                id: 'N8',
                name: 'Walk-forward',
                color: null,
                weight: weightFor(levelWeights.walkForward),
                strength: 0,
                score: 0,
                details: 'Erro interno em N8',
                disabled: false
            });
        }
    } else {
        levelReports.push({
            id: 'N8',
            name: 'Walk-forward',
            color: null,
            weight: 0,
            strength: 0,
            score: 0,
            details: 'DESATIVADO',
            disabled: true
        });
    }

    // N10 - CalibraÃ§Ã£o Bayesiana (id N10) - sÃ³ calibra
    const n10Enabled = isLevelEnabledLocal('N10');
    let bayesResult = null;
    if (n10Enabled) {
        const bayesHistoryConfigured = Math.max(30, Math.min(400, getDiamondWindowFromConfig(config, 'n9History', 100)));
        const bayesNullThresholdConfigured = Math.max(2, Math.min(20, getDiamondWindowFromConfig(config, 'n9NullThreshold', 8)));
        const bayesPriorStrengthConfigured = Math.max(0.2, Math.min(5, getDiamondWindowFromConfig(config, 'n9PriorStrength', 1)));
        const bayesPriorConfig = {
            red: bayesPriorStrengthConfigured,
            black: bayesPriorStrengthConfigured,
            white: Math.max(0.1, bayesPriorStrengthConfigured * 0.5)
        };
        bayesResult = analyzeBayesianCalibration(
            history,
            bayesHistoryConfigured,
            bayesPriorConfig,
            bayesNullThresholdConfigured / 100
        );

        if (bayesResult && bayesResult.adjustments) {
            levelReports.forEach(level => {
                if (!level.color) return;
                const factor = bayesResult.adjustments[level.color] ?? 1;
                level.strength = clamp01Local((level.strength || 0) * factor);
                level.score = directionValue(level.color) * (level.strength || 0);
            });
        }
    }

    levelReports.push({
        id: 'N10',
        name: 'CalibraÃ§Ã£o Bayesiana',
        color: null,
        weight: 0,
        strength: 0,
        score: 0,
        details: n10Enabled && bayesResult ? bayesResult.details : 'DESATIVADO',
        disabled: !n10Enabled
    });

    // AlternÃ¢ncia override com controle de entradas
    let alternanceOverride = false;
    let alternanceBlocked = false;
    let alternanceBlockReason = '';

    if (alternanceOverrideActive && alternanceColor) {
        const otherLevelsAgreeingCount = levelReports.filter(lvl =>
            lvl.id !== 'N3' && lvl.id !== 'N9' && lvl.color === alternanceColor
        ).length;

        const alternanceSignature = `${nivel7?.pattern}-${alternanceColor}`;
        const now = Date.now();
        const ctrl = simState.alternanceEntryControl;

        if (ctrl.active && ctrl.patternSignature === alternanceSignature) {
            if (ctrl.lastResult === 'loss' && ctrl.entryCount === 1) {
                alternanceBlocked = true;
                alternanceBlockReason = 'LOSS na 1Âª entrada â†’ bloqueado';
            } else if (ctrl.entryCount >= 2) {
                alternanceBlocked = true;
                alternanceBlockReason = 'Limite de 2 entradas atingido';
            } else if (ctrl.lastResult === 'win' && ctrl.entryCount === 1) {
                const { consecutiveMartingale: allowsConsecutiveEntries } = getMartingaleSettings('diamond', config);
                if (!allowsConsecutiveEntries) {
                    alternanceBlocked = true;
                    alternanceBlockReason = 'Entradas consecutivas desativadas';
                }
            }
        }

        if (!alternanceBlocked && otherLevelsAgreeingCount >= 2) {
            alternanceOverride = true;

            levelReports.forEach(lvl => {
                if (lvl.id !== 'N3' && lvl.id !== 'N6') {
                    lvl.score = 0;
                    lvl.strength = 0;
                }
            });

            if (!ctrl.active || ctrl.patternSignature !== alternanceSignature) {
                ctrl.active = true;
                ctrl.patternSignature = alternanceSignature;
                ctrl.entryColor = alternanceColor;
                ctrl.entryCount = 1;
                ctrl.lastResult = null;
                ctrl.lastEntryTimestamp = now;
            } else {
                ctrl.entryCount = 2;
                ctrl.lastEntryTimestamp = now;
            }
        }
    }

    // N0 forÃ§a branco
    if (n0ForceWhite) {
        if (intervalBlocked) return null;
        const eff = (typeof n0EffectiveConfidence === 'number' && Number.isFinite(n0EffectiveConfidence)) ? n0EffectiveConfidence : (n0WhiteStrength || 0);
        const whiteConfidencePct = Math.max(0, Math.min(100, Math.round(eff * 100)));
        try {
            // contabilizar tambÃ©m na simulaÃ§Ã£o (override) para manter proporÃ§Ã£o por hora
            const nowMs = Number.isFinite(parseSpinTimestamp(history && history[0])) ? parseSpinTimestamp(history[0]) : Date.now();
            const hourKey = buildHourKeyLocal(nowMs);
            if (!simState.n0WhiteBudget) simState.n0WhiteBudget = { hourKey: null, target: N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK, used: 0 };
            if (simState.n0WhiteBudget.hourKey !== hourKey) {
                const info = computeN0TargetWhitesPerHour(history, nowMs);
                const proposed = (info && Number.isFinite(Number(info.target))) ? Math.floor(Number(info.target)) : N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK;
                simState.n0WhiteBudget = {
                    hourKey,
                    target: Math.max(N0_WHITE_SIGNAL_TARGET_MIN, Math.min(N0_WHITE_SIGNAL_TARGET_MAX, proposed)),
                    used: 0
                };
            }
            simState.n0WhiteBudget.used = (Number(simState.n0WhiteBudget.used) || 0) + 1;
        } catch (_) {}
        return {
            color: 'white',
            confidence: whiteConfidencePct,
            probability: whiteConfidencePct,
            reasoning: `N0 bloqueou e forÃ§ou branco (simulaÃ§Ã£o)${n0ObsShort ? ` â€¢ ${n0ObsShort}` : ''}`,
            patternDescription: 'Detector de Branco (N0)'
        };
    }

    const anyVotingLevelEnabled = (() => {
        try {
            const votingIds = ['N1','N2','N3','N4','N5','N6','N7','N8'];
            return votingIds.some((id) => !!diamondLevelEnabledMap[id]);
        } catch (_) {
            return false;
        }
    })();
    const n0PredictedWhite = !!n0UiVoteWhite;

    // âœ… MODO MISTO (N0 + outros nÃ­veis):
    // Se o N0 prever WHITE com confianÃ§a suficiente (>= limiar do SOFT), emitir sinal WHITE
    // mesmo com outros nÃ­veis ativos. Isso mantÃ©m a simulaÃ§Ã£o idÃªntica ao modo real.
    // âœ… Aplicar budget no simulador tambÃ©m (mesma regra do modo real)
    const n0BudgetOk = (() => {
        if (!n0PredictedWhite) return { ok: false, reason: n0GateReason || 'not_predicted' };
        try {
            const nowMs = Number.isFinite(parseSpinTimestamp(history && history[0])) ? parseSpinTimestamp(history[0]) : Date.now();
            const hourKey = buildHourKeyLocal(nowMs);
            if (!simState.n0WhiteBudget) simState.n0WhiteBudget = { hourKey: null, target: N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK, used: 0 };
            if (simState.n0WhiteBudget.hourKey !== hourKey) {
                const info = computeN0TargetWhitesPerHour(history, nowMs);
                const proposed = (info && Number.isFinite(Number(info.target))) ? Math.floor(Number(info.target)) : N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK;
                simState.n0WhiteBudget = {
                    hourKey,
                    target: Math.max(N0_WHITE_SIGNAL_TARGET_MIN, Math.min(N0_WHITE_SIGNAL_TARGET_MAX, proposed)),
                    used: 0
                };
            }
            const L = Math.max(1, Math.min(6, Math.floor(Number(n0LookaheadSpins) || 1)));
            const base = 1 - Math.pow(1 - (1 / 15), L);
            const minConf = Math.max(0.12, Math.min(0.75, clamp01Local(base * N0_WHITE_SIGNAL_MIN_LIFT)));
            if ((Number(simState.n0WhiteBudget.used) || 0) >= (Number(simState.n0WhiteBudget.target) || 0)) {
                return { ok: false, reason: 'budget_exceeded' };
            }
            const eff = (typeof n0EffectiveConfidence === 'number' && Number.isFinite(n0EffectiveConfidence)) ? n0EffectiveConfidence : (n0WhiteStrength || 0);
            if (eff < minConf) {
                return { ok: false, reason: 'below_min_conf' };
            }
            simState.n0WhiteBudget.used = (Number(simState.n0WhiteBudget.used) || 0) + 1;
            return { ok: true, effectiveConfidence: eff };
        } catch (_) {
            return { ok: false, reason: 'budget_error' };
        }
    })();
    if (anyVotingLevelEnabled && n0BudgetOk && n0BudgetOk.ok) {
        if (intervalBlocked) return null;
        const whiteConfidencePct = Math.max(0, Math.min(100, Math.round((Number(n0BudgetOk.effectiveConfidence) || 0) * 100)));
        const actionLabel =
            n0SoftBlockActive ? 'SOFT BLOCK'
            : (n0ActionSuppressed ? 'ALERTA (informativo)' : 'ALERTA');
        return {
            color: 'white',
            confidence: whiteConfidencePct,
            probability: whiteConfidencePct,
            reasoning: `N0 previu branco (modo misto) â€¢ ${actionLabel}${n0ObsShort ? ` â€¢ ${n0ObsShort}` : ''}`,
            patternDescription: 'Detector de Branco (N0)'
        };
    }

    // âœ… MODO "SOMENTE N0" (mesma intenÃ§Ã£o do modo real):
    // Emitir WHITE apenas quando passar no budget + lift mÃ­nimo (evita chute em massa).
    if (!anyVotingLevelEnabled && n0PredictedWhite) {
        if (intervalBlocked) return null;
        const okSolo = (() => {
            try {
                const nowMs = Number.isFinite(parseSpinTimestamp(history && history[0])) ? parseSpinTimestamp(history[0]) : Date.now();
                const hourKey = buildHourKeyLocal(nowMs);
                if (!simState.n0WhiteBudget) simState.n0WhiteBudget = { hourKey: null, target: N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK, used: 0 };
                if (simState.n0WhiteBudget.hourKey !== hourKey) {
                    const info = computeN0TargetWhitesPerHour(history, nowMs);
                    const proposed = (info && Number.isFinite(Number(info.target))) ? Math.floor(Number(info.target)) : N0_WHITE_SIGNAL_TARGET_PER_HOUR_FALLBACK;
                    simState.n0WhiteBudget = {
                        hourKey,
                        target: Math.max(N0_WHITE_SIGNAL_TARGET_MIN, Math.min(N0_WHITE_SIGNAL_TARGET_MAX, proposed)),
                        used: 0
                    };
                }
                const L = Math.max(1, Math.min(6, Math.floor(Number(n0LookaheadSpins) || 1)));
                const base = 1 - Math.pow(1 - (1 / 15), L);
                const minConf = Math.max(0.12, Math.min(0.75, clamp01Local(base * N0_WHITE_SIGNAL_MIN_LIFT)));
                if ((Number(simState.n0WhiteBudget.used) || 0) >= (Number(simState.n0WhiteBudget.target) || 0)) return false;
                const eff = (typeof n0EffectiveConfidence === 'number' && Number.isFinite(n0EffectiveConfidence)) ? n0EffectiveConfidence : (n0WhiteStrength || 0);
                if (eff < minConf) return false;
                simState.n0WhiteBudget.used = (Number(simState.n0WhiteBudget.used) || 0) + 1;
                return true;
            } catch (_) {
                return false;
            }
        })();
        if (okSolo) {
            const eff = (typeof n0EffectiveConfidence === 'number' && Number.isFinite(n0EffectiveConfidence)) ? n0EffectiveConfidence : (n0WhiteStrength || 0);
            const whiteConfidencePct = Math.max(0, Math.min(100, Math.round(eff * 100)));
            const actionLabel =
                n0SoftBlockActive ? 'SOFT BLOCK'
                : (n0ActionSuppressed ? 'ALERTA (informativo)' : 'ALERTA');
            return {
                color: 'white',
                confidence: whiteConfidencePct,
                probability: whiteConfidencePct,
                reasoning: `N0 previu branco (modo somente N0) â€¢ ${actionLabel}${n0ObsShort ? ` â€¢ ${n0ObsShort}` : ''}`,
                patternDescription: 'Detector de Branco (N0)'
            };
        }
    }

    // Score preliminar e barreira
    const scoreWithoutBarrier = levelReports.reduce((sum, lvl) => sum + (lvl.score * (lvl.weight || 0)), 0);

    // âœ… Para a Barreira (N9), usar a cor lÃ­der da votaÃ§Ã£o (incluindo WHITE) quando houver lideranÃ§a clara.
    const preVoteCounts = { red: 0, black: 0, white: 0 };
    levelReports.forEach(lvl => {
        if (!lvl || lvl.disabled) return;
        if (lvl.id === 'N0' || lvl.id === 'N9' || lvl.id === 'N10') return;
        if (!lvl.color || (lvl.strength || 0) <= 0) return;
        if (lvl.color === 'red') preVoteCounts.red++;
        if (lvl.color === 'black') preVoteCounts.black++;
        if (lvl.color === 'white') preVoteCounts.white++;
    });
    const orderedPreVotes = Object.entries(preVoteCounts).sort(([, a], [, b]) => b - a);
    const preLeader = orderedPreVotes[0] || ['red', 0];
    const preSecond = orderedPreVotes[1] || ['black', 0];
    const hasPreLeader = preLeader[1] > 0 && preLeader[1] !== preSecond[1];

    let predictedColor = hasPreLeader
        ? preLeader[0]
        : (scoreWithoutBarrier === 0
        ? (minuteBiasColor || momentumColor || patternColor || 'red')
            : (scoreWithoutBarrier >= 0 ? 'red' : 'black'));
    if (alternanceOverride) {
        predictedColor = alternanceColor;
    }

    const n9Enabled = isLevelEnabledLocal('N9');
    let barrierResult = { allowed: true, alternanceBlocked: false };
    if (alternanceBlocked && alternanceOverrideActive) {
        return null;
    }
    let barrierDetailsText = '';
    if (n9Enabled) {
        barrierResult = validateSequenceBarrier(history, predictedColor, getDiamondWindowFromConfig(config, 'n8Barrier', historySize), {
            override: alternanceOverrideActive,
            targetRuns: nivel7 ? nivel7.alternanceTargetRuns : null,
            maxRuns: nivel7 ? nivel7.alternanceMaxRuns : null
        });
        if (barrierResult && barrierResult.alternanceBlocked) {
            barrierDetailsText = 'BLOQUEADO â€¢ alternÃ¢ncia';
        } else if (barrierResult && barrierResult.allowed) {
            const cur = Number(barrierResult.currentStreak ?? 0);
            const target = Number(barrierResult.targetStreak ?? 0);
            const maxHist = Number(barrierResult.maxStreakFound ?? 0);
            barrierDetailsText = `APROVADO â€¢ atual ${cur} â€¢ alvo ${target} â€¢ mÃ¡xHist ${maxHist}`;
        } else {
            const cur = Number(barrierResult.currentStreak ?? 0);
            const target = Number(barrierResult.targetStreak ?? 0);
            const maxHist = Number(barrierResult.maxStreakFound ?? 0);
            barrierDetailsText = `BLOQUEADO â€¢ atual ${cur} â€¢ alvo ${target} â€¢ mÃ¡xHist ${maxHist}`;
        }
        if (!barrierResult.allowed) {
            return null;
        }
    }

    levelReports.push({
        id: 'N9',
        name: 'Barreira Final',
        color: null,
        weight: 0,
        strength: 0,
        score: 0,
        details: n9Enabled ? (barrierDetailsText || (barrierResult.allowed ? 'APROVADO' : 'BLOQUEADO')) : 'DESATIVADO',
        disabled: !n9Enabled
    });

    // VerificaÃ§Ã£o: precisa existir voto de nÃ­veis 1-8
    const votingLevelsOnly = levelReports.filter(lvl =>
        lvl.id !== 'N0' && lvl.id !== 'N9' && lvl.id !== 'N10' &&
        !lvl.disabled && lvl.color && (lvl.strength || 0) > 0
    );
    if (votingLevelsOnly.length === 0) {
        return null;
    }

    // Intensidade
    // âœ… Intensidade removida (por enquanto): travar sempre em "aggressive"
    let signalIntensity = 'aggressive';
    const votingLevelIds = ['N1','N2','N3','N4','N5','N6','N7','N8'];
    const allVotingLevelsEnabled = votingLevelIds.every(id => diamondLevelEnabledMap[id]);
    if (signalIntensity === 'conservative' && !allVotingLevelsEnabled) {
        signalIntensity = 'aggressive';
    }

    if (intervalBlocked) {
        return null;
    }

    // âœ… SÃ³ nÃ­veis que VOTAM entram na conta de confianÃ§a (N9/N10 sÃ£o validadores)
    const VOTING_LEVEL_IDS = new Set(['N1','N2','N3','N4','N5','N6','N7','N8']);
    const votingLevelsList = levelReports.filter(lvl => VOTING_LEVEL_IDS.has(lvl.id) && !lvl.disabled);
    const positiveVotingLevels = votingLevelsList.filter(lvl => lvl.color && (lvl.strength || 0) > 0);
    const negativeVotingLevels = votingLevelsList.filter(lvl => lvl.color && (lvl.strength || 0) < 0);
    const neutralVotingLevels = votingLevelsList.filter(lvl => !lvl.color || (lvl.strength || 0) === 0);

    const voteCounts = { red: 0, black: 0, white: 0 };
    positiveVotingLevels.forEach(lvl => {
        if (lvl.color === 'red') voteCounts.red++;
        if (lvl.color === 'black') voteCounts.black++;
        if (lvl.color === 'white') voteCounts.white++;
    });

    const totalVotes = voteCounts.red + voteCounts.black + voteCounts.white;
    if (totalVotes === 0) return null;

    const orderedVotes = Object.entries(voteCounts).sort(([, a], [, b]) => b - a);
    const consensusColor = orderedVotes[0] ? orderedVotes[0][0] : null;
    const consensusVotes = orderedVotes[0] ? orderedVotes[0][1] : 0;
    const secondVotes = orderedVotes[1] ? orderedVotes[1][1] : 0;

    if (!consensusColor || consensusVotes === 0) return null;
    if (consensusVotes === secondVotes) return null;

    if (signalIntensity === 'conservative') {
        if (voteCounts[consensusColor] < 5) return null;
        if (!n9Enabled) return null;
        if (!barrierResult.allowed) return null;
        const bayesApproves = n10Enabled && bayesResult && bayesResult.color && bayesResult.color === consensusColor;
        if (!n10Enabled || !bayesApproves) return null;
    }

    const maxVotingSlots = votingLevelsList.length;
    const winningVotes = voteCounts[consensusColor];
    let rawConfidence = Math.round((winningVotes / Math.max(1, maxVotingSlots)) * 100);
    rawConfidence = Math.max(0, Math.min(100, rawConfidence));
    const finalConfidence = Math.max(0, Math.min(100, Math.round(rawConfidence)));

    // âœ… Helper local: no modo real existe `describeLevel` (funÃ§Ã£o interna daquele escopo).
    // Na simulaÃ§Ã£o precisamos de um serializer equivalente para o modal conseguir fazer parse.
    const describeLevelLocal = (level) => {
        const id = level?.id ? String(level.id) : 'N?';
        const name = level?.name ? String(level.name) : 'NÃ­vel';
        const disabled = !!level?.disabled;
        const details = level?.details ? String(level.details) : '';
        const color = level?.color === 'red' || level?.color === 'black' || level?.color === 'white'
            ? level.color
            : null;

        if (disabled) {
            return `${id} - ${name} â†’ DESATIVADO`;
        }

        if (color) {
            const pct = Math.max(0, Math.min(100, Number.isFinite(Number(level?.strength))
                ? Math.abs(Number(level.strength)) * 100
                : 0));
            const pctText = pct > 0 ? ` (${pct.toFixed(1)}%)` : '';
            const detailText = details ? ` â€¢ ${details}` : '';
            // Importante: usar RED/BLACK/WHITE em inglÃªs para o parser do `content.js` detectar o voto
            return `${id} - ${name} â†’ Voto: ${color.toUpperCase()}${pctText}${detailText}`;
        }

        if (details) {
            return `${id} - ${name} â†’ ${details}`;
        }

        return `${id} - ${name} â†’ NULO`;
    };

    // âœ… RaciocÃ­nio completo (mesmo formato do modo real, para o modal "PadrÃ£o da Entrada")
    const intensityLabel = signalIntensity === 'conservative' ? 'Conservador' : 'Agressivo';
    const reasoning =
        `${levelReports.map(level => describeLevelLocal(level)).join('\n')}\n` +
        `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n` +
        `Modo: ${intensityLabel}\n` +
        `Score combinado: ${rawConfidence.toFixed(1)}%\n` +
        `DECISÃƒO: ${consensusColor.toUpperCase()}\n` +
        `ConfianÃ§a: ${finalConfidence}%`;

    return {
        color: consensusColor,
        confidence: finalConfidence,
        probability: finalConfidence,
        reasoning,
        patternDescription,
        safeZone: safeZoneMeta,
        meta: {
            votes: voteCounts,
            neutral: neutralVotingLevels.length,
            negative: negativeVotingLevels.length
        }
    };
}

function createDiamondAnalysisForNextSpin(history, simState, aiResult) {
    if (!aiResult) return null;
    const config = simState.config || {};
    let aiColor = aiResult.color;
    let aiPhase = 'G0';

    if (simState.martingaleState.active) {
        const { consecutiveGales } = getMartingaleSettingsForEntryColor(simState?.martingaleState?.entryColor, 'diamond', config);
        aiPhase = simState.martingaleState.stage;
        // âœ… SÃ³ forÃ§a a cor quando o estÃ¡gio atual Ã© consecutivo
        const forcedColor = simState.martingaleState.currentColor || simState.martingaleState.entryColor;
        if (forcedColor && isMartingaleStageConsecutive(simState.martingaleState.stage, consecutiveGales)) {
            aiColor = forcedColor;
        }
    }

    const aiHistorySizeUsed = Math.min(Math.max(config.aiHistorySize || 50, 20), history.length);
    const last10SpinsForDescription = history.slice(0, 10).map(spin => ({
        color: spin.color,
        number: spin.number,
        timestamp: spin.timestamp
    }));

    const aiDescriptionData = {
        type: 'AI_ANALYSIS',
        color: aiColor,
        confidence: aiResult.confidence,
        last10Spins: last10SpinsForDescription,
        last5Spins: last10SpinsForDescription ? last10SpinsForDescription.slice(0, 10) : [],
        reasoning: aiResult.reasoning || aiResult.patternDescription || `SimulaÃ§Ã£o baseada nos Ãºltimos ${aiHistorySizeUsed} giros.`,
        historySize: aiHistorySizeUsed
    };
    const aiDescription = JSON.stringify(aiDescriptionData);

    const analysis = {
        color: aiColor,
        confidence: aiResult.confidence,
        patternDescription: aiDescription,
        last10Spins: last10SpinsForDescription,
        last5Spins: last10SpinsForDescription ? last10SpinsForDescription.slice(0, 10) : [],
        patternType: 'ai-analysis',
        phase: aiPhase,
        predictedFor: 'next',
        createdOnTimestamp: (history[0] && (history[0].created_at ?? history[0].timestamp)) || Date.now(),
        aiPattern: null
    };

    if (analysis.phase && analysis.phase !== 'G0' && analysis.phase !== 'ENTRADA') {
        analysis.confidence = calculateGaleConfidenceValue(analysis.confidence, analysis, simState.martingaleState);
    }

    return analysis;
}

function maybeGenerateDiamondAnalysisSimulation(history, simState) {
    const config = simState.config || {};
    const { consecutiveGales } = getMartingaleSettingsForEntryColor(simState?.martingaleState?.entryColor, 'diamond', config);

    // Se anÃ¡lise pendente, nÃ£o gerar outra
    if (simState.analysis && simState.analysis.createdOnTimestamp && simState.analysis.predictedFor === 'next') {
        const latestTs = history[0]?.timestamp;
        if (latestTs && simState.analysis.createdOnTimestamp !== latestTs) {
            return;
        }
    }

    if (simState.martingaleState.active && isMartingaleStageConsecutive(simState.martingaleState.stage, consecutiveGales)) return;

    const aiResult = analyzeDiamondLevelsSimulation(history, config, simState);
    if (!aiResult) return;

    const analysis = createDiamondAnalysisForNextSpin(history, simState, aiResult);
    if (!analysis) return;

    simState.analysis = analysis;
    simState.lastSignalSpinNumber = history[0]?.number ?? null;
    simState.lastSignalSpinId = history[0]?.id ?? null;
    simState.lastSignalSpinTimestamp = history[0]?.timestamp ?? null;

    // N7 usa signalsHistory.signals verificados
    const signal = {
        timestamp: history[0]?.timestamp ? new Date(history[0].timestamp).getTime() : Date.now(),
        patternType: 'nivel-diamante',
        patternName: 'SimulaÃ§Ã£o Diamante',
        colorRecommended: analysis.color,
        verified: false,
        colorThatCame: null,
        hit: null
    };
    if (simState.signalsHistory && Array.isArray(simState.signalsHistory.signals)) {
        simState.signalsHistory.signals.push(signal);
        if (simState.signalsHistory.signals.length > 200) {
            simState.signalsHistory.signals = simState.signalsHistory.signals.slice(-200);
        }
    }

    simState.totalSignals++;
}

function filterFinalEntries(entriesHistory) {
    const allEntries = Array.isArray(entriesHistory) ? entriesHistory : [];
    return allEntries.filter(e => {
        if (!e) return false;
        if (e.result === 'WIN') return true;
        if (e.result === 'LOSS') {
            if (e.finalResult === 'RED' || e.finalResult === 'RET') return true;
            let isContinuing = false;
            for (let key in e) {
                if (key.startsWith('continuingToG')) {
                    isContinuing = true;
                    break;
                }
            }
            if (isContinuing) return false;
            return true;
        }
        return true;
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– IA VIVA: manter janela deslizante de ciclos (por modo)
// - MantÃ©m os N ciclos finais mais recentes (WIN ou LOSS final) para o modo informado
// - Preserva o ciclo "em andamento" (mais recente), mesmo se ainda nÃ£o tiver final
// - Remove ciclos mais antigos (inclui entradas intermediÃ¡rias do ciclo)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function trimEntriesHistoryByModeCycleCap(entriesHistoryRaw, modeKeyRaw, maxCycles = 100) {
    try {
        const list = Array.isArray(entriesHistoryRaw) ? entriesHistoryRaw : [];
        const modeKey = String(modeKeyRaw || '').toLowerCase().trim() === 'diamond' ? 'diamond' : 'standard';
        const cap = Math.max(10, Math.min(500, Math.floor(Number(maxCycles) || 100)));

        const hasExplicitMode = list.some(e => e && (e.analysisMode === 'diamond' || e.analysisMode === 'standard'));
        const inMode = (e) => {
            try {
                return resolveEntryModeMaster(e, hasExplicitMode) === modeKey;
            } catch (_) {
                const m = e && typeof e.analysisMode === 'string' ? e.analysisMode : null;
                if (m === 'diamond' || m === 'standard') return m === modeKey;
                return modeKey === 'standard'; // legado
            }
        };
        const isFinalEntry = (e) => {
            try {
                if (typeof isFinalCycleMaster === 'function') return !!isFinalCycleMaster(e);
            } catch (_) {}
            const isWin = String(e && e.result || '').toUpperCase().trim() === 'WIN';
            if (isWin) return true;
            const isLoss = String(e && e.result || '').toUpperCase().trim() === 'LOSS';
            if (!isLoss) return false;
            const finalRes = e && e.finalResult ? String(e.finalResult).toUpperCase().trim() : '';
            if (finalRes === 'RED' || finalRes === 'RET') return true;
            try {
                return !hasContinuationFlagMaster(e);
            } catch (_) {
                // Fallback: se nÃ£o tiver flags de continuidade, tratamos como final
                let isContinuing = false;
                for (let k in (e || {})) {
                    if (String(k).startsWith('continuingToG')) { isContinuing = true; break; }
                }
                return !isContinuing;
            }
        };

        // Encontrar o Ã­ndice onde comeÃ§a o (cap+1)Âº ciclo final (do modo alvo).
        // Mantemos tudo acima disso (inclui entradas intermediÃ¡rias), e removemos ciclos antigos.
        let finalsCount = 0;
        let cutIndex = null;
        for (let i = 0; i < list.length; i++) {
            const e = list[i];
            if (!inMode(e)) continue;
            if (isFinalEntry(e)) finalsCount++;
            if (finalsCount > cap) {
                cutIndex = i; // este Ã© o final do (cap+1)Âº ciclo â†’ remover este e os mais antigos
                break;
            }
        }

        if (cutIndex == null) return list;

        return list.filter((e, idx) => {
            if (!inMode(e)) return true;
            return idx < cutIndex;
        });
    } catch (_) {
        return Array.isArray(entriesHistoryRaw) ? entriesHistoryRaw : [];
    }
}

async function runDiamondPastSimulation({ config, mode, levelId, senderTabId, jobId, historyLimit, sessionId, reuseSnapshot }) {
    const job = diamondSimulationJobs.get(jobId);
    const requestedLimit = Number(historyLimit);
    const safeDefault = 1440; // padrÃ£o: 12h (2 giros/min)
    const sourceHistory = await getHistorySourceForPastRuns(requestedLimit);
    const availableHistory = Array.isArray(sourceHistory) ? sourceHistory.length : 0;
    const limit = (Number.isFinite(requestedLimit) && requestedLimit > 0)
        ? Math.min(requestedLimit, 10000, availableHistory || requestedLimit)
        : Math.min(safeDefault, availableHistory || safeDefault);

    let stableWindow = null;
    let chronological = [];
    const useSnap = reuseSnapshot !== false && sessionId;
    const snapKey = useSnap ? makePastSimSnapshotKey('diamond', sessionId, limit) : null;
    const snap = snapKey ? pastSimHistorySnapshots.get(snapKey) : null;
    if (snap && Array.isArray(snap.chronological)) {
        chronological = snap.chronological;
        stableWindow = {
            chronological,
            meta: snap.meta || {
                availableHistory: chronological.length,
                uniqueCount: chronological.length,
                droppedDuplicates: 0,
                droppedInvalidTs: 0,
                usedHistoryLimit: chronological.length
            }
        };
    } else {
        stableWindow = getStableChronologicalHistoryWindow({ limit, sourceHistory: Array.isArray(sourceHistory) ? sourceHistory : [] });
        chronological = stableWindow.chronological;
        if (snapKey) {
            pastSimHistorySnapshots.set(snapKey, {
                chronological,
                meta: stableWindow.meta,
                fromTimestamp: chronological[0]?.timestamp || null,
                toTimestamp: chronological[chronological.length - 1]?.timestamp || null
            });
            prunePastSimSnapshots();
        }
    }
    const totalSpins = chronological.length;

    const simConfigBase = config && typeof config === 'object' ? { ...config } : {};
    simConfigBase.aiMode = true;
    ensureMartingaleProfiles(simConfigBase);

    const simConfig = mode === 'level'
        ? {
            ...simConfigBase,
            diamondLevelEnabled: buildDiamondSingleLevelEnabledMap(levelId, simConfigBase.diamondLevelEnabled || {})
        }
        : simConfigBase;

    const simState = createDiamondSimulationState(simConfig);
    const simHistory = [];

    const fromTimestamp = chronological[0]?.timestamp || null;
    const toTimestamp = chronological[totalSpins - 1]?.timestamp || null;

    // âœ… Baseline do jogo (para debug/educaÃ§Ã£o no modal de simulaÃ§Ã£o)
    // Ajuda a entender quando a estratÃ©gia estÃ¡ colada no "esperado do jogo" (ex.: 85% atÃ© G2),
    // e por que Martingale pode ficar negativo mesmo com alta taxa de acerto.
    const baseline = (() => {
        try {
            const counts = { red: 0, black: 0, white: 0, other: 0 };
            for (const spin of chronological) {
                const c = String(spin?.color || '').toLowerCase().trim();
                if (c === 'red' || c === 'vermelho') counts.red++;
                else if (c === 'black' || c === 'preto') counts.black++;
                else if (c === 'white' || c === 'branco') counts.white++;
                else counts.other++;
            }
            const total = counts.red + counts.black + counts.white;
            const freq = total > 0
                ? {
                    red: counts.red / total,
                    black: counts.black / total,
                    white: counts.white / total
                }
                : { red: 0, black: 0, white: 0 };

            const bestColor = freq.black > freq.red ? 'black' : 'red';
            const pBest = Math.max(freq.red, freq.black);

            const { maxGales } = getMartingaleSettings('diamond', simConfig);
            const steps = Math.max(1, Math.min(50, Math.floor(Number(maxGales) || 0) + 1));
            const pCycle = 1 - Math.pow(1 - pBest, steps);

            const autoBetCfg = sanitizeAutoBetConfig(simConfig && simConfig.autoBetConfig ? simConfig.autoBetConfig : null);
            const galeMult = Number(autoBetCfg.galeMultiplier) || 2;
            const payoutRB = 2;

            // Break-even (apenas para o martingale clÃ¡ssico) quando:
            // - payoutRB=2
            // - galeMultiplier=2 (dobro)
            // - objetivo Ã© recuperar perdas e ganhar +1 unidade base por ciclo
            const breakEvenPcycle = (payoutRB === 2 && galeMult === 2)
                ? (1 - (1 / Math.pow(2, steps)))
                : null;

            return {
                counts,
                freq,
                bestColor,
                pBest,
                steps,
                pCycle,
                breakEvenPcycle,
                assumptions: { payoutRB, galeMultiplier: galeMult }
            };
        } catch (_) {
            return null;
        }
    })();

    for (let i = 0; i < totalSpins; i++) {
        if (job && job.cancelled) {
            if (senderTabId != null) {
                try { chrome.tabs.sendMessage(senderTabId, { type: 'DIAMOND_SIMULATION_CANCELLED', data: { jobId } }); } catch (_) {}
            }
            return {
                cancelled: true,
                fromTimestamp,
                toTimestamp,
                totalSpins,
                requestedLimit,
                usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
                availableHistory: stableWindow.meta.availableHistory,
                uniqueHistory: stableWindow.meta.uniqueCount,
                droppedDuplicates: stableWindow.meta.droppedDuplicates,
                droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
                baseline,
                simState
            };
        }

        const spin = chronological[i];
        simHistory.unshift(spin);
        if (simHistory.length > limit) simHistory.pop();

        // 1) Avaliar anÃ¡lise pendente (giro atual resolve o sinal anterior)
        evaluatePendingAnalysisSimulation(spin, simState, simHistory, 'diamond');

        // 2) Gerar sinal para o PRÃ“XIMO giro (sem ver o futuro)
        if (i < totalSpins - 1) {
            maybeGenerateDiamondAnalysisSimulation(simHistory, simState);
        }

        if (i % DIAMOND_SIMULATION_BATCH === 0 || i === totalSpins - 1) {
            try {
                // âœ… Enviar via runtime (nÃ£o depende de tabId). Quem nÃ£o for o job atual ignora pelo jobId.
                try {
                    chrome.runtime.sendMessage({
                        type: 'DIAMOND_SIMULATION_PROGRESS',
                        data: { jobId, processed: i + 1, total: totalSpins }
                    });
                } catch (_) {}
            } catch (_) {}
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    return {
        cancelled: false,
        fromTimestamp,
        toTimestamp,
        totalSpins,
        requestedLimit,
        usedHistoryLimit: stableWindow.meta.usedHistoryLimit,
        availableHistory: stableWindow.meta.availableHistory,
        uniqueHistory: stableWindow.meta.uniqueCount,
        droppedDuplicates: stableWindow.meta.droppedDuplicates,
        droppedInvalidTs: stableWindow.meta.droppedInvalidTs,
        baseline,
        simState
    };
}

// Listen for messages from popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    // Log removido: reduÃ§Ã£o de verbosidade
    
    if (request.action === 'start') {
        startDataCollection();
        sendResponse({status: 'started'});
        return true;
    } else if (request.action === 'stop') {
        stopDataCollection();
        sendResponse({status: 'stopped'});
        return true;
    } else if (request.action === 'status') {
        sendResponse({status: isRunning ? 'running' : 'stopped'});
        return true;
    } else if (request.action === 'SET_ANALYSIS_ENABLED') {
        (async () => {
            analysisEnabled = request.enabled !== false;
            console.log(`ğŸ”§ AnÃ¡lise ${analysisEnabled ? 'ativada' : 'pausada'} via UI`);
            
            if (!analysisEnabled) {
                await clearActiveAnalysisState('toggle_ui_off');
            } else if (cachedHistory && cachedHistory.length > 0) {
                runAnalysisIfEnabled(cachedHistory, 'TOGGLE_ON').catch((error) => {
                    console.error('âŒ Falha ao reativar anÃ¡lises apÃ³s toggle:', error);
                });
            }
            
            sendResponse({ status: 'ok', enabled: analysisEnabled });
        })();
        return true;
    } else if (request.action === 'GET_ANALYSIS_STATUS') {
        sendResponse({ status: 'ok', enabled: analysisEnabled });
        return true;
    } else if (request.action === 'SET_RECOVERY_MODE') {
        // ğŸ§¼ RecuperaÃ§Ã£o desativada: manter compatibilidade com UI antiga, mas nÃ£o permitir ativaÃ§Ã£o.
        (async () => {
            try {
                recoveryModeEnabled = false;
                await chrome.storage.local.set({ [RECOVERY_MODE_KEY]: { enabled: false, updatedAt: Date.now(), disabledBy: 'white_panel' } });
            } catch (_) {}
            sendResponse({ status: 'ok', enabled: false, disabled: true });
        })();
        return true; // async
    } else if (request.action === 'GET_RECOVERY_MODE') {
        sendResponse({ status: 'ok', enabled: false, disabled: true });
        return true;
    } else if (request.action === 'FORCE_CLEAR_PENDING') {
        (async () => {
            try {
                const reason = request && request.reason ? String(request.reason) : 'manual';
                console.warn('ğŸ§¯ [FORCE_CLEAR_PENDING] Limpando pendÃªncia para destravar.', { reason });

                // Resetar estado do ciclo (martingale) + limpar anÃ¡lise/padrÃ£o
                resetMartingaleState();
                await chrome.storage.local.set({
                    analysis: null,
                    pattern: null,
                    lastBet: { status: 'loss', phase: 'G0', resolvedAtTimestamp: Date.now(), clearedReason: reason },
                    martingaleState
                });

                sendMessageToContent('CLEAR_ANALYSIS');
                sendResponse({ status: 'ok' });
            } catch (e) {
                console.error('âŒ Falha em FORCE_CLEAR_PENDING:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true; // async response
    } else if (request.action === 'GET_MEMORIA_ATIVA_STATUS') {
        // ğŸ§  Retornar status da memÃ³ria ativa para interface
        console.log('%cğŸ§  [BACKGROUND] RequisiÃ§Ã£o de status da memÃ³ria ativa recebida', 'color: #00CED1; font-weight: bold;');
        
        const statusResponse = {
            status: {
                inicializada: memoriaAtiva.inicializada,
                totalAtualizacoes: memoriaAtiva.totalAtualizacoes,
                tempoUltimaAtualizacao: memoriaAtiva.tempoUltimaAtualizacao,
                totalGiros: memoriaAtiva.giros.length,
                ultimaAtualizacao: memoriaAtiva.ultimaAtualizacao
            }
        };
        
        console.log('%cğŸ§  [BACKGROUND] Enviando resposta:', 'color: #00CED1;', statusResponse);
        
        sendResponse(statusResponse);
        return true;
    } else if (request.action === 'getFullHistory') {
        // ğŸ“‚ Retornar histÃ³rico completo para visualizaÃ§Ã£o do banco de padrÃµes
        console.log('%cğŸ“‚ [BACKGROUND] RequisiÃ§Ã£o de histÃ³rico completo recebida', 'color: #667eea; font-weight: bold;');
        console.log(`ğŸ“Š HistÃ³rico em cache: ${cachedHistory.length} giros`);
        
        sendResponse({ history: cachedHistory });
        return true;
	} else if (request.action === 'REQUEST_MODE_SNAPSHOT') {
		const contextLabel = request.reason ? `Solicitado (${request.reason})` : 'Solicitado pela UI';
		const snapshot = buildModeSnapshot(contextLabel, cachedHistory.length);
		sendMessageToContent('MODE_SNAPSHOT', snapshot);
		sendResponse({ status: 'ok', snapshot });
        return true;
    } else if (request.action === 'PAST_SIM_CLEAR_SESSION') {
        const sid = typeof request.sessionId === 'string' ? request.sessionId.trim() : '';
        if (sid) {
            try {
                const keys = Array.from(pastSimHistorySnapshots.keys());
                keys.forEach((k) => {
                    if (k.includes(`|${sid}|`)) pastSimHistorySnapshots.delete(k);
                });
            } catch (_) {}
        }
        sendResponse({ status: 'ok' });
        return true;
    } else if (request.action === 'DIAMOND_CLEAR_N0_FROZEN_MODEL') {
        (async () => {
            try {
                const stored = await chrome.storage.local.get(['analyzerConfig']);
                const base = stored && stored.analyzerConfig && typeof stored.analyzerConfig === 'object' ? stored.analyzerConfig : {};
                const updated = {
                    ...base,
                    n0FrozenEnabled: false,
                    n0FrozenModel: null,
                    _clientUpdatedAt: Date.now()
                };
                await chrome.storage.local.set({ analyzerConfig: updated });
                mergeAnalyzerConfig(updated);
                sendResponse({ status: 'success' });
            } catch (e) {
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'DIAMOND_FREEZE_N0_MODEL_FROM_BACKTEST') {
        (async () => {
            try {
                const sid = (typeof request.sessionId === 'string' && request.sessionId.trim()) ? request.sessionId.trim() : '';
                const cfg = request.config && typeof request.config === 'object' ? request.config : (analyzerConfig || {});
                const requestedLimit = Number(request.historyLimit);
                const safeDefault = 1440;

                const sourceHistory = await getHistorySourceForPastRuns(requestedLimit);
                const availableHistory = Array.isArray(sourceHistory) ? sourceHistory.length : 0;
                const limit = (Number.isFinite(requestedLimit) && requestedLimit > 0)
                    ? Math.min(requestedLimit, 10000, availableHistory || requestedLimit)
                    : Math.min(safeDefault, availableHistory || safeDefault);

                const snapKey = sid ? makePastSimSnapshotKey('diamond', sid, limit) : null;
                let chronological = [];
                if (snapKey) {
                    const snap = pastSimHistorySnapshots.get(snapKey);
                    if (snap && Array.isArray(snap.chronological)) {
                        chronological = snap.chronological;
                    }
                }
                if (!chronological.length) {
                    const stableWindow = getStableChronologicalHistoryWindow({ limit, sourceHistory: Array.isArray(sourceHistory) ? sourceHistory : [] });
                    chronological = stableWindow.chronological;
                    if (snapKey) {
                        pastSimHistorySnapshots.set(snapKey, {
                            chronological,
                            meta: stableWindow.meta,
                            fromTimestamp: chronological[0]?.timestamp || null,
                            toTimestamp: chronological[chronological.length - 1]?.timestamp || null
                        });
                        prunePastSimSnapshots();
                    }
                }

                const historyMostRecentFirst = chronological.slice().reverse();
                const n0Settings = (typeof getN0SettingsFromConfig === 'function')
                    ? getN0SettingsFromConfig(cfg)
                    : { historySize: N0_DEFAULTS.historySize, windowSize: N0_DEFAULTS.windowSize, allowBlockAll: true };
                const { maxGales: n0MaxGalesConfigured } = getMartingaleSettingsForEntryColor('white', 'diamond', cfg);
                const n0LookaheadSpins = Math.max(1, Math.min(6, (Math.floor(Number(n0MaxGalesConfigured) || 0) + 1)));

                const settings = {
                    historySize: n0Settings.historySize,
                    windowSize: n0Settings.windowSize,
                    lookaheadSpins: n0LookaheadSpins,
                    analysesToRun: N0_DEFAULTS.analysesToRun,
                    minWindowsRequired: N0_DEFAULTS.minWindowsRequired,
                    precisionMin: N0_DEFAULTS.precisionMin,
                    confidenceGrid: N0_DEFAULTS.confidenceGrid,
                    holdoutEnabled: N0_DEFAULTS.holdoutEnabled,
                    holdoutTolerance: N0_DEFAULTS.holdoutTolerance,
                    seed: N0_DEFAULTS.seed
                };
                const cacheKey = buildN0RuntimeCacheKey(settings);
                try { n0RuntimeModelCache.delete(cacheKey); } catch (_) {}

                // Treinar (forÃ§ar) com histÃ³rico estÃ¡vel do backtest
                runN0Detector(historyMostRecentFirst, {
                    ...settings,
                    assumeStableHistory: true,
                    silent: true,
                    cache: true,
                    cacheMaxAgeSpins: 0
                });

                const cachedRow = n0RuntimeModelCache.get(cacheKey);
                const model = cachedRow && cachedRow.model && typeof cachedRow.model === 'object' ? cachedRow.model : null;
                if (!model || !model.best_config) {
                    sendResponse({ status: 'error', error: 'NÃ£o foi possÃ­vel gerar o modelo do N0.' });
                    return;
                }

                const frozenModel = {
                    ...model,
                    frozenAt: Date.now(),
                    frozenFrom: {
                        fromTimestamp: chronological[0]?.timestamp || null,
                        toTimestamp: chronological[chronological.length - 1]?.timestamp || null,
                        usedHistoryLimit: chronological.length
                    }
                };

                const stored = await chrome.storage.local.get(['analyzerConfig']);
                const base = stored && stored.analyzerConfig && typeof stored.analyzerConfig === 'object' ? stored.analyzerConfig : {};
                const updated = {
                    ...base,
                    aiMode: true,
                    n0FrozenEnabled: true,
                    n0FrozenModel: frozenModel,
                    _clientUpdatedAt: Date.now()
                };
                await chrome.storage.local.set({ analyzerConfig: updated });
                mergeAnalyzerConfig(updated);

                sendResponse({ status: 'success' });
            } catch (e) {
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'STANDARD_SIMULATE_PAST') {
        (async () => {
            try {
                const senderTabId = sender && sender.tab ? sender.tab.id : null;
                const config = request.config || {};
                const historyLimit = request.historyLimit;
                const sessionId = (typeof request.sessionId === 'string' && request.sessionId.trim()) ? request.sessionId.trim() : null;
                const reuseSnapshot = request.reuseSnapshot !== false;

                const requestedJobId = (typeof request.jobId === 'string' && request.jobId.trim())
                    ? request.jobId.trim()
                    : null;
                const jobId = requestedJobId || makeStandardSimulationJobId();
                standardSimulationJobs.set(jobId, { cancelled: false });

                const result = await runStandardPastSimulation({ config, senderTabId, jobId, historyLimit, sessionId, reuseSnapshot });
                standardSimulationJobs.delete(jobId);

                if (result.cancelled) {
                    sendResponse({ status: 'cancelled', jobId });
                    return;
                }

                const entries = result.simState.entriesHistory || [];
                const filtered = filterFinalEntries(entries);
                const wins = filtered.filter(e => e.result === 'WIN').length;
                const totalCycles = filtered.length;
                const losses = totalCycles - wins;
                const pct = totalCycles ? ((wins / totalCycles) * 100) : 0;

                sendResponse({
                    status: 'success',
                    jobId,
                    label: 'Testar configuraÃ§Ãµes â€¢ Premium',
                    entries,
                    stats: { wins, losses, totalCycles, pct: Number(pct.toFixed(1)) },
                    meta: {
                        totalSpins: result.totalSpins,
                        totalSignals: result.simState.totalSignals,
                        fromTimestamp: result.fromTimestamp,
                        toTimestamp: result.toTimestamp,
                        availableHistory: result.availableHistory,
                        uniqueHistory: result.uniqueHistory,
                        droppedDuplicates: result.droppedDuplicates,
                        droppedInvalidTs: result.droppedInvalidTs,
                        requestedHistoryLimit: result.requestedLimit,
                        usedHistoryLimit: result.usedHistoryLimit
                    }
                });
            } catch (e) {
                console.error('âŒ Falha na simulaÃ§Ã£o Premium (passado):', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'STANDARD_OPTIMIZE_PAST') {
        (async () => {
            try {
                const senderTabId = sender && sender.tab ? sender.tab.id : null;
                const config = request.config || {};
                const historyLimit = request.historyLimit;
                const trials = request.trials;

                const requestedJobId = (typeof request.jobId === 'string' && request.jobId.trim())
                    ? request.jobId.trim()
                    : null;
                const jobId = requestedJobId || makeStandardOptimizationJobId();
                standardOptimizationJobs.set(jobId, { cancelled: false });

                const result = await runStandardPastOptimization({ config, senderTabId, jobId, historyLimit, trials });
                standardOptimizationJobs.delete(jobId);

                if (result.cancelled) {
                    sendResponse({ status: 'cancelled', jobId });
                    return;
                }
                if (!result.bestEligible && !result.bestOverall) {
                    sendResponse({ status: 'error', jobId, error: 'Nenhuma configuraÃ§Ã£o elegÃ­vel encontrada' });
                    return;
                }

                const minPct = Number(result.minPct) || STANDARD_OPTIMIZATION_MIN_PCT_DEFAULT;
                const recommended = result.bestEligible || null;
                const overall = result.bestOverall || null;
                const payloadPick = recommended || overall;

                sendResponse({
                    status: 'success',
                    jobId,
                    trials: result.totalTrials,
                    minPct,
                    recommendedFound: !!recommended,
                    recommended: recommended ? {
                        score: Number(recommended.score.toFixed(2)),
                        pct: recommended.pct,
                        wins: recommended.wins,
                        losses: recommended.losses,
                        totalCycles: recommended.totalCycles,
                        totalSignals: recommended.totalSignals,
                        config: recommended.config
                    } : null,
                    bestOverall: overall ? {
                        score: Number(overall.score.toFixed(2)),
                        pct: overall.pct,
                        wins: overall.wins,
                        losses: overall.losses,
                        totalCycles: overall.totalCycles,
                        totalSignals: overall.totalSignals,
                        config: overall.config
                    } : null,
                    config: payloadPick ? payloadPick.config : null,
                    entries: payloadPick ? payloadPick.entries : [],
                    meta: {
                        totalSpins: result.totalSpins,
                        totalSignals: payloadPick ? payloadPick.totalSignals : 0,
                        fromTimestamp: result.fromTimestamp,
                        toTimestamp: result.toTimestamp,
                        availableHistory: result.availableHistory,
                        uniqueHistory: result.uniqueHistory,
                        droppedDuplicates: result.droppedDuplicates,
                        droppedInvalidTs: result.droppedInvalidTs,
                        requestedHistoryLimit: result.requestedLimit,
                        usedHistoryLimit: result.usedHistoryLimit
                    }
                });
            } catch (e) {
                console.error('âŒ Falha na otimizaÃ§Ã£o Premium (passado):', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'DIAMOND_SIMULATE_PAST') {
        (async () => {
            try {
                const senderTabId = sender && sender.tab ? sender.tab.id : null;
                const mode = request.mode === 'level' ? 'level' : 'all';
                const levelId = request.levelId || null;
                const config = request.config || {};
                const historyLimit = request.historyLimit;
                const sessionId = (typeof request.sessionId === 'string' && request.sessionId.trim()) ? request.sessionId.trim() : null;
                const reuseSnapshot = request.reuseSnapshot !== false;

                const requestedJobId = (typeof request.jobId === 'string' && request.jobId.trim())
                    ? request.jobId.trim()
                    : null;
                const jobId = requestedJobId || makeDiamondSimulationJobId();
                diamondSimulationJobs.set(jobId, { cancelled: false });

                const result = await runDiamondPastSimulation({ config, mode, levelId, senderTabId, jobId, historyLimit, sessionId, reuseSnapshot });
                diamondSimulationJobs.delete(jobId);

                if (result.cancelled) {
                    sendResponse({ status: 'cancelled', jobId });
                    return;
                }

                const entries = result.simState.entriesHistory || [];
                const filtered = filterFinalEntries(entries);
                const wins = filtered.filter(e => e.result === 'WIN').length;
                const totalCycles = filtered.length;
                const losses = totalCycles - wins;
                const pct = totalCycles ? ((wins / totalCycles) * 100) : 0;

                const label = mode === 'level' && levelId ? `Testar configuraÃ§Ãµes â€¢ ${levelId}` : 'Testar configuraÃ§Ãµes â€¢ Todos os nÃ­veis';

                sendResponse({
                    status: 'success',
                    jobId,
                    label,
                    entries,
                    stats: {
                        wins,
                        losses,
                        totalCycles,
                        pct: Number(pct.toFixed(1))
                    },
                    meta: {
                        totalSpins: result.totalSpins,
                        totalSignals: result.simState.totalSignals,
                        fromTimestamp: result.fromTimestamp,
                        toTimestamp: result.toTimestamp,
                        availableHistory: result.availableHistory,
                        uniqueHistory: result.uniqueHistory,
                        droppedDuplicates: result.droppedDuplicates,
                        droppedInvalidTs: result.droppedInvalidTs,
                        requestedHistoryLimit: result.requestedLimit,
                        usedHistoryLimit: result.usedHistoryLimit,
                        baseline: result.baseline || null
                    }
                });
            } catch (e) {
                console.error('âŒ Falha na simulaÃ§Ã£o Diamante (passado):', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'DIAMOND_OPTIMIZE_PAST') {
        (async () => {
            try {
                const senderTabId = sender && sender.tab ? sender.tab.id : null;
                const levelId = request.levelId || null;
                if (!levelId) {
                    sendResponse({ status: 'error', error: 'levelId obrigatÃ³rio' });
                    return;
                }
                const config = request.config || {};
                const historyLimit = request.historyLimit;
                const trials = request.trials;

                const requestedJobId = (typeof request.jobId === 'string' && request.jobId.trim())
                    ? request.jobId.trim()
                    : null;
                const jobId = requestedJobId || makeDiamondOptimizationJobId();
                diamondOptimizationJobs.set(jobId, { cancelled: false });

                const result = await runDiamondPastOptimization({ config, levelId, senderTabId, jobId, historyLimit, trials });
                diamondOptimizationJobs.delete(jobId);

                if (result.cancelled) {
                    sendResponse({ status: 'cancelled', jobId });
                    return;
                }
                if (!result.bestEligible && !result.bestOverall) {
                    sendResponse({ status: 'error', jobId, error: 'Nenhuma configuraÃ§Ã£o elegÃ­vel encontrada' });
                    return;
                }

                const from = result.fromTimestamp;
                const to = result.toTimestamp;
                const minPct = Number(result.minPct) || DIAMOND_OPTIMIZATION_MIN_PCT_DEFAULT;
                const recommended = result.bestEligible || null;
                const overall = result.bestOverall || null;
                const payloadPick = recommended || overall;

                sendResponse({
                    status: 'success',
                    jobId,
                    levelId,
                    trials: result.totalTrials,
                    minPct,
                    recommendedFound: !!recommended,
                    recommended: recommended ? {
                        score: Number(recommended.score.toFixed(2)),
                        pct: recommended.pct,
                        wins: recommended.wins,
                        losses: recommended.losses,
                        totalCycles: recommended.totalCycles,
                        totalSignals: recommended.totalSignals,
                        config: recommended.config
                    } : null,
                    bestOverall: overall ? {
                        score: Number(overall.score.toFixed(2)),
                        pct: overall.pct,
                        wins: overall.wins,
                        losses: overall.losses,
                        totalCycles: overall.totalCycles,
                        totalSignals: overall.totalSignals,
                        config: overall.config
                    } : null,
                    // âœ… para renderizar a lista/grÃ¡fico: mostra o "recomendado" se existir; senÃ£o, a melhor encontrada (abaixo do mÃ­nimo)
                    config: payloadPick ? payloadPick.config : null,
                    entries: payloadPick ? payloadPick.entries : [],
                    meta: {
                        totalSpins: result.totalSpins,
                        totalSignals: payloadPick ? payloadPick.totalSignals : 0,
                        fromTimestamp: from,
                        toTimestamp: to,
                        availableHistory: result.availableHistory,
                        uniqueHistory: result.uniqueHistory,
                        droppedDuplicates: result.droppedDuplicates,
                        droppedInvalidTs: result.droppedInvalidTs,
                        requestedHistoryLimit: result.requestedLimit,
                        usedHistoryLimit: result.usedHistoryLimit
                    }
                });
            } catch (e) {
                console.error('âŒ Falha na otimizaÃ§Ã£o Diamante (passado):', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'DIAMOND_SIMULATE_CANCEL') {
        const jobId = request.jobId;
        if (jobId && diamondSimulationJobs.has(jobId)) {
            const job = diamondSimulationJobs.get(jobId);
            job.cancelled = true;
            diamondSimulationJobs.set(jobId, job);
            sendResponse({ status: 'ok', cancelled: true });
        } else {
            sendResponse({ status: 'ok', cancelled: false });
        }
        return true;
    } else if (request.action === 'STANDARD_SIMULATE_CANCEL') {
        const jobId = request.jobId;
        if (jobId && standardSimulationJobs.has(jobId)) {
            const job = standardSimulationJobs.get(jobId);
            job.cancelled = true;
            standardSimulationJobs.set(jobId, job);
            sendResponse({ status: 'ok', cancelled: true });
        } else {
            sendResponse({ status: 'ok', cancelled: false });
        }
        return true;
    } else if (request.action === 'DIAMOND_OPTIMIZE_CANCEL') {
        const jobId = request.jobId;
        if (jobId && diamondOptimizationJobs.has(jobId)) {
            const job = diamondOptimizationJobs.get(jobId);
            job.cancelled = true;
            diamondOptimizationJobs.set(jobId, job);
            sendResponse({ status: 'ok', cancelled: true });
        } else {
            sendResponse({ status: 'ok', cancelled: false });
        }
        return true;
    } else if (request.action === 'STANDARD_OPTIMIZE_CANCEL') {
        const jobId = request.jobId;
        if (jobId && standardOptimizationJobs.has(jobId)) {
            const job = standardOptimizationJobs.get(jobId);
            job.cancelled = true;
            standardOptimizationJobs.set(jobId, job);
            sendResponse({ status: 'ok', cancelled: true });
        } else {
            sendResponse({ status: 'ok', cancelled: false });
        }
        return true;
    } else if (request.action === 'applyConfig') {
        console.log('%câœ… ENTROU NO else if applyConfig!', 'color: #00FF00; font-weight: bold; font-size: 16px;');
        (async () => {
            try {
                console.log('%câœ… EXECUTANDO async function...', 'color: #00FF00; font-weight: bold;');
                // âœ… Usar CACHE EM MEMÃ“RIA (nÃ£o buscar de doubleHistory)
                const history = cachedHistory;
                
                const res = await chrome.storage.local.get(['analyzerConfig']);
                if (res && res.analyzerConfig) {
                    mergeAnalyzerConfig(res.analyzerConfig);
                }
                await enforceProfileGateOnAIMode('applyConfig');
                console.log('%câš™ï¸ Nova configuraÃ§Ã£o aplicada via UI:', 'color: #00D4FF; font-weight: bold;');
                const depthLog = clampInt(
                    analyzerConfig.historyDepth ?? DEFAULT_ANALYZER_CONFIG.historyDepth,
                    50,
                    REALTIME_HISTORY_CAP
                );
                console.log('%cğŸ“Š Profundidade de AnÃ¡lise: ' + depthLog + ' giros', 'color: #00FF88; font-weight: bold; background: #003322; padding: 4px 8px; border-radius: 4px;');
                logActiveConfiguration();
                
                // âš ï¸ SÃ“ REANALISAR SE MODO IA ESTIVER ATIVO E HOUVER HISTÃ“RICO SUFICIENTE
                if (analyzerConfig.aiMode && history && history.length >= 10) {
                    if (!analysisEnabled) {
                        console.log('â¸ï¸ AnÃ¡lises pausadas â€“ ignorando reanÃ¡lise automÃ¡tica apÃ³s applyConfig.');
                    } else {
                    console.log('ğŸ“Š Reanalisando com', history.length, 'giros do cache...');
                    await runAnalysisController(history);
                    }
                } else {
                    if (!analyzerConfig.aiMode) {
                        console.log('â„¹ï¸ Modo IA desativado - nÃ£o reanalisando automaticamente');
                    } else if (!history || history.length < 10) {
                        console.log('â„¹ï¸ HistÃ³rico insuficiente para anÃ¡lise - mÃ­nimo 10 giros');
                    }
                }
                
                console.log('%câœ… CHAMANDO sendResponse com status: applied', 'color: #00FF00; font-weight: bold;');
                sendResponse({ status: 'applied' });
            } catch (e) {
                console.error('âŒ Falha ao aplicar configuraÃ§Ã£o:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        console.log('%câœ… RETORNANDO TRUE do listener!', 'color: #00FF00; font-weight: bold; font-size: 16px;');
        return true; // âš ï¸ CRÃTICO: Indicar que vamos responder assincronamente!
    } else if (request.action === 'showPatternStats') {
        // Exibir estatÃ­sticas do banco de padrÃµes
        (async () => {
            try {
                const db = await loadPatternDB();
                sendResponse({ status: 'shown', total: db.patterns_found ? db.patterns_found.length : 0 });
            } catch (e) {
                console.error('Erro ao exibir estatÃ­sticas:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true; // async response
    } else if (request.action === 'getObserverStats') {
        // Enviar estatÃ­sticas do observador inteligente
        const stats = getObserverStats();
        sendResponse({ status: 'success', stats: stats });
        return true;
    } else if (request.action === 'getMasterSignalStats') {
        // âœ… Enviar estatÃ­sticas do SINAL DE ENTRADA (Fase 2) para a UI
        (async () => {
            try {
                const mode = request && request.mode ? request.mode : (analyzerConfig && analyzerConfig.aiMode ? 'diamond' : 'standard');
                const stored = await chrome.storage.local.get([
                    'entriesHistory',
                    'analysis',
                    RECOVERY_MODE_KEY,
                    RECOVERY_SECURE_HISTORY_KEY,
                    ENTRIES_CLEAR_CUTOFF_KEY
                ]);
                const entriesHistoryAll = stored && Array.isArray(stored.entriesHistory) ? stored.entriesHistory : [];
                const recoverySecureAll = stored && Array.isArray(stored[RECOVERY_SECURE_HISTORY_KEY]) ? stored[RECOVERY_SECURE_HISTORY_KEY] : [];
                const cutoffMs = getMasterCutoffMsForMode(stored ? stored[ENTRIES_CLEAR_CUTOFF_KEY] : null, mode);
                const storedRecoveryEnabled = !!(stored && stored[RECOVERY_MODE_KEY] && stored[RECOVERY_MODE_KEY].enabled);
                const recoveryEnabled = storedRecoveryEnabled || !!recoveryModeEnabled;

                // Fonte:
                // - RecuperaÃ§Ã£o ativa => usar histÃ³rico interno (recoverySecureHistory)
                // - Caso contrÃ¡rio => usar histÃ³rico normal (entriesHistory)
                const historyAll = recoveryEnabled ? recoverySecureAll : entriesHistoryAll;
                const entriesHistory = filterEntriesHistoryByCutoff(historyAll, cutoffMs);
                const currentAnalysis = stored && stored.analysis ? stored.analysis : null;
                // Garantir que masterSignal do analysis respeita o cutoff (evita "Sinal liberado" grudado apÃ³s Limpar)
                const annotated = await attachMasterSignalToAnalysis(currentAnalysis, mode);
                const stats = computeMasterSignalStats(entriesHistory, mode, annotated);
                // âœ… RecuperaÃ§Ã£o segura: expor gate + contador (faltam X) para o card "RecuperaÃ§Ã£o segura"
                try {
                    const gate = computeRecoveryGateFromEntries(entriesHistory, mode);
                    stats.recoveryEnabled = recoveryEnabled;
                    stats.recoveryGate = gate;
                    stats.currentSignalRecovery = !!(annotated && annotated.recoveryMode);
                    stats.source = recoveryEnabled ? 'recoverySecureHistory' : 'entriesHistory';
                } catch (_) {}
                sendResponse({ status: 'success', stats });
            } catch (e) {
                console.error('âŒ Falha ao calcular stats dos Sinais de entrada:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'IA_BOOTSTRAP_HISTORY') {
        // âœ… Desativado a pedido do usuÃ¡rio:
        // - Removida a bolinha/CTA "Analisar histÃ³rico"
        // - Removido o bootstrap de histÃ³rico (ex.: 20 ciclos iniciais)
        sendResponse({ status: 'error', error: 'IA_BOOTSTRAP_HISTORY desativado' });
        return true;

        // ğŸ¤– IA VIVA: bootstrap do histÃ³rico via simulaÃ§Ã£o no passado, usando a config atual (sem alterar config)
        (async () => {
            try {
                const mode = String(request && request.mode ? request.mode : (analyzerConfig && analyzerConfig.aiMode ? 'diamond' : 'standard'))
                    .toLowerCase()
                    .trim() === 'diamond'
                    ? 'diamond'
                    : 'standard';
                // âœ… Pedido: bootstrap inicial = 20 ciclos (mais recentes). Sem cap permanente no histÃ³rico.
                const targetCycles = Math.max(1, Math.min(200, Math.floor(Number(request && request.targetCycles) || 20)));

                const stored = await chrome.storage.local.get(['analyzerConfig', 'entriesHistory', 'analysis', ENTRIES_CLEAR_CUTOFF_KEY]);
                const cfg = stored && stored.analyzerConfig && typeof stored.analyzerConfig === 'object'
                    ? stored.analyzerConfig
                    : (typeof analyzerConfig !== 'undefined' ? analyzerConfig : {});
                const entriesHistoryAll = stored && Array.isArray(stored.entriesHistory) ? stored.entriesHistory : [];
                const cutoffMs = getMasterCutoffMsForMode(stored ? stored[ENTRIES_CLEAR_CUTOFF_KEY] : null, mode);

                // Definir historyLimit inicial (reaproveita a lÃ³gica do simulador)
                const computeInitialHistoryLimit = () => {
                    if (mode === 'diamond') {
                        const windows = cfg && cfg.diamondLevelWindows ? cfg.diamondLevelWindows : {};
                        const enabled = cfg && cfg.diamondLevelEnabled ? cfg.diamondLevelEnabled : {};
                        const requiredHistory = Math.max(
                            enabled.n0 ? (Number(windows.n0History) || 0) : 0,
                            enabled.n3 ? (Number(windows.n3Alternance) || 0) : 0,
                            enabled.n4 ? (Number(windows.n4Persistence) || 0) : 0,
                            enabled.n7 ? (Number(windows.n7HistoryWindow) || 0) : 0,
                            enabled.n8 ? (Number(windows.n10History) || 0) : 0,
                            enabled.n10 ? (Number(windows.n9History) || 0) : 0
                        );
                        return Math.max(1440, requiredHistory || 0, 2000);
                    }
                    // âœ… Pedido: respeitar a profundidade REAL configurada (historyDepth) no modo padrÃ£o
                    // (nÃ£o â€œestourarâ€ para 2000/10k sÃ³ para gerar mais ciclos no bootstrap)
                    const rawDepth = Number(cfg && cfg.historyDepth != null ? cfg.historyDepth : 500) || 500;
                    const depth = clampInt(rawDepth, 100, 10000);
                    return depth;
                };

                const runSim = async (historyLimit) => {
                    if (mode === 'diamond') {
                        const jobId = `ia-boot-dia-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                        return await runDiamondPastSimulation({
                            config: cfg,
                            mode: 'all',
                            levelId: null,
                            senderTabId: null,
                            jobId,
                            historyLimit
                        });
                    }
                    const jobId = `ia-boot-std-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                    return await runStandardPastSimulation({
                        config: cfg,
                        senderTabId: null,
                        jobId,
                        historyLimit
                    });
                };

                let historyLimit = Math.min(10000, computeInitialHistoryLimit());
                let simResult = await runSim(historyLimit);
                let simEntries = simResult && simResult.simState && Array.isArray(simResult.simState.entriesHistory)
                    ? simResult.simState.entriesHistory
                    : [];

                // âœ… Pedido: nÃ£o aumentar historyLimit acima do configurado sÃ³ para â€œforÃ§arâ€ ciclos.
                // Se nÃ£o houver ciclos suficientes, bootstrap parcial Ã© OK (mantÃ©m consistÃªncia com historyDepth).

                const hasExplicitModeSim2 = simEntries.some(e => e && (e.analysisMode === 'diamond' || e.analysisMode === 'standard'));
                const inModeSim2 = (e) => resolveEntryModeMaster(e, hasExplicitModeSim2) === mode;
                const finals = filterFinalEntries(simEntries).filter(inModeSim2);

                // Selecionar os 100 ciclos mais recentes (CICLOS = entradas finais WIN/RED/RET),
                // mas manter TODAS as "entradas/tentativas" dentro desses ciclos.
                // (Evita depender de cycleId/patternData, e garante que 100 CICLOS podem gerar >100 ENTRADAS)
                const isFinalEntry = (e) => {
                    try {
                        if (typeof isFinalCycleMaster === 'function') return !!isFinalCycleMaster(e);
                    } catch (_) {}
                    const isWin = String(e && e.result || '').toUpperCase().trim() === 'WIN';
                    if (isWin) return true;
                    const isLoss = String(e && e.result || '').toUpperCase().trim() === 'LOSS';
                    if (!isLoss) return false;
                    const fr = e && e.finalResult ? String(e.finalResult).toUpperCase().trim() : '';
                    if (fr === 'RED' || fr === 'RET') return true;
                    try {
                        return !hasContinuationFlagMaster(e);
                    } catch (_) {
                        let isContinuing = false;
                        for (let k in (e || {})) {
                            if (String(k).startsWith('continuingToG')) { isContinuing = true; break; }
                        }
                        return !isContinuing;
                    }
                };

                let keptEntriesRaw = [];
                let createdCycles = 0;
                let started = false;
                for (let i = 0; i < simEntries.length; i++) {
                    const e = simEntries[i];
                    if (!inModeSim2(e)) continue;
                    const isFinal = isFinalEntry(e);
                    if (isFinal) {
                        if (!started) started = true;
                        if (createdCycles >= targetCycles) {
                            break; // este seria o (target+1)Âº ciclo final
                        }
                        createdCycles++;
                    }
                    if (started) {
                        keptEntriesRaw.push(e);
                    }
                }

                if (createdCycles < Math.max(10, targetCycles)) {
                    // Ainda assim permite bootstrap parcial (ex.: pouco histÃ³rico), mas mantÃ©m coerÃªncia
                    console.warn(`âš ï¸ IA_BOOTSTRAP_HISTORY: ciclos insuficientes (${createdCycles}/${targetCycles}) para modo ${mode}`);
                }

                // Carimbar "visibilidade" para passar no cutoff apÃ³s "Limpar", MAS sem destruir o timestamp real.
                // - `timestamp` permanece o original (para exibir hora correta no UI)
                // - `visibleAtTimestamp` Ã© usado sÃ³ para filtro/cutoff (content.js)
                const stampMs = Math.max(Date.now(), (Number(cutoffMs) || 0) + 1);
                const keptEntries = keptEntriesRaw.map((e, idx) => ({
                    ...(e && typeof e === 'object' ? e : {}),
                    bootstrap: true,
                    visibleAtTimestamp: stampMs + idx // pequeno offset para estabilidade
                }));

                // Remover do histÃ³rico antigo tudo que for do modo alvo ANTES do cutoff (limpeza real, para nÃ£o misturar)
                const hasExplicitExisting = entriesHistoryAll.some(e => e && (e.analysisMode === 'diamond' || e.analysisMode === 'standard'));
                const cleanedExisting = entriesHistoryAll.filter(e => {
                    const isMode = resolveEntryModeMaster(e, hasExplicitExisting) === mode;
                    if (!isMode) return true;
                    const ts = getEntryTimestampMsForHistory(e);
                    return !(Number.isFinite(Number(cutoffMs)) && cutoffMs > 0 && ts < cutoffMs);
                });

                // Inserir as entradas bootstrap como as mais antigas da janela atual (sem bagunÃ§ar o topo atual)
                // entriesHistory Ã© newest-first, entÃ£o anexar no fim preserva "mais recente" no topo.
                let merged = cleanedExisting.concat(keptEntries);

                // âœ… Sem cap apÃ³s bootstrap: manter histÃ³rico acumulando normalmente (sem limitar em 20/200).

                await chrome.storage.local.set({ entriesHistory: merged });

                // Atualizar UI imediatamente
                try { sendMessageToContent('ENTRIES_UPDATE', merged); } catch (_) {}
                try {
                    const currentAnalysis = stored && stored.analysis ? stored.analysis : null;
                    const annotated = await attachMasterSignalToAnalysis(currentAnalysis, mode);
                    if (annotated) {
                        const payload = { ...attachLatestSpinsSnapshot(annotated) };
                        payload.analysisMode = mode;
                        sendMessageToContent('NEW_ANALYSIS', payload);
                    }
                } catch (_) {}

                sendResponse({
                    status: 'success',
                    mode,
                    targetCycles,
                    createdCycles,
                    usedHistoryLimit: historyLimit
                });
            } catch (e) {
                console.error('âŒ IA_BOOTSTRAP_HISTORY falhou:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'RECOMPUTE_MASTER_SIGNAL') {
        // âœ… ForÃ§ar recomputar masterSignal do analysis atual (usado apÃ³s "Limpar" na UI)
        (async () => {
            try {
                const mode = request && request.mode ? request.mode : (analyzerConfig && analyzerConfig.aiMode ? 'diamond' : 'standard');
                const stored = await chrome.storage.local.get(['analysis']);
                const currentAnalysis = stored && stored.analysis ? stored.analysis : null;
                const annotated = await attachMasterSignalToAnalysis(currentAnalysis, mode);
                if (annotated) {
                    // Re-enviar para a UI para atualizar overlay/topo imediatamente
                    const payload = { ...attachLatestSpinsSnapshot(annotated) };
                    payload.analysisMode = mode;
                    sendMessageToContent('NEW_ANALYSIS', payload);
                }
                sendResponse({ status: 'success' });
            } catch (e) {
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'recalibrateObserver') {
        // Recalibrar observador manualmente (botÃ£o "Atualizar")
        console.log('ğŸ”„ RecalibraÃ§Ã£o manual do observador solicitada...');
        recalibrateConfidenceModel();
        const stats = getObserverStats();
        sendResponse({ status: 'success', stats: stats });
        // Enviar atualizaÃ§Ã£o para content.js
        sendObserverUpdate(true); // Mostrar log na recalibraÃ§Ã£o manual
        return true;
    } else if (request.action === 'FORCE_LOGOUT') {
        console.warn('%câš ï¸ [BACKGROUND] Logout forÃ§ado solicitado: ' + (request.reason || 'motivo nÃ£o informado'), 'color: #FF4444; font-weight: bold;');
        stopDataCollection();

        try {
            chrome.storage?.local?.remove(['authToken', 'user', 'lastAuthCheck'], () => {
                if (chrome.runtime?.lastError) {
                    console.warn('âš ï¸ [BACKGROUND] Erro ao limpar chrome.storage.local durante logout forÃ§ado:', chrome.runtime.lastError.message);
                } else {
                    console.log('%cğŸ§¹ [BACKGROUND] SessÃ£o removida do chrome.storage.local', 'color: #FF4444; font-weight: bold;');
                }
            });
        } catch (error) {
            console.error('âŒ [BACKGROUND] Falha ao remover sessÃ£o do chrome.storage.local:', error);
        }

        if (!forceLogoutTabOpened) {
            forceLogoutTabOpened = true;
            const loginUrl = chrome.runtime?.getURL ? chrome.runtime.getURL('auth.html') : 'auth.html';
            chrome.tabs.create({ url: loginUrl }, () => {
                setTimeout(() => { forceLogoutTabOpened = false; }, 2000);
            });
        }

        sendResponse({ status: 'logged_out' });
        return true;
    } else if (request.action === 'aiModeChanged') {
        // Modo IA foi alterado
        (async () => {
            try {
                console.log('%cğŸ”„ MUDANÃ‡A DE MODO DETECTADA!', 'color: #FFAA00; font-weight: bold; font-size: 14px;');
                
                const res = await chrome.storage.local.get(['analyzerConfig']);
                if (res && res.analyzerConfig) {
                    console.log('%cğŸ“¥ ConfiguraÃ§Ã£o lida do storage:', 'color: #00FFFF; font-weight: bold;');
                    console.log('%c   aiMode: ' + res.analyzerConfig.aiMode, 'color: #00FFFF; font-weight: bold; font-size: 13px;');
                    console.log('%c   minOccurrences: ' + res.analyzerConfig.minOccurrences, 'color: #00FFFF;');
                    
                    mergeAnalyzerConfig(res.analyzerConfig);
                    await enforceProfileGateOnAIMode('aiModeChanged');
                    
                    console.log('%cğŸ¤– Modo IA ' + (analyzerConfig.aiMode ? 'ATIVADO' : 'DESATIVADO'), 'color: ' + (analyzerConfig.aiMode ? '#00FF00' : '#FF6666') + '; font-weight: bold; font-size: 16px; background: ' + (analyzerConfig.aiMode ? '#003300' : '#330000') + '; padding: 5px;');
                    
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // âœ… LIMPAR COMPLETAMENTE ANÃLISE ANTERIOR AO TROCAR DE MODO
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    console.log('%cğŸ—‘ï¸ LIMPANDO ANÃLISE ANTERIOR DO MODO ANTIGO...', 'color: #FF6666; font-weight: bold;');
                    
                    // 1. Limpar anÃ¡lise e padrÃ£o do storage
                    await chrome.storage.local.set({ 
                        analysis: null, 
                        pattern: null,
                        lastBet: null
                    });
                    console.log('   âœ… Storage limpo (analysis, pattern, lastBet)');
                    
                    // 2. Resetar estado do Martingale se houver
                    if (martingaleState.active) {
                        console.log('   âœ… Resetando Martingale ativo');
                        resetMartingaleState();
                        await chrome.storage.local.set({ martingaleState });
                    }
                    
                    // 3. Enviar mensagem para limpar UI no content.js
                    sendMessageToContent('CLEAR_ANALYSIS');
                    console.log('   âœ… UI limpa (mensagem CLEAR_ANALYSIS enviada)');
                    
                    // âœ… Se modo IA foi ATIVADO, marcar flag para aguardar 1 giro antes de enviar sinal
                    if (analyzerConfig.aiMode) {
                        aiModeJustActivated = true;
                        console.log('%câ³ MODO IA ATIVADO: Aguardando 1 giro antes de enviar primeiro sinal...', 'color: #FFAA00; font-weight: bold; font-size: 13px; background: #332200; padding: 5px;');
                    } else {
                        // Se desativou, limpar flag
                        aiModeJustActivated = false;
                        console.log('%câœ… MODO PADRÃƒO ATIVADO: Sistema pronto para anÃ¡lise...', 'color: #00FF00; font-weight: bold; font-size: 13px; background: #003300; padding: 5px;');
                    }
                    
                    logActiveConfiguration();
                    
                    // Executar nova anÃ¡lise se houver histÃ³rico (mas nÃ£o enviarÃ¡ sinal se aiModeJustActivated = true)
                    if (cachedHistory.length > 0) {
                        const executed = await runAnalysisIfEnabled(cachedHistory, 'MODE_CHANGE');
                        if (!executed) {
                            console.log('â¸ï¸ AnÃ¡lises pausadas â€“ mudanÃ§a de modo aguardarÃ¡ atÃ© reativaÃ§Ã£o.');
                        }
                    } else {
                        console.log('%câš ï¸ Nenhum histÃ³rico disponÃ­vel para anÃ¡lise', 'color: #FFAA00;');
                    }
                }
                sendResponse({ status: 'success' });
            } catch (e) {
                console.error('%câŒ Erro ao alterar modo IA:', 'color: #FF0000; font-weight: bold;', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'requestImmediateAnalysis') {
        // Solicitar anÃ¡lise imediata (para buscar padrÃ£o quente)
        console.log('ğŸ”¥ ANÃLISE IMEDIATA SOLICITADA PARA BUSCAR PADRÃƒO QUENTE');
        console.log(`ğŸ“Š HistÃ³rico disponÃ­vel: ${cachedHistory ? cachedHistory.length : 0} giros`);
        
        (async () => {
            try {
                if (!analysisEnabled) {
                    console.log('â¸ï¸ AnÃ¡lises pausadas â€“ ignorando requestImmediateAnalysis.');
                    sendResponse({ status: 'paused' });
                    return;
                }
                
                if (cachedHistory && cachedHistory.length > 0) {
                    console.log('âœ… Executando anÃ¡lise...');
                    const startTime = Date.now();
                    
                    await runAnalysisController(cachedHistory);
                    
                    const elapsed = Date.now() - startTime;
                    console.log(`âœ… AnÃ¡lise concluÃ­da em ${elapsed}ms`);
                    
                    sendResponse({ status: 'analyzed' });
                } else {
                    console.log('âš ï¸ Nenhum histÃ³rico disponÃ­vel para anÃ¡lise');
                    sendResponse({ status: 'no_history' });
                }
            } catch (e) {
                console.error('âŒ Erro ao executar anÃ¡lise imediata:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        return true;
    } else if (request.action === 'clearEntriesAndObserver') {
        // Limpar histÃ³rico de entradas E calibrador (mantÃ©m sincronizado)
        (async () => {
            console.log('â•‘  ğŸ—‘ï¸ LIMPANDO ENTRADAS E CALIBRADOR                       â•‘');
            
            // Resetar observerData
            observerData = {
                entries: [],
                calibrationFactor: 1.0,
                lastCalibration: null,
                lastCalibratedCount: 0,
                stats: {
                    high: { predicted: 0, actual: 0, wins: 0, total: 0 },
                    medium: { predicted: 0, actual: 0, wins: 0, total: 0 },
                    low: { predicted: 0, actual: 0, wins: 0, total: 0 }
                }
            };
            
            // Salvar observerData resetado
            await saveObserverData(true); // Mostrar log
            
            console.log('âœ… Calibrador limpo e sincronizado com histÃ³rico de entradas');
            
            // Enviar atualizaÃ§Ã£o para UI
            sendObserverUpdate(true); // Mostrar log apÃ³s limpar
            
            sendResponse({ status: 'success', message: 'Entradas e calibrador limpos com sucesso!' });
        })();
        return true; // async response
    } else if (request.action === 'getDefaultPrompt') {
        // ğŸ”§ Retornar o prompt padrÃ£o para visualizaÃ§Ã£o
        try {
            const historyLength = request.historyLength || 50;
            const historyText = request.historyText || '(exemplo de histÃ³rico)';
            const defaultPrompt = DEFAULT_AI_PROMPT(historyLength, historyText);
            sendResponse({ status: 'success', prompt: defaultPrompt });
        } catch (e) {
            console.error('âŒ Erro ao buscar prompt padrÃ£o:', e);
            sendResponse({ status: 'error', error: String(e) });
        }
        return true;
    } else if (request.action === 'startPatternSearch') {
        console.log('%câœ… ENTROU NO else if startPatternSearch!', 'color: #00FFFF; font-weight: bold; font-size: 16px;');
        // Iniciar busca manual de padrÃµes (encerra ao completar a varredura; respeita config do usuÃ¡rio)
        (async () => {
            try {
                console.log('%cğŸ” Iniciando busca manual de padrÃµes...', 'color: #00FFFF; font-weight: bold;');
                // Verificar se jÃ¡ estÃ¡ buscando
                if (initialSearchActive) {
                    console.log('%câš ï¸ Busca jÃ¡ estÃ¡ ativa!', 'color: #FFAA00; font-weight: bold;');
                    sendResponse({ status: 'already_running' });
                    return;
                }

                // âœ… Garantir que a busca respeita SEMPRE as configs mais recentes do usuÃ¡rio
                try {
                    const storedCfg = await chrome.storage.local.get(['analyzerConfig']);
                    if (storedCfg && storedCfg.analyzerConfig && typeof storedCfg.analyzerConfig === 'object') {
                        mergeAnalyzerConfig(storedCfg.analyzerConfig);
                    }
                } catch (e) {
                    console.warn('âš ï¸ Falha ao recarregar analyzerConfig antes da busca de padrÃµes:', e);
                }
                
                // âœ… Usar CACHE EM MEMÃ“RIA (mais rÃ¡pido) ou buscar do servidor se vazio
                let historyToAnalyze = cachedHistory;
                
                if (!historyToAnalyze || historyToAnalyze.length < 50) {
                    console.log('ğŸ“¥ Cache vazio, buscando histÃ³rico do servidor...');
                    const serverGiros = await fetchGirosFromAPI(REALTIME_HISTORY_CAP);
                    
                    if (!serverGiros || serverGiros.length < 50) {
                        sendResponse({ status: 'insufficient_data', message: `HistÃ³rico insuficiente (<50 giros). Atual: ${serverGiros ? serverGiros.length : 0}` });
                        return;
                    }
                    
                    historyToAnalyze = serverGiros;
                    cachedHistory = serverGiros; // Atualizar cache
                }
                
                // âœ… APLICAR PROFUNDIDADE DE ANÃLISE CONFIGURADA PELO USUÃRIO
                const configuredDepth = clampInt(
                    analyzerConfig.historyDepth ?? DEFAULT_ANALYZER_CONFIG.historyDepth,
                    50,
                    REALTIME_HISTORY_CAP
                );
                const actualDepth = Math.min(configuredDepth, historyToAnalyze.length);
                historyToAnalyze = historyToAnalyze.slice(0, actualDepth);
                
                console.log(`%câœ… Iniciando busca de padrÃµes com ${historyToAnalyze.length} giros`, 'color: #00FF88; font-weight: bold;');
                console.log(`%cğŸ“Š Profundidade configurada: ${configuredDepth} giros`, 'color: #00D4FF; font-weight: bold; background: #002244; padding: 2px 6px;');
                
                await clearPatternDiscoveryCutoffFlag();
                
                // âœ… PASSO 1: LIMPAR O BANCO DE PADRÃ•ES
                await clearAllPatterns();
                
                // âœ… VERIFICAR SE REALMENTE ZEROU (DEBUG)
                const dbCheck = await chrome.storage.local.get(['patternDB']);
                const totalAfterClear = dbCheck.patternDB?.patterns_found?.length || 0;
                console.log('%cğŸ” VERIFICAÃ‡ÃƒO PÃ“S-LIMPEZA:', 'color: #FF00FF; font-weight: bold;');
                console.log(`   PadrÃµes no banco: ${totalAfterClear}`);
                
                // âœ… PASSO 2: NOTIFICAR UI IMEDIATAMENTE QUE O BANCO ESTÃ ZERADO (0/5000)
                sendMessageToContent('PATTERN_BANK_UPDATE', { total: totalAfterClear });
                console.log(`%cğŸ—‘ï¸ Banco zerado na UI (${totalAfterClear}/5000)`, 'color: #FF6600; font-weight: bold;');
                
                // âœ… PASSO 3: Aguardar um pouco para garantir que a UI foi atualizada
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // âœ… PASSO 4: Iniciar busca (encerra ao completar a varredura)
                await startInitialPatternSearch(historyToAnalyze);
                
                sendResponse({ status: 'started', historySize: historyToAnalyze.length });
            } catch (e) {
                console.error('Erro ao iniciar busca de padrÃµes:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        console.log('%câœ… RETORNANDO TRUE do startPatternSearch!', 'color: #00FFFF; font-weight: bold; font-size: 16px;');
        return true; // async response
    } else if (request.action === 'resetPatterns') {
        console.log('%câœ… ENTROU NO else if resetPatterns!', 'color: #00FF00; font-weight: bold; font-size: 16px;');
        // Resetar/Limpar TUDO: padrÃµes E anÃ¡lise pendente
        (async () => {
            try {
                console.log('%cğŸ—‘ï¸ Executando limpeza de padrÃµes...', 'color: #FFAA00; font-weight: bold;');
                // Parar busca se estiver em andamento
                if (initialSearchActive) {
                    console.log('â¸ï¸ Parando busca ativa...');
                    stopInitialPatternSearch();
                }
                
                // Limpar TUDO (padrÃµes + anÃ¡lise pendente)
                await clearAllPatternsAndAnalysis();
                
                console.log('âœ… Reset completo realizado manualmente pelo usuÃ¡rio.');
                sendResponse({ status: 'success', message: 'PadrÃµes e anÃ¡lise pendente resetados com sucesso!' });
            } catch (e) {
                console.error('Erro ao resetar padrÃµes:', e);
                sendResponse({ status: 'error', error: String(e) });
            }
        })();
        console.log('%câœ… RETORNANDO TRUE do resetPatterns!', 'color: #00FF00; font-weight: bold; font-size: 16px;');
        return true; // async response
    } else {
        // Log removido: nÃ£o Ã© necessÃ¡rio avisar sobre aÃ§Ãµes nÃ£o correspondidas
    }
});

// âœ… INICIAR APENAS SE HOUVER ABA DA BLAZE ABERTA
(async function initExtension() {
    
    const hasBlaze = await hasBlazeTabOpen();
    
    if (hasBlaze) {
        console.log('â•‘  âœ… ABA DA BLAZE ENCONTRADA - INICIANDO EXTENSÃƒO         â•‘');
startDataCollection();
    } else {
        console.log('â•‘  âš ï¸ NENHUMA ABA DA BLAZE ABERTA                          â•‘');
        console.log('â•‘  ğŸ’¡ Abra blaze.com para ativar a extensÃ£o                â•‘');
    }
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ LISTENER PARA MUDANÃ‡AS NAS CONFIGURAÃ‡Ã•ES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Detecta quando o usuÃ¡rio altera as configuraÃ§Ãµes e atualiza a variÃ¡vel global
chrome.storage.onChanged.addListener((changes, areaName) => {
    if (areaName === 'local' && changes.analyzerConfig) {
        const newConfig = changes.analyzerConfig.newValue;
        if (newConfig) {
            // âœ… ATUALIZAR CONFIGURAÃ‡Ã•ES
            mergeAnalyzerConfig(newConfig);
            
            // âœ… MOSTRAR LOG COMPLETO DAS NOVAS CONFIGURAÃ‡Ã•ES
            console.log('â•‘  ğŸ”„ CONFIGURAÃ‡Ã•ES ATUALIZADAS EM TEMPO REAL!             â•‘');
            
            // âœ… EXIBIR TODAS AS CONFIGURAÃ‡Ã•ES USANDO A FUNÃ‡ÃƒO logActiveConfiguration
            logActiveConfiguration();
            
            console.log('âœ… Novas configuraÃ§Ãµes aplicadas com sucesso!');
            console.log('â„¹ï¸  As regras jÃ¡ estÃ£o ativas - nÃ£o precisa recarregar a extensÃ£o');
        }
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“± LISTENERS DE VISIBILIDADE - Critical para mobile/desktop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detectar quando usuÃ¡rio volta para uma aba da Blaze (mobile/desktop)
chrome.tabs.onActivated.addListener(async (activeInfo) => {
    try {
        const tab = await chrome.tabs.get(activeInfo.tabId);
        
        if (tab.url && (tab.url.includes('blaze.com') || tab.url.includes('blaze.bet.br'))) {
            console.log('%câ•‘  ğŸ“± USUÃRIO VOLTOU PARA ABA DA BLAZE                     â•‘', 'color: #00FFFF; font-weight: bold;');
            
            // âœ… Verificar se WebSocket estÃ¡ conectado
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.warn('âš ï¸ WebSocket desconectado. Reconectando...');
                connectWebSocket();
            }
            
            // âœ… ForÃ§ar busca imediata de dados para garantir que estÃ¡ atualizado
            console.log('ğŸ”„ Buscando dados mais recentes...');
            await collectDoubleData();
            
            // âœ… Resetar timer de Ãºltimo dado recebido
            lastDataReceived = Date.now();
        }
    } catch (error) {
        // Ignorar erros silenciosamente (tab pode ter sido fechada)
    }
});

// Detectar quando uma aba da Blaze Ã© atualizada/recarregada
chrome.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
    try {
        // SÃ³ processar quando a pÃ¡gina terminou de carregar
        if (changeInfo.status === 'complete' && tab.url && (tab.url.includes('blaze.com') || tab.url.includes('blaze.bet.br'))) {
            console.log('%câ•‘  ğŸ”„ ABA DA BLAZE RECARREGADA                             â•‘', 'color: #00FFFF; font-weight: bold;');
            console.log('%câ•‘  Reconectando sistemas...                               â•‘', 'color: #00FFFF;');
            
            // âœ… Aguardar 2 segundos para pÃ¡gina estabilizar
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // âœ… Verificar se WebSocket estÃ¡ conectado
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.warn('âš ï¸ WebSocket desconectado apÃ³s recarregar pÃ¡gina. Reconectando...');
                connectWebSocket();
            }
            
            // âœ… ForÃ§ar busca imediata de dados
            console.log('ğŸ”„ Sincronizando dados apÃ³s reload...');
            await collectDoubleData();
            
            // âœ… Resetar timer
            lastDataReceived = Date.now();
        }
    } catch (error) {
        // Ignorar erros silenciosamente
    }
});

console.log('%câœ… Listeners de visibilidade instalados!', 'color: #00FF88; font-weight: bold;');
console.log('%c   - DetectarÃ¡ quando usuÃ¡rio voltar para aba da Blaze', 'color: #00FF88;');
console.log('%c   - ReconectarÃ¡ automaticamente se necessÃ¡rio', 'color: #00FF88;');
console.log('%c   - Critical para funcionamento no mobile', 'color: #00FF88;');


